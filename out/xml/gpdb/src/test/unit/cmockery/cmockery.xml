<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/test/unit/cmockery/cmockery.c"><comment type="block">/*
 * Copyright 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MALLOC_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !_WIN32</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// _WIN32</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cmockery.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vsnprintf</name></cpp:macro> <cpp:value>_vsnprintf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// _WIN32</comment>

<comment type="block">/* Backwards compatibility with headers shipped with Visual Studio 2005 and
 * earlier. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<function_decl><type><name>WINBASEAPI</name> <name>BOOL</name> <name>WINAPI</name></type> <name>IsDebuggerPresent</name><parameter_list>(<parameter><decl><type><name>VOID</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// _WIN32</comment>

<comment type="line">// Size of guard bytes around dynamically allocated blocks.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_GUARD_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<comment type="line">// Pattern used to initialize guard blocks.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_GUARD_PATTERN</name></cpp:macro> <cpp:value>0xEF</cpp:value></cpp:define>
<comment type="line">// Pattern used to initialize memory allocated with test_malloc().</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_ALLOC_PATTERN</name></cpp:macro> <cpp:value>0xBA</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_FREE_PATTERN</name></cpp:macro> <cpp:value>0xCD</cpp:value></cpp:define>
<comment type="line">// Alignment of allocated blocks.  NOTE: This must be base2.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_ALIGNMENT</name></cpp:macro> <cpp:value>sizeof(size_t)</cpp:value></cpp:define>

<comment type="line">// Printf formatting for source code locations.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOURCE_LOCATION_FORMAT</name></cpp:macro> <cpp:value>"%s:%d"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_PADDING</name></cpp:macro> 			<cpp:value>"                "</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_RESET</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_TERM_RED</name></cpp:macro> <cpp:value>"\e[0;31m"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_TERM_GREEN</name></cpp:macro> <cpp:value>"\e[0;32m"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_TERM_RESET</name></cpp:macro> <cpp:value>"\e[0m"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_NOTERM_RED</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_NOTERM_GREEN</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_NOTERM_RESET</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>

<comment type="line">// Calculates the number of elements in an array.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARRAY_LENGTH</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof(x) / sizeof((x)[0]))</cpp:value></cpp:define>

<comment type="line">// Declare and initialize the pointer member of ValuePointer variable name</comment>
<comment type="line">// with ptr.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>declare_initialize_value_pointer_pointer</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>ValuePointer name ; \
		name.value = 0; \
		name.pointer = (void*)(ptr)</cpp:value></cpp:define>

<comment type="line">// Declare and initialize the value member of ValuePointer variable name</comment>
<comment type="line">// with val.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>declare_initialize_value_pointer_value</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>ValuePointer name ; \
		name.value = val</cpp:value></cpp:define>

<comment type="line">// Cast a LargestIntegralType to pointer_type via a ValuePointer.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cast_largest_integral_type_to_pointer</name><parameter_list>( \
		<parameter><type><name>pointer_type</name></type></parameter>, <parameter><type><name>largest_integral_type</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>((pointer_type)((ValuePointer*)&amp;(largest_integral_type))-&gt;pointer)</cpp:value></cpp:define>

<comment type="line">// Used to cast LargetIntegralType to void* and vice versa.</comment>
<typedef>typedef <type><union>union <name>ValuePointer</name> <block>{
	<decl_stmt><decl><type><name>LargestIntegralType</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl>;</decl_stmt>
}</block></union></type> <name>ValuePointer</name>;</typedef>

<comment type="line">// Doubly linked list node.</comment>
<typedef>typedef <type><struct>struct <name>ListNode</name> <block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>refcount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>ListNode</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>ListNode</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
}</block></struct></type> <name>ListNode</name>;</typedef>

<comment type="line">// Debug information for malloc().</comment>
<typedef>typedef <type><struct>struct <name>MallocBlockInfo</name> <block>{
	<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>block</name></decl>;</decl_stmt>              <comment type="line">// Address of the block returned by malloc().</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>allocated_size</name></decl>;</decl_stmt>    <comment type="line">// Total size of the allocated block.</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>              <comment type="line">// Request block size.</comment>
	<decl_stmt><decl><type><name>SourceLocation</name></type> <name>location</name></decl>;</decl_stmt>  <comment type="line">// Where the block was allocated.</comment>
	<decl_stmt><decl><type><name>ListNode</name></type> <name>node</name></decl>;</decl_stmt>            <comment type="line">// Node within list of all allocated blocks.</comment>
}</block></struct></type> <name>MallocBlockInfo</name>;</typedef>

<comment type="line">// State of each test.</comment>
<typedef>typedef <type><struct>struct <name>TestState</name> <block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier></type><name>check_point</name></decl>;</decl_stmt> <comment type="line">// Check point of the test if there's a</comment>
	<comment type="line">// setup function.</comment>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>                 <comment type="line">// State associated with the test.</comment>
}</block></struct></type> <name>TestState</name>;</typedef>

<comment type="line">// Determines whether two values are the same.</comment>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>EqualityFunction</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="line">// Value of a symbol and the place it was declared.</comment>
<typedef>typedef <type><struct>struct <name>SymbolValue</name> <block>{
	<decl_stmt><decl><type><name>SourceLocation</name></type> <name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LargestIntegralType</name></type> <name>value</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SideeffectCallbackValue</name></type> <name>sideffect</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>sideeffect_data</name></decl>;</decl_stmt>
}</block></struct></type> <name>SymbolValue</name>;</typedef>

<comment type="block">/* Contains a list of values for a symbol.
 * NOTE: Each structure referenced by symbol_values_list_head must have a
 * SourceLocation as its' first member.
 */</comment>
<typedef>typedef <type><struct>struct <name>SymbolMapValue</name> <block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>symbol_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListNode</name></type> <name>symbol_values_list_head</name></decl>;</decl_stmt>
}</block></struct></type> <name>SymbolMapValue</name>;</typedef>

<comment type="line">// Used by list_free() to deallocate values referenced by list nodes.</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>CleanupListValue</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cleanup_value_data</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="line">// Structure used to check the range of integer types.</comment>
<typedef>typedef <type><struct>struct <name>CheckIntegerRange</name> <block>{
	<decl_stmt><decl><type><name>CheckParameterEvent</name></type> <name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LargestIntegralType</name></type> <name>minimum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LargestIntegralType</name></type> <name>maximum</name></decl>;</decl_stmt>
}</block></struct></type> <name>CheckIntegerRange</name>;</typedef>

<comment type="line">// Structure used to check whether an integer value is in a set.</comment>
<typedef>typedef <type><struct>struct <name>CheckIntegerSet</name> <block>{
	<decl_stmt><decl><type><name>CheckParameterEvent</name></type> <name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>LargestIntegralType</name> <modifier>*</modifier></type><name>set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size_of_set</name></decl>;</decl_stmt>
}</block></struct></type> <name>CheckIntegerSet</name>;</typedef>

<comment type="block">/* Used to check whether a parameter matches the area of memory referenced by
 * this structure.  */</comment>
<typedef>typedef <type><struct>struct <name>CheckMemoryData</name> <block>{
	<decl_stmt><decl><type><name>CheckParameterEvent</name></type> <name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>memory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
}</block></struct></type> <name>CheckMemoryData</name>;</typedef>

<typedef>typedef <type><struct>struct <name>AssignMemoryData</name>
<block>{
	<decl_stmt><decl><type><name>AssignParameterEvent</name></type> <name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>memory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>value_size</name></decl>;</decl_stmt>
}</block></struct></type> <name>AssignMemoryData</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>list_initialize</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>list_add</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>, <parameter><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>new_node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>list_add_value</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>list_remove</name><parameter_list>(
		<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CleanupListValue</name></type> <name>cleanup_value</name></decl></parameter>,
		<parameter><decl><type><name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>cleanup_value_data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>list_remove_free</name><parameter_list>(
		<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CleanupListValue</name></type> <name>cleanup_value</name></decl></parameter>,
		<parameter><decl><type><name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>cleanup_value_data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>list_empty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>list_find</name><parameter_list>(
		<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>EqualityFunction</name></type> <name>equal_func</name></decl></parameter>, <parameter><decl><type><name>ListNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>list_first</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>, <parameter><decl><type><name>ListNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>list_free</name><parameter_list>(
		<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CleanupListValue</name></type> <name>cleanup_value</name></decl></parameter>,
		<parameter><decl><type><name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>cleanup_value_data</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_symbol_value</name><parameter_list>(
		<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>symbol_map_head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>symbol_names</name><index>[]</index></name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_symbol_names</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_symbol_value</name><parameter_list>(
		<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>symbol_map_head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>symbol_names</name><index>[]</index></name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_symbol_names</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_error</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cleanup_value_data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_symbol_map_value</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cleanup_value_data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_always_return_values</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>map_head</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_symbol_names</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>check_for_leftover_values</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>map_head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>error_message</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_symbol_names</name></decl></parameter>)</parameter_list> __attribute__<parameter_list>(<parameter/></parameter_list>(format<parameter_list>(<parameter><decl><type><name>printf</name></type></decl></parameter>, <parameter/></parameter_list>2<operator>,</operator> 0</function_decl>)))<empty_stmt>;</empty_stmt>
<comment type="line">// This must be called at the beginning of a test to initialize some data</comment>
<comment type="line">// structures.</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_testing</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>test_name</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// This must be called at the end of a test to free() allocated structures.</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>teardown_testing</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>test_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>get_color</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>color_code</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_color_env</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">// Keeps track of the calling context returned by setenv() so that the fail()</comment>
<comment type="line">// method can jump out of a test.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>jmp_buf</name></type> <name>global_run_test_env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>global_running_test</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="line">// Keeps track of the calling context returned by setenv() so that</comment>
<comment type="line">// mock_assert() can optionally jump back to expect_assert_failure().</comment>
<decl_stmt><decl><type><name>jmp_buf</name></type> <name>global_expect_assert_env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>global_expecting_assert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="line">// Keeps a map of the values that functions will have to return to provide</comment>
<comment type="line">// mocked interfaces.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ListNode</name></type> <name>global_function_result_map_head</name></decl>;</decl_stmt>
<comment type="line">// Location of the last mock value returned was declared.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SourceLocation</name></type> <name>global_last_mock_value_location</name></decl>;</decl_stmt>

<comment type="block">/* Keeps a map of the values that functions expect as parameters to their
 * mocked interfaces. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ListNode</name></type> <name>global_function_parameter_map_head</name></decl>;</decl_stmt>

<comment type="block">/* Keeps a map of the values that are assigned to parameters in their
 * mocked interfaces.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ListNode</name></type> <name>global_function_parameter_assignment_map_head</name></decl>;</decl_stmt>

<comment type="line">// Location of last parameter value checked was declared.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SourceLocation</name></type> <name>global_last_parameter_location</name></decl>;</decl_stmt>

<comment type="line">// List of all currently allocated blocks.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ListNode</name></type> <name>global_allocated_blocks</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>abort_for_missing_check</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>generate_suppression</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>run_disabled_tests</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>use_color</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<comment type="line">// Signals caught by exception_handler().</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>exception_signals</name><index>[]</index></name> <init>= <expr><block>{
		<expr><name>SIGFPE</name></expr>,
		<expr><name>SIGILL</name></expr>,
		<expr><name>SIGSEGV</name></expr>,
		<expr><name>SIGBUS</name></expr>,
		<expr><name>SIGSYS</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="line">// Default signal functions that should be restored after a test is complete.</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>SignalFunction</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>SignalFunction</name></type> <name><name>default_signal_functions</name><index>[
                                               <expr><call><name>ARRAY_LENGTH</name><argument_list>(<argument><expr><name>exception_signals</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// _WIN32</comment>

<comment type="line">// The default exception filter.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>LPTOP_LEVEL_EXCEPTION_FILTER</name></type> <name>previous_exception_filter</name></decl>;</decl_stmt>

<comment type="line">// Fatal exceptions.</comment>
<typedef>typedef <type><struct>struct <name>ExceptionCodeInfo</name> <block>{
	<decl_stmt><decl><type><name>DWORD</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>description</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExceptionCodeInfo</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXCEPTION_CODE_INFO</name><parameter_list>(<parameter><type><name>exception_code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{exception_code, #exception_code}</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ExceptionCodeInfo</name></type> <name><name>exception_codes</name><index>[]</index></name> <init>= <expr><block>{
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_ACCESS_VIOLATION</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_ARRAY_BOUNDS_EXCEEDED</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_DATATYPE_MISALIGNMENT</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_FLT_DENORMAL_OPERAND</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_FLT_DIVIDE_BY_ZERO</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_FLT_INEXACT_RESULT</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_FLT_INVALID_OPERATION</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_FLT_OVERFLOW</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_FLT_STACK_CHECK</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_FLT_UNDERFLOW</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_GUARD_PAGE</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_ILLEGAL_INSTRUCTION</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_INT_DIVIDE_BY_ZERO</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_INT_OVERFLOW</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_INVALID_DISPOSITION</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_INVALID_HANDLE</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_IN_PAGE_ERROR</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_NONCONTINUABLE_EXCEPTION</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_PRIV_INSTRUCTION</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>EXCEPTION_CODE_INFO</name><argument_list>(<argument><expr><name>EXCEPTION_STACK_OVERFLOW</name></expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !_WIN32</comment>


<comment type="line">// Exit the currently executing test.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exit_test</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>quit_application</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>global_running_test</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name>global_run_test_env</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>quit_application</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="line">// Initialize a SourceLocation structure.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>initialize_source_location</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>location</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>location</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>location</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="line">// Determine whether a source location is currently set.</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>source_location_is_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SourceLocation</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>location</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>location</name><operator>-&gt;</operator><name>file</name></name> <operator>&amp;&amp;</operator> <name><name>location</name><operator>-&gt;</operator><name>line</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Set a source location.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>set_source_location</name><parameter_list>(
		<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>location</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>location</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>location</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="line">// Create function results and expected parameter lists.</comment>
<function><type><name>void</name></type> <name>initialize_testing</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>test_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>list_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_result_map_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initialize_source_location</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_last_mock_value_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_parameter_map_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_parameter_assignment_map_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initialize_source_location</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_last_parameter_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>fail_if_leftover_values</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>test_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>error_occurred</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>remove_always_return_values</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_result_map_head</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>check_for_leftover_values</name><argument_list>(
			<argument><expr><operator>&amp;</operator><name>global_function_result_map_head</name></expr></argument>,
			<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"%s() has remaining non-returned values.\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>error_occurred</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>remove_always_return_values</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_parameter_assignment_map_head</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>check_for_leftover_values</name><argument_list>(
			<argument><expr><operator>&amp;</operator><name>global_function_parameter_assignment_map_head</name></expr></argument>,
			<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"%s() has remaining non-assigned out-values.\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>error_occurred</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>remove_always_return_values</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_parameter_map_head</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>check_for_leftover_values</name><argument_list>(
			<argument><expr><operator>&amp;</operator><name>global_function_parameter_map_head</name></expr></argument>,
			<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"%s parameter still has values that haven't been checked.\n"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>error_occurred</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>error_occurred</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>exit_test</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>teardown_testing</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>test_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_result_map_head</name></expr></argument>, <argument><expr><name>free_symbol_map_value</name></expr></argument>,
			<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initialize_source_location</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_last_mock_value_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_parameter_map_head</name></expr></argument>, <argument><expr><name>free_symbol_map_value</name></expr></argument>,
			<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initialize_source_location</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_last_parameter_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Initialize a list node.</comment>
<function><type><specifier>static</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>list_initialize</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Adds a value at the tail of a given list.
 * The node referencing the value is allocated from the heap. */</comment>
<function><type><specifier>static</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>list_add_value</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>refcount</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>new_node</name> <init>= <expr><operator>(</operator><name>ListNode</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <name>refcount</name></expr>;</expr_stmt>
	<return>return <expr><call><name>list_add</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Add new_node to the end of the list.</comment>
<function><type><specifier>static</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>list_add</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>, <parameter><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>new_node</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
	<return>return <expr><name>new_node</name></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Remove a node from a list.</comment>
<function><type><specifier>static</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>list_remove</name><parameter_list>(
		<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CleanupListValue</name></type> <name>cleanup_value</name></decl></parameter>,
		<parameter><decl><type><name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>cleanup_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cleanup_value</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>cleanup_value</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>cleanup_value_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Remove a list node from a list and free the node. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>list_remove_free</name><parameter_list>(
		<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CleanupListValue</name></type> <name>cleanup_value</name></decl></parameter>,
		<parameter><decl><type><name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>cleanup_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><call><name>list_remove</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>cleanup_value</name></expr></argument>, <argument><expr><name>cleanup_value_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Frees memory kept by a linked list
 * The cleanup_value function is called for every "value" field of nodes in the
 * list, except for the head.  In addition to each list value,
 * cleanup_value_data is passed to each call to cleanup_value.  The head
 * of the list is not deallocated.
 */</comment>
<function><type><specifier>static</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>list_free</name><parameter_list>(
		<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CleanupListValue</name></type> <name>cleanup_value</name></decl></parameter>,
		<parameter><decl><type><name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>cleanup_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><call><name>list_empty</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>list_remove_free</name><argument_list>(<argument><expr><name><name>head</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>cleanup_value</name></expr></argument>, <argument><expr><name>cleanup_value_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>head</name></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Determine whether a list is empty.</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>list_empty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>head</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>head</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Find a value in the list using the equal_func to compare each node with the
 * value.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>list_find</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>EqualityFunction</name></type> <name>equal_func</name></decl></parameter>, <parameter><decl><type><name>ListNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>current</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>current</name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>current</name> <operator>!=</operator> <name>head</name></expr>;</condition> <incr><expr><name>current</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>equal_func</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Returns the first node of a list</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>list_first</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>, <parameter><decl><type><name>ListNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>target_node</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_empty</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>target_node</name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <name>target_node</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Deallocate a value referenced by a list.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>free_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cleanup_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="line">// Releases memory associated to a symbol_map_value.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>free_symbol_map_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
		<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cleanup_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SymbolMapValue</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>map_value</name> <init>= <expr><operator>(</operator><name>SymbolMapValue</name><operator>*</operator><operator>)</operator><name>value</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>map_value</name><operator>-&gt;</operator><name>symbol_values_list_head</name></name></expr></argument>,
			<argument><expr><ternary><condition><expr><name>cleanup_value_data</name></expr> ?</condition><then> <expr><name>free_symbol_map_value</name></expr> </then><else>: <expr><name>free_value</name></expr></else></ternary></expr></argument>,
			  <argument><expr><operator>(</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>cleanup_value_data</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>map_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Determine whether a symbol name referenced by a symbol_map_value
 * matches the specified function name. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>symbol_names_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>map_value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>symbol</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SymbolMapValue</name><operator>*</operator><operator>)</operator><name>map_value</name><operator>)</operator><operator>-&gt;</operator><name>symbol_name</name></expr></argument>,
			<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>symbol</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Adds a value to the queue of values associated with the given
 * hierarchy of symbols.  It's assumed value is allocated from the heap.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>add_symbol_value</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>symbol_map_head</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>symbol_names</name><index>[]</index></name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_symbol_names</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>refcount</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>symbol_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>target_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SymbolMapValue</name> <modifier>*</modifier></type><name>target_map_value</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>symbol_map_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>symbol_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>number_of_symbol_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>symbol_name</name> <operator>=</operator> <name><name>symbol_names</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_find</name><argument_list>(<argument><expr><name>symbol_map_head</name></expr></argument>, <argument><expr><name>symbol_name</name></expr></argument>, <argument><expr><name>symbol_names_match</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>SymbolMapValue</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>new_symbol_map_value</name> <init>=
				<expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>new_symbol_map_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>new_symbol_map_value</name><operator>-&gt;</operator><name>symbol_name</name></name> <operator>=</operator> <name>symbol_name</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_symbol_map_value</name><operator>-&gt;</operator><name>symbol_values_list_head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>target_node</name> <operator>=</operator> <call><name>list_add_value</name><argument_list>(<argument><expr><name>symbol_map_head</name></expr></argument>, <argument><expr><name>new_symbol_map_value</name></expr></argument>,
				<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>target_map_value</name> <operator>=</operator> <operator>(</operator><name>SymbolMapValue</name><operator>*</operator><operator>)</operator><name><name>target_node</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>number_of_symbol_names</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>list_add_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target_map_value</name><operator>-&gt;</operator><name>symbol_values_list_head</name></name></expr></argument>,
				<argument><expr><name>value</name></expr></argument>, <argument><expr><name>refcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>add_symbol_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target_map_value</name><operator>-&gt;</operator><name>symbol_values_list_head</name></name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>symbol_names</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>number_of_symbol_names</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>,
				<argument><expr><name>refcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Gets the next value associated with the given hierarchy of symbols.
 * The value is returned as an output parameter with the function returning the
 * node's old refcount value if a value is found, 0 otherwise.
 * This means that a return value of 1 indicates the node was just removed from
 * the list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>get_symbol_value</name><parameter_list>(
		<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>symbol_names</name><index>[]</index></name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_symbol_names</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_error</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>symbol_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>target_node</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>symbol_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>number_of_symbol_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>symbol_name</name> <operator>=</operator> <name><name>symbol_names</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_find</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><name>symbol_name</name></expr></argument>, <argument><expr><name>symbol_names_match</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>SymbolMapValue</name> <modifier>*</modifier></type><name>map_value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>child_list</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>return_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>target_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>target_node</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>map_value</name> <operator>=</operator> <operator>(</operator><name>SymbolMapValue</name><operator>*</operator><operator>)</operator><name><name>target_node</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>child_list</name> <operator>=</operator> <operator>&amp;</operator><name><name>map_value</name><operator>-&gt;</operator><name>symbol_values_list_head</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>number_of_symbol_names</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>value_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>list_first</name><argument_list>(<argument><expr><name>child_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>return_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name><name>value_node</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>return_value</name> <operator>=</operator> <name><name>value_node</name><operator>-&gt;</operator><name>refcount</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>value_node</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>list_remove_free</name><argument_list>(<argument><expr><name>value_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>get_symbol_value</name><argument_list>(
					<argument><expr><name>child_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>symbol_names</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>number_of_symbol_names</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
					<argument><expr><name>log_error</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_empty</name><argument_list>(<argument><expr><name>child_list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>list_remove_free</name><argument_list>(<argument><expr><name>target_node</name></expr></argument>, <argument><expr><name>free_symbol_map_value</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>return_value</name></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>log_error</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"No entries for symbol %s.\n"</literal></expr></argument>, <argument><expr><name>symbol_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Traverse down a tree of symbol values and remove the first symbol value
 * in each branch that has a refcount &lt; -1 (i.e should always be returned
 * and has been returned at least once).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>remove_always_return_values</name><parameter_list>(<parameter><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>map_head</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_symbol_names</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>current</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>map_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>number_of_symbol_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>map_head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>current</name> <operator>!=</operator> <name>map_head</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>SymbolMapValue</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>value</name> <init>= <expr><operator>(</operator><name>SymbolMapValue</name><operator>*</operator><operator>)</operator><name><name>current</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>next</name> <init>= <expr><name><name>current</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier></type><name>child_list</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>child_list</name> <operator>=</operator> <operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>symbol_values_list_head</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_empty</name><argument_list>(<argument><expr><name>child_list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>number_of_symbol_names</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>child_node</name> <init>= <expr><name><name>child_list</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
				<comment type="line">// If this item has been returned more than once, free it.</comment>
				<if_stmt><if>if <condition>(<expr><name><name>child_node</name><operator>-&gt;</operator><name>refcount</name></name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>list_remove_free</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>free_value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><call><name>remove_always_return_values</name><argument_list>(<argument><expr><name>child_list</name></expr></argument>,
						<argument><expr><name>number_of_symbol_names</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_empty</name><argument_list>(<argument><expr><name>child_list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>list_remove_free</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>free_value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>current</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Checks if there are any leftover values set up by the test that were never
 * retrieved through execution, and fail the test if that is the case.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_for_leftover_values</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>map_head</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>error_message</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_symbol_names</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier></type><name>current</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>symbols_with_leftover_values</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>map_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>number_of_symbol_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>current</name> <operator>=</operator> <name><name>map_head</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>current</name> <operator>!=</operator> <name>map_head</name></expr>;</condition>
			<incr><expr><name>current</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>SymbolMapValue</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>value</name> <init>=
				<expr><operator>(</operator><name>SymbolMapValue</name><operator>*</operator><operator>)</operator><name><name>current</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier></type><name>child_list</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>child_list</name> <operator>=</operator> <operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>symbol_values_list_head</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_empty</name><argument_list>(<argument><expr><name>child_list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>number_of_symbol_names</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier></type><name>child_node</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>error_message</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>symbol_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"  Remaining item(s) declared at...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>child_node</name> <operator>=</operator> <name><name>child_list</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>child_node</name> <operator>!=</operator> <name>child_list</name></expr>;</condition>
						<incr><expr><name>child_node</name> <operator>=</operator> <name><name>child_node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>SourceLocation</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>location</name> <init>= <expr><name><name>child_node</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"    "</literal> <name>SOURCE_LOCATION_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
							<argument><expr><name><name>location</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name><name>location</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>symbol_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>check_for_leftover_values</name><argument_list>(<argument><expr><name>child_list</name></expr></argument>, <argument><expr><name>error_message</name></expr></argument>,
						<argument><expr><name>number_of_symbol_names</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>symbols_with_leftover_values</name> <operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>symbols_with_leftover_values</name></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Get the next return value for the specified mock function.</comment>
<function><type><name>LargestIntegralType</name></type> <name>_mock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>rc</name> <init>= <expr><call><name>get_symbol_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_result_map_head</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>function</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>SymbolValue</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>symbol</name> <init>= <expr><operator>(</operator><name>SymbolValue</name><operator>*</operator><operator>)</operator><name>result</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name> <init>= <expr><name><name>symbol</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>global_last_mock_value_location</name> <operator>=</operator> <name><name>symbol</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>


		<if_stmt><if>if <condition>(<expr><name><name>symbol</name><operator>-&gt;</operator><name>sideffect</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name><name>symbol</name><operator>-&gt;</operator><name>sideffect</name></name><argument_list>(<argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>sideeffect_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>value</name></expr>;</return>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>generate_suppression</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* We could generate a better line here, if we read the JSON information. But that is a different "story" */</comment>
		<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_DEFAULT</name></expr></argument>, <argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"Suppression for "</literal> <name>SOURCE_LOCATION_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_DEFAULT</name></expr></argument>, <argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"will_return(%s, /*insert value */);\n"</literal> <name>OUTPUT_PADDING</name> <literal type="string">" will_be_called(%s);\n\n"</literal></expr></argument>, <argument><expr><name>function</name></expr></argument>, <argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"ERROR: "</literal> <name>SOURCE_LOCATION_FORMAT</name> <literal type="string">" - Could not get value "</literal>
				<literal type="string">"to mock function %s\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>source_location_is_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_last_mock_value_location</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"Previously returned mock value was declared at "</literal>
					<name>SOURCE_LOCATION_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
					<argument><expr><name><name>global_last_mock_value_location</name><operator>.</operator><name>file</name></name></expr></argument>,
					<argument><expr><name><name>global_last_mock_value_location</name><operator>.</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"There were no previously returned mock values for "</literal>
					<literal type="string">"this test.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>abort_for_missing_check</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>exit_test</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Add a return value for the specified mock function name.</comment>
<function><type><name>void</name></type> <name>_will_return</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>function_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><name>SideeffectCallbackValue</name></type> <name>sideeffect</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>sideeffect_data</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SymbolValue</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>return_value</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>return_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>return_value</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>return_value</name><operator>-&gt;</operator><name>sideffect</name></name> <operator>=</operator> <name>sideeffect</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>return_value</name><operator>-&gt;</operator><name>sideeffect_data</name></name> <operator>=</operator> <name>sideeffect_data</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_source_location</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>return_value</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_symbol_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_result_map_head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>function_name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
			<argument><expr><name>return_value</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_will_be_called</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>function_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><name>SideeffectCallbackValue</name></type> <name>sideeffect</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>sideeffect_data</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SymbolValue</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>return_value</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>return_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>return_value</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>return_value</name><operator>-&gt;</operator><name>sideffect</name></name> <operator>=</operator> <name>sideeffect</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>return_value</name><operator>-&gt;</operator><name>sideeffect_data</name></name> <operator>=</operator> <name>sideeffect_data</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_source_location</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>return_value</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_symbol_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_result_map_head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>function_name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
			<argument><expr><name>return_value</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a custom parameter checking function.  If the event parameter is NULL
 * the event structure is allocated internally by this function.  If event
 * parameter is provided it must be allocated on the heap and doesn't need to
 * be deallocated by the caller.
 */</comment>
<function><type><name>void</name></type> <name>_expect_check</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>CheckParameterValue</name></type> <name>check_function</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_data</name></decl></parameter>,
		<parameter><decl><type><name>CheckParameterEvent</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>event</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>CheckParameterEvent</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check</name> <init>=
			<expr><ternary><condition><expr><name>event</name></expr> ?</condition><then> <expr><name>event</name></expr> </then><else>: <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>check</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>symbols</name><index>[]</index></name> <init>= <expr><block>{<expr><name>function</name></expr>, <expr><name>parameter</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>check</name><operator>-&gt;</operator><name>parameter_name</name></name> <operator>=</operator> <name>parameter</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>check</name><operator>-&gt;</operator><name>check_value</name></name> <operator>=</operator> <name>check_function</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>check</name><operator>-&gt;</operator><name>check_value_data</name></name> <operator>=</operator> <name>check_data</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_source_location</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>check</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_symbol_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_parameter_map_head</name></expr></argument>, <argument><expr><name>symbols</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>check</name></expr></argument>,
			<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Returns 1 if the specified values are equal.  If the values are not equal
 * an error is displayed and 0 is returned. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>values_equal_display_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>left</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>right</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>equal</name> <init>= <expr><name>left</name> <operator>==</operator> <name>right</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>equal</name></expr>)</condition> <block>{<block_content>
		<macro><name>print_error</name><argument_list>(<argument>OUTPUT_PADDING LargestIntegralTypePrintfFormat <literal type="string">" != "</literal>
				LargestIntegralTypePrintfFormat <literal type="string">"\n"</literal></argument>, <argument>left</argument>, <argument>right</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>equal</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns 1 if the specified values are not equal.  If the values are equal
 * an error is displayed and 0 is returned. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>values_not_equal_display_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>left</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>right</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>not_equal</name> <init>= <expr><name>left</name> <operator>!=</operator> <name>right</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>not_equal</name></expr>)</condition> <block>{<block_content>
		<macro><name>print_error</name><argument_list>(<argument>OUTPUT_PADDING LargestIntegralTypePrintfFormat <literal type="string">" == "</literal>
				LargestIntegralTypePrintfFormat <literal type="string">"\n"</literal></argument>, <argument>left</argument>, <argument>right</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>not_equal</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Determine whether value is contained within check_integer_set.
 * If invert is 0 and the value is in the set 1 is returned, otherwise 0 is
 * returned and an error is displayed.  If invert is 1 and the value is not
 * in the set 1 is returned, otherwise 0 is returned and an error is
 * displayed. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>value_in_set_display_error</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>CheckIntegerSet</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check_integer_set</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>invert</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>succeeded</name> <init>= <expr><name>invert</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>check_integer_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>LargestIntegralType</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>set</name> <init>= <expr><name><name>check_integer_set</name><operator>-&gt;</operator><name>set</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size_of_set</name> <init>= <expr><name><name>check_integer_set</name><operator>-&gt;</operator><name>size_of_set</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size_of_set</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>value</name></expr>)</condition> <block>{<block_content>
				<comment type="line">// If invert = 0 and item is found, succeeded = 1.</comment>
				<comment type="line">// If invert = 1 and item is found, succeeded = 0.</comment>
				<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <operator>!</operator><name>succeeded</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>succeeded</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"%d is %sin the set ("</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><ternary><condition><expr><name>invert</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"not "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size_of_set</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><literal type="string">"%d, "</literal></expr></argument>, <argument><expr><name><name>set</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Determine whether a value is within the specified range.  If the value is
 * within the specified range 1 is returned.  If the value isn't within the
 * specified range an error is displayed and 0 is returned. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>integer_in_range_display_error</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>range_min</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>range_max</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <name>range_min</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;=</operator> <name>range_max</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"%d is not within the range %d-%d\n"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>range_min</name></expr></argument>,
			<argument><expr><name>range_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Determine whether a value is within the specified range.  If the value
 * is not within the range 1 is returned.  If the value is within the
 * specified range an error is displayed and zero is returned. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>integer_not_in_range_display_error</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>range_min</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>range_max</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>value</name> <argument_list type="generic">&lt; <argument><expr><name>range_min</name> <operator>||</operator> <name>value</name></expr></argument> &gt;</argument_list></name> <name>range_max</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"%d is within the range %d-%d\n"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>range_min</name></expr></argument>,
			<argument><expr><name>range_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Determine whether the specified strings are equal.  If the strings are equal
 * 1 is returned.  If they're not equal an error is displayed and 0 is
 * returned. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>string_equal_display_error</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>right</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"\"%s\" != \"%s\"\n"</literal></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Determine whether the specified strings are equal.  If the strings are not
 * equal 1 is returned.  If they're not equal an error is displayed and 0 is
 * returned */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>string_not_equal_display_error</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>right</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"\"%s\" == \"%s\"\n"</literal></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Determine whether the specified areas of memory are equal.  If they're equal
 * 1 is returned otherwise an error is displayed and 0 is returned. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memory_equal_display_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>b</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>differences</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>l</name> <init>= <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>r</name> <init>= <expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>r</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"difference at offset %d 0x%02x 0x%02x\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>differences</name> <operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>differences</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"%d bytes of 0x%08x and 0x%08x differ\n"</literal></expr></argument>, <argument><expr><name>differences</name></expr></argument>,
				<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Determine whether the specified areas of memory are not equal.  If they're
 * not equal 1 is returned otherwise an error is displayed and 0 is
 * returned. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memory_not_equal_display_error</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>same</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>l</name> <init>= <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>r</name> <init>= <expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>r</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>same</name> <operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>same</name> <operator>==</operator> <name>size</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"%d bytes of 0x%08x and 0x%08x the same\n"</literal></expr></argument>, <argument><expr><name>same</name></expr></argument>,
				<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="line">// CheckParameterValue callback to check whether a value is within a set.</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_in_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>value_in_set_display_error</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
			<argument><expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(<argument><expr><name>CheckIntegerSet</name><operator>*</operator></expr></argument>,
					<argument><expr><name>check_value_data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="line">// CheckParameterValue callback to check whether a value isn't within a set.</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_not_in_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>value_in_set_display_error</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
			<argument><expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(<argument><expr><name>CheckIntegerSet</name><operator>*</operator></expr></argument>,
					<argument><expr><name>check_value_data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Create the callback data for check_in_set() or check_not_in_set() and
 * register a check event. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expect_set</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name><name>values</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_values</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>CheckParameterValue</name></type> <name>check_function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>CheckIntegerSet</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check_integer_set</name> <init>=
			<expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>check_integer_set</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
					<operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>number_of_values</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LargestIntegralType</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>set</name> <init>= <expr><operator>(</operator><name>LargestIntegralType</name><operator>*</operator><operator>)</operator><operator>(</operator>
			<name>check_integer_set</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>declare_initialize_value_pointer_pointer</name><argument_list>(<argument><expr><name>check_data</name></expr></argument>, <argument><expr><name>check_integer_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>number_of_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>number_of_values</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>check_integer_set</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <name>set</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>check_integer_set</name><operator>-&gt;</operator><name>size_of_set</name></name> <operator>=</operator> <name>number_of_values</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_expect_check</name><argument_list>(
			<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>check_function</name></expr></argument>,
			<argument><expr><name><name>check_data</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>check_integer_set</name><operator>-&gt;</operator><name>event</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="line">// Add an event to check whether a value is in a set.</comment>
<function><type><name>void</name></type> <name>_expect_in_set</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name><name>values</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_values</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>expect_set</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>number_of_values</name></expr></argument>,
			<argument><expr><name>check_in_set</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="line">// Add an event to check whether a value isn't in a set.</comment>
<function><type><name>void</name></type> <name>_expect_not_in_set</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name><name>values</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_values</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>expect_set</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>number_of_values</name></expr></argument>,
			<argument><expr><name>check_not_in_set</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="line">// CheckParameterValue callback to check whether a value is within a range.</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_in_range</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>CheckIntegerRange</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check_integer_range</name> <init>=
			<expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(<argument><expr><name>CheckIntegerRange</name><operator>*</operator></expr></argument>,
					<argument><expr><name>check_value_data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>check_integer_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>integer_in_range_display_error</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>check_integer_range</name><operator>-&gt;</operator><name>minimum</name></name></expr></argument>,
			<argument><expr><name><name>check_integer_range</name><operator>-&gt;</operator><name>maximum</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="line">// CheckParameterValue callback to check whether a value is not within a range.</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_not_in_range</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>CheckIntegerRange</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check_integer_range</name> <init>=
			<expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(<argument><expr><name>CheckIntegerRange</name><operator>*</operator></expr></argument>,
					<argument><expr><name>check_value_data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>check_integer_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>integer_not_in_range_display_error</name><argument_list>(
			<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>check_integer_range</name><operator>-&gt;</operator><name>minimum</name></name></expr></argument>, <argument><expr><name><name>check_integer_range</name><operator>-&gt;</operator><name>maximum</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Create the callback data for check_in_range() or check_not_in_range() and
 * register a check event. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expect_range</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>minimum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>maximum</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>CheckParameterValue</name></type> <name>check_function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>CheckIntegerRange</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check_integer_range</name> <init>=
			<expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>check_integer_range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>declare_initialize_value_pointer_pointer</name><argument_list>(<argument><expr><name>check_data</name></expr></argument>, <argument><expr><name>check_integer_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>check_integer_range</name><operator>-&gt;</operator><name>minimum</name></name> <operator>=</operator> <name>minimum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>check_integer_range</name><operator>-&gt;</operator><name>maximum</name></name> <operator>=</operator> <name>maximum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_expect_check</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>check_function</name></expr></argument>,
			<argument><expr><name><name>check_data</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>check_integer_range</name><operator>-&gt;</operator><name>event</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="line">// Add an event to determine whether a parameter is within a range.</comment>
<function><type><name>void</name></type> <name>_expect_in_range</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>minimum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>maximum</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>expect_range</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>maximum</name></expr></argument>,
			<argument><expr><name>check_in_range</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="line">// Add an event to determine whether a parameter is not within a range.</comment>
<function><type><name>void</name></type> <name>_expect_not_in_range</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>minimum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>maximum</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>expect_range</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>maximum</name></expr></argument>,
			<argument><expr><name>check_not_in_range</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* CheckParameterValue callback to check whether a value is equal to an
 * expected value. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>values_equal_display_error</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>check_value_data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Add an event to check a parameter equals an expected value.</comment>
<function><type><name>void</name></type> <name>_expect_value</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_expect_check</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>check_value</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
			<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* CheckParameterValue callback to check whether a value is not equal to an
 * expected value. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_not_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>values_not_equal_display_error</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>check_value_data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Add an event to check a parameter is not equal to an expected value.</comment>
<function><type><name>void</name></type> <name>_expect_not_value</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_expect_check</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>check_not_value</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
			<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="line">// CheckParameterValue callback to check whether a parameter equals a string.</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>string_equal_display_error</name><argument_list>(
			<argument><expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>, <argument><expr><name>check_value_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Add an event to check whether a parameter is equal to a string.</comment>
<function><type><name>void</name></type> <name>_expect_string</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>string</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>declare_initialize_value_pointer_pointer</name><argument_list>(<argument><expr><name>string_pointer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_expect_check</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>check_string</name></expr></argument>,
			<argument><expr><name><name>string_pointer</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* CheckParameterValue callback to check whether a parameter is not equals to
 * a string. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_not_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>string_not_equal_display_error</name><argument_list>(
			<argument><expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>, <argument><expr><name>check_value_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Add an event to check whether a parameter is not equal to a string.</comment>
<function><type><name>void</name></type> <name>_expect_not_string</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>string</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>declare_initialize_value_pointer_pointer</name><argument_list>(<argument><expr><name>string_pointer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_expect_check</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>check_not_string</name></expr></argument>,
			<argument><expr><name><name>string_pointer</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* CheckParameterValue callback to check whether a parameter equals an area of
 * memory. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_memory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>CheckMemoryData</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check</name> <init>= <expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(
			<argument><expr><name>CheckMemoryData</name><operator>*</operator></expr></argument>, <argument><expr><name>check_value_data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>memory_equal_display_error</name><argument_list>(
			<argument><expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name><name>check</name><operator>-&gt;</operator><name>memory</name></name></expr></argument>, <argument><expr><name><name>check</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Create the callback data for check_memory() or check_not_memory() and
 * register a check event. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>expect_memory_setup</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>memory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>CheckParameterValue</name></type> <name>check_function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>CheckMemoryData</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check_data</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>check_data</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>mem</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>check_data</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>declare_initialize_value_pointer_pointer</name><argument_list>(<argument><expr><name>check_data_pointer</name></expr></argument>, <argument><expr><name>check_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>memory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>memory</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>check_data</name><operator>-&gt;</operator><name>memory</name></name> <operator>=</operator> <name>mem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>check_data</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_expect_check</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>check_function</name></expr></argument>,
			<argument><expr><name><name>check_data_pointer</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>check_data</name><operator>-&gt;</operator><name>event</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="line">// Add an event to check whether a parameter matches an area of memory.</comment>
<function><type><name>void</name></type> <name>_expect_memory</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>memory</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>expect_memory_setup</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>memory</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
			<argument><expr><name>check_memory</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* CheckParameterValue callback to check whether a parameter is not equal to
 * an area of memory. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_not_memory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>CheckMemoryData</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check</name> <init>= <expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(
			<argument><expr><name>CheckMemoryData</name><operator>*</operator></expr></argument>, <argument><expr><name>check_value_data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>memory_not_equal_display_error</name><argument_list>(
			<argument><expr><call><name>cast_largest_integral_type_to_pointer</name><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>check</name><operator>-&gt;</operator><name>memory</name></name></expr></argument>,
			<argument><expr><name><name>check</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Add an event to check whether a parameter doesn't match an area of memory.</comment>
<function><type><name>void</name></type> <name>_expect_not_memory</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>memory</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>expect_memory_setup</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>memory</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
			<argument><expr><name>check_not_memory</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="line">// CheckParameterValue callback that always returns 1.</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_any</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>check_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Add an event to allow any value for a parameter.</comment>
<function><type><name>void</name></type> <name>_expect_any</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_expect_check</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>check_any</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
			<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_will_assign</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>AssignParameterValue</name></type> <name>assign_function</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>assign_data</name></decl></parameter>,
		<parameter><decl><type><name>AssignParameterEvent</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>event</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AssignParameterEvent</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>assign</name> <init>=
			<expr><ternary><condition><expr><name>event</name></expr> ?</condition><then> <expr><name>event</name></expr> </then><else>: <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>assign</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>symbols</name><index>[]</index></name> <init>= <expr><block>{<expr><name>function</name></expr>, <expr><name>parameter</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>assign</name><operator>-&gt;</operator><name>parameter_name</name></name> <operator>=</operator> <name>parameter</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>assign</name><operator>-&gt;</operator><name>assign_value</name></name> <operator>=</operator> <name>assign_function</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>assign</name><operator>-&gt;</operator><name>assign_value_data</name></name> <operator>=</operator> <name>assign_data</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_source_location</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>assign</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_symbol_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_parameter_assignment_map_head</name></expr></argument>,
			<argument><expr><name>symbols</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>assign</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>_assign_memory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>assign_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>AssignMemoryData</name><modifier>*</modifier></type> <name>memory_value</name> <init>= <expr><operator>(</operator><name>AssignMemoryData</name><operator>*</operator><operator>)</operator><name>assign_value_data</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>v</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>value</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>memory_value</name><operator>-&gt;</operator><name>memory</name></name></expr></argument>, <argument><expr><name><name>memory_value</name><operator>-&gt;</operator><name>value_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>_assign_ignore</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>assign_value_data</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_will_not_assign</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_will_assign</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>_assign_ignore</name></expr></argument>,
			<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_will_assign_memory</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>memory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>AssignMemoryData</name></name> <modifier>*</modifier></type> <name>assign_data</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>assign_data</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>mem</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>assign_data</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>declare_initialize_value_pointer_pointer</name><argument_list>(<argument><expr><name>assign_data_pointer</name></expr></argument>, <argument><expr><name>assign_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>memory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>memory</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>assign_data</name><operator>-&gt;</operator><name>memory</name></name> <operator>=</operator> <name>mem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>assign_data</name><operator>-&gt;</operator><name>value_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_will_assign</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>_assign_memory</name></expr></argument>,
			<argument><expr><name><name>assign_data_pointer</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>assign_data</name><operator>-&gt;</operator><name>event</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_will_assign_string</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>_will_assign_memory</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_will_assign_value</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parameter</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_will_assign_memory</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>parameter</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_check_expected</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>function_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>parameter_name</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>symbols</name><index>[]</index></name> <init>= <expr><block>{<expr><name>function_name</name></expr>, <expr><name>parameter_name</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>rc</name> <init>= <expr><call><name>get_symbol_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_parameter_map_head</name></expr></argument>,
			<argument><expr><name>symbols</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>CheckParameterEvent</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check</name> <init>= <expr><operator>(</operator><name>CheckParameterEvent</name><operator>*</operator><operator>)</operator><name>result</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>check_succeeded</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>global_last_parameter_location</name> <operator>=</operator> <name><name>check</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>check_succeeded</name> <operator>=</operator> <call><name><name>check</name><operator>-&gt;</operator><name>check_value</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>check</name><operator>-&gt;</operator><name>check_value_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>check_succeeded</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"ERROR: Check of parameter %s, function %s failed\n"</literal>
					<literal type="string">"Expected parameter declared at "</literal>
					<name>SOURCE_LOCATION_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
					<argument><expr><name>parameter_name</name></expr></argument>, <argument><expr><name>function_name</name></expr></argument>,
					<argument><expr><name><name>global_last_parameter_location</name><operator>.</operator><name>file</name></name></expr></argument>,
					<argument><expr><name><name>global_last_parameter_location</name><operator>.</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>generate_suppression</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_DEFAULT</name></expr></argument>, <argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"Suppression for "</literal> <name>SOURCE_LOCATION_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_DEFAULT</name></expr></argument>, <argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"expect_any(%s, %s);\n"</literal></expr></argument>, <argument><expr><name>function_name</name></expr></argument>, <argument><expr><name>parameter_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_DEFAULT</name></expr></argument>, <argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"expect_value(%s, %s, %d);\n\n"</literal></expr></argument>, <argument><expr><name>function_name</name></expr></argument>, <argument><expr><name>parameter_name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"ERROR: "</literal> <name>SOURCE_LOCATION_FORMAT</name> <literal type="string">" - Could not get value "</literal>
				<literal type="string">"to check parameter %s of function %s\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
				<argument><expr><name>parameter_name</name></expr></argument>, <argument><expr><name>function_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>source_location_is_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_last_parameter_location</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"Previously declared parameter value was declared at "</literal>
					<name>SOURCE_LOCATION_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
					<argument><expr><name><name>global_last_parameter_location</name><operator>.</operator><name>file</name></name></expr></argument>,
					<argument><expr><name><name>global_last_parameter_location</name><operator>.</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"There were no previously declared parameter values "</literal>
					<literal type="string">"for this test.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>abort_for_missing_check</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>exit_test</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_optional_assignment</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>function_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>parameter_name</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name><name>symbols</name><index>[]</index></name> <init>= <expr><block>{<expr><name>function_name</name></expr>, <expr><name>parameter_name</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>rc</name> <init>= <expr><call><name>get_symbol_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_function_parameter_assignment_map_head</name></expr></argument>,
			<argument><expr><name>symbols</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>AssignParameterEvent</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>assign</name> <init>= <expr><operator>(</operator><name>AssignParameterEvent</name><operator>*</operator><operator>)</operator><name>result</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>assign_succeeded</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>global_last_parameter_location</name> <operator>=</operator> <name><name>assign</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>assign_succeeded</name> <operator>=</operator> <call><name><name>assign</name><operator>-&gt;</operator><name>assign_value</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>assign</name><operator>-&gt;</operator><name>assign_value_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>assign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>assign_succeeded</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"ERROR: Assignment of parameter %s, function %s failed\n"</literal>
					<literal type="string">"Expected parameter declared at "</literal>
					<name>SOURCE_LOCATION_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
					<argument><expr><name>parameter_name</name></expr></argument>, <argument><expr><name>function_name</name></expr></argument>,
					<argument><expr><name><name>global_last_parameter_location</name><operator>.</operator><name>file</name></name></expr></argument>,
					<argument><expr><name><name>global_last_parameter_location</name><operator>.</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Replacement for assert.</comment>
<function><type><name>void</name></type> <name>mock_assert</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>expression</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>global_expecting_assert</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name>global_expect_assert_env</name></expr></argument>, <argument><expr><operator>(</operator><name>intptr_t</name><operator>)</operator><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"ASSERT: %s\n"</literal></expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>_assert_true</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>result</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>expression</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"expected '%s' to be true\n"</literal></expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_assert_false</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>result</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>expression</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"expected '%s' to be false\n"</literal></expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_assert_int_equal</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>b</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>values_equal_display_error</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>_assert_int_not_equal</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>b</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>values_not_equal_display_error</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>_assert_string_equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>b</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>string_equal_display_error</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>_assert_string_not_equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>b</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>string_not_equal_display_error</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>_assert_memory_equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>b</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memory_equal_display_error</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>a</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>b</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>_assert_memory_not_equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>b</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memory_not_equal_display_error</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>a</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>b</name></expr></argument>,
			<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>_assert_in_range</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>minimum</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>maximum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>integer_in_range_display_error</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_assert_not_in_range</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>minimum</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>maximum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>integer_not_in_range_display_error</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>minimum</name></expr></argument>, <argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_assert_in_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name><name>values</name><index>[]</index></name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>CheckIntegerSet</name></type> <name>check_integer_set</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>check_integer_set</name><operator>.</operator><name>set</name></name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>check_integer_set</name><operator>.</operator><name>size_of_set</name></name> <operator>=</operator> <name>number_of_values</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>value_in_set_display_error</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>check_integer_set</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_assert_not_in_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name>value</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>LargestIntegralType</name></type> <name><name>values</name><index>[]</index></name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>CheckIntegerSet</name></type> <name>check_integer_set</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>check_integer_set</name><operator>.</operator><name>set</name></name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>check_integer_set</name><operator>.</operator><name>size_of_set</name></name> <operator>=</operator> <name>number_of_values</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>value_in_set_display_error</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>check_integer_set</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="line">// Get the list of allocated blocks.</comment>
<function><type><specifier>static</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>get_allocated_blocks_list</name><parameter_list>()</parameter_list> <block>{<block_content>
	<comment type="line">// If it initialized, initialize the list of allocated blocks.</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>global_allocated_blocks</name><operator>.</operator><name>value</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>list_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_allocated_blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>global_allocated_blocks</name><operator>.</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>&amp;</operator><name>global_allocated_blocks</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Use the real malloc in this function.</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>malloc</name></cpp:undef>
<function><type><name>void</name><modifier>*</modifier></type> <name>_test_malloc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MallocBlockInfo</name> <modifier>*</modifier></type><name>block_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>block_list</name> <init>= <expr><call><name>get_allocated_blocks_list</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>allocate_size</name> <init>= <expr><name>size</name> <operator>+</operator> <operator>(</operator><name>MALLOC_GUARD_SIZE</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator>
			<sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>block_info</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>MALLOC_ALIGNMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>block</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>allocate_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Calculate the returned address.</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>block</name> <operator>+</operator> <name>MALLOC_GUARD_SIZE</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>block_info</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
			<name>MALLOC_ALIGNMENT</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>MALLOC_ALIGNMENT</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<comment type="line">// Initialize the guard blocks.</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <name>MALLOC_GUARD_SIZE</name></expr></argument>, <argument><expr><name>MALLOC_GUARD_PATTERN</name></expr></argument>, <argument><expr><name>MALLOC_GUARD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>size</name></expr></argument>, <argument><expr><name>MALLOC_GUARD_PATTERN</name></expr></argument>, <argument><expr><name>MALLOC_GUARD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>MALLOC_ALLOC_PATTERN</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>block_info</name> <operator>=</operator> <operator>(</operator><name>MallocBlockInfo</name><operator>*</operator><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <operator>(</operator><name>MALLOC_GUARD_SIZE</name> <operator>+</operator>
			<sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>block_info</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_source_location</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>block_info</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>block_info</name><operator>-&gt;</operator><name>allocated_size</name></name> <operator>=</operator> <name>allocate_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>block_info</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>block_info</name><operator>-&gt;</operator><name>block</name></name> <operator>=</operator> <name>block</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>block_info</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>block_info</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_add</name><argument_list>(<argument><expr><name>block_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>block_info</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc</name></cpp:macro> <cpp:value>test_malloc</cpp:value></cpp:define>


<function><type><name>void</name><modifier>*</modifier></type> <name>_test_calloc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_elements</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ptr</name> <init>= <expr><call><name>_test_malloc</name><argument_list>(<argument><expr><name>number_of_elements</name> <operator>*</operator> <name>size</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>number_of_elements</name> <operator>*</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Use the real free in this function.</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>free</name></cpp:undef>
<function><type><name>void</name></type> <name>_test_free</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MallocBlockInfo</name> <modifier>*</modifier></type><name>block_info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_assert_true</name><argument_list>(<argument><expr><operator>(</operator><name>intptr_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"ptr"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>block_info</name> <operator>=</operator> <operator>(</operator><name>MallocBlockInfo</name><operator>*</operator><operator>)</operator><operator>(</operator><name>block</name> <operator>-</operator> <operator>(</operator><name>MALLOC_GUARD_SIZE</name> <operator>+</operator>
			<sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>block_info</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<comment type="line">// Check the guard blocks.</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>guards</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>block</name> <operator>-</operator> <name>MALLOC_GUARD_SIZE</name></expr>,
				<expr><name>block</name> <operator>+</operator> <name><name>block_info</name><operator>-&gt;</operator><name>size</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_LENGTH</name><argument_list>(<argument><expr><name>guards</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>guard</name> <init>= <expr><name><name>guards</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>MALLOC_GUARD_SIZE</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>diff</name> <init>= <expr><name><name>guard</name><index>[<expr><name>j</name></expr>]</index></name> <operator>-</operator> <name>MALLOC_GUARD_PATTERN</name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>diff</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>print_error</name><argument_list>(
							<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"Guard block of 0x%08x size=%d allocated by "</literal>
							<name>SOURCE_LOCATION_FORMAT</name> <literal type="string">" at 0x%08x is corrupt\n"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name><name>block_info</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
							<argument><expr><name><name>block_info</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>file</name></name></expr></argument>, <argument><expr><name><name>block_info</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>line</name></name></expr></argument>,
							<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>&amp;</operator><name><name>guard</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>_fail</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>block_info</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>block</name> <operator>=</operator> <name><name>block_info</name><operator>-&gt;</operator><name>block</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>MALLOC_FREE_PATTERN</name></expr></argument>, <argument><expr><name><name>block_info</name><operator>-&gt;</operator><name>allocated_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>free</name></cpp:macro> <cpp:value>test_free</cpp:value></cpp:define>


<comment type="line">// Crudely checkpoint the current heap state.</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ListNode</name><modifier>*</modifier></type> <name>check_point_allocated_blocks</name><parameter_list>()</parameter_list> <block>{<block_content>
	<return>return <expr><call><name>get_allocated_blocks_list</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>prev</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Display the blocks allocated after the specified check point.  This
 * function returns the number of blocks displayed. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>display_allocated_blocks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check_point</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name> <init>= <expr><call><name>get_allocated_blocks_list</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>allocated_blocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>check_point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>check_point</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>node</name> <operator>=</operator> <name><name>check_point</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>node</name> <operator>!=</operator> <name>head</name></expr>;</condition> <incr><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>MallocBlockInfo</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>block_info</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>block_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allocated_blocks</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><literal type="string">"Blocks allocated...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><literal type="string">"  0x%08x : "</literal> <name>SOURCE_LOCATION_FORMAT</name> <literal type="string">"\n"</literal></expr></argument>,
				<argument><expr><name><name>block_info</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>block_info</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>file</name></name></expr></argument>,
				<argument><expr><name><name>block_info</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>allocated_blocks</name> <operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>allocated_blocks</name></expr>;</return>
</block_content>}</block></function>


<comment type="line">// Free all blocks allocated after the specified check point.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>free_allocated_blocks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check_point</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>head</name> <init>= <expr><call><name>get_allocated_blocks_list</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>check_point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>check_point</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>head</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>MallocBlockInfo</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>block_info</name> <init>= <expr><operator>(</operator><name>MallocBlockInfo</name><operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>block_info</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>block_info</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>MALLOC_GUARD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="line">// Fail if any any blocks are allocated after the specified check point.</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fail_if_blocks_allocated</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check_point</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>test_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>allocated_blocks</name> <init>= <expr><call><name>display_allocated_blocks</name><argument_list>(<argument><expr><name>check_point</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>allocated_blocks</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>free_allocated_blocks</name><argument_list>(<argument><expr><name>check_point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"ERROR: %s leaked %d block(s)\n"</literal></expr></argument>, <argument><expr><name>test_name</name></expr></argument>,
				<argument><expr><name>allocated_blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_test</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>_fail</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"ERROR: "</literal> <name>SOURCE_LOCATION_FORMAT</name> <literal type="string">" Failure!\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit_test</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exception_handler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>strsignal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit_test</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// _WIN32</comment>

<function><type><specifier>static</specifier> <name>LONG</name> <name>WINAPI</name></type> <name>exception_filter</name><parameter_list>(<parameter><decl><type><name>EXCEPTION_POINTERS</name> <modifier>*</modifier></type><name>exception_pointers</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>EXCEPTION_RECORD</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>exception_record</name> <init>=
			<expr><name><name>exception_pointers</name><operator>-&gt;</operator><name>ExceptionRecord</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DWORD</name></type> <name>code</name> <init>= <expr><name><name>exception_record</name><operator>-&gt;</operator><name>ExceptionCode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_LENGTH</name><argument_list>(<argument><expr><name>exception_codes</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ExceptionCodeInfo</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>code_info</name> <init>= <expr><operator>&amp;</operator><name><name>exception_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <name><name>code_info</name><operator>-&gt;</operator><name>code</name></name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>shown_debug_message</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"%s occurred at 0x%08x.\n"</literal></expr></argument>, <argument><expr><name><name>code_info</name><operator>-&gt;</operator><name>description</name></name></expr></argument>,
					<argument><expr><name><name>exception_record</name><operator>-&gt;</operator><name>ExceptionAddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shown_debug_message</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>print_error</name><argument_list>(
						<argument><expr><literal type="string">"\n"</literal>
						<literal type="string">"To debug in Visual Studio...\n"</literal>
						<literal type="string">"1. Select menu item File-&gt;Open Project\n"</literal>
						<literal type="string">"2. Change 'Files of type' to 'Executable Files'\n"</literal>
						<literal type="string">"3. Open this executable.\n"</literal>
						<literal type="string">"4. Select menu item Debug-&gt;Start\n"</literal>
						<literal type="string">"\n"</literal>
						<literal type="string">"Alternatively, set the environment variable \n"</literal>
						<literal type="string">"UNIT_TESTING_DEBUG to 1 and rebuild this executable, \n"</literal>
						<literal type="string">"then click 'Debug' in the popup dialog box.\n"</literal>
						<literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>shown_debug_message</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>exit_test</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>EXCEPTION_EXECUTE_HANDLER</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>EXCEPTION_CONTINUE_SEARCH</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !_WIN32</comment>


<comment type="line">// Standard output and error print methods.</comment>
<function><type><name>void</name></type> <name>vprint_message</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>color_code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><call><name>get_color</name><argument_list>(<argument><expr><name>color_code</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>get_color</name><argument_list>(<argument><expr><name>COLOR_RESET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>OutputDebugString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// _WIN32</comment>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>vprint_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><call><name>get_color</name><argument_list>(<argument><expr><name>COLOR_RED</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>get_color</name><argument_list>(<argument><expr><name>COLOR_RESET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>OutputDebugString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// _WIN32</comment>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>print_message</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>color_code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vprint_message</name><argument_list>(<argument><expr><name>color_code</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>print_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vprint_error</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>_run_test</name><parameter_list>(
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>function_name</name></decl></parameter>,  <parameter><decl><type><specifier>const</specifier> <name>UnitTestFunction</name></type> <name>Function</name></decl></parameter>,
		<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier> <specifier>const</specifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UnitTestFunctionType</name></type> <name>function_type</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>heap_check_point</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check_point</name> <init>= <expr><ternary><condition><expr><name>heap_check_point</name></expr> ?</condition><then>
			<expr><name>heap_check_point</name></expr> </then><else>: <expr><call><name>check_point_allocated_blocks</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>current_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>handle_exceptions</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
	<expr_stmt><expr><name>handle_exceptions</name> <operator>=</operator> <operator>!</operator><call><name>IsDebuggerPresent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// _WIN32</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UNIT_TESTING_DEBUG</name></expr></cpp:if>
	<expr_stmt><expr><name>handle_exceptions</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// UNIT_TESTING_DEBUG</comment>

	<if_stmt><if>if <condition>(<expr><name>handle_exceptions</name></expr>)</condition> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_LENGTH</name><argument_list>(<argument><expr><name>exception_signals</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name><name>default_signal_functions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>signal</name><argument_list>(
					<argument><expr><name><name>exception_signals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>exception_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// _WIN32</comment>
		<expr_stmt><expr><name>previous_exception_filter</name> <operator>=</operator> <call><name>SetUnhandledExceptionFilter</name><argument_list>(
				<argument><expr><name>exception_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !_WIN32</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initialize_testing</name><argument_list>(<argument><expr><name>function_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>global_running_test</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name>global_run_test_env</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>Function</name><argument_list>(<argument><expr><ternary><condition><expr><name>state</name></expr> ?</condition><then> <expr><name>state</name></expr> </then><else>: <expr><operator>&amp;</operator><name>current_state</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fail_if_leftover_values</name><argument_list>(<argument><expr><name>function_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If this is a setup function then ignore any allocated blocks
		 * only ensure they're deallocated on tear down. */</comment>
		<if_stmt><if>if <condition>(<expr><name>function_type</name> <operator>!=</operator> <name>UNIT_TEST_FUNCTION_TYPE_SETUP</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>fail_if_blocks_allocated</name><argument_list>(<argument><expr><name>check_point</name></expr></argument>, <argument><expr><name>function_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>global_running_test</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>function_type</name> <operator>==</operator> <name>UNIT_TEST_FUNCTION_TYPE_TEST</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_GREEN</name></expr></argument>, <argument><expr><literal type="string">"[          OK ] %s\n"</literal></expr></argument>, <argument><expr><name>function_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>global_running_test</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_RED</name></expr></argument>, <argument><expr><literal type="string">"[      FAILED ] %s\n"</literal></expr></argument>, <argument><expr><name>function_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>teardown_testing</name><argument_list>(<argument><expr><name>function_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>handle_exceptions</name></expr>)</condition> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRAY_LENGTH</name><argument_list>(<argument><expr><name>exception_signals</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name><name>exception_signals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>default_signal_functions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// _WIN32</comment>
		<if_stmt><if>if <condition>(<expr><name>previous_exception_filter</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>SetUnhandledExceptionFilter</name><argument_list>(<argument><expr><name>previous_exception_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>previous_exception_filter</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !_WIN32</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>_run_tests</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnitTest</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>tests</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>number_of_tests</name></decl></parameter>)</parameter_list> <block>{<block_content>

	<expr_stmt><expr><call><name>check_color_env</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Whether to execute the next test.</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>run_next_test</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<comment type="line">// Whether the previous test failed.</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>previous_test_failed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="line">// Check point of the heap state.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>check_point</name> <init>= <expr><call><name>check_point_allocated_blocks</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Current test being executed.</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>current_test</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="line">// Number of tests executed.</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>tests_executed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="line">// Number of failed tests.</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>total_failed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="line">// Number of setup functions.</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>setups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="line">// Number of teardown functions.</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>teardowns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="block">/* A stack of test states.  A state is pushed on the stack
	 * when a test setup occurs and popped on tear down. */</comment>
	<decl_stmt><decl><type><name>TestState</name><modifier>*</modifier></type> <name>test_states</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>number_of_tests</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>test_states</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>number_of_test_states</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="line">// Names of the tests that failed.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>failed_names</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>number_of_tests</name> <operator>*</operator>
			<sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>failed_names</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>current_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// Make sure LargestIntegralType is at least the size of a pointer.</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LargestIntegralType</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>current_test</name> <operator>&lt;</operator> <name>number_of_tests</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ListNode</name> <modifier>*</modifier></type><name>test_check_point</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TestState</name> <modifier>*</modifier></type><name>current_TestState</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>UnitTest</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>test</name> <init>= <expr><operator>&amp;</operator><name><name>tests</name><index>[<expr><name>current_test</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>test</name><operator>-&gt;</operator><name>function</name></name></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>function_type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>UNIT_TEST_FUNCTION_TYPE_TEST</name></expr>:</case>
			<expr_stmt><expr><name>run_next_test</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>UNIT_TEST_FUNCTION_TYPE_SETUP</name></expr>:</case> <block>{<block_content>
			<comment type="line">// Checkpoint the heap before the setup.</comment>
			<expr_stmt><expr><name>current_TestState</name> <operator>=</operator> <operator>&amp;</operator><name><name>test_states</name><index>[<expr><name>number_of_test_states</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>current_TestState</name><operator>-&gt;</operator><name>check_point</name></name> <operator>=</operator> <call><name>check_point_allocated_blocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>test_check_point</name> <operator>=</operator> <name><name>current_TestState</name><operator>-&gt;</operator><name>check_point</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>current_state</name> <operator>=</operator> <operator>&amp;</operator><name><name>current_TestState</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>current_state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_next_test</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>setups</name> <operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>UNIT_TEST_FUNCTION_TYPE_TEARDOWN</name></expr>:</case>
			<comment type="line">// Check the heap based on the last setup checkpoint.</comment>
			<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>number_of_test_states</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>current_TestState</name> <operator>=</operator> <operator>&amp;</operator><name><name>test_states</name><index>[<expr><operator>--</operator><name>number_of_test_states</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>test_check_point</name> <operator>=</operator> <name><name>current_TestState</name><operator>-&gt;</operator><name>check_point</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>current_state</name> <operator>=</operator> <operator>&amp;</operator><name><name>current_TestState</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>teardowns</name> <operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><literal type="string">"Invalid unit test function type %d\n"</literal></expr></argument>,
					<argument><expr><name><name>test</name><operator>-&gt;</operator><name>function_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit_test</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>run_next_test</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>failed</name> <init>= <expr><call><name>_run_test</name><argument_list>(<argument><expr><name><name>test</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>test</name><operator>-&gt;</operator><name>function</name></name></expr></argument>, <argument><expr><name>current_state</name></expr></argument>,
					<argument><expr><name><name>test</name><operator>-&gt;</operator><name>function_type</name></name></expr></argument>, <argument><expr><name>test_check_point</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>failed</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>failed_names</name><index>[<expr><name>total_failed</name></expr>]</index></name> <operator>=</operator> <name><name>test</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<switch>switch <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>function_type</name></name></expr>)</condition> <block>{<block_content>
			<case>case <expr><name>UNIT_TEST_FUNCTION_TYPE_TEST</name></expr>:</case>
				<expr_stmt><expr><name>previous_test_failed</name> <operator>=</operator> <name>failed</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>total_failed</name> <operator>+=</operator> <name>failed</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tests_executed</name> <operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>UNIT_TEST_FUNCTION_TYPE_SETUP</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>failed</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>total_failed</name> <operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>tests_executed</name> <operator>++</operator></expr>;</expr_stmt>
					<comment type="line">// Skip forward until the next test or setup function.</comment>
					<expr_stmt><expr><name>run_next_test</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>previous_test_failed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>UNIT_TEST_FUNCTION_TYPE_TEARDOWN</name></expr>:</case>
				<comment type="line">// If this test failed.</comment>
				<if_stmt><if>if <condition>(<expr><name>failed</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>previous_test_failed</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>total_failed</name> <operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>assert_false</name><argument_list>(<argument><expr><literal type="string">"BUG: shouldn't be here!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_GREEN</name></expr></argument>, <argument><expr><literal type="string">"[=============] %d tests ran\n"</literal></expr></argument>, <argument><expr><name>tests_executed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_GREEN</name></expr></argument>, <argument><expr><literal type="string">"[ PASSED      ] %d tests\n"</literal></expr></argument>, <argument><expr><name>tests_executed</name> <operator>-</operator> <name>total_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>total_failed</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_RED</name></expr></argument>, <argument><expr><literal type="string">"[ FAILED      ] %d tests, listed below\n"</literal></expr></argument>, <argument><expr><name>total_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>total_failed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_RED</name></expr></argument>, <argument><expr><literal type="string">"[ FAILED      ] %s \n"</literal></expr></argument>, <argument><expr><name><name>failed_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>number_of_test_states</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><literal type="string">"Mismatched number of setup %d and teardown %d "</literal>
				<literal type="string">"functions\n"</literal></expr></argument>, <argument><expr><name>setups</name></expr></argument>, <argument><expr><name>teardowns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_failed</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>test_states</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>failed_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fail_if_blocks_allocated</name><argument_list>(<argument><expr><name>check_point</name></expr></argument>, <argument><expr><literal type="string">"run_tests"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>total_failed</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>cmockery_parse_arguments</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--cmockery_abort_at_missing_check"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>cmockery_abort_at_missing_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--cmockery_generate_suppression"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>cmockery_enable_generate_suppression</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--cmockery_run_disabled_tests"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>cmockery_run_disabled_tests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>cmockery_run_disabled_tests</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_DEFAULT</name></expr></argument>, <argument><expr><literal type="string">"Run cmockery with \"disabled tests\" enabled\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_disabled_tests</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>cmockery_abort_at_missing_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_DEFAULT</name></expr></argument>, <argument><expr><literal type="string">"Run cmockery with \"abort at missing check\" enabled\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>abort_for_missing_check</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>cmockery_enable_generate_suppression</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_DEFAULT</name></expr></argument>, <argument><expr><literal type="string">"Run cmockery with \"generate suppression\" enabled\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>generate_suppression</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>cmockery_test_deactivated_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>run_disabled_tests</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>print_message</name><argument_list>(<argument><expr><name>COLOR_DEFAULT</name></expr></argument>, <argument><expr><name>OUTPUT_PADDING</name> <literal type="string">"%s is currently DISABLED.\n"</literal></expr></argument>, <argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>check_color_env</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>term</name> <init>= <expr><call><name>getenv</name> <argument_list>(<argument><expr><literal type="string">"TERM"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>term</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><literal type="string">"xterm-color"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><literal type="string">"xterm"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><literal type="string">"xterm-256color"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>use_color</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>get_color</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>color_code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>use_color</name></expr>)</condition> <block>{<block_content>
		<switch>switch <condition>(<expr><name>color_code</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>COLOR_GREEN</name></expr>:</case>
			<return>return <expr><name>COLOR_TERM_GREEN</name></expr>;</return>
		<case>case <expr><name>COLOR_RED</name></expr>:</case>
			<return>return <expr><name>COLOR_TERM_RED</name></expr>;</return>
		<case>case <expr><name>COLOR_RESET</name></expr>:</case>
			<return>return <expr><name>COLOR_TERM_RESET</name></expr>;</return>
		<default>default:</default>
			<return>return <expr><literal type="string">""</literal></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<switch>switch <condition>(<expr><name>color_code</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>COLOR_GREEN</name></expr>:</case>
			<return>return <expr><name>COLOR_NOTERM_GREEN</name></expr>;</return>
		<case>case <expr><name>COLOR_RED</name></expr>:</case>
			<return>return <expr><name>COLOR_NOTERM_RED</name></expr>;</return>
		<case>case <expr><name>COLOR_RESET</name></expr>:</case>
			<return>return <expr><name>COLOR_NOTERM_RESET</name></expr>;</return>
		<default>default:</default>
			<return>return <expr><literal type="string">""</literal></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
