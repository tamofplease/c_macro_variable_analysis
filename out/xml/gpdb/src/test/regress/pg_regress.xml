<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/test/regress/pg_regress.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_regress --- regression test driver
 *
 * This is a C implementation of the previous shell script for running
 * the regression tests, and should be mostly compatible with it.
 * Initial author of C translation: Magnus Hagander
 *
 * This code is released under the terms of the PostgreSQL License.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/test/regress/pg_regress.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mntent.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_RESOURCE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_regress.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/logging.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/restricted_token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/username.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqcomm.h"</cpp:file></cpp:include>		<comment type="block">/* needed for UNIXSOCK_PATH() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_config_paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>

<comment type="block">/* for resultmap we need a list of pairs of strings */</comment>
<typedef>typedef <type><struct>struct <name>_resultmap</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>test</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>resultfile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>_resultmap</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>_resultmap</name>;</typedef>

<comment type="block">/*
 * Values obtained from Makefile.
 */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>host_platform</name> <init>= <expr><name>HOST_TUPLE</name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>					<comment type="block">/* not used in WIN32 case */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>shellprog</name> <init>= <expr><name>SHELLPROG</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>gpdiffprog</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>gpstringsubsprog</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * On Windows we use -w in diff switches to avoid problems with inconsistent
 * newline representation.  The actual result files will generally have
 * Windows-style newlines, but the comparison files might or might not.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<comment type="block">/* GPDB:  Add stuff to ignore all the extra NOTICE messages we give */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>basic_diff_opts</name> <init>= <expr><literal type="string">"-I HINT: -I CONTEXT: -I GP_IGNORE:"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pretty_diff_opts</name> <init>= <expr><literal type="string">"-I HINT: -I CONTEXT: -I GP_IGNORE: -U3"</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>basic_diff_opts</name> <init>= <expr><literal type="string">"-w"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pretty_diff_opts</name> <init>= <expr><literal type="string">"-w -U3"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>setup_tests</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* options settable from command line */</comment>
<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>dblist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>debug</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>inputdir</name> <init>= <expr><literal type="string">"."</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>outputdir</name> <init>= <expr><literal type="string">"."</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tablespacedir</name> <init>= <expr><literal type="string">"."</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exclude_tests_file</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prehook</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bindir</name> <init>= <expr><name>PGBINDIR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>launcher</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>print_failure_diffs_is_enabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 		<name>optimizer_enabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 		<name>resgroup_enabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>_stringlist</name> <modifier>*</modifier></type><name>loadlanguage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>_stringlist</name> <modifier>*</modifier></type><name>loadextension</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>max_connections</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>max_concurrent_tests</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>_stringlist</name> <modifier>*</modifier></type><name>init_file_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>_stringlist</name> <modifier>*</modifier></type><name>schedulelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>_stringlist</name> <modifier>*</modifier></type><name>exclude_tests</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>_stringlist</name> <modifier>*</modifier></type><name>extra_tests</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>temp_instance</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>_stringlist</name> <modifier>*</modifier></type><name>temp_configs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>nolocale</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>use_existing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>port</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>port_specified_by_user</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>dlpath</name> <init>= <expr><name>PKGLIBDIR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>sslmode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>_stringlist</name> <modifier>*</modifier></type><name>extraroles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>config_auth_datadir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>  <name>ignore_plans</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* internal variables */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>logfilename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>logfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>difffilename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sockdir</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>temp_sockdir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>sockself</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>socklock</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>_resultmap</name> <modifier>*</modifier></type><name>resultmap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PID_TYPE</name></type> <name>postmaster_pid</name> <init>= <expr><name>INVALID_PID</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>postmaster_running</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>success_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>fail_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>fail_ignore_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>halt_work</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>directory_exists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>1<operator>,</operator> 2</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>status</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>1<operator>,</operator> 2</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>psql_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>database</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>2<operator>,</operator> 3</function_decl>)<empty_stmt>;</empty_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>detectCgroupMountPoint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cgdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>should_exclude_test</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>test</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>run_diff</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>content_zero_hostname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_host_name</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>contentid</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>role</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cluster_healthy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * allow core files if possible.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlimit_core_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>lim</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>lim</name><operator>.</operator><name>rlim_max</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not set core size: disallowed by hard limit\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>lim</name><operator>.</operator><name>rlim_max</name></name> <operator>==</operator> <name>RLIM_INFINITY</name> <operator>||</operator> <name><name>lim</name><operator>.</operator><name>rlim_cur</name></name> <operator>&lt;</operator> <name><name>lim</name><operator>.</operator><name>rlim_max</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lim</name><operator>.</operator><name>rlim_cur</name></name> <operator>=</operator> <name><name>lim</name><operator>.</operator><name>rlim_max</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setrlimit</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * Add an item at the end of a stringlist.
 */</comment>
<function><type><name>void</name></type>
<name>add_stringlist_item</name><parameter_list>(<parameter><decl><type><name>_stringlist</name> <modifier>*</modifier><modifier>*</modifier></type><name>listhead</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>newentry</name> <init>= <expr><call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_stringlist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>oldentry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>newentry</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newentry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>listhead</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>listhead</name> <operator>=</operator> <name>newentry</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>oldentry</name> <operator>=</operator> <operator>*</operator><name>listhead</name></expr>;</init> <condition><expr><name><name>oldentry</name><operator>-&gt;</operator><name>next</name></name></expr>;</condition> <incr><expr><name>oldentry</name> <operator>=</operator> <name><name>oldentry</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
			 <comment type="block">/* skip */</comment> <empty_stmt>;</empty_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>oldentry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>newentry</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free a stringlist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_stringlist</name><parameter_list>(<parameter><decl><type><name>_stringlist</name> <modifier>*</modifier><modifier>*</modifier></type><name>listhead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>listhead</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>listhead</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>listhead</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free_stringlist</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>listhead</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>listhead</name><operator>)</operator><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>listhead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>listhead</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Split a delimited string into a stringlist
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>split_to_stringlist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delim</name></decl></parameter>, <parameter><decl><type><name>_stringlist</name> <modifier>*</modifier><modifier>*</modifier></type><name>listhead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sc</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>token</name> <init>= <expr><call><name>strtok</name><argument_list>(<argument><expr><name>sc</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>token</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_stringlist_item</name><argument_list>(<argument><expr><name>listhead</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_exclude_tests_file</name><parameter_list>(<parameter><decl><type><name>_stringlist</name> <modifier>*</modifier><modifier>*</modifier></type><name>listhead</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>exclude_tests_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>excludefile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>excludefile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>exclude_tests_file</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>excludefile</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\ncould not open file %s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>exclude_tests_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>excludefile</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>add_stringlist_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exclude_tests</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>excludefile</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\ncould not read file %s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>exclude_tests_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>excludefile</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\ncould not close file %s: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>exclude_tests_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print a progress banner on stdout.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tmp</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>ap</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"============== %-38s ==============\n"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print "doing something ..." --- supplied text should not end with newline
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>status</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>ap</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>logfile</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Done "doing something ..."
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>status_end</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>logfile</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shut down temp postmaster
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>stop_postmaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>postmaster_running</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We use pg_ctl to issue the kill and wait for stop */</comment>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

		<comment type="block">/* On Windows, system() seems not to force fflush, so... */</comment>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"\"%s%spg_ctl\" stop -D \"%s/data\" -s"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><name>bindir</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name>temp_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: could not stop postmaster: exit code was %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* not exit(), that could be recursive */</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>postmaster_running</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
<comment type="block">/*
 * Remove the socket temporary directory.  pg_regress never waits for a
 * postmaster exit, so it is indeterminate whether the postmaster has yet to
 * unlink the socket and lock file.  Unlink them here so we can proceed to
 * remove the directory.  Ignore errors; leaking a temporary directory is
 * unimportant.  This can run from a signal handler.  The code is not
 * acceptable in a Windows signal handler (see initdb.c:trapsig()), but
 * Windows is not a HAVE_UNIX_SOCKETS platform.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_temp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>temp_sockdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sockself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>socklock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rmdir</name><argument_list>(<argument><expr><name>temp_sockdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Signal handler that calls remove_temp() and reraises the signal.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>signal_remove_temp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>remove_temp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>signum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a temporary directory suitable for the server's Unix-domain socket.
 * The directory will have mode 0700 or stricter, so no other OS user can open
 * our socket to exploit our use of trust authentication.  Most systems
 * constrain the length of socket paths well below _POSIX_PATH_MAX, so we
 * place the directory under /tmp rather than relative to the possibly-deep
 * current working directory.
 *
 * Compared to using the compiled-in DEFAULT_PGSOCKET_DIR, this also permits
 * testing to work in builds that relocate it to a directory not writable to
 * the build/test user.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>make_temp_sockdir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>template</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"/tmp/pg_regress-XXXXXX"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>temp_sockdir</name> <operator>=</operator> <call><name>mkdtemp</name><argument_list>(<argument><expr><name>template</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>temp_sockdir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>template</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Stage file names for remove_temp().  Unsafe in a signal handler. */</comment>
	<expr_stmt><expr><call><name>UNIXSOCK_PATH</name><argument_list>(<argument><expr><name>sockself</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>temp_sockdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>socklock</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>socklock</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.lock"</literal></expr></argument>, <argument><expr><name>sockself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove the directory during clean exit. */</comment>
	<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>remove_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove the directory before dying to the usual signals.  Omit SIGQUIT,
	 * preserving it as a quick, untidy exit.
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>signal_remove_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>signal_remove_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>signal_remove_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>signal_remove_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>temp_sockdir</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_UNIX_SOCKETS */</comment>

<comment type="block">/*
 * Check whether string matches pattern
 *
 * In the original shell script, this function was implemented using expr(1),
 * which provides basic regular expressions restricted to match starting at
 * the string start (in conventional regex terms, there's an implicit "^"
 * at the start of the pattern --- but no implicit "$" at the end).
 *
 * For now, we only support "." and ".*" as non-literal metacharacters,
 * because that's all that anyone has found use for in resultmap.  This
 * code could be extended if more functionality is needed.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>string_matches_pattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pattern</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pattern</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>pattern</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pattern</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<comment type="block">/* Trailing .* matches everything. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pattern</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Otherwise, scan for a text position at which we can match the
			 * rest of the pattern.
			 */</comment>
			<while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Optimization to prevent most recursion: don't recurse
				 * unless first pattern char might match this text char.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <operator>*</operator><name>pattern</name> <operator>||</operator> <operator>*</operator><name>pattern</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>string_matches_pattern</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>

			<comment type="block">/*
			 * End of text with no match.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>pattern</name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>!=</operator> <operator>*</operator><name>pattern</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Not the single-character wildcard and no explicit match? Then
			 * time to quit...
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>pattern</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pattern</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* end of pattern, so declare match */</comment>

	<comment type="block">/* End of input string.  Do we have matching pattern remaining? */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>pattern</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>pattern</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pattern</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pattern</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* end of pattern, so declare match */</comment>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Replace all occurrences of "replace" in "string" with "replacement".
 * The StringInfo will be suitably enlarged if necessary.
 *
 * Note: this is optimized on the assumption that most calls will find
 * no more than one occurrence of "replace", and quite likely none.
 */</comment>
<function><type><name>void</name></type>
<name>replace_string</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replacement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>string</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must copy the remainder of the string out of the StringInfo */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>suffix</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Truncate StringInfo at start of found string ... */</comment>
		<expr_stmt><expr><name><name>string</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name><name>string</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
		<comment type="block">/* ... and append the replacement (this restores the trailing '\0') */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Next search should start after the replacement */</comment>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>string</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
		<comment type="block">/* Put back the remainder of the string */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>replacements</name>
<block>{
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>abs_srcdir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>abs_builddir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>testtablespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dlpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dlsuffix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bindir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cgroup_mnt_point</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>content_zero_hostname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl>;</decl_stmt>
}</block></struct></type> <name>replacements</name>;</typedef>

<comment type="block">/* Internal helper function to detect cgroup mount point at runtime.*/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>detectCgroupMountPoint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cgdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
	<decl_stmt><decl><type><name><name>struct</name> <name>mntent</name></name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>setmntent</name><argument_list>(<argument><expr><literal type="string">"/proc/self/mounts"</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>me</name> <operator>=</operator> <call><name>getmntent</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>mnt_type</name></name></expr></argument>, <argument><expr><literal type="string">"cgroup"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>cgdir</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>mnt_dir</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>cgdir</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<break>break;</break>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>endmntent</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_line</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>replacements</name> <modifier>*</modifier></type><name>repls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@cgroup_mnt_point@"</literal></expr></argument>, <argument><expr><name><name>repls</name><operator>-&gt;</operator><name>cgroup_mnt_point</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@abs_srcdir@"</literal></expr></argument>, <argument><expr><name><name>repls</name><operator>-&gt;</operator><name>abs_srcdir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@abs_builddir@"</literal></expr></argument>, <argument><expr><name><name>repls</name><operator>-&gt;</operator><name>abs_builddir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@testtablespace@"</literal></expr></argument>, <argument><expr><name><name>repls</name><operator>-&gt;</operator><name>testtablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@libdir@"</literal></expr></argument>, <argument><expr><name><name>repls</name><operator>-&gt;</operator><name>dlpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@DLSUFFIX@"</literal></expr></argument>, <argument><expr><name><name>repls</name><operator>-&gt;</operator><name>dlsuffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@bindir@"</literal></expr></argument>, <argument><expr><name><name>repls</name><operator>-&gt;</operator><name>bindir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@hostname@"</literal></expr></argument>, <argument><expr><name><name>repls</name><operator>-&gt;</operator><name>content_zero_hostname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@curusername@"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>repls</name><operator>-&gt;</operator><name>username</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>repls</name><operator>-&gt;</operator><name>amname</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@amname@"</literal></expr></argument>, <argument><expr><name><name>repls</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>repls</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>, <argument><expr><literal type="string">"ao_row"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@aoseg@"</literal></expr></argument>, <argument><expr><literal type="string">"aoseg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>replace_string</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"@aoseg@"</literal></expr></argument>, <argument><expr><literal type="string">"aocsseg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generate two files for each UAO test case, one for row and the
 * other for column amname.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>generate_uao_sourcefiles</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src_dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dest_dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>, <parameter><decl><type><name>replacements</name> <modifier>*</modifier></type><name>repls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Return silently if src_dir or dest_dir is not a directory, in
	 * the same spirit as in convert_sourcefiles_in().
	 */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>stat</name><argument_list>(<argument><expr><name>src_dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>stat</name><argument_list>(<argument><expr><name>dest_dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>pgfnames</name><argument_list>(<argument><expr><name>src_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>names</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Error logged in pgfnames */</comment>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* finally loop on each file and generate the files */</comment>
	<for>for <control>(<init><expr><name>name</name> <operator>=</operator> <name>names</name></expr>;</init> <condition><expr><operator>*</operator><name>name</name></expr>;</condition> <incr><expr><name>name</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>srcfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>destfile_row</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>destfile_col</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>prefix</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>infile</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>outfile_row</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>outfile_col</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>line</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>line_row</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_tokens</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* reject filenames not finishing in ".source" */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>name</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">".source"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Build the full actual paths to open.  Optimizer specific
		 * answer filenames must end with "optimizer".
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>src_dir</name></expr></argument>, <argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">17</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>name</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">17</literal></expr></argument>, <argument><expr><literal type="string">"_optimizer.source"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>destfile_row</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s_row_optimizer.%s"</literal></expr></argument>,
					 <argument><expr><name>dest_dir</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>destfile_col</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s_column_optimizer.%s"</literal></expr></argument>,
					 <argument><expr><name>dest_dir</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>destfile_row</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s_row.%s"</literal></expr></argument>,
					 <argument><expr><name>dest_dir</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>destfile_col</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s_column.%s"</literal></expr></argument>,
					 <argument><expr><name>dest_dir</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>infile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>infile</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>srcfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>outfile_row</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>destfile_row</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outfile_row</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>destfile_row</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>outfile_col</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>destfile_col</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outfile_col</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>destfile_col</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>pg_get_line_buf</name><argument_list>(<argument><expr><name>infile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_row</name></expr></argument>, <argument><expr><name><name>line</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>repls</name><operator>-&gt;</operator><name>amname</name></name> <operator>=</operator> <literal type="string">"ao_row"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>convert_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_row</name></expr></argument>, <argument><expr><name>repls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>repls</name><operator>-&gt;</operator><name>amname</name></name> <operator>=</operator> <literal type="string">"ao_column"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>convert_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><name>repls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>line</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>outfile_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>line_row</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>outfile_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * Remember if there are any more tokens that we didn't recognize.
			 * They need to be handled by the gpstringsubs.pl script
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_tokens</name> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>line</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"@gp"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>has_tokens</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>line</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>line_row</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>outfile_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>outfile_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>has_tokens</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>gpstringsubsprog</name></expr></argument>, <argument><expr><name>destfile_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>run_diff</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>destfile_row</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not convert %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>destfile_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>gpstringsubsprog</name></expr></argument>, <argument><expr><name>destfile_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>run_diff</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>destfile_col</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not convert %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>destfile_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pgfnames_cleanup</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert *.source found in the "source" directory, replacing certain tokens
 * in the file contents with their intended values, and put the resulting files
 * in the "dest" directory, replacing the ".source" prefix in their names with
 * the given suffix.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_sourcefiles_in</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source_subdir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dest_dir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dest_subdir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>testtablespace</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>indir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cgroup_mnt_point</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>replacements</name></type> <name>repls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errstr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>indir</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>inputdir</name></expr></argument>, <argument><expr><name>source_subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that indir actually exists and is a directory */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>stat</name><argument_list>(<argument><expr><name>indir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No warning, to avoid noise in tests that do not have these
		 * directories; for example, ecpg, contrib and src/pl.
		 */</comment>
		<return>return <expr><name>count</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>pgfnames</name><argument_list>(<argument><expr><name>indir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>names</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Error logged in pgfnames */</comment>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* also create the output directory if not present */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>directory_exists</name><argument_list>(<argument><expr><name>dest_subdir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>make_directory</name><argument_list>(<argument><expr><name>dest_subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>testtablespace</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/testtablespace"</literal></expr></argument>, <argument><expr><name>tablespacedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/*
	 * On Windows only, clean out the test tablespace dir, or create it if it
	 * doesn't exist.  On other platforms we expect the Makefile to take care
	 * of that.  (We don't migrate that functionality in here because it'd be
	 * harder to cope with platform-specific issues such as SELinux.)
	 *
	 * XXX it would be better if pg_regress.c had nothing at all to do with
	 * testtablespace, and this were handled by a .BAT file or similar on
	 * Windows.  See pgsql-hackers discussion of 2008-01-18.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>directory_exists</name><argument_list>(<argument><expr><name>testtablespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>testtablespace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: could not remove test tablespace \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>testtablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>make_directory</name><argument_list>(<argument><expr><name>testtablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cgroup_mnt_point</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cgroup_mnt_point</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>detectCgroupMountPoint</name><argument_list>(<argument><expr><name>cgroup_mnt_point</name></expr></argument>,
								<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cgroup_mnt_point</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>cgroup_mnt_point</name></expr></argument>, <argument><expr><literal type="string">"/sys/fs/cgroup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>repls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repls</name><operator>.</operator><name>abs_srcdir</name></name> <operator>=</operator> <name>inputdir</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repls</name><operator>.</operator><name>abs_builddir</name></name> <operator>=</operator> <name>outputdir</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repls</name><operator>.</operator><name>testtablespace</name></name> <operator>=</operator> <name>testtablespace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repls</name><operator>.</operator><name>dlpath</name></name> <operator>=</operator> <name>dlpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repls</name><operator>.</operator><name>dlsuffix</name></name> <operator>=</operator> <name>DLSUFFIX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repls</name><operator>.</operator><name>bindir</name></name> <operator>=</operator> <name>bindir</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repls</name><operator>.</operator><name>cgroup_mnt_point</name></name> <operator>=</operator> <name>cgroup_mnt_point</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repls</name><operator>.</operator><name>content_zero_hostname</name></name> <operator>=</operator> <name>content_zero_hostname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repls</name><operator>.</operator><name>username</name></name> <operator>=</operator> <call><name>get_user_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>repls</name><operator>.</operator><name>username</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finally loop on each file and do the replacement */</comment>
	<for>for <control>(<init><expr><name>name</name> <operator>=</operator> <name>names</name></expr>;</init> <condition><expr><operator>*</operator><name>name</name></expr>;</condition> <incr><expr><name>name</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>srcfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>destfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>prefix</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>infile</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>outfile</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>line</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_tokens</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,  <argument><expr><name>indir</name></expr></argument>, <argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: stat failed for \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>srcfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* recurse if it's a directory */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>fst</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>generate_uao_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>generate_uao_file</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,  <argument><expr><name>srcfile</name></expr></argument>, <argument><expr><literal type="string">"GENERATE_ROW_AND_COLUMN_FILES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>source_subdir</name></expr></argument>, <argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>destfile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>dest_subdir</name></expr></argument>, <argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>generate_uao_file</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>count</name> <operator>+=</operator> <call><name>generate_uao_sourcefiles</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>, <argument><expr><name>destfile</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>repls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>count</name> <operator>+=</operator> <call><name>convert_sourcefiles_in</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>, <argument><expr><name>dest_dir</name></expr></argument>, <argument><expr><name>destfile</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* reject filenames not finishing in ".source" */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>name</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">".source"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* build the full actual paths to open */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>indir</name></expr></argument>, <argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>destfile</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s.%s"</literal></expr></argument>, <argument><expr><name>dest_dir</name></expr></argument>, <argument><expr><name>dest_subdir</name></expr></argument>,
				 <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>infile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>infile</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>srcfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>outfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>destfile</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outfile</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>destfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>pg_get_line_buf</name><argument_list>(<argument><expr><name>infile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>convert_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>repls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>line</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remember if there are any more tokens that we didn't recognize.
			 * They need to be handled by the gpstringsubs.pl script
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_tokens</name> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>line</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"@gp"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>has_tokens</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>line</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>has_tokens</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>gpstringsubsprog</name></expr></argument>, <argument><expr><name>destfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>run_diff</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>destfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not convert %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>destfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block></for>

	<comment type="block">/*
	 * If we didn't process any files, complain because it probably means
	 * somebody neglected to pass the needed --inputdir argument.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no *.source files found in \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>indir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgfnames_cleanup</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create the .sql, .out and .yml files from the .source files, if any */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_sourcefiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>content_zero_hostname</name> <operator>=</operator> <call><name>get_host_name</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>convert_sourcefiles_in</name><argument_list>(<argument><expr><literal type="string">"input"</literal></expr></argument>, <argument><expr><name>outputdir</name></expr></argument>, <argument><expr><literal type="string">"sql"</literal></expr></argument>, <argument><expr><literal type="string">"sql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>convert_sourcefiles_in</name><argument_list>(<argument><expr><literal type="string">"output"</literal></expr></argument>, <argument><expr><name>outputdir</name></expr></argument>, <argument><expr><literal type="string">"expected"</literal></expr></argument>, <argument><expr><literal type="string">"out"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>convert_sourcefiles_in</name><argument_list>(<argument><expr><literal type="string">"yml_in"</literal></expr></argument>, <argument><expr><name>inputdir</name></expr></argument>, <argument><expr><literal type="string">"yml"</literal></expr></argument>, <argument><expr><literal type="string">"yml"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Scan resultmap file to find which platform-specific expected files to use.
 *
 * The format of each line of the file is
 *		   testname/hostplatformpattern=substitutefile
 * where the hostplatformpattern is evaluated per the rules of expr(1),
 * namely, it is a standard regular expression with an implicit ^ at the start.
 * (We currently support only a very limited subset of regular expressions,
 * see string_matches_pattern() above.)  What hostplatformpattern will be
 * matched against is the config.guess output.  (In the shell-script version,
 * we also provided an indication of whether gcc or another compiler was in
 * use, but that facility isn't used anymore.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_resultmap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

	<comment type="block">/* scan the file ... */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/resultmap"</literal></expr></argument>, <argument><expr><name>inputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* OK if it doesn't exist, else complain */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>platform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>file_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>expected</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* strip trailing whitespace, especially the newline */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>buf</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/* parse out the line fields */</comment>
		<expr_stmt><expr><name>file_type</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>file_type</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"incorrectly formatted resultmap entry: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>file_type</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>platform</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>file_type</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>platform</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"incorrectly formatted resultmap entry: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>platform</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>expected</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>platform</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expected</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"incorrectly formatted resultmap entry: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>expected</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * if it's for current platform, save it in resultmap list. Note: by
		 * adding at the front of the list, we ensure that in ambiguous cases,
		 * the last match in the resultmap file is used. This mimics the
		 * behavior of the old shell script.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>string_matches_pattern</name><argument_list>(<argument><expr><name>host_platform</name></expr></argument>, <argument><expr><name>platform</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>_resultmap</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_resultmap</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>test</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>file_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>resultfile</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>resultmap</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>resultmap</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check in resultmap if we should be looking at a different file
 */</comment>
<function><type><specifier>static</specifier>
<specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_expectfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>testname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>default_expectfile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>expectpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>file_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>file_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>base_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_resultmap</name> <modifier>*</modifier></type><name>rm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Determine the file type from the file name. This is just what is
	 * following the last dot in the file name.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>file</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>file_type</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>file_type</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also determine the base file name from the result full path.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>file_name</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>file_name</name> <operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>file_type</name> <operator>&lt;</operator> <name>file_name</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>base_file</name></expr></argument>, <argument><expr><name>file_name</name></expr></argument>, <argument><expr><operator>(</operator><name>file_type</name><operator>)</operator> <operator>-</operator> <name>file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find the directory the default expected file is in. That is, everything
	 * up to the last slash.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>default_expectfile</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>expectpath</name></expr></argument>, <argument><expr><name>default_expectfile</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>default_expectfile</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<for>for <control>(<init><expr><name>rm</name> <operator>=</operator> <name>resultmap</name></expr>;</init> <condition><expr><name>rm</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>rm</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>testname</name></expr></argument>, <argument><expr><name><name>rm</name><operator>-&gt;</operator><name>test</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>file_type</name></expr></argument>, <argument><expr><name><name>rm</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>expectpath</name></expr></argument>, <argument><expr><name><name>rm</name><operator>-&gt;</operator><name>resultfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Use ORCA or resgroup expected outputs, if available */</comment>
	<if_stmt><if>if  <condition>(<expr><name>optimizer_enabled</name> <operator>&amp;&amp;</operator> <name>resgroup_enabled</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s_optimizer_resgroup.%s"</literal></expr></argument>, <argument><expr><name>expectpath</name></expr></argument>, <argument><expr><name>base_file</name></expr></argument>, <argument><expr><name>file_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>file_exists</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if  <condition>(<expr><name>optimizer_enabled</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s_optimizer.%s"</literal></expr></argument>, <argument><expr><name>expectpath</name></expr></argument>, <argument><expr><name>base_file</name></expr></argument>, <argument><expr><name>file_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>file_exists</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if  <condition>(<expr><name>resgroup_enabled</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s_resgroup.%s"</literal></expr></argument>, <argument><expr><name>expectpath</name></expr></argument>, <argument><expr><name>base_file</name></expr></argument>, <argument><expr><name>file_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>file_exists</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handy subroutine for setting an environment variable "var" to "val"
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>doputenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare environment variables for running regression tests
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_environment</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><literal type="string">"PGAPPNAME=pg_regress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nolocale</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Clear out any non-C locale settings
		 */</comment>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"LC_COLLATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"LC_CTYPE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"LC_MONETARY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"LC_NUMERIC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"LC_TIME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"LANG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Most platforms have adopted the POSIX locale as their
		 * implementation-defined default locale.  Exceptions include native
		 * Windows, macOS with --enable-nls, and Cygwin with --enable-nls.
		 * (Use of --enable-nls matters because libintl replaces setlocale().)
		 * Also, PostgreSQL does not support macOS with locale environment
		 * variables unset; see PostmasterMain().
		 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><literal type="string">"LANG=C"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set translation-related settings to English; otherwise psql will
	 * produce translated messages and produce diffs.  (XXX If we ever support
	 * translation of pg_regress, this needs to be moved elsewhere, where psql
	 * is actually called.)
	 */</comment>
	<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"LANGUAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"LC_ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><literal type="string">"LC_MESSAGES=C"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set encoding as requested
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>encoding</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>doputenv</name><argument_list>(<argument><expr><literal type="string">"PGCLIENTENCODING"</literal></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGCLIENTENCODING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Set timezone and datestyle for datetime-related tests
	 */</comment>
	<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><literal type="string">"PGTZ=PST8PDT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><literal type="string">"PGDATESTYLE=Postgres, MDY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Likewise set intervalstyle to ensure consistent results.  This is a bit
	 * more painful because we must use PGOPTIONS, and we want to preserve the
	 * user's ability to set other variables through that.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_pgoptions</name> <init>= <expr><literal type="string">"-c intervalstyle=postgres_verbose"</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_pgoptions</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGOPTIONS"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>new_pgoptions</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_pgoptions</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>old_pgoptions</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>new_pgoptions</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"PGOPTIONS=%s %s"</literal></expr></argument>,
								 <argument><expr><name>old_pgoptions</name></expr></argument>, <argument><expr><name>my_pgoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><name>new_pgoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>temp_instance</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Clear out any environment vars that might cause psql to connect to
		 * the wrong postmaster, or otherwise behave in nondefault ways. (Note
		 * we also use psql's -X switch consistently, so that ~/.psqlrc files
		 * won't mess things up.)  Also, set PGPORT to the temp port, and set
		 * PGHOST depending on whether we are using TCP or Unix sockets.
		 */</comment>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGDATABASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGUSER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGSERVICE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGSSLMODE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGREQUIRESSL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGCONNECT_TIMEOUT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGDATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>hostname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>doputenv</name><argument_list>(<argument><expr><literal type="string">"PGHOST"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sockdir</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PG_REGRESS_SOCK_DIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sockdir</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sockdir</name> <operator>=</operator> <call><name>make_temp_sockdir</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>doputenv</name><argument_list>(<argument><expr><literal type="string">"PGHOST"</literal></expr></argument>, <argument><expr><name>sockdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hostname</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>doputenv</name><argument_list>(<argument><expr><literal type="string">"PGHOST"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGHOSTADDR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>port</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>s</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>doputenv</name><argument_list>(<argument><expr><literal type="string">"PGPORT"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pghost</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgport</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * When testing an existing install, we honor existing environment
		 * variables, except if they're overridden by command line options.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hostname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>doputenv</name><argument_list>(<argument><expr><literal type="string">"PGHOST"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGHOSTADDR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>port</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>s</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>doputenv</name><argument_list>(<argument><expr><literal type="string">"PGPORT"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>user</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>doputenv</name><argument_list>(<argument><expr><literal type="string">"PGUSER"</literal></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>sslmode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>doputenv</name><argument_list>(<argument><expr><literal type="string">"PGSSLMODE"</literal></expr></argument>, <argument><expr><name>sslmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Report what we're connecting to
		 */</comment>
		<expr_stmt><expr><name>pghost</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGHOST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pgport</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGPORT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifndef>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pghost</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pghost</name> <operator>=</operator> <literal type="string">"localhost"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>pghost</name> <operator>&amp;&amp;</operator> <name>pgport</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"(using postmaster on %s, port %s)\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pghost</name></expr></argument>, <argument><expr><name>pgport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>pghost</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pgport</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"(using postmaster on %s, default port)\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pghost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pghost</name> <operator>&amp;&amp;</operator> <name>pgport</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"(using postmaster on Unix socket, port %s)\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pghost</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pgport</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"(using postmaster on Unix socket, default port)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>convert_sourcefiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>load_resultmap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>

<comment type="block">/* support for config_sspi_auth() */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>fmtHba</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>raw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>wp</name> <operator>=</operator> <name>ret</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>raw</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>wp</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>rp</name> <operator>=</operator> <name>raw</name></expr>;</init> <condition><expr><operator>*</operator><name>rp</name></expr>;</condition> <incr><expr><name>rp</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rp</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>wp</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>wp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>rp</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>wp</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>wp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get account and domain/realm names for the current user.  This is based on
 * pg_SSPI_recvauth().  The returned strings use static storage.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>current_windows_user</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>acct</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dom</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>accountname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>domainname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TOKEN_USER</name> <modifier>*</modifier></type><name>tokenuser</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>retlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>accountnamesize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>accountname</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>domainnamesize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>domainname</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SID_NAME_USE</name></type> <name>accountnameuse</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OpenProcessToken</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TOKEN_READ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open process token: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTokenInformation</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TokenUser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>retlen</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">122</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get token information buffer size: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>tokenuser</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>retlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTokenInformation</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TokenUser</name></expr></argument>, <argument><expr><name>tokenuser</name></expr></argument>, <argument><expr><name>retlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retlen</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get token information: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LookupAccountSid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tokenuser</name><operator>-&gt;</operator><name>User</name><operator>.</operator><name>Sid</name></name></expr></argument>, <argument><expr><name>accountname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>accountnamesize</name></expr></argument>,
						  <argument><expr><name>domainname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>domainnamesize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>accountnameuse</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not look up account SID: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tokenuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>acct</name> <operator>=</operator> <name>accountname</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>dom</name> <operator>=</operator> <name>domainname</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Rewrite pg_hba.conf and pg_ident.conf to use SSPI authentication.  Permit
 * the current OS user to authenticate as the bootstrap superuser and as any
 * user named in a --create-role option.
 *
 * In --config-auth mode, the --user switch can be used to specify the
 * bootstrap superuser's name, otherwise we assume it is the default.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>config_sspi_auth</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>superuser_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>accountname</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>domainname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_ipv6</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>hba</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ident</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>

	<comment type="block">/* Find out the name of the current OS user */</comment>
	<expr_stmt><expr><call><name>current_windows_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accountname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>domainname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine the bootstrap superuser's name */</comment>
	<if_stmt><if>if <condition>(<expr><name>superuser_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Compute the default superuser name the same way initdb does.
		 *
		 * It's possible that this result always matches "accountname", the
		 * value SSPI authentication discovers.  But the underlying system
		 * functions do not clearly guarantee that.
		 */</comment>
		<expr_stmt><expr><name>superuser_name</name> <operator>=</operator> <call><name>get_user_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>superuser_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Like initdb.c:setup_config(), determine whether the platform recognizes
	 * ::1 (IPv6 loopback) as a numeric host address string.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>gai_result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hints</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WSADATA</name></type>		<name>wsaData</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_NUMERICHOST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addrlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_canonname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>have_ipv6</name> <operator>=</operator> <operator>(</operator><call><name>WSAStartup</name><argument_list>(<argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>wsaData</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					 <call><name>getaddrinfo</name><argument_list>(<argument><expr><literal type="string">"::1"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gai_result</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Check a Write outcome and report any error. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CW</name><parameter_list>(<parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>do { \
		if (!(cond)) \
		{ \
			fprintf(stderr, _("%s: could not write to file \"%s\": %s\n"), \
					progname, fname, strerror(errno)); \
			exit(2); \
		} \
	} while (0)</cpp:value></cpp:define>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/pg_hba.conf"</literal></expr></argument>, <argument><expr><name>pgdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>res</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Truncating this name is a fatal error, because we must not fail to
		 * overwrite an original trust-authentication pg_hba.conf.
		 */</comment>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: directory name too long\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>hba</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hba</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>CW</name><argument_list>(<argument><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"# Configuration written by config_sspi_auth()\n"</literal></expr></argument>, <argument><expr><name>hba</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CW</name><argument_list>(<argument><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"host all all 127.0.0.1/32  sspi include_realm=1 map=regress\n"</literal></expr></argument>,
			 <argument><expr><name>hba</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_ipv6</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CW</name><argument_list>(<argument><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"host all all ::1/128  sspi include_realm=1 map=regress\n"</literal></expr></argument>,
				 <argument><expr><name>hba</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>CW</name><argument_list>(<argument><expr><call><name>fclose</name><argument_list>(<argument><expr><name>hba</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/pg_ident.conf"</literal></expr></argument>, <argument><expr><name>pgdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ident</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ident</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>CW</name><argument_list>(<argument><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"# Configuration written by config_sspi_auth()\n"</literal></expr></argument>, <argument><expr><name>ident</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Double-quote for the benefit of account names containing whitespace or
	 * '#'.  Windows forbids the double-quote character itself, so don't
	 * bother escaping embedded double-quote characters.
	 */</comment>
	<expr_stmt><expr><call><name>CW</name><argument_list>(<argument><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>ident</name></expr></argument>, <argument><expr><literal type="string">"regress  \"%s@%s\"  %s\n"</literal></expr></argument>,
			   <argument><expr><name>accountname</name></expr></argument>, <argument><expr><name>domainname</name></expr></argument>, <argument><expr><call><name>fmtHba</name><argument_list>(<argument><expr><name>superuser_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>extraroles</name></expr>;</init> <condition><expr><name>sl</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CW</name><argument_list>(<argument><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>ident</name></expr></argument>, <argument><expr><literal type="string">"regress  \"%s@%s\"  %s\n"</literal></expr></argument>,
				   <argument><expr><name>accountname</name></expr></argument>, <argument><expr><name>domainname</name></expr></argument>, <argument><expr><call><name>fmtHba</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>CW</name><argument_list>(<argument><expr><call><name>fclose</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_SSPI */</comment>

<comment type="block">/*
 * Issue a command via psql, connecting to the specified database
 *
 * Since we use system(), this doesn't return until the operation finishes
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>psql_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>database</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>query_formatted</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>query_escaped</name><index>[<expr><literal type="number">2048</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>psql_cmd</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">2048</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

	<comment type="block">/* Generate the query with insertion of sprintf arguments */</comment>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>query_formatted</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query_formatted</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now escape any shell double-quote metacharacters */</comment>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <name>query_escaped</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>query_formatted</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"\\\"$`"</literal></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* And now we can build and execute the shell command */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>psql_cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>psql_cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"\"%s%spsql\" -X -c \"%s\" \"%s\""</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><name>bindir</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			 <argument><expr><name>query_escaped</name></expr></argument>,
			 <argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>system</name><argument_list>(<argument><expr><name>psql_cmd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* psql probably already reported the error */</comment>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"command failed: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>psql_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Spawn a process to execute the given shell command; don't wait for it
 *
 * Returns the process ID (or HANDLE) so we can wait for it later
 */</comment>
<function><type><name>PID_TYPE</name></type>
<name>spawn_process</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Must flush I/O buffers before fork.  Ideally we'd use fflush(NULL) here
	 * ... does anyone still care about systems where that doesn't work?
	 */</comment>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>logfile</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not fork: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In child
		 *
		 * Instead of using system(), exec the shell directly, and tell it to
		 * "exec" the command too.  This saves two useless processes per
		 * parallel test case.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cmdline2</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cmdline2</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"exec %s"</literal></expr></argument>, <argument><expr><name>cmdline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>execl</name><argument_list>(<argument><expr><name>shellprog</name></expr></argument>, <argument><expr><name>shellprog</name></expr></argument>, <argument><expr><literal type="string">"-c"</literal></expr></argument>, <argument><expr><name>cmdline2</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not exec \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>shellprog</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>				<comment type="block">/* not exit() here... */</comment>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* in parent */</comment>
	<return>return <expr><name>pid</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>pi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cmdline2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>restrictedToken</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmdline2</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"cmd /c \"%s\""</literal></expr></argument>, <argument><expr><name>cmdline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>restrictedToken</name> <operator>=</operator>
		 <call><name>CreateRestrictedProcess</name><argument_list>(<argument><expr><name>cmdline2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Count bytes in file
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>file_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Count lines in file
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>file_line_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>l</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>l</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>open_file_for_reading</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>file</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>file</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_contents_of_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>string</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>open_file_for_reading</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>file_exists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>directory_exists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create a directory */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>S_IRWXU</name> <operator>|</operator> <name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * In: filename.ext, Return: filename_i.ext, where 0 &lt; i &lt;= 9
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_alternative_expectfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expectfile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>last_dot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ssize</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>expectfile</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>tmp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>ssize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>ssize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>expectfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_dot</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last_dot</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>last_dot</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ssize</name></expr></argument>, <argument><expr><literal type="string">"%s_%d.%s"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>last_dot</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Run a "diff" command and also check that it didn't crash
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>run_diff</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"diff command failed with status %d: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/*
	 * On WIN32, if the 'diff' command cannot be found, system() returns 1,
	 * but produces nothing to stdout, so we check for that here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>file_size</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"diff command not found: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check the actual result file for the given test against expected results
 *
 * Returns true if different (failure), false if correct match found.
 * In the true case, the diff is appended to the diffs file.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>results_differ</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>testname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultsfile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>default_expectfile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>expectfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>diff</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>best_expect_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>		<name><name>diff_opts</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>diff_opts_st</name> <init>= <expr><name>diff_opts</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>diff_opts_en</name> <init>= <expr><name>diff_opts</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>diff_opts</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>m_pretty_diff_opts</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>generated_initfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pretty_diff_opts_st</name> <init>= <expr><name>m_pretty_diff_opts</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pretty_diff_opts_en</name> <init>= <expr><name>m_pretty_diff_opts</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>m_pretty_diff_opts</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>difffile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>best_line_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>platform_expectfile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ignore_plans_opts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can pass either the resultsfile or the expectfile, they should have
	 * the same type (filename.type) anyway.
	 */</comment>
	<expr_stmt><expr><name>platform_expectfile</name> <operator>=</operator> <call><name>get_expectfile</name><argument_list>(<argument><expr><name>testname</name></expr></argument>, <argument><expr><name>resultsfile</name></expr></argument>, <argument><expr><name>default_expectfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>platform_expectfile</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>expectfile</name></expr></argument>, <argument><expr><name>platform_expectfile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>expectfile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>expectfile</name></expr></argument>, <argument><expr><name>default_expectfile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>expectfile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ignore_plans</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ignore_plans_opts</name> <operator>=</operator> <literal type="string">" -gpd_ignore_plans"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ignore_plans_opts</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Name to use for temporary diff file */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.diff"</literal></expr></argument>, <argument><expr><name>resultsfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
	<comment type="block">/* Add init file arguments if provided via commandline */</comment>
	<expr_stmt><expr><name>diff_opts_st</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>diff_opts_st</name></expr></argument>,
							 <argument><expr><name>diff_opts_en</name> <operator>-</operator> <name>diff_opts_st</name></expr></argument>,
							 <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>basic_diff_opts</name></expr></argument>, <argument><expr><name>ignore_plans_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pretty_diff_opts_st</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>pretty_diff_opts_st</name></expr></argument>,
									<argument><expr><name>pretty_diff_opts_en</name> <operator>-</operator> <name>pretty_diff_opts_st</name></expr></argument>,
									<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>pretty_diff_opts</name></expr></argument>, <argument><expr><name>ignore_plans_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>init_file_list</name></expr>;</init> <condition><expr><name>sl</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>diff_opts_st</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>diff_opts_st</name></expr></argument>,
								 <argument><expr><name>diff_opts_en</name> <operator>-</operator> <name>diff_opts_st</name></expr></argument>,
								 <argument><expr><literal type="string">" --gpd_init %s"</literal></expr></argument>, <argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pretty_diff_opts_st</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>pretty_diff_opts_st</name></expr></argument>,
										<argument><expr><name>pretty_diff_opts_en</name> <operator>-</operator> <name>pretty_diff_opts_st</name></expr></argument>,
										<argument><expr><literal type="string">" --gpd_init %s"</literal></expr></argument>, <argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Add auto generated init file if it is generated */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.initfile"</literal></expr></argument>, <argument><expr><name>resultsfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>file_exists</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>generated_initfile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>generated_initfile</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"--gpd_init %s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>generated_initfile</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>generated_initfile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* OK, run the diff */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"%s %s %s \"%s\" \"%s\" &gt; \"%s\""</literal></expr></argument>,
			 <argument><expr><name>gpdiffprog</name></expr></argument>, <argument><expr><name>diff_opts</name></expr></argument>, <argument><expr><name>generated_initfile</name></expr></argument>, <argument><expr><name>expectfile</name></expr></argument>, <argument><expr><name>resultsfile</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Is the diff file empty? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>run_diff</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* There may be secondary comparison files that match better */</comment>
	<expr_stmt><expr><name>best_line_count</name> <operator>=</operator> <call><name>file_line_count</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>best_expect_file</name></expr></argument>, <argument><expr><name>expectfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">9</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>alt_expectfile</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>alt_expectfile</name> <operator>=</operator> <call><name>get_alternative_expectfile</name><argument_list>(<argument><expr><name>expectfile</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alt_expectfile</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unable to check secondary comparison files: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>file_exists</name><argument_list>(<argument><expr><name>alt_expectfile</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>alt_expectfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"%s %s %s \"%s\" \"%s\" &gt; \"%s\""</literal></expr></argument>,
				 <argument><expr><name>gpdiffprog</name></expr></argument>, <argument><expr><name>diff_opts</name></expr></argument>, <argument><expr><name>generated_initfile</name></expr></argument>, <argument><expr><name>alt_expectfile</name></expr></argument>, <argument><expr><name>resultsfile</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>run_diff</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>alt_expectfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>file_line_count</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <name>best_line_count</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* This diff was a better match than the last one */</comment>
			<expr_stmt><expr><name>best_line_count</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>best_expect_file</name></expr></argument>, <argument><expr><name>alt_expectfile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>best_expect_file</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>alt_expectfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * fall back on the canonical results file if we haven't tried it yet and
	 * haven't found a complete match yet.
	 *
	 * In GPDB, platform_expectfile is used for determining ORCA/planner/resgroup
	 * expect files, wheras in upstream that is not the case and it is based on
	 * the underlying platform. Thus, it is unnecessary and confusing to compare
	 * against default answer file even when platform_expect file exists. It gets
	 * confusing because the below block chooses the best expect file based on
	 * the number of lines in diff file.
	 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	if (platform_expectfile)
	{
		snprintf(cmd, sizeof(cmd),
				 "%s %s %s \"%s\" \"%s\" &gt; \"%s\"",
				 gpdiffprog, diff_opts, generated_initfile, default_expectfile, resultsfile, diff);

		if (run_diff(cmd, diff) == 0)
		{
			<comment type="block">/* No diff = no changes = good */</comment>
			unlink(diff);
			return false;
		}

		l = file_line_count(diff);
		if (l &lt; best_line_count)
		{
			<comment type="block">/* This diff was a better match than the last one */</comment>
			best_line_count = l;
			strlcpy(best_expect_file, default_expectfile, sizeof(best_expect_file));
		}
	}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/*
	 * Use the best comparison file to generate the "pretty" diff, which we
	 * append to the diffs summary file.
	 */</comment>

	<comment type="block">/* Write diff header */</comment>
	<expr_stmt><expr><name>difffile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>difffilename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>difffile</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>difffile</name></expr></argument>,
				<argument><expr><literal type="string">"diff %s %s %s\n"</literal></expr></argument>,
				<argument><expr><name>pretty_diff_opts</name></expr></argument>, <argument><expr><name>best_expect_file</name></expr></argument>, <argument><expr><name>resultsfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>difffile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Run diff */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"%s %s %s \"%s\" \"%s\" &gt;&gt; \"%s\""</literal></expr></argument>,
			 <argument><expr><name>gpdiffprog</name></expr></argument>, <argument><expr><name>m_pretty_diff_opts</name></expr></argument>, <argument><expr><name>generated_initfile</name></expr></argument>, <argument><expr><name>best_expect_file</name></expr></argument>, <argument><expr><name>resultsfile</name></expr></argument>, <argument><expr><name>difffilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>run_diff</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>difffilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for specified subprocesses to finish, and return their exit
 * statuses into statuses[] and stop times into stoptimes[]
 *
 * If names isn't NULL, print each subprocess's name as it finishes
 *
 * Note: it's OK to scribble on the pids array, but not on the names array
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>wait_for_tests</name><parameter_list>(<parameter><decl><type><name>PID_TYPE</name> <modifier>*</modifier></type> <name>pids</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>statuses</name></decl></parameter>, <parameter><decl><type><name>instr_time</name> <modifier>*</modifier></type><name>stoptimes</name></decl></parameter>,
			   <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_tests</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tests_left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PID_TYPE</name>   <modifier>*</modifier></type><name>active_pids</name> <init>= <expr><call><name>pg_malloc</name><argument_list>(<argument><expr><name>num_tests</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PID_TYPE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>active_pids</name></expr></argument>, <argument><expr><name>pids</name></expr></argument>, <argument><expr><name>num_tests</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PID_TYPE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>tests_left</name> <operator>=</operator> <name>num_tests</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>tests_left</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PID_TYPE</name></type>	<name>p</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>int</name></type>			<name>exit_status</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exit_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>INVALID_PID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to wait for subprocesses: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>DWORD</name></type>		<name>exit_status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WaitForMultipleObjects</name><argument_list>(<argument><expr><name>tests_left</name></expr></argument>, <argument><expr><name>active_pids</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <name>WAIT_OBJECT_0</name> <operator>||</operator> <name>r</name> <operator>&gt;=</operator> <name>WAIT_OBJECT_0</name> <operator>+</operator> <name>tests_left</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to wait for subprocesses: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>active_pids</name><index>[<expr><name>r</name> <operator>-</operator> <name>WAIT_OBJECT_0</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* compact the active_pids array */</comment>
		<expr_stmt><expr><name><name>active_pids</name><index>[<expr><name>r</name> <operator>-</operator> <name>WAIT_OBJECT_0</name></expr>]</index></name> <operator>=</operator> <name><name>active_pids</name><index>[<expr><name>tests_left</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tests</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>pids</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
				<expr_stmt><expr><call><name>GetExitCodeProcess</name><argument_list>(<argument><expr><name><name>pids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exit_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name><name>pids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>INVALID_PID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>statuses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>exit_status</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>stoptimes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>names</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>tests_left</name><operator>--</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>active_pids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * report nonzero exit code from a test process
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_child_failure</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>exitstatus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (test process exited with exit code %d)"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (test process was terminated by exception 0x%X)"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (test process was terminated by signal %d: %s)"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pg_strsignal</name><argument_list>(<argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (test process exited with unrecognized status %d)"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run all the tests specified in one schedule file
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_schedule</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schedule</name></decl></parameter>, <parameter><decl><type><name>test_function</name></type> <name>tfunc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PARALLEL_TESTS</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>tests</name><index>[<expr><name>MAX_PARALLEL_TESTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name><name>resultfiles</name><index>[<expr><name>MAX_PARALLEL_TESTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name><name>expectfiles</name><index>[<expr><name>MAX_PARALLEL_TESTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name><name>tags</name><index>[<expr><name>MAX_PARALLEL_TESTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PID_TYPE</name></type>	<name><name>pids</name><index>[<expr><name>MAX_PARALLEL_TESTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name><name>starttimes</name><index>[<expr><name>MAX_PARALLEL_TESTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name><name>stoptimes</name><index>[<expr><name>MAX_PARALLEL_TESTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>statuses</name><index>[<expr><name>MAX_PARALLEL_TESTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>ignorelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>scbuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>scf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>line_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>tests</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>resultfiles</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resultfiles</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>expectfiles</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>expectfiles</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>tags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tags</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scf</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>schedule</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>schedule</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>scbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>scbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>scf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>test</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_tests</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>excluded_tests</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>inword</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>start_time</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>line_num</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* strip trailing whitespace, especially the newline */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>scbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>scbuf</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scbuf</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><name><name>scbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>scbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>scbuf</name></expr></argument>, <argument><expr><literal type="string">"test: "</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>test</name> <operator>=</operator> <name>scbuf</name> <operator>+</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>scbuf</name></expr></argument>, <argument><expr><literal type="string">"ignore: "</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <name>scbuf</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>*</operator><name>c</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>add_stringlist_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ignorelist</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Note: ignore: lines do not run the test, they just say that
			 * failure of this test when run later on is to be ignored. A bit
			 * odd but that's how the shell-script version did it.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"syntax error in schedule file \"%s\" line %d: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>schedule</name></expr></argument>, <argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>scbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>num_tests</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>excluded_tests</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>inword</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>test</name></expr>;</init><condition>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>inword</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Reached end of a test name */</comment>
					<decl_stmt><decl><type><name>char</name></type>		<name>sav</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>num_tests</name> <operator>&gt;=</operator> <name>MAX_PARALLEL_TESTS</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many parallel tests (more than %d) in schedule file \"%s\" line %d: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>MAX_PARALLEL_TESTS</name></expr></argument>, <argument><expr><name>schedule</name></expr></argument>, <argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>scbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>sav</name> <operator>=</operator> <operator>*</operator><name>c</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tests</name><index>[<expr><name>num_tests</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>num_tests</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <name>sav</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>inword</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * GPDB: if this test is in the exclude list, don't add it to the
					 * array, after all.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>should_exclude_test</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>num_tests</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>excluded_tests</name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name>num_tests</name><operator>--</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* loop exit is here */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name>inword</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Start of a test name */</comment>
				<expr_stmt><expr><name>test</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>inword</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* The last test in the line needs to be checked for exclusion */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_tests</name> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>should_exclude_test</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>num_tests</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>num_tests</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>excluded_tests</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>num_tests</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>excluded_tests</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"syntax error in schedule file \"%s\" line %d: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>schedule</name></expr></argument>, <argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>scbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* All tests in this line are to be excluded, so go to the next line */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_tests</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cluster_healthy</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>num_tests</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"test %-28s ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>tfunc</name><operator>)</operator> <operator>(</operator><name><name>tests</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <operator>&amp;</operator><name><name>resultfiles</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <operator>&amp;</operator><name><name>expectfiles</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <operator>&amp;</operator><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>starttimes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>wait_for_tests</name><argument_list>(<argument><expr><name>pids</name></expr></argument>, <argument><expr><name>statuses</name></expr></argument>, <argument><expr><name>stoptimes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* status line is finished below */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>max_concurrent_tests</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>max_concurrent_tests</name> <operator>&lt;</operator> <name>num_tests</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many parallel tests (more than %d) in schedule file \"%s\" line %d: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>max_concurrent_tests</name></expr></argument>, <argument><expr><name>schedule</name></expr></argument>, <argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>scbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>max_connections</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>max_connections</name> <operator>&lt;</operator> <name>num_tests</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>oldest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"parallel group (%d tests, in groups of %d): "</literal></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>num_tests</name></expr></argument>, <argument><expr><name>max_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tests</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>-</operator> <name>oldest</name> <operator>&gt;=</operator> <name>max_connections</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>wait_for_tests</name><argument_list>(<argument><expr><name>pids</name> <operator>+</operator> <name>oldest</name></expr></argument>, <argument><expr><name>statuses</name> <operator>+</operator> <name>oldest</name></expr></argument>,
								   <argument><expr><name>stoptimes</name> <operator>+</operator> <name>oldest</name></expr></argument>,
								   <argument><expr><name>tests</name> <operator>+</operator> <name>oldest</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <name>oldest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>oldest</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>pids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>tfunc</name><operator>)</operator> <operator>(</operator><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>,</operator> <operator>&amp;</operator><name><name>resultfiles</name><index>[<expr><name>i</name></expr>]</index></name><operator>,</operator> <operator>&amp;</operator><name><name>expectfiles</name><index>[<expr><name>i</name></expr>]</index></name><operator>,</operator> <operator>&amp;</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>starttimes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>wait_for_tests</name><argument_list>(<argument><expr><name>pids</name> <operator>+</operator> <name>oldest</name></expr></argument>, <argument><expr><name>statuses</name> <operator>+</operator> <name>oldest</name></expr></argument>,
						   <argument><expr><name>stoptimes</name> <operator>+</operator> <name>oldest</name></expr></argument>,
						   <argument><expr><name>tests</name> <operator>+</operator> <name>oldest</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <name>oldest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>status_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"parallel group (%d tests): "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>num_tests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tests</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>pids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>tfunc</name><operator>)</operator> <operator>(</operator><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>,</operator> <operator>&amp;</operator><name><name>resultfiles</name><index>[<expr><name>i</name></expr>]</index></name><operator>,</operator> <operator>&amp;</operator><name><name>expectfiles</name><index>[<expr><name>i</name></expr>]</index></name><operator>,</operator> <operator>&amp;</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>starttimes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>wait_for_tests</name><argument_list>(<argument><expr><name>pids</name></expr></argument>, <argument><expr><name>statuses</name></expr></argument>, <argument><expr><name>stoptimes</name></expr></argument>, <argument><expr><name>tests</name></expr></argument>, <argument><expr><name>num_tests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>status_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Check results for all tests */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tests</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>rl</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>el</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>differ</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>instr_time</name></type> <name>diff_start_time</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>instr_time</name></type> <name>diff_stop_time</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>num_tests</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"     %-28s ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Advance over all three lists simultaneously.
			 *
			 * Compare resultfiles[j] with expectfiles[j] always. Tags are
			 * optional but if there are tags, the tag list has the same
			 * length as the other two lists.
			 */</comment>

			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>diff_start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>rl</name> <operator>=</operator> <name><name>resultfiles</name><index>[<expr><name>i</name></expr>]</index></name></expr><operator>,</operator> <expr><name>el</name> <operator>=</operator> <name><name>expectfiles</name><index>[<expr><name>i</name></expr>]</index></name></expr><operator>,</operator> <expr><name>tl</name> <operator>=</operator> <name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init>
				 <condition><expr><name>rl</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>	<comment type="block">/* rl and el have the same length */</comment>
				 <incr><expr><name>rl</name> <operator>=</operator> <name><name>rl</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>el</name> <operator>=</operator> <name><name>el</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator>
				 <expr><name>tl</name> <operator>=</operator> <ternary><condition><expr><name>tl</name></expr> ?</condition><then> <expr><name><name>tl</name><operator>-&gt;</operator><name>next</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>newdiff</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>newdiff</name> <operator>=</operator> <call><name>results_differ</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>el</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>newdiff</name> <operator>&amp;&amp;</operator> <name>tl</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><name><name>tl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>differ</name> <operator>|=</operator> <name>newdiff</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>diff_stop_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>differ</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>ignore</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>ignorelist</name></expr>;</init> <condition><expr><name>sl</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>ignore</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><name>ignore</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed (ignored)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>fail_ignore_count</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"FAILED"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>fail_count</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"ok    "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* align with FAILED */</comment>
				<expr_stmt><expr><name>success_count</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>statuses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>log_child_failure</name><argument_list>(<argument><expr><name><name>statuses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name><name>stoptimes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>starttimes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" %8.0f ms"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name><name>stoptimes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>diff_stop_time</name></expr></argument>, <argument><expr><name>diff_start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (diff %4.0f ms)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>diff_stop_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>status_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tests</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free_stringlist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>resultfiles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free_stringlist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>expectfiles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free_stringlist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>free_stringlist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ignorelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>scf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run a single test
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_single_test</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>test</name></decl></parameter>, <parameter><decl><type><name>test_function</name></type> <name>tfunc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PID_TYPE</name></type>	<name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>starttime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>stoptime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>exit_status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>resultfiles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>expectfiles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>tags</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>rl</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>el</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>differ</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cluster_healthy</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>should_exclude_test</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>test</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"test %-28s ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>(</operator><name>tfunc</name><operator>)</operator> <operator>(</operator><name>test</name><operator>,</operator> <operator>&amp;</operator><name>resultfiles</name><operator>,</operator> <operator>&amp;</operator><name>expectfiles</name><operator>,</operator> <operator>&amp;</operator><name>tags</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>wait_for_tests</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exit_status</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stoptime</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advance over all three lists simultaneously.
	 *
	 * Compare resultfiles[j] with expectfiles[j] always. Tags are optional
	 * but if there are tags, the tag list has the same length as the other
	 * two lists.
	 */</comment>
	<for>for <control>(<init><expr><name>rl</name> <operator>=</operator> <name>resultfiles</name></expr><operator>,</operator> <expr><name>el</name> <operator>=</operator> <name>expectfiles</name></expr><operator>,</operator> <expr><name>tl</name> <operator>=</operator> <name>tags</name></expr>;</init>
		 <condition><expr><name>rl</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>			<comment type="block">/* rl and el have the same length */</comment>
		 <incr><expr><name>rl</name> <operator>=</operator> <name><name>rl</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>el</name> <operator>=</operator> <name><name>el</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator>
		 <expr><name>tl</name> <operator>=</operator> <ternary><condition><expr><name>tl</name></expr> ?</condition><then> <expr><name><name>tl</name><operator>-&gt;</operator><name>next</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>newdiff</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newdiff</name> <operator>=</operator> <call><name>results_differ</name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name><name>rl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>el</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newdiff</name> <operator>&amp;&amp;</operator> <name>tl</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><name><name>tl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>differ</name> <operator>|=</operator> <name>newdiff</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>differ</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"FAILED"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fail_count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"ok    "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* align with FAILED */</comment>
		<expr_stmt><expr><name>success_count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>exit_status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>log_child_failure</name><argument_list>(<argument><expr><name>exit_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>stoptime</name></expr></argument>, <argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" %8.0f ms"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>stoptime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>status_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find the other binaries that we need. Currently, gpdiff.pl and
 * gpstringsubs.pl.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_helper_programs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>find_other_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><literal type="string">"gpdiff.pl"</literal></expr></argument>, <argument><expr><literal type="string">"gpdiff.pl "</literal> <name>GP_VERSION</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>gpdiffprog</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>full_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>full_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The program \"gpdiff.pl\" is needed by %s "</literal>
				  <literal type="string">"but was not found in the same directory as \"%s\".\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>find_other_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><literal type="string">"gpstringsubs.pl"</literal></expr></argument>, <argument><expr><literal type="string">"gpstringsubs.pl "</literal> <name>GP_VERSION</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>gpstringsubsprog</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>full_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>full_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The program \"gpstringsubs.pl\" is needed by %s "</literal>
				  <literal type="string">"but was not found in the same directory as \"%s\".\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Create the summary-output files (making them empty if already existing)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>open_result_files</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>difffile</name></decl>;</decl_stmt>

	<comment type="block">/* create outputdir directory if not present */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>directory_exists</name><argument_list>(<argument><expr><name>outputdir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>make_directory</name><argument_list>(<argument><expr><name>outputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* create the log file (copy of running status output) */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/regression.out"</literal></expr></argument>, <argument><expr><name>outputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>logfilename</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>logfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>logfilename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>logfile</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>logfilename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* create the diffs file as empty */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/regression.diffs"</literal></expr></argument>, <argument><expr><name>outputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>difffilename</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>difffile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>difffilename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>difffile</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for writing: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>difffilename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* we don't keep the diffs file open continuously */</comment>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>difffile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* also create the results directory if not present */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/results"</literal></expr></argument>, <argument><expr><name>outputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>directory_exists</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>make_directory</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>drop_database_if_exists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"dropping database \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>psql_command</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><literal type="string">"DROP DATABASE IF EXISTS \"%s\""</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_database</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use template0 so that any installation-local cruft in template1 will
	 * not mess up the tests.
	 */</comment>
	<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating database \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>encoding</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>psql_command</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><literal type="string">"CREATE DATABASE \"%s\" TEMPLATE=template0 ENCODING='%s'"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>psql_command</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><literal type="string">"CREATE DATABASE \"%s\" TEMPLATE=template0%s"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><operator>(</operator><name>nolocale</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" LC_COLLATE='C' LC_CTYPE='C'"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>psql_command</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>,
				 <argument><expr><literal type="string">"ALTER DATABASE \"%s\" SET lc_messages TO 'C';"</literal>
				 <literal type="string">"ALTER DATABASE \"%s\" SET lc_monetary TO 'C';"</literal>
				 <literal type="string">"ALTER DATABASE \"%s\" SET lc_numeric TO 'C';"</literal>
				 <literal type="string">"ALTER DATABASE \"%s\" SET lc_time TO 'C';"</literal>
				 <literal type="string">"ALTER DATABASE \"%s\" SET bytea_output TO 'hex';"</literal>
				 <literal type="string">"ALTER DATABASE \"%s\" SET timezone_abbreviations TO 'Default';"</literal></expr></argument>,
				 <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Install any requested procedural languages.  We use CREATE OR REPLACE
	 * so that this will work whether or not the language is preinstalled.
	 */</comment>
	<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>loadlanguage</name></expr>;</init> <condition><expr><name>sl</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"installing %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>psql_command</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE LANGUAGE \"%s\""</literal></expr></argument>, <argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Install any requested extensions.  We use CREATE IF NOT EXISTS so that
	 * this will work whether or not the extension is preinstalled.
	 */</comment>
	<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>loadextension</name></expr>;</init> <condition><expr><name>sl</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"installing %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>psql_command</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><literal type="string">"CREATE EXTENSION IF NOT EXISTS \"%s\""</literal></expr></argument>, <argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>drop_role_if_exists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rolename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"dropping role \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rolename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>psql_command</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><literal type="string">"DROP ROLE IF EXISTS \"%s\""</literal></expr></argument>, <argument><expr><name>rolename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_role</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rolename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>_stringlist</name> <modifier>*</modifier></type><name>granted_dbs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating role \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rolename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>psql_command</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><literal type="string">"CREATE ROLE \"%s\" WITH LOGIN"</literal></expr></argument>, <argument><expr><name>rolename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init> <condition><expr><name>granted_dbs</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>granted_dbs</name> <operator>=</operator> <name><name>granted_dbs</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>psql_command</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><literal type="string">"GRANT ALL ON DATABASE \"%s\" TO \"%s\""</literal></expr></argument>,
					 <argument><expr><name><name>granted_dbs</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>rolename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>trim_white_space</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>str</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>end</name> <operator>=</operator> <name>str</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>end</name> <operator>&gt;</operator> <name>str</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>end</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>end</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>end</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Should the test be excluded from running
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>should_exclude_test</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>test</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>exclude_tests</name></expr>;</init> <condition><expr><name>sl</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>test</name></expr></argument>, <argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * @brief Check whether a feature (e.g. optimizer) is on or off.
 * If the input feature is optimizer, then set the global
 * variable "optimizer_enabled" accordingly.
 *
 * @param feature_name Name of the feature to be checked (e.g. optimizer)
 * @param feature_value Expected value when the feature is enabled (i.e., on or group)
 * @param on_msg Message to be printed when the feature is enabled
 * @param off_msg Message to be printed when the feature is disabled
 * @return true if the feature is enabled; false otherwise
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_feature_status</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>feature_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>feature_value</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>on_msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>off_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>psql_cmd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>statusfilename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isEnabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"checking %s status"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>feature_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>statusfilename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>statusfilename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s_status.out"</literal></expr></argument>, <argument><expr><name>outputdir</name></expr></argument>, <argument><expr><name>feature_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>psql_cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>psql_cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			<argument><expr><literal type="string">"\"%s%spsql\" -X -t -c \"show %s;\" -o \"%s\" -d \"postgres\""</literal></expr></argument>,
			<argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><name>bindir</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			<argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			<argument><expr><name>feature_name</name></expr></argument>,
			<argument><expr><name>statusfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>psql_cmd</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>system</name><argument_list>(<argument><expr><name>psql_cmd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>statusfile</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>statusfilename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>statusfile</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>statusfilename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>statusfile</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>trimmed</name> <init>= <expr><call><name>trim_white_space</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>trimmed</name></expr></argument>, <argument><expr><name>feature_value</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>on_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>isEnabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isEnabled</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>status</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>off_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>status_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>statusfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>statusfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>isEnabled</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>help</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"PostgreSQL regression test driver\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n  %s [OPTION]... [EXTRA-TEST]...\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --bindir=BINPATH          use BINPATH for programs that are run;\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"                                if empty, use PATH from the environment\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --config-auth=DATADIR     update authentication settings for DATADIR\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --create-role=ROLE        create the specified role before testing\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --dbname=DB               use database DB (default \"regression\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --debug                   turn on debug mode in programs that are run\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --dlpath=DIR              look for dynamic libraries in DIR\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --encoding=ENCODING       use ENCODING as the encoding\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -h, --help                    show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --inputdir=DIR            take input files from DIR (default \".\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --launcher=CMD            use CMD as launcher of psql\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --load-extension=EXT      load the named extension before running the\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"                                tests; can appear multiple times\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --load-language=LANG      load the named language before running the\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"                                tests; can appear multiple times\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --max-connections=N       maximum number of concurrent connections\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"                                (default is 0, meaning unlimited)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --max-concurrent-tests=N  maximum number of concurrent tests in schedule\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"                                (default is 0, meaning unlimited)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --outputdir=DIR           place output files in DIR (default \".\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --schedule=FILE           use test ordering schedule from FILE\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"                                (can be used multiple times to concatenate)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --temp-instance=DIR       create a temporary instance in DIR\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --use-existing            use an existing installation\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Please put GPDB specific options here, at the end */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --prehook=NAME            pre-hook name (default \"\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --exclude-tests=TEST      comma or space delimited tests to exclude from running\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --exclude-file=FILE       file with tests to exclude from running, one test name per line\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --init-file=GPD_INIT_FILE  init file to be used for gpdiff (could be used multiple times)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --ignore-plans            ignore any explain plan diffs\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --print-failure-diffs     Print the diff file to standard out after a failure\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --tablespace-dir=DIR      place tablespace files in DIR/testtablespace (default \"./testtablespace\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* end of GPDB specific options */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version                 output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Options for \"temp-instance\" mode:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --no-locale               use C locale\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --port=PORT               start postmaster on PORT\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --temp-config=FILE        append contents of FILE to temporary config\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Options for using an existing installation:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --host=HOST               use postmaster running on HOST\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --port=PORT               use postmaster running at PORT\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --user=USER               connect as USER\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --sslmode=SSLMODE         connect with SSLMODE\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The exit status is 0 if all tests passed, 1 if some tests failed, and 2\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"if the tests could not be run for some reason.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Report bugs to &lt;bugs@greenplum.org&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>regression_main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>init_function</name></type> <name>ifunc</name></decl></parameter>, <parameter><decl><type><name>test_function</name></type> <name>tfunc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"dbname"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"inputdir"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"load-language"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"max-connections"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"encoding"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"outputdir"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"schedule"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">8</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"temp-instance"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">9</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-locale"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">10</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"host"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">13</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">14</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"user"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">15</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"bindir"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">16</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"dlpath"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">17</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"create-role"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">18</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"temp-config"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">19</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"use-existing"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">20</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"launcher"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">21</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"load-extension"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">22</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"config-auth"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">24</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"max-concurrent-tests"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">25</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"init-file"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">80</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"exclude-tests"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">81</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"ignore-plans"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">82</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"prehook"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">83</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"print-failure-diffs"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">84</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"tablespace-dir"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">85</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"exclude-file"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">87</literal></expr>}</block></expr>, <comment type="block">/* 86 conflicts with 'V' */</comment>
		<expr><block>{<expr><literal type="string">"sslmode"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">88</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>_stringlist</name> <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>option_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf2</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_logging_init</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"pg_regress"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_restricted_token</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>stop_postmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifndef>
	<comment type="block">/* no unix domain sockets available, so change default */</comment>
	<expr_stmt><expr><name>hostname</name> <operator>=</operator> <literal type="string">"localhost"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * We call the initialization function here because that way we can set
	 * default parameters and let them be overwritten by the commandline.
	 */</comment>
	<expr_stmt><expr><call><name>ifunc</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PG_REGRESS_DIFF_OPTS"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pretty_diff_opts</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PG_REGRESS_DIFF_OPTS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"hV"</literal></expr></argument>, <argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option_index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
				<expr_stmt><expr><call><name>help</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><literal type="char">'V'</literal></expr>:</case>
				<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"pg_regress (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><literal type="number">1</literal></expr>:</case>

				<comment type="block">/*
				 * If a default database was specified, we need to remove it
				 * before we add the specified one.
				 */</comment>
				<expr_stmt><expr><call><name>free_stringlist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>split_to_stringlist</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><name>debug</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">3</literal></expr>:</case>
				<expr_stmt><expr><name>inputdir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">4</literal></expr>:</case>
				<expr_stmt><expr><call><name>add_stringlist_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>loadlanguage</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">5</literal></expr>:</case>
				<expr_stmt><expr><name>max_connections</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">6</literal></expr>:</case>
				<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">7</literal></expr>:</case>
				<expr_stmt><expr><name>outputdir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">8</literal></expr>:</case>
				<expr_stmt><expr><call><name>add_stringlist_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schedulelist</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">9</literal></expr>:</case>
				<expr_stmt><expr><name>temp_instance</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">10</literal></expr>:</case>
				<expr_stmt><expr><name>nolocale</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">13</literal></expr>:</case>
				<expr_stmt><expr><name>hostname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">14</literal></expr>:</case>
				<expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>port_specified_by_user</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">15</literal></expr>:</case>
				<expr_stmt><expr><name>user</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">16</literal></expr>:</case>
				<comment type="block">/* "--bindir=" means to use PATH */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bindir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>bindir</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">17</literal></expr>:</case>
				<expr_stmt><expr><name>dlpath</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">18</literal></expr>:</case>
				<expr_stmt><expr><call><name>split_to_stringlist</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>extraroles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">19</literal></expr>:</case>
				<expr_stmt><expr><call><name>add_stringlist_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp_configs</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">20</literal></expr>:</case>
				<expr_stmt><expr><name>use_existing</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">21</literal></expr>:</case>
				<expr_stmt><expr><name>launcher</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">22</literal></expr>:</case>
				<expr_stmt><expr><call><name>add_stringlist_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>loadextension</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">24</literal></expr>:</case>
				<expr_stmt><expr><name>config_auth_datadir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">25</literal></expr>:</case>
				<expr_stmt><expr><name>max_concurrent_tests</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<comment type="block">/* GPDB-added options */</comment>
            <case>case <expr><literal type="number">80</literal></expr>:</case>
				<expr_stmt><expr><call><name>add_stringlist_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>init_file_list</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">81</literal></expr>:</case>
                <expr_stmt><expr><call><name>split_to_stringlist</name><argument_list>(<argument><expr><call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>exclude_tests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
			<case>case <expr><literal type="number">82</literal></expr>:</case>
				<expr_stmt><expr><name>ignore_plans</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">83</literal></expr>:</case>
				<expr_stmt><expr><name>prehook</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">84</literal></expr>:</case>
				<expr_stmt><expr><name>print_failure_diffs_is_enabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">85</literal></expr>:</case>
				<expr_stmt><expr><name>tablespacedir</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">87</literal></expr>:</case>
				<expr_stmt><expr><name>exclude_tests_file</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>load_exclude_tests_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exclude_tests</name></expr></argument>, <argument><expr><name>exclude_tests_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">88</literal></expr>:</case>
				<expr_stmt><expr><name>sslmode</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<comment type="block">/* getopt_long already emitted a complaint */</comment>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nTry \"%s -h\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/*
	 * if we still have arguments, they are extra tests to run
	 */</comment>
	<while>while <condition>(<expr><name>argc</name> <operator>-</operator> <name>optind</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_stringlist_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extra_tests</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>optind</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>config_auth_datadir</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>
		<expr_stmt><expr><call><name>config_sspi_auth</name><argument_list>(<argument><expr><name>config_auth_datadir</name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>temp_instance</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>port_specified_by_user</name></expr>)</condition><block type="pseudo"><block_content>

		<comment type="block">/*
		 * To reduce chances of interference with parallel installations, use
		 * a port number starting in the private range (49152-65535)
		 * calculated from the version number.  This aids !HAVE_UNIX_SOCKETS
		 * systems; elsewhere, the use of a private socket directory already
		 * prevents interference.
		 */</comment>
		<expr_stmt><expr><name>port</name> <operator>=</operator> <literal type="number">0xC000</literal> <operator>|</operator> <operator>(</operator><name>PG_VERSION_NUM</name> <operator>&amp;</operator> <literal type="number">0x3FFF</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>inputdir</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>inputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outputdir</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>outputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dlpath</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>dlpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tablespacedir</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>tablespacedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialization
	 */</comment>
	<expr_stmt><expr><call><name>find_helper_programs</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>open_result_files</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prehook</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fullname</name> <init>= <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/sql/hooks/%s.sql"</literal></expr></argument>, <argument><expr><name>inputdir</name></expr></argument>, <argument><expr><name>prehook</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>file_exists</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>convert_sourcefiles_in</name><argument_list>(<argument><expr><literal type="string">"input/hooks"</literal></expr></argument>, <argument><expr><name>outputdir</name></expr></argument>, <argument><expr><literal type="string">"sql/hooks"</literal></expr></argument>, <argument><expr><literal type="string">"sql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>file_exists</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initialize_environment</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>unlimit_core_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>temp_instance</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>pg_conf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>env_wait</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>wait_seconds</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Prepare the temp instance
		 */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>directory_exists</name><argument_list>(<argument><expr><name>temp_instance</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"removing existing temp instance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>temp_instance</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: could not remove temp instance \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>temp_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating temporary instance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make the temp instance top directory */</comment>
		<expr_stmt><expr><call><name>make_directory</name><argument_list>(<argument><expr><name>temp_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* and a directory for log files */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/log"</literal></expr></argument>, <argument><expr><name>outputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>directory_exists</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>make_directory</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* initdb */</comment>
		<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"initializing database system"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"\"%s%sinitdb\" -D \"%s/data\" --no-clean --no-sync%s%s &gt; \"%s/log/initdb.log\" 2&gt;&amp;1"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><name>bindir</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name>temp_instance</name></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>debug</name></expr> ?</condition><then> <expr><literal type="string">" --debug"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>nolocale</name></expr> ?</condition><then> <expr><literal type="string">" --no-locale"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name>outputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>system</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: initdb failed\nExamine %s/log/initdb.log for the reason.\nCommand was: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>outputdir</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Adjust the default postgresql.conf for regression testing. The user
		 * can specify a file to be appended; in any case we expand logging
		 * and set max_prepared_transactions to enable testing of prepared
		 * xacts.  (Note: to reduce the probability of unexpected shmmax
		 * failures, don't set max_prepared_transactions any higher than
		 * actually needed by the prepared_xacts regression test.)
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/data/postgresql.conf"</literal></expr></argument>, <argument><expr><name>temp_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pg_conf</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pg_conf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: could not open \"%s\" for adding extra config: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\n# Configuration added by pg_regress\n\n"</literal></expr></argument>, <argument><expr><name>pg_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"log_autovacuum_min_duration = 0\n"</literal></expr></argument>, <argument><expr><name>pg_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"log_checkpoints = on\n"</literal></expr></argument>, <argument><expr><name>pg_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"log_line_prefix = '%m [%p] %q%a '\n"</literal></expr></argument>, <argument><expr><name>pg_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"log_lock_waits = on\n"</literal></expr></argument>, <argument><expr><name>pg_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"log_temp_files = 128kB\n"</literal></expr></argument>, <argument><expr><name>pg_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"max_prepared_transactions = 2\n"</literal></expr></argument>, <argument><expr><name>pg_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>temp_configs</name></expr>;</init> <condition><expr><name>sl</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>temp_config</name> <init>= <expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>extra_conf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>line_buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><name>extra_conf</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>temp_config</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>extra_conf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: could not open \"%s\" to read extra config: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>temp_config</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>line_buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>extra_conf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>line_buf</name></expr></argument>, <argument><expr><name>pg_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>extra_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>pg_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>

		<comment type="block">/*
		 * Since we successfully used the same buffer for the much-longer
		 * "initdb" command, this can't truncate.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/data"</literal></expr></argument>, <argument><expr><name>temp_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>config_sspi_auth</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNIX_SOCKETS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:error>#<cpp:directive>error</cpp:directive> Platform has no means to secure the test installation.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Check if there is a postmaster running already.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf2</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"\"%s%spsql\" -X postgres &lt;%s 2&gt;%s"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><name>bindir</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name>DEVNULL</name></expr></argument>, <argument><expr><name>DEVNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>system</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>s</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>port_specified_by_user</name> <operator>||</operator> <name>i</name> <operator>==</operator> <literal type="number">15</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"port %d apparently in use\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>port_specified_by_user</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not determine an available port\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Specify an unused port using the --port option or shut down any conflicting PostgreSQL servers.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"port %d apparently in use, trying %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>port</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>port</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>doputenv</name><argument_list>(<argument><expr><literal type="string">"PGPORT"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<break>break;</break></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Start the temp postmaster
		 */</comment>
		<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"starting postmaster"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"\"%s%spostgres\" -D \"%s/data\" -F%s "</literal>
				 <literal type="string">"-c \"listen_addresses=%s\" -k \"%s\" "</literal>
				 <literal type="string">"&gt; \"%s/log/postmaster.log\" 2&gt;&amp;1"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><name>bindir</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name>temp_instance</name></expr></argument>, <argument><expr><ternary><condition><expr><name>debug</name></expr> ?</condition><then> <expr><literal type="string">" -d 5"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>hostname</name></expr> ?</condition><then> <expr><name>hostname</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>sockdir</name></expr> ?</condition><then> <expr><name>sockdir</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name>outputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>postmaster_pid</name> <operator>=</operator> <call><name>spawn_process</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>postmaster_pid</name> <operator>==</operator> <name>INVALID_PID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: could not spawn postmaster: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wait till postmaster is able to accept connections; normally this
		 * is only a second or so, but Cygwin is reportedly *much* slower, and
		 * test builds using Valgrind or similar tools might be too.  Hence,
		 * allow the default timeout of 60 seconds to be overridden from the
		 * PGCTLTIMEOUT environment variable.
		 */</comment>
		<expr_stmt><expr><name>env_wait</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGCTLTIMEOUT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>env_wait</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>wait_seconds</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>env_wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>wait_seconds</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>wait_seconds</name> <operator>=</operator> <literal type="number">60</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>wait_seconds</name> <operator>=</operator> <literal type="number">60</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>wait_seconds</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Done if psql succeeds */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>system</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Fail immediately if postmaster has exited
			 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
			<if_stmt><if>if <condition>(<expr><call><name>waitpid</name><argument_list>(<argument><expr><name>postmaster_pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>WNOHANG</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>postmaster_pid</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<if_stmt><if>if <condition>(<expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name>postmaster_pid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>WAIT_OBJECT_0</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: postmaster failed\nExamine %s/log/postmaster.log for the reason\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>outputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>wait_seconds</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: postmaster did not respond within %d seconds\nExamine %s/log/postmaster.log for the reason\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>wait_seconds</name></expr></argument>, <argument><expr><name>outputdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we get here, the postmaster is probably wedged somewhere in
			 * startup.  Try to kill it ungracefully rather than leaving a
			 * stuck postmaster that might interfere with subsequent test
			 * attempts.
			 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
			<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>postmaster_pid</name></expr></argument>, <argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name>errno</name> <operator>!=</operator> <name>ESRCH</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: could not kill failed postmaster: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<if_stmt><if>if <condition>(<expr><call><name>TerminateProcess</name><argument_list>(<argument><expr><name>postmaster_pid</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: could not kill failed postmaster: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>postmaster_running</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN64</name></cpp:ifdef>
<comment type="block">/* need a series of two casts to convert HANDLE without compiler warning */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ULONGPID</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(unsigned long) (unsigned long long) (x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ULONGPID</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(unsigned long) (x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"running on port %d with PID %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>port</name></expr></argument>, <argument><expr><call><name>ULONGPID</name><argument_list>(<argument><expr><name>postmaster_pid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Using an existing installation, so may need to get rid of
		 * pre-existing database(s) and role(s)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_existing</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>dblist</name></expr>;</init> <condition><expr><name>sl</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>drop_database_if_exists</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>extraroles</name></expr>;</init> <condition><expr><name>sl</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>drop_role_if_exists</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"faultinjector enabled"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"faultinjector not enabled"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Create the test database(s) and role(s)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_existing</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>dblist</name></expr>;</init> <condition><expr><name>sl</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>create_database</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>extraroles</name></expr>;</init> <condition><expr><name>sl</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>create_role</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find out if optimizer is on or off
	 */</comment>
	<expr_stmt><expr><name>optimizer_enabled</name> <operator>=</operator> <call><name>check_feature_status</name><argument_list>(<argument><expr><literal type="string">"optimizer"</literal></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>,
			<argument><expr><literal type="string">"Optimizer enabled. Using optimizer answer files whenever possible"</literal></expr></argument>,
			<argument><expr><literal type="string">"Optimizer disabled. Using planner answer files"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find out if gp_resource_manager is group or not
	 */</comment>
	<expr_stmt><expr><name>resgroup_enabled</name> <operator>=</operator> <call><name>check_feature_status</name><argument_list>(<argument><expr><literal type="string">"gp_resource_manager"</literal></expr></argument>, <argument><expr><literal type="string">"group"</literal></expr></argument>,
			<argument><expr><literal type="string">"Resource group enabled. Using resource group answer files whenever possible"</literal></expr></argument>,
			<argument><expr><literal type="string">"Resource group disabled. Using default answer files"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ready to run the tests
	 */</comment>
	<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"running regression test queries"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>setup_tests</name></expr>;</init> <condition><expr><name>sl</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>halt_work</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>run_single_test</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>tfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>schedulelist</name></expr>;</init> <condition><expr><name>sl</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>halt_work</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>run_schedule</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>tfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>sl</name> <operator>=</operator> <name>extra_tests</name></expr>;</init> <condition><expr><name>sl</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>halt_work</name></expr>;</condition> <incr><expr><name>sl</name> <operator>=</operator> <name><name>sl</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>run_single_test</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>tfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Shut down temp installation's postmaster
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>temp_instance</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"shutting down postmaster"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>stop_postmaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there were no errors, remove the temp instance immediately to
	 * conserve disk space.  (If there were errors, we leave the instance in
	 * place for possible manual investigation.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>temp_instance</name> <operator>&amp;&amp;</operator> <name>fail_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fail_ignore_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>header</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"removing temporary instance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>temp_instance</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: could not remove temp instance \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>temp_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Emit nice-looking summary message
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fail_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fail_ignore_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" All %d tests passed. "</literal></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>success_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>fail_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* fail_count=0, fail_ignore_count&gt;0 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" %d of %d tests passed, %d failed test(s) ignored. "</literal></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>success_count</name></expr></argument>,
				 <argument><expr><name>success_count</name> <operator>+</operator> <name>fail_ignore_count</name></expr></argument>,
				 <argument><expr><name>fail_ignore_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>fail_ignore_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* fail_count&gt;0 &amp;&amp; fail_ignore_count=0 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" %d of %d tests failed. "</literal></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>fail_count</name></expr></argument>,
				 <argument><expr><name>success_count</name> <operator>+</operator> <name>fail_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* fail_count&gt;0 &amp;&amp; fail_ignore_count&gt;0 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" %d of %d tests failed, %d of these failures ignored. "</literal></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>fail_count</name> <operator>+</operator> <name>fail_ignore_count</name></expr></argument>,
				 <argument><expr><name>success_count</name> <operator>+</operator> <name>fail_count</name> <operator>+</operator> <name>fail_ignore_count</name></expr></argument>,
				 <argument><expr><name>fail_ignore_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%s\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>file_size</name><argument_list>(<argument><expr><name>difffilename</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>print_failure_diffs_is_enabled</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>print_contents_of_file</name><argument_list>(<argument><expr><name>difffilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The differences that caused some tests to fail can be viewed in the\n"</literal>
				 <literal type="string">"file \"%s\".  A copy of the test summary that you see\n"</literal>
				 <literal type="string">"above is saved in the file \"%s\".\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>difffilename</name></expr></argument>, <argument><expr><name>logfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>difffilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>logfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fail_count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Issue a command via psql, connecting to the specified database
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>psql_command_output</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>database</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>query_formatted</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>query_escaped</name><index>[<expr><literal type="number">2048</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>psql_cmd</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">2048</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

	<comment type="block">/* Generate the query with insertion of sprintf arguments */</comment>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>query_formatted</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query_formatted</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now escape any shell double-quote metacharacters */</comment>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <name>query_escaped</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>query_formatted</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"\\\"$`"</literal></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* And now we can build and execute the shell command */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>psql_cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>psql_cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				   <argument><expr><literal type="string">"\"%s%spsql\" -X -t -c \"%s\" \"%s\""</literal></expr></argument>,
				   <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><name>bindir</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				   <argument><expr><ternary><condition><expr><name>bindir</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				   <argument><expr><name>query_escaped</name></expr></argument>,
				   <argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>psql_cmd</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Execute the command with pipe and read the standard output. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>psql_cmd</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: cannot launch shell command\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: cannot read the result\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: cannot close shell command\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cluster_healthy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>psql_command_output</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>,
						<argument><expr><literal type="string">"SELECT * FROM gp_segment_configuration WHERE status = 'd' OR preferred_role != role;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>halt_work</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n==================================\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" Cluster validation failed:\n%s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"==================================\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>halt_work</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>!</operator><name>halt_work</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_host_name</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>contentid</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>role</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hostname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>psql_command_output</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>,
						<argument><expr><literal type="string">"SELECT hostname FROM gp_segment_configuration WHERE role=\'%c\' AND content = %d;"</literal></expr></argument>,
						<argument><expr><name>role</name></expr></argument>,
						<argument><expr><name>contentid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hostname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>trim_white_space</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to determine hostname for content 0 primary\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>hostname</name></expr>;</return>
</block_content>}</block></function>
</unit>
