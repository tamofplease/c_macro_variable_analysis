<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/test/modules/test_integerset/test_integerset.c"><comment type="block">/*--------------------------------------------------------------------------
 *
 * test_integerset.c
 *		Test integer set data structure.
 *
 * Copyright (c) 2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		src/test/modules/test_integerset/test_integerset.c
 *
 * -------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/integerset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/bitmapset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/block.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/itemptr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<comment type="block">/*
 * If you enable this, the "pattern" tests will print information about
 * how long populating, probing, and iterating the test set takes, and
 * how much memory the test set consumed.  That can be used as
 * micro-benchmark of various operations and input patterns (you might
 * want to increase the number of values used in each of the test, if
 * you do that, to reduce noise).
 *
 * The information is printed to the server's stderr, mostly because
 * that's where MemoryContextStats() output goes.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>intset_test_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>test_integerset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * A struct to define a pattern of integers, for use with the test_pattern()
 * function.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>test_name</name></decl>;</decl_stmt>		<comment type="block">/* short name of the test, for humans */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pattern_str</name></decl>;</decl_stmt>	<comment type="block">/* a bit pattern */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>spacing</name></decl>;</decl_stmt>		<comment type="block">/* pattern repeats at this interval */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>num_values</name></decl>;</decl_stmt>		<comment type="block">/* number of integers to set in total */</comment>
}</block></struct></type> <name>test_spec</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>test_spec</name></type> <name><name>test_specs</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{
		<expr><literal type="string">"all ones"</literal></expr>, <expr><literal type="string">"1111111111"</literal></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">10000000</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"alternating bits"</literal></expr>, <expr><literal type="string">"0101010101"</literal></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">10000000</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"clusters of ten"</literal></expr>, <expr><literal type="string">"1111111111"</literal></expr>,
		<expr><literal type="number">10000</literal></expr>, <expr><literal type="number">10000000</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"clusters of hundred"</literal></expr>,
		<expr><literal type="string">"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"</literal></expr>,
		<expr><literal type="number">10000</literal></expr>, <expr><literal type="number">100000000</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"one-every-64k"</literal></expr>, <expr><literal type="string">"1"</literal></expr>,
		<expr><literal type="number">65536</literal></expr>, <expr><literal type="number">10000000</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"sparse"</literal></expr>, <expr><literal type="string">"100000000000000000000000000000001"</literal></expr>,
		<expr><literal type="number">10000000</literal></expr>, <expr><literal type="number">10000000</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"single values, distance &gt; 2^32"</literal></expr>, <expr><literal type="string">"1"</literal></expr>,
		<expr><call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">10000000000</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">1000000</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"clusters, distance &gt; 2^32"</literal></expr>, <expr><literal type="string">"10101010"</literal></expr>,
		<expr><call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">10000000000</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">10000000</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"clusters, distance &gt; 2^60"</literal></expr>, <expr><literal type="string">"10101010"</literal></expr>,
		<expr><call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">2000000000000000000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><literal type="number">23</literal></expr>						<comment type="block">/* can't be much higher than this, or we
								 * overflow uint64 */</comment>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>test_pattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>test_spec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>test_empty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>test_single_value</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_with_filler</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>filler_min</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>filler_max</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>test_single_value_and_filler</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>filler_min</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>filler_max</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>test_huge_distances</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * SQL-callable entry point to perform all tests.
 */</comment>
<function><type><name>Datum</name></type>
<name>test_integerset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Tests for various corner cases */</comment>
	<expr_stmt><expr><call><name>test_empty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_huge_distances</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_single_value</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_single_value</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_single_value</name><argument_list>(<argument><expr><name>PG_UINT64_MAX</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_single_value</name><argument_list>(<argument><expr><name>PG_UINT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_single_value_and_filler</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_single_value_and_filler</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_single_value_and_filler</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><literal type="number">2000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_single_value_and_filler</name><argument_list>(<argument><expr><name>PG_UINT64_MAX</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_single_value_and_filler</name><argument_list>(<argument><expr><name>PG_UINT64_MAX</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test different test patterns, with lots of entries */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>test_specs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>test_pattern</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>test_specs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test with a repeating pattern, defined by the 'spec'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_pattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>test_spec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>intset_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>starttime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>endtime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>last_int</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>patternlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name>	   <modifier>*</modifier></type><name>pattern_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>pattern_num_values</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"testing intset with pattern \"%s\""</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>test_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>intset_test_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"-----\ntesting intset with pattern \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>test_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Pre-process the pattern, creating an array of integers from it. */</comment>
	<expr_stmt><expr><name>patternlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>pattern_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pattern_values</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>patternlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pattern_num_values</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>patternlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>pattern_str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'1'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pattern_values</name><index>[<expr><name>pattern_num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Allocate the integer set.
	 *
	 * Allocate it in a separate memory context, so that we can print its
	 * memory usage easily.  (intset_create() creates a memory context of its
	 * own, too, but we don't have direct access to it, so we cannot call
	 * MemoryContextStats() on it directly).
	 */</comment>
	<expr_stmt><expr><name>intset_ctx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									   <argument><expr><literal type="string">"intset test"</literal></expr></argument>,
									   <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSetIdentifier</name><argument_list>(<argument><expr><name>intset_ctx</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>test_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_ctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>intset_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>intset</name> <operator>=</operator> <call><name>intset_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add values to the set.
	 */</comment>
	<expr_stmt><expr><name>starttime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_int</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pattern_num_values</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>x</name> <operator>=</operator> <name>last_int</name> <operator>+</operator> <name><name>pattern_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>intset_add_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>last_int</name> <operator>+=</operator> <name><name>spec</name><operator>-&gt;</operator><name>spacing</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>endtime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>intset_test_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"added "</literal> <name>UINT64_FORMAT</name> <literal type="string">" values in %d ms\n"</literal></expr></argument>,
				<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>endtime</name> <operator>-</operator> <name>starttime</name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Print stats on the amount of memory used.
	 *
	 * We print the usage reported by intset_memory_usage(), as well as the
	 * stats from the memory context.  They should be in the same ballpark,
	 * but it's hard to automate testing that, so if you're making changes to
	 * the implementation, just observe that manually.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>intset_test_stats</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>mem_usage</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Also print memory usage as reported by intset_memory_usage().  It
		 * should be in the same ballpark as the usage reported by
		 * MemoryContextStats().
		 */</comment>
		<expr_stmt><expr><name>mem_usage</name> <operator>=</operator> <call><name>intset_memory_usage</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"intset_memory_usage() reported "</literal> <name>UINT64_FORMAT</name> <literal type="string">" (%0.2f bytes / integer)\n"</literal></expr></argument>,
				<argument><expr><name>mem_usage</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>mem_usage</name> <operator>/</operator> <name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>intset_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check that intset_get_num_entries works */</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>intset_num_entries</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_num_entries returned "</literal> <name>UINT64_FORMAT</name> <literal type="string">", expected "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Test random-access probes with intset_is_member()
	 */</comment>
	<expr_stmt><expr><name>starttime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>b</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>expected</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>x</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Pick next value to probe at random.  We limit the probes to the
		 * last integer that we added to the set, plus an arbitrary constant
		 * (1000).  There's no point in probing the whole 0 - 2^64 range, if
		 * only a small part of the integer space is used.  We would very
		 * rarely hit values that are actually in the set.
		 */</comment>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><call><name>pg_lrand48</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">31</literal><operator>)</operator> <operator>|</operator> <call><name>pg_lrand48</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name>x</name> <operator>%</operator> <operator>(</operator><name>last_int</name> <operator>+</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Do we expect this value to be present in the set? */</comment>
		<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;=</operator> <name>last_int</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expected</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>idx</name> <init>= <expr><name>x</name> <operator>%</operator> <name><name>spec</name><operator>-&gt;</operator><name>spacing</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>patternlen</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>expected</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>pattern_str</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="char">'1'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>expected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>expected</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Is it present according to intset_is_member() ? */</comment>
		<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>b</name> <operator>!=</operator> <name>expected</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatch at "</literal> <name>UINT64_FORMAT</name> <literal type="string">": %d vs %d"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>endtime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>intset_test_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"probed "</literal> <name>UINT64_FORMAT</name> <literal type="string">" values in %d ms\n"</literal></expr></argument>,
				<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>endtime</name> <operator>-</operator> <name>starttime</name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Test iterator
	 */</comment>
	<expr_stmt><expr><name>starttime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>intset_begin_iterate</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_int</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pattern_num_values</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>expected</name> <init>= <expr><name>last_int</name> <operator>+</operator> <name><name>pattern_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>x</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>intset_iterate_next</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>x</name> <operator>!=</operator> <name>expected</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"iterate returned wrong value; got "</literal> <name>UINT64_FORMAT</name> <literal type="string">", expected "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>last_int</name> <operator>+=</operator> <name><name>spec</name><operator>-&gt;</operator><name>spacing</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>endtime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>intset_test_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"iterated "</literal> <name>UINT64_FORMAT</name> <literal type="string">" values in %d ms\n"</literal></expr></argument>,
				<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>endtime</name> <operator>-</operator> <name>starttime</name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"iterator stopped short after "</literal> <name>UINT64_FORMAT</name> <literal type="string">" entries, expected "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"iterator returned "</literal> <name>UINT64_FORMAT</name> <literal type="string">" entries, "</literal> <name>UINT64_FORMAT</name> <literal type="string">" was expected"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>num_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>intset_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test with a set containing a single integer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_single_value</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>num_entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"testing intset with single value "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the set. */</comment>
	<expr_stmt><expr><name>intset</name> <operator>=</operator> <call><name>intset_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>intset_add_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test intset_get_num_entries() */</comment>
	<expr_stmt><expr><name>num_entries</name> <operator>=</operator> <call><name>intset_num_entries</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>num_entries</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_num_entries returned "</literal> <name>UINT64_FORMAT</name> <literal type="string">", expected 1"</literal></expr></argument>, <argument><expr><name>num_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Test intset_is_member() at various special values, like 0 and maximum
	 * possible 64-bit integer, as well as the value itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>value</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_is_member failed for 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>value</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_is_member failed for 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>PG_UINT64_MAX</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>value</name> <operator>==</operator> <name>PG_UINT64_MAX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_is_member failed for PG_UINT64_MAX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_is_member failed for the tested value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Test iterator
	 */</comment>
	<expr_stmt><expr><call><name>intset_begin_iterate</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>intset_iterate_next</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <name>x</name> <operator>!=</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_iterate_next failed for "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>intset_iterate_next</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_iterate_next failed "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test with an integer set that contains:
 *
 * - a given single 'value', and
 * - all integers between 'filler_min' and 'filler_max'.
 *
 * This exercises different codepaths than testing just with a single value,
 * because the implementation buffers newly-added values.  If we add just a
 * single value to the set, we won't test the internal B-tree code at all,
 * just the code that deals with the buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_single_value_and_filler</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>filler_min</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>filler_max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name>	   <modifier>*</modifier></type><name>iter_expected</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>num_entries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>mem_usage</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"testing intset with value "</literal> <name>UINT64_FORMAT</name> <literal type="string">", and all between "</literal> <name>UINT64_FORMAT</name> <literal type="string">" and "</literal> <name>UINT64_FORMAT</name></expr></argument>,
		 <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>intset</name> <operator>=</operator> <call><name>intset_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>iter_expected</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>filler_max</name> <operator>-</operator> <name>filler_min</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name>filler_min</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>intset_add_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter_expected</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <name>filler_min</name></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>filler_max</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>intset_add_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter_expected</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <name>filler_max</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>intset_add_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter_expected</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Test intset_get_num_entries() */</comment>
	<expr_stmt><expr><name>num_entries</name> <operator>=</operator> <call><name>intset_num_entries</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>num_entries</name> <operator>!=</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_num_entries returned "</literal> <name>UINT64_FORMAT</name> <literal type="string">", expected "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>num_entries</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Test intset_is_member() at various spots, at and around the values that
	 * we expect to be set, as well as 0 and the maximum possible value.
	 */</comment>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>filler_min</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>filler_min</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>value</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>filler_max</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>filler_max</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>PG_UINT64_MAX</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_with_filler</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>PG_UINT64_MAX</name></expr></argument>,
					  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>filler_min</name></expr></argument>, <argument><expr><name>filler_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>intset_begin_iterate</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>uint64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>intset_iterate_next</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <name>x</name> <operator>!=</operator> <name><name>iter_expected</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_iterate_next failed for "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>intset_iterate_next</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_iterate_next failed "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>mem_usage</name> <operator>=</operator> <call><name>intset_memory_usage</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mem_usage</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">5000</literal> <operator>||</operator> <name>mem_usage</name></expr></argument> &gt;</argument_list></name> <literal type="number">500000000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_memory_usage() reported suspicious value: "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>mem_usage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function for test_single_value_and_filler.
 *
 * Calls intset_is_member() for value 'x', and checks that the result is what
 * we expect.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_with_filler</name><parameter_list>(<parameter><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>x</name></decl></parameter>,
				  <parameter><decl><type><name>uint64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>filler_min</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>filler_max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>expected</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>actual</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>expected</name> <operator>=</operator> <operator>(</operator><name>x</name> <operator>==</operator> <name>value</name> <operator>||</operator> <operator>(</operator><name>filler_min</name> <operator>&lt;=</operator> <name>x</name> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <name>filler_max</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>actual</name> <operator>=</operator> <call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>actual</name> <operator>!=</operator> <name>expected</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_is_member failed for "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test empty set
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_empty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"testing intset with empty set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>intset</name> <operator>=</operator> <call><name>intset_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test intset_is_member() */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_is_member on empty set returned true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_is_member on empty set returned true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>PG_UINT64_MAX</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_is_member on empty set returned true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Test iterator */</comment>
	<expr_stmt><expr><call><name>intset_begin_iterate</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>intset_iterate_next</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_iterate_next on empty set returned a value ("</literal> <name>UINT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test with integers that are more than 2^60 apart.
 *
 * The Simple-8b encoding used by the set implementation can only encode
 * values up to 2^60.  That makes large differences like this interesting
 * to test.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_huge_distances</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IntegerSet</name> <modifier>*</modifier></type><name>intset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name><name>values</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_values</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"testing intset with distances &gt; 2^60 between values"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<comment type="block">/* Test differences on both sides of the 2^60 boundary. */</comment>
	<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1152921504606846976</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* 2^60 - 1 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1152921504606846976</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* 2^60 - 1 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1152921504606846976</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* 2^60 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1152921504606846976</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* 2^60 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1152921504606846976</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* 2^60 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1152921504606846976</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* 2^60 + 1 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1152921504606846976</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* 2^60 + 1 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1152921504606846976</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* 2^60 + 1 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1152921504606846976</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>	<comment type="block">/* 2^60 + 2 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1152921504606846976</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>	<comment type="block">/* 2^60 + 2 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">1152921504606846976</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* 2^60 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We're now very close to 2^64, so can't add large values anymore.  But
	 * add more smaller values to the end, to make sure that all the above
	 * values get flushed and packed into the tree structure.
	 */</comment>
	<while>while <condition>(<expr><name>num_values</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>pg_lrand48</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>num_values</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Create an IntegerSet using these values */</comment>
	<expr_stmt><expr><name>intset</name> <operator>=</operator> <call><name>intset_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_values</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>intset_add_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Test intset_is_member() around each of these values
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_values</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>x</name> <init>= <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>expected</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>expected</name> <operator>=</operator> <operator>(</operator><name><name>values</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>x</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>x</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>expected</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_is_member failed for "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>x</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_is_member failed for "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>expected</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>i</name> <operator>!=</operator> <name>num_values</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name><name>values</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>x</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>intset_is_member</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><name>x</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>expected</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_is_member failed for "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>x</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Test iterator
	 */</comment>
	<expr_stmt><expr><call><name>intset_begin_iterate</name><argument_list>(<argument><expr><name>intset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_values</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>intset_iterate_next</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <name>x</name> <operator>!=</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_iterate_next failed for "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>intset_iterate_next</name><argument_list>(<argument><expr><name>intset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"intset_iterate_next failed "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
