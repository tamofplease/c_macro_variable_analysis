<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/pl/plperl/plperl.c"><comment type="block" format="doxygen">/**********************************************************************
 * plperl.c - perl as a procedural language for PostgreSQL
 *
 *	  src/pl/plperl/plperl.c
 *
 **********************************************************************/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<comment type="block">/* system stuff */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<comment type="block">/* postgreSQL stuff */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<comment type="block">/* define our text domain for translations */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TEXTDOMAIN</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEXTDOMAIN</name></cpp:macro> <cpp:value>PG_TEXTDOMAIN("plperl")</cpp:value></cpp:define>

<comment type="block">/* perl stuff */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plperl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plperl_helpers.h"</cpp:file></cpp:include>

<comment type="block">/* string literal macros defining chunks of perl code */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"perlchunks.h"</cpp:file></cpp:include>
<comment type="block">/* defines PLPERL_SET_OPMASK */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plperl_opmask.h"</cpp:file></cpp:include>

<function_decl><type><name>EXTERN_C</name> <name>void</name></type> <name>boot_DynaLoader</name><parameter_list>(<parameter><decl><type><name>pTHX_</name> <name>CV</name> <modifier>*</modifier></type><name>cv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>EXTERN_C</name> <name>void</name></type> <name>boot_PostgreSQL__InServer__Util</name><parameter_list>(<parameter><decl><type><name>pTHX_</name> <name>CV</name> <modifier>*</modifier></type><name>cv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>EXTERN_C</name> <name>void</name></type> <name>boot_PostgreSQL__InServer__SPI</name><parameter_list>(<parameter><decl><type><name>pTHX_</name> <name>CV</name> <modifier>*</modifier></type><name>cv</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block" format="doxygen">/**********************************************************************
 * Information associated with a Perl interpreter.  We have one interpreter
 * that is used for all plperlu (untrusted) functions.  For plperl (trusted)
 * functions, there is a separate interpreter for each effective SQL userid.
 * (This is needed to ensure that an unprivileged user can't inject Perl code
 * that'll be executed with the privileges of some other SQL user.)
 *
 * The plperl_interp_desc structs are kept in a Postgres hash table indexed
 * by userid OID, with OID 0 used for the single untrusted interpreter.
 * Once created, an interpreter is kept for the life of the process.
 *
 * We start out by creating a "held" interpreter, which we initialize
 * only as far as we can do without deciding if it will be trusted or
 * untrusted.  Later, when we first need to run a plperl or plperlu
 * function, we complete the initialization appropriately and move the
 * PerlInterpreter pointer into the plperl_interp_hash hashtable.  If after
 * that we need more interpreters, we create them as needed if we can, or
 * fail if the Perl build doesn't support multiple interpreters.
 *
 * The reason for all the dancing about with a held interpreter is to make
 * it possible for people to preload a lot of Perl code at postmaster startup
 * (using plperl.on_init) and then use that code in backends.  Of course this
 * will only work for the first interpreter created in any backend, but it's
 * still useful with that restriction.
 **********************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>plperl_interp_desc</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>user_id</name></decl>;</decl_stmt>		<comment type="block">/* Hash key (must be first!) */</comment>
	<decl_stmt><decl><type><name>PerlInterpreter</name> <modifier>*</modifier></type><name>interp</name></decl>;</decl_stmt>	<comment type="block">/* The interpreter */</comment>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>query_hash</name></decl>;</decl_stmt>		<comment type="block">/* plperl_query_entry structs */</comment>
}</block></struct></type> <name>plperl_interp_desc</name>;</typedef>


<comment type="block" format="doxygen">/**********************************************************************
 * The information we cache about loaded procedures
 *
 * The fn_refcount field counts the struct's reference from the hash table
 * shown below, plus one reference for each function call level that is using
 * the struct.  We can release the struct, and the associated Perl sub, when
 * the fn_refcount goes to zero.  Releasing the struct itself is done by
 * deleting the fn_cxt, which also gets rid of all subsidiary data.
 **********************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>plperl_proc_desc</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proname</name></decl>;</decl_stmt>		<comment type="block">/* user name of procedure */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>fn_cxt</name></decl>;</decl_stmt>		<comment type="block">/* memory context for this procedure */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>fn_refcount</name></decl>;</decl_stmt>	<comment type="block">/* number of active references */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>fn_xmin</name></decl>;</decl_stmt>		<comment type="block">/* xmin/TID of procedure's pg_proc tuple */</comment>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>fn_tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>reference</name></decl>;</decl_stmt>		<comment type="block">/* CODE reference for Perl sub */</comment>
	<decl_stmt><decl><type><name>plperl_interp_desc</name> <modifier>*</modifier></type><name>interp</name></decl>;</decl_stmt> <comment type="block">/* interpreter it's created in */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fn_readonly</name></decl>;</decl_stmt>	<comment type="block">/* is function readonly (not volatile)? */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>lang_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>trftypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lanpltrusted</name></decl>;</decl_stmt>	<comment type="block">/* is it plperl, rather than plperlu? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fn_retistuple</name></decl>;</decl_stmt>	<comment type="block">/* true, if function returns tuple */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fn_retisset</name></decl>;</decl_stmt>	<comment type="block">/* true, if function returns set */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fn_retisarray</name></decl>;</decl_stmt>	<comment type="block">/* true if function returns array */</comment>
	<comment type="block">/* Conversion info for function's result type: */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result_oid</name></decl>;</decl_stmt>		<comment type="block">/* Oid of result type */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>result_in_func</name></decl>;</decl_stmt> <comment type="block">/* I/O function and arg for result type */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result_typioparam</name></decl>;</decl_stmt>
	<comment type="block">/* Per-argument info for function's argument types: */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>arg_out_func</name></decl>;</decl_stmt>	<comment type="block">/* output fns for arg types */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>arg_is_rowtype</name></decl>;</decl_stmt> <comment type="block">/* is each arg composite? */</comment>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>arg_arraytype</name></decl>;</decl_stmt>	<comment type="block">/* InvalidOid if not an array */</comment>
}</block></struct></type> <name>plperl_proc_desc</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>increment_prodesc_refcount</name><parameter_list>(<parameter><type><name>prodesc</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>((prodesc)-&gt;fn_refcount++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>decrement_prodesc_refcount</name><parameter_list>(<parameter><type><name>prodesc</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>do { \
		Assert((prodesc)-&gt;fn_refcount &gt; 0); \
		if (--((prodesc)-&gt;fn_refcount) == 0) \
			free_plperl_function(prodesc); \
	} while(0)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**********************************************************************
 * For speedy lookup, we maintain a hash table mapping from
 * function OID + trigger flag + user OID to plperl_proc_desc pointers.
 * The reason the plperl_proc_desc struct isn't directly part of the hash
 * entry is to simplify recovery from errors during compile_plperl_function.
 *
 * Note: if the same function is called by multiple userIDs within a session,
 * there will be a separate plperl_proc_desc entry for each userID in the case
 * of plperl functions, but only one entry for plperlu functions, because we
 * set user_id = 0 for that case.  If the user redeclares the same function
 * from plperl to plperlu or vice versa, there might be multiple
 * plperl_proc_ptr entries in the hashtable, but only one is valid.
 **********************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>plperl_proc_key</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>proc_id</name></decl>;</decl_stmt>		<comment type="block">/* Function OID */</comment>

	<comment type="block">/*
	 * is_trigger is really a bool, but declare as Oid to ensure this struct
	 * contains no padding
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>is_trigger</name></decl>;</decl_stmt>		<comment type="block">/* is it a trigger function? */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>user_id</name></decl>;</decl_stmt>		<comment type="block">/* User calling the function, or 0 */</comment>
}</block></struct></type> <name>plperl_proc_key</name>;</typedef>

<typedef>typedef <type><struct>struct <name>plperl_proc_ptr</name>
<block>{
	<decl_stmt><decl><type><name>plperl_proc_key</name></type> <name>proc_key</name></decl>;</decl_stmt>	<comment type="block">/* Hash key (must be first!) */</comment>
	<decl_stmt><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>proc_ptr</name></decl>;</decl_stmt>
}</block></struct></type> <name>plperl_proc_ptr</name>;</typedef>

<comment type="block">/*
 * The information we cache for the duration of a single call to a
 * function.
 */</comment>
<typedef>typedef <type><struct>struct <name>plperl_call_data</name>
<block>{
	<decl_stmt><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
	<comment type="block">/* remaining fields are used only in a function returning set: */</comment>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>ret_tdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>cdomain_oid</name></decl>;</decl_stmt>	<comment type="block">/* 0 unless returning domain-over-composite */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>cdomain_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmp_cxt</name></decl>;</decl_stmt>
}</block></struct></type> <name>plperl_call_data</name>;</typedef>

<comment type="block" format="doxygen">/**********************************************************************
 * The information we cache about prepared and saved plans
 **********************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>plperl_query_desc</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>qname</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>plan_cxt</name></decl>;</decl_stmt>		<comment type="block">/* context holding this struct */</comment>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>arginfuncs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypioparams</name></decl>;</decl_stmt>
}</block></struct></type> <name>plperl_query_desc</name>;</typedef>

<comment type="block">/* hash table entry for query desc	*/</comment>

<typedef>typedef <type><struct>struct <name>plperl_query_entry</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>query_name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_query_desc</name> <modifier>*</modifier></type><name>query_data</name></decl>;</decl_stmt>
}</block></struct></type> <name>plperl_query_entry</name>;</typedef>

<comment type="block" format="doxygen">/**********************************************************************
 * Information for PostgreSQL - Perl array conversion.
 **********************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>plperl_array_info</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>elem_is_rowtype</name></decl>;</decl_stmt>	<comment type="block">/* 't' if element type is a rowtype */</comment>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elements</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>nelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>transform_proc</name></decl>;</decl_stmt>
}</block></struct></type> <name>plperl_array_info</name>;</typedef>

<comment type="block" format="doxygen">/**********************************************************************
 * Global data
 **********************************************************************/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>plperl_interp_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>plperl_proc_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>plperl_interp_desc</name> <modifier>*</modifier></type><name>plperl_active_interp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* If we have an unassigned "held" interpreter, it's stored here */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PerlInterpreter</name> <modifier>*</modifier></type><name>plperl_held_interp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* GUC variables */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>plperl_use_strict</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>plperl_on_init</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>plperl_on_plperl_init</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>plperl_on_plperlu_init</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>plperl_ending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>OP</name>  <modifier>*</modifier></type>(<modifier>*</modifier><name>pp_require_orig</name>) <parameter_list>(<parameter><decl><type><name>pTHX</name></type></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>plperl_opmask</name><index>[<expr><name>MAXO</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* this is saved and restored by plperl_call_handler */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>plperl_call_data</name> <modifier>*</modifier></type><name>current_call_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/**********************************************************************
 * Forward declarations
 **********************************************************************/</comment>
<function_decl><type><name>void</name></type>		<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PerlInterpreter</name> <modifier>*</modifier></type><name>plperl_init_interp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plperl_destroy_interp</name><parameter_list>(<parameter><decl><type><name>PerlInterpreter</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plperl_fini</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_interp_require</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>trusted</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>plperl_func_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>plperl_trigger_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plperl_event_trigger_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_plperl_function</name><parameter_list>(<parameter><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>plperl_proc_desc</name> <modifier>*</modifier></type><name>compile_plperl_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>fn_oid</name></decl></parameter>,
												 <parameter><decl><type><name>bool</name></type> <name>is_trigger</name></decl></parameter>,
												 <parameter><decl><type><name>bool</name></type> <name>is_event_trigger</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type><name>plperl_hash_from_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_generated</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type><name>plperl_hash_from_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type><name>plperl_ref_from_pg_array</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type><name>split_array</name><parameter_list>(<parameter><decl><type><name>plperl_array_info</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>last</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type><name>make_array_ref</name><parameter_list>(<parameter><decl><type><name>plperl_array_info</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>last</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type><name>get_perl_array_ref</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>sv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>plperl_sv_to_datum</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>sv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
								<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
								<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>,
								<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_sv_to_datum_finfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typioparam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>plperl_array_to_datum</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>array_to_datum_internal</name><parameter_list>(<parameter><decl><type><name>AV</name> <modifier>*</modifier></type><name>av</name></decl></parameter>, <parameter><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>,
									<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ndims</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dims</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_depth</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name></type> <name>arraytypid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>elemtypid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
									<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>plperl_hash_to_datum</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>td</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plperl_init_shared_libs</name><parameter_list>(<parameter><decl><type><name>pTHX</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plperl_trusted_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plperl_untrusted_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HV</name>  <modifier>*</modifier></type><name>plperl_spi_execute_fetch_result</name><parameter_list>(<parameter><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint64</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plperl_return_next_internal</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>sv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>hek2cstr</name><parameter_list>(<parameter><decl><type><name>HE</name> <modifier>*</modifier></type><name>he</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SV</name> <modifier>*</modifier><modifier>*</modifier></type><name>hv_store_string</name><parameter_list>(<parameter><decl><type><name>HV</name> <modifier>*</modifier></type><name>hv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SV</name> <modifier>*</modifier><modifier>*</modifier></type><name>hv_fetch_string</name><parameter_list>(<parameter><decl><type><name>HV</name> <modifier>*</modifier></type><name>hv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plperl_create_sub</name><parameter_list>(<parameter><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>fn_oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type><name>plperl_call_perl_func</name><parameter_list>(<parameter><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
								  <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plperl_compile_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plperl_exec_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plperl_inline_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>strip_trailing_ws</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OP</name>  <modifier>*</modifier></type><name>pp_require_safe</name><parameter_list>(<parameter><decl><type><name>pTHX</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>activate_interpreter</name><parameter_list>(<parameter><decl><type><name>plperl_interp_desc</name> <modifier>*</modifier></type><name>interp_desc</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>setlocale_perl</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>category</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Decrement the refcount of the given SV within the active Perl interpreter
 *
 * This is handy because it reloads the active-interpreter pointer, saving
 * some notation in callers that switch the active interpreter.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>SvREFCNT_dec_current</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>sv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SvREFCNT_dec</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * convert a HE (hash entry) key to a cstr in the current database encoding
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>hek2cstr</name><parameter_list>(<parameter><decl><type><name>HE</name> <modifier>*</modifier></type><name>he</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sv</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * HeSVKEY_force will return a temporary mortal SV*, so we need to make
	 * sure to free it with ENTER/SAVE/FREE/LEAVE
	 */</comment>
	<expr_stmt><expr><name>ENTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SAVETMPS</name></expr>;</expr_stmt>

	<comment type="block">/*-------------------------
	 * Unfortunately,  while HeUTF8 is true for most things &gt; 256, for values
	 * 128..255 it's not, but perl will treat them as unicode code points if
	 * the utf8 flag is not set ( see The "Unicode Bug" in perldoc perlunicode
	 * for more)
	 *
	 * So if we did the expected:
	 *	  if (HeUTF8(he))
	 *		  utf_u2e(key...);
	 *	  else // must be ascii
	 *		  return HePV(he);
	 * we won't match columns with codepoints from 128..255
	 *
	 * For a more concrete example given a column with the name of the unicode
	 * codepoint U+00ae (registered sign) and a UTF8 database and the perl
	 * return_next { "\N{U+00ae}=&gt;'text } would always fail as heUTF8 returns
	 * 0 and HePV() would give us a char * with 1 byte contains the decimal
	 * value 174
	 *
	 * Perl has the brains to know when it should utf8 encode 174 properly, so
	 * here we force it into an SV so that perl will figure it out and do the
	 * right thing
	 *-------------------------
	 */</comment>

	<expr_stmt><expr><name>sv</name> <operator>=</operator> <call><name>HeSVKEY_force</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeUTF8</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SvUTF8_on</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>sv2cstr</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free sv */</comment>
	<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * _PG_init()			- library load-time initialization
 *
 * DO NOT make this static nor change its name!
 */</comment>
<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Be sure we do initialization only once.
	 *
	 * If initialization fails due to, e.g., plperl_init_interp() throwing an
	 * exception, then we'll return here on the next usage and the user will
	 * get a rather cryptic: ERROR:  attempt to redefine parameter
	 * "plperl.use_strict"
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>inited</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>inited</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Support localized messages.
	 */</comment>
	<expr_stmt><expr><call><name>pg_bindtextdomain</name><argument_list>(<argument><expr><name>TEXTDOMAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize plperl's GUCs.
	 */</comment>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"plperl.use_strict"</literal></expr></argument>,
							 <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"If true, trusted and untrusted Perl code will be compiled in strict mode."</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>plperl_use_strict</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * plperl.on_init is marked PGC_SIGHUP to support the idea that it might
	 * be executed in the postmaster (if plperl is loaded into the postmaster
	 * via shared_preload_libraries).  This isn't really right either way,
	 * though.
	 */</comment>
	<expr_stmt><expr><call><name>DefineCustomStringVariable</name><argument_list>(<argument><expr><literal type="string">"plperl.on_init"</literal></expr></argument>,
							   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Perl initialization code to execute when a Perl interpreter is initialized."</literal></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>plperl_on_init</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>PGC_SIGHUP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * plperl.on_plperl_init is marked PGC_SUSET to avoid issues whereby a
	 * user who might not even have USAGE privilege on the plperl language
	 * could nonetheless use SET plperl.on_plperl_init='...' to influence the
	 * behaviour of any existing plperl function that they can execute (which
	 * might be SECURITY DEFINER, leading to a privilege escalation).  See
	 * http://archives.postgresql.org/pgsql-hackers/2010-02/msg00281.php and
	 * the overall thread.
	 *
	 * Note that because plperl.use_strict is USERSET, a nefarious user could
	 * set it to be applied against other people's functions.  This is judged
	 * OK since the worst result would be an error.  Your code oughta pass
	 * use_strict anyway ;-)
	 */</comment>
	<expr_stmt><expr><call><name>DefineCustomStringVariable</name><argument_list>(<argument><expr><literal type="string">"plperl.on_plperl_init"</literal></expr></argument>,
							   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Perl initialization code to execute once when plperl is first used."</literal></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>plperl_on_plperl_init</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DefineCustomStringVariable</name><argument_list>(<argument><expr><literal type="string">"plperl.on_plperlu_init"</literal></expr></argument>,
							   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Perl initialization code to execute once when plperlu is first used."</literal></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>plperl_on_plperlu_init</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EmitWarningsOnPlaceholders</name><argument_list>(<argument><expr><literal type="string">"plperl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create hash tables.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plperl_interp_desc</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>plperl_interp_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PL/Perl interpreters"</literal></expr></argument>,
									 <argument><expr><literal type="number">8</literal></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
									 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plperl_proc_key</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plperl_proc_ptr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>plperl_proc_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PL/Perl procedures"</literal></expr></argument>,
								   <argument><expr><literal type="number">32</literal></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
								   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save the default opmask.
	 */</comment>
	<expr_stmt><expr><call><name>PLPERL_SET_OPMASK</name><argument_list>(<argument><expr><name>plperl_opmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the first Perl interpreter, but only partially initialize it.
	 */</comment>
	<expr_stmt><expr><name>plperl_held_interp</name> <operator>=</operator> <call><name>plperl_init_interp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>inited</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_interp_require</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>trusted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>trusted</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>PL_ppaddr</name><index>[<expr><name>OP_REQUIRE</name></expr>]</index></name> <operator>=</operator> <name>pp_require_safe</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PL_ppaddr</name><index>[<expr><name>OP_DOFILE</name></expr>]</index></name> <operator>=</operator> <name>pp_require_safe</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>PL_ppaddr</name><index>[<expr><name>OP_REQUIRE</name></expr>]</index></name> <operator>=</operator> <name>pp_require_orig</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PL_ppaddr</name><index>[<expr><name>OP_DOFILE</name></expr>]</index></name> <operator>=</operator> <name>pp_require_orig</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup perl interpreters, including running END blocks.
 * Does not fully undo the actions of _PG_init() nor make it callable again.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_fini</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_interp_desc</name> <modifier>*</modifier></type><name>interp_desc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"plperl_fini"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Indicate that perl is terminating. Disables use of spi_* functions when
	 * running END/DESTROY code. See check_spi_usage_allowed(). Could be
	 * enabled in future, with care, using a transaction
	 * http://archives.postgresql.org/pgsql-hackers/2010-01/msg02743.php
	 */</comment>
	<expr_stmt><expr><name>plperl_ending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Only perform perl cleanup if we're exiting cleanly */</comment>
	<if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"plperl_fini: skipped"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Zap the "held" interpreter, if we still have it */</comment>
	<expr_stmt><expr><call><name>plperl_destroy_interp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plperl_held_interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zap any fully-initialized interpreters */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>plperl_interp_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>interp_desc</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name>interp_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>plperl_destroy_interp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"plperl_fini: done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Select and activate an appropriate Perl interpreter.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>select_perl_context</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>trusted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>user_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_interp_desc</name> <modifier>*</modifier></type><name>interp_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PerlInterpreter</name> <modifier>*</modifier></type><name>interp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Find or create the interpreter hashtable entry for this userid */</comment>
	<if_stmt><if>if <condition>(<expr><name>trusted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>user_id</name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>user_id</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>interp_desc</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>plperl_interp_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>user_id</name></expr></argument>,
							  <argument><expr><name>HASH_ENTER</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Initialize newly-created hashtable entry */</comment>
		<expr_stmt><expr><name><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interp_desc</name><operator>-&gt;</operator><name>query_hash</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make sure we have a query_hash for this interpreter */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>interp_desc</name><operator>-&gt;</operator><name>query_hash</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plperl_query_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interp_desc</name><operator>-&gt;</operator><name>query_hash</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PL/Perl queries"</literal></expr></argument>,
											  <argument><expr><literal type="number">32</literal></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
											  <argument><expr><name>HASH_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Quick exit if already have an interpreter
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name>interp_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * adopt held interp if free, else create new one if possible
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plperl_held_interp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* first actual use of a perl interpreter */</comment>
		<expr_stmt><expr><name>interp</name> <operator>=</operator> <name>plperl_held_interp</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset the plperl_held_interp pointer first; if we fail during init
		 * we don't want to try again with the partially-initialized interp.
		 */</comment>
		<expr_stmt><expr><name>plperl_held_interp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>trusted</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>plperl_trusted_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>plperl_untrusted_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* successfully initialized, so arrange for cleanup */</comment>
		<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>plperl_fini</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MULTIPLICITY</name></cpp:ifdef>

		<comment type="block">/*
		 * plperl_init_interp will change Perl's idea of the active
		 * interpreter.  Reset plperl_active_interp temporarily, so that if we
		 * hit an error partway through here, we'll make sure to switch back
		 * to a non-broken interpreter before running any other Perl
		 * functions.
		 */</comment>
		<expr_stmt><expr><name>plperl_active_interp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Now build the new interpreter */</comment>
		<expr_stmt><expr><name>interp</name> <operator>=</operator> <call><name>plperl_init_interp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>trusted</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>plperl_trusted_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>plperl_untrusted_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot allocate multiple Perl interpreters on this platform"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>set_interp_require</name><argument_list>(<argument><expr><name>trusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since the timing of first use of PL/Perl can't be predicted, any
	 * database interaction during initialization is problematic. Including,
	 * but not limited to, security definer issues. So we only enable access
	 * to the database AFTER on_*_init code has run. See
	 * http://archives.postgresql.org/pgsql-hackers/2010-01/msg02669.php
	 */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>newXS</name><argument_list>(<argument><expr><literal type="string">"PostgreSQL::InServer::SPI::bootstrap"</literal></expr></argument>,
			  <argument><expr><name>boot_PostgreSQL__InServer__SPI</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>eval_pv</name><argument_list>(<argument><expr><literal type="string">"PostgreSQL::InServer::SPI::bootstrap()"</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>SvTRUE</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strip_trailing_ws</name><argument_list>(<argument><expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while executing PostgreSQL::InServer::SPI::bootstrap"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Fully initialized, so mark the hashtable entry valid */</comment>
	<expr_stmt><expr><name><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name> <operator>=</operator> <name>interp</name></expr>;</expr_stmt>

	<comment type="block">/* And mark this as the active interpreter */</comment>
	<expr_stmt><expr><name>plperl_active_interp</name> <operator>=</operator> <name>interp_desc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make the specified interpreter the active one
 *
 * A call with NULL does nothing.  This is so that "restoring" to a previously
 * null state of plperl_active_interp doesn't result in useless thrashing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>activate_interpreter</name><parameter_list>(<parameter><decl><type><name>plperl_interp_desc</name> <modifier>*</modifier></type><name>interp_desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>interp_desc</name> <operator>&amp;&amp;</operator> <name>plperl_active_interp</name> <operator>!=</operator> <name>interp_desc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PERL_SET_CONTEXT</name><argument_list>(<argument><expr><name><name>interp_desc</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* trusted iff user_id isn't InvalidOid */</comment>
		<expr_stmt><expr><call><name>set_interp_require</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>interp_desc</name><operator>-&gt;</operator><name>user_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>plperl_active_interp</name> <operator>=</operator> <name>interp_desc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new Perl interpreter.
 *
 * We initialize the interpreter as far as we can without knowing whether
 * it will become a trusted or untrusted interpreter; in particular, the
 * plperl.on_init code will get executed.  Later, either plperl_trusted_init
 * or plperl_untrusted_init must be called to complete the initialization.
 */</comment>
<function><type><specifier>static</specifier> <name>PerlInterpreter</name> <modifier>*</modifier></type>
<name>plperl_init_interp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PerlInterpreter</name> <modifier>*</modifier></type><name>plperl</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>embedding</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"-e"</literal></expr>, <expr><name>PLC_PERLBOOT</name></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/*
	 * The perl library on startup does horrible things like call
	 * setlocale(LC_ALL,""). We have protected against that on most platforms
	 * by setting the environment appropriately. However, on Windows,
	 * setlocale() does not consult the environment, so we need to save the
	 * existing locale settings before perl has a chance to mangle them and
	 * restore them after its dirty deeds are done.
	 *
	 * MSDN ref:
	 * http://msdn.microsoft.com/library/en-us/vclib/html/_crt_locale.asp
	 *
	 * It appears that we only need to do this on interpreter startup, and
	 * subsequent calls to the interpreter don't mess with the locale
	 * settings.
	 *
	 * We restore them using setlocale_perl(), defined below, so that Perl
	 * doesn't have a different idea of the locale from Postgres.
	 *
	 */</comment>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save_collate</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>save_ctype</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>save_monetary</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>save_numeric</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>save_time</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_COLLATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_collate</name> <operator>=</operator> <ternary><condition><expr><name>loc</name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_ctype</name> <operator>=</operator> <ternary><condition><expr><name>loc</name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_MONETARY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_monetary</name> <operator>=</operator> <ternary><condition><expr><name>loc</name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_NUMERIC</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_numeric</name> <operator>=</operator> <ternary><condition><expr><name>loc</name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_TIME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_time</name> <operator>=</operator> <ternary><condition><expr><name>loc</name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLPERL_RESTORE_LOCALE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>saved</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>STMT_START { \
		if (saved != NULL) { setlocale_perl(name, saved); pfree(saved); } \
	} STMT_END</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

	<if_stmt><if>if <condition>(<expr><name>plperl_on_init</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>plperl_on_init</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>embedding</name><index>[<expr><name>nargs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"-e"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>embedding</name><index>[<expr><name>nargs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>plperl_on_init</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The perl API docs state that PERL_SYS_INIT3 should be called before
	 * allocating interpreters. Unfortunately, on some platforms this fails in
	 * the Perl_do_taint() routine, which is called when the platform is using
	 * the system's malloc() instead of perl's own. Other platforms, notably
	 * Windows, fail if PERL_SYS_INIT3 is not called. So we call it if it's
	 * available, unless perl is using the system malloc(), which is true when
	 * MYMALLOC is set.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PERL_SYS_INIT3</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MYMALLOC</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>perl_sys_init_done</name></decl>;</decl_stmt>

		<comment type="block">/* only call this the first time through, as per perlembed man page */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>perl_sys_init_done</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>dummy_env</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>PERL_SYS_INIT3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>embedding</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dummy_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * For unclear reasons, PERL_SYS_INIT3 sets the SIGFPE handler to
			 * SIG_IGN.  Aside from being extremely unfriendly behavior for a
			 * library, this is dumb on the grounds that the results of a
			 * SIGFPE in this state are undefined according to POSIX, and in
			 * fact you get a forced process kill at least on Linux.  Hence,
			 * restore the SIGFPE handler to the backend's standard setting.
			 * (See Perl bug 114574 for more information.)
			 */</comment>
			<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>FloatExceptionHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>perl_sys_init_done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<comment type="block">/* quiet warning if PERL_SYS_INIT3 doesn't use the third argument */</comment>
			<expr_stmt><expr><name><name>dummy_env</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>plperl</name> <operator>=</operator> <call><name>perl_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plperl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not allocate Perl interpreter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PERL_SET_CONTEXT</name><argument_list>(<argument><expr><name>plperl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>perl_construct</name><argument_list>(<argument><expr><name>plperl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run END blocks in perl_destruct instead of perl_run.  Note that dTHX
	 * loads up a pointer to the current interpreter, so we have to postpone
	 * it to here rather than put it at the function head.
	 */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>PL_exit_flags</name> <operator>|=</operator> <name>PERL_EXIT_DESTRUCT_END</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Record the original function for the 'require' and 'dofile'
		 * opcodes.  (They share the same implementation.)  Ensure it's used
		 * for new interpreters.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pp_require_orig</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pp_require_orig</name> <operator>=</operator> <name><name>PL_ppaddr</name><index>[<expr><name>OP_REQUIRE</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>PL_ppaddr</name><index>[<expr><name>OP_REQUIRE</name></expr>]</index></name> <operator>=</operator> <name>pp_require_orig</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>PL_ppaddr</name><index>[<expr><name>OP_DOFILE</name></expr>]</index></name> <operator>=</operator> <name>pp_require_orig</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PLPERL_ENABLE_OPMASK_EARLY</name></cpp:ifdef>

		<comment type="block">/*
		 * For regression testing to prove that the PLC_PERLBOOT and
		 * PLC_TRUSTED code doesn't even compile any unsafe ops.  In future
		 * there may be a valid need for them to do so, in which case this
		 * could be softened (perhaps moved to plperl_trusted_init()) or
		 * removed.
		 */</comment>
		<expr_stmt><expr><name>PL_op_mask</name> <operator>=</operator> <name>plperl_opmask</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><call><name>perl_parse</name><argument_list>(<argument><expr><name>plperl</name></expr></argument>, <argument><expr><name>plperl_init_shared_libs</name></expr></argument>,
					   <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>embedding</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strip_trailing_ws</name><argument_list>(<argument><expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while parsing Perl initialization"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>perl_run</name><argument_list>(<argument><expr><name>plperl</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strip_trailing_ws</name><argument_list>(<argument><expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while running Perl initialization"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PLPERL_RESTORE_LOCALE</name></cpp:ifdef>
		<expr_stmt><expr><call><name>PLPERL_RESTORE_LOCALE</name><argument_list>(<argument><expr><name>LC_COLLATE</name></expr></argument>, <argument><expr><name>save_collate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PLPERL_RESTORE_LOCALE</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>save_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PLPERL_RESTORE_LOCALE</name><argument_list>(<argument><expr><name>LC_MONETARY</name></expr></argument>, <argument><expr><name>save_monetary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PLPERL_RESTORE_LOCALE</name><argument_list>(<argument><expr><name>LC_NUMERIC</name></expr></argument>, <argument><expr><name>save_numeric</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PLPERL_RESTORE_LOCALE</name><argument_list>(<argument><expr><name>LC_TIME</name></expr></argument>, <argument><expr><name>save_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block>

	<return>return <expr><name>plperl</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Our safe implementation of the require opcode.
 * This is safe because it's completely unable to load any code.
 * If the requested file/module has already been loaded it'll return true.
 * If not, it'll die.
 * So now "use Foo;" will work iff Foo has already been loaded.
 */</comment>
<function><type><specifier>static</specifier> <name>OP</name>  <modifier>*</modifier></type>
<name>pp_require_safe</name><parameter_list>(<parameter><decl><type><name>pTHX</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dVAR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dSP</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sv</name></decl>,
			  <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>svp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>STRLEN</name></type>		<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sv</name> <operator>=</operator> <name>POPs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>SvPV</name><argument_list>(<argument><expr><name>sv</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>name</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>RETPUSHNO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>svp</name> <operator>=</operator> <call><name>hv_fetch</name><argument_list>(<argument><expr><call><name>GvHVn</name><argument_list>(<argument><expr><name>PL_incgv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>svp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>svp</name> <operator>!=</operator> <operator>&amp;</operator><name>PL_sv_undef</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>RETPUSHYES</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>DIE</name><argument_list>(<argument><expr><name>aTHX_</name> <literal type="string">"Unable to load %s into plperl"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In most Perl versions, DIE() expands to a return statement, so the next
	 * line is not necessary.  But in versions between but not including
	 * 5.11.1 and 5.13.3 it does not, so the next line is necessary to avoid a
	 * "control reaches end of non-void function" warning from gcc.  Other
	 * compilers such as Solaris Studio will, however, issue a "statement not
	 * reached" warning instead.
	 */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Destroy one Perl interpreter ... actually we just run END blocks.
 *
 * Caller must have ensured this interpreter is the active one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_destroy_interp</name><parameter_list>(<parameter><decl><type><name>PerlInterpreter</name> <modifier>*</modifier><modifier>*</modifier></type><name>interp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>interp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>interp</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Only a very minimal destruction is performed: - just call END
		 * blocks.
		 *
		 * We could call perl_destruct() but we'd need to audit its actions
		 * very carefully and work-around any that impact us. (Calling
		 * sv_clean_objs() isn't an option because it's not part of perl's
		 * public API so isn't portably available.) Meanwhile END blocks can
		 * be used to perform manual cleanup.
		 */</comment>
		<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>

		<comment type="block">/* Run END blocks - based on perl's perl_destruct() */</comment>
		<if_stmt><if>if <condition>(<expr><name>PL_exit_flags</name> <operator>&amp;</operator> <name>PERL_EXIT_DESTRUCT_END</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dJMPENV</name></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>JMPENV_PUSH</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PERL_UNUSED_VAR</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>PL_endav</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>PL_minus_c</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>call_list</name><argument_list>(<argument><expr><name>PL_scopestack_ix</name></expr></argument>, <argument><expr><name>PL_endav</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>JMPENV_POP</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>interp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the current Perl interpreter as a trusted interp
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_trusted_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>stash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>I32</name></type>			<name>klen</name></decl>;</decl_stmt>

	<comment type="block">/* use original require while we set up */</comment>
	<expr_stmt><expr><name><name>PL_ppaddr</name><index>[<expr><name>OP_REQUIRE</name></expr>]</index></name> <operator>=</operator> <name>pp_require_orig</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>PL_ppaddr</name><index>[<expr><name>OP_DOFILE</name></expr>]</index></name> <operator>=</operator> <name>pp_require_orig</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>eval_pv</name><argument_list>(<argument><expr><name>PLC_TRUSTED</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SvTRUE</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strip_trailing_ws</name><argument_list>(<argument><expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while executing PLC_TRUSTED"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Force loading of utf8 module now to prevent errors that can arise from
	 * the regex code later trying to load utf8 modules. See
	 * http://rt.perl.org/rt3/Ticket/Display.html?id=47576
	 */</comment>
	<expr_stmt><expr><call><name>eval_pv</name><argument_list>(<argument><expr><literal type="string">"my $a=chr(0x100); return $a =~ /\\xa9/i"</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SvTRUE</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strip_trailing_ws</name><argument_list>(<argument><expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while executing utf8fix"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Lock down the interpreter
	 */</comment>

	<comment type="block">/* switch to the safe require/dofile opcode for future code */</comment>
	<expr_stmt><expr><name><name>PL_ppaddr</name><index>[<expr><name>OP_REQUIRE</name></expr>]</index></name> <operator>=</operator> <name>pp_require_safe</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>PL_ppaddr</name><index>[<expr><name>OP_DOFILE</name></expr>]</index></name> <operator>=</operator> <name>pp_require_safe</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * prevent (any more) unsafe opcodes being compiled PL_op_mask is per
	 * interpreter, so this only needs to be set once
	 */</comment>
	<expr_stmt><expr><name>PL_op_mask</name> <operator>=</operator> <name>plperl_opmask</name></expr>;</expr_stmt>

	<comment type="block">/* delete the DynaLoader:: namespace so extensions can't be loaded */</comment>
	<expr_stmt><expr><name>stash</name> <operator>=</operator> <call><name>gv_stashpv</name><argument_list>(<argument><expr><literal type="string">"DynaLoader"</literal></expr></argument>, <argument><expr><name>GV_ADDWARN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hv_iterinit</name><argument_list>(<argument><expr><name>stash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>sv</name> <operator>=</operator> <call><name>hv_iternextsv</name><argument_list>(<argument><expr><name>stash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klen</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isGV_with_GP</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>GvCV</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>SvREFCNT_dec</name><argument_list>(<argument><expr><call><name>GvCV</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* free the CV */</comment>
		<expr_stmt><expr><call><name>GvCV_set</name><argument_list>(<argument><expr><name>sv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* prevent call via GV */</comment>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>hv_clear</name><argument_list>(<argument><expr><name>stash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* invalidate assorted caches */</comment>
	<expr_stmt><expr><operator>++</operator><name>PL_sub_generation</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hv_clear</name><argument_list>(<argument><expr><name>PL_stashcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute plperl.on_plperl_init in the locked-down interpreter
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plperl_on_plperl_init</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>plperl_on_plperl_init</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>eval_pv</name><argument_list>(<argument><expr><name>plperl_on_plperl_init</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* XXX need to find a way to determine a better errcode here */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SvTRUE</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strip_trailing_ws</name><argument_list>(<argument><expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while executing plperl.on_plperl_init"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Initialize the current Perl interpreter as an untrusted interp
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_untrusted_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Nothing to do except execute plperl.on_plperlu_init
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plperl_on_plperlu_init</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>plperl_on_plperlu_init</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>eval_pv</name><argument_list>(<argument><expr><name>plperl_on_plperlu_init</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>SvTRUE</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strip_trailing_ws</name><argument_list>(<argument><expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while executing plperl.on_plperlu_init"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Perl likes to put a newline after its error messages; clean up such
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>strip_trailing_ws</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>res</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>res</name><index>[<expr><operator>--</operator><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Build a tuple from a hash. */</comment>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>plperl_build_tuple_result</name><parameter_list>(<parameter><decl><type><name>HV</name> <modifier>*</modifier></type><name>perlhash</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>td</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HE</name>		   <modifier>*</modifier></type><name>he</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>td</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hv_iterinit</name><argument_list>(<argument><expr><name>perlhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>he</name> <operator>=</operator> <call><name>hv_iternext</name><argument_list>(<argument><expr><name>perlhash</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>HeVAL</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>hek2cstr</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attn</name> <init>= <expr><call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attn</name> <operator>==</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Perl hash contains nonexistent column \"%s\""</literal></expr></argument>,
							<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>attn</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set system attribute \"%s\""</literal></expr></argument>,
							<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>plperl_sv_to_datum</name><argument_list>(<argument><expr><name>val</name></expr></argument>,
											  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
											  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><name>InvalidOid</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>hv_iterinit</name><argument_list>(<argument><expr><name>perlhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* convert a hash reference to a datum */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>plperl_hash_to_datum</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>td</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name> <init>= <expr><call><name>plperl_build_tuple_result</name><argument_list>(<argument><expr><operator>(</operator><name>HV</name> <operator>*</operator><operator>)</operator> <call><name>SvRV</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * if we are an array ref return the reference. this is special in that if we
 * are a PostgreSQL::InServer::ARRAY object we will return the 'magic' array.
 */</comment>
<function><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type>
<name>get_perl_array_ref</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>sv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SvOK</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SvROK</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>SvTYPE</name><argument_list>(<argument><expr><call><name>SvRV</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>SVt_PVAV</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>sv</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>sv_isa</name><argument_list>(<argument><expr><name>sv</name></expr></argument>, <argument><expr><literal type="string">"PostgreSQL::InServer::ARRAY"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>hv</name> <init>= <expr><operator>(</operator><name>HV</name> <operator>*</operator><operator>)</operator> <call><name>SvRV</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SV</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>sav</name> <init>= <expr><call><name>hv_fetch_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"array"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sav</name> <operator>&amp;&amp;</operator> <call><name>SvOK</name><argument_list>(<argument><expr><operator>*</operator><name>sav</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SvROK</name><argument_list>(<argument><expr><operator>*</operator><name>sav</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>SvTYPE</name><argument_list>(<argument><expr><call><name>SvRV</name><argument_list>(<argument><expr><operator>*</operator><name>sav</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>SVt_PVAV</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>*</operator><name>sav</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not get array reference from PostgreSQL::InServer::ARRAY object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * helper function for plperl_array_to_datum, recurses for multi-D arrays
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>array_to_datum_internal</name><parameter_list>(<parameter><decl><type><name>AV</name> <modifier>*</modifier></type><name>av</name></decl></parameter>, <parameter><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>,
						<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ndims</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dims</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_depth</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>arraytypid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>elemtypid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
						<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>av_len</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* fetch the array element */</comment>
		<decl_stmt><decl><type><name>SV</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>svp</name> <init>= <expr><call><name>av_fetch</name><argument_list>(<argument><expr><name>av</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* see if this element is an array, if so get that */</comment>
		<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sav</name> <init>= <expr><ternary><condition><expr><name>svp</name></expr> ?</condition><then> <expr><call><name>get_perl_array_ref</name><argument_list>(<argument><expr><operator>*</operator><name>svp</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/* multi-dimensional array? */</comment>
		<if_stmt><if>if <condition>(<expr><name>sav</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AV</name>		   <modifier>*</modifier></type><name>nav</name> <init>= <expr><operator>(</operator><name>AV</name> <operator>*</operator><operator>)</operator> <call><name>SvRV</name><argument_list>(<argument><expr><name>sav</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* dimensionality checks */</comment>
			<if_stmt><if>if <condition>(<expr><name>cur_depth</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
								<argument><expr><name>cur_depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* set size when at first element in this level, else compare */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ndims</name> <operator>==</operator> <name>cur_depth</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>dims</name><index>[<expr><operator>*</operator><name>ndims</name></expr>]</index></name> <operator>=</operator> <call><name>av_len</name><argument_list>(<argument><expr><name>nav</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>ndims</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>av_len</name><argument_list>(<argument><expr><name>nav</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name><name>dims</name><index>[<expr><name>cur_depth</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multidimensional arrays must have array expressions with matching dimensions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* recurse to fetch elements of this sub-array */</comment>
			<expr_stmt><expr><call><name>array_to_datum_internal</name><argument_list>(<argument><expr><name>nav</name></expr></argument>, <argument><expr><name>astate</name></expr></argument>,
									<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>cur_depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									<argument><expr><name>arraytypid</name></expr></argument>, <argument><expr><name>elemtypid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>,
									<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>dat</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<comment type="block">/* scalar after some sub-arrays at same level? */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ndims</name> <operator>!=</operator> <name>cur_depth</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multidimensional arrays must have array expressions with matching dimensions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>dat</name> <operator>=</operator> <call><name>plperl_sv_to_datum</name><argument_list>(<argument><expr><ternary><condition><expr><name>svp</name></expr> ?</condition><then> <expr><operator>*</operator><name>svp</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
									 <argument><expr><name>elemtypid</name></expr></argument>,
									 <argument><expr><name>typmod</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><name>finfo</name></expr></argument>,
									 <argument><expr><name>typioparam</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>dat</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
									<argument><expr><name>elemtypid</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * convert perl array ref to a datum
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>plperl_array_to_datum</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elemtypid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>finfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>dims</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>lbs</name><index>[<expr><name>MAXDIM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>elemtypid</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>elemtypid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert Perl array to non-array type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>initArrayResult</name><argument_list>(<argument><expr><name>elemtypid</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_sv_to_datum_finfo</name><argument_list>(<argument><expr><name>elemtypid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>finfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dims</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dims</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>av_len</name><argument_list>(<argument><expr><operator>(</operator><name>AV</name> <operator>*</operator><operator>)</operator> <call><name>SvRV</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>array_to_datum_internal</name><argument_list>(<argument><expr><operator>(</operator><name>AV</name> <operator>*</operator><operator>)</operator> <call><name>SvRV</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>astate</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
							<argument><expr><name>typid</name></expr></argument>, <argument><expr><name>elemtypid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>finfo</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ensure we get zero-D array for no inputs, as per PG convention */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ndims</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lbs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><call><name>makeMdArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>,
							 <argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the information needed to convert data to the specified PG type */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_sv_to_datum_finfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typioparam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>;</decl_stmt>

	<comment type="block">/* XXX would be better to cache these lookups */</comment>
	<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * convert Perl SV to PG datum of type typid, typmod typmod
 *
 * Pass the PL/Perl function's fcinfo when attempting to convert to the
 * function's result type; otherwise pass NULL.  This is used when we need to
 * resolve the actual result type of a function returning RECORD.
 *
 * finfo and typioparam should be the results of _sv_to_datum_finfo for the
 * given typid, or NULL/InvalidOid to let this function do the lookups.
 *
 * *isnull is an output parameter.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>plperl_sv_to_datum</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>sv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
				   <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
				   <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typioparam</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>

	<comment type="block">/* we might recurse */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return NULL if result is undef, or if we're in a function returning
	 * VOID.  In the latter case, we should pay no attention to the last Perl
	 * statement's result, and this is a convenient means to ensure that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sv</name> <operator>||</operator> <operator>!</operator><call><name>SvOK</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>typid</name> <operator>==</operator> <name>VOIDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* look up type info if they did not pass it */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>finfo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_sv_to_datum_finfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>finfo</name> <operator>=</operator> <operator>&amp;</operator><name>tmp</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* must call typinput in case it wants to reject NULL */</comment>
		<return>return <expr><call><name>InputFunctionCall</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>funcid</name> <operator>=</operator> <call><name>get_transform_tosql</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>lang_oid</name></name></expr></argument>, <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>trftypes</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>SvROK</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* handle references */</comment>
		<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sav</name> <init>= <expr><call><name>get_perl_array_ref</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sav</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* handle an arrayref */</comment>
			<return>return <expr><call><name>plperl_array_to_datum</name><argument_list>(<argument><expr><name>sav</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>SvTYPE</name><argument_list>(<argument><expr><call><name>SvRV</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>SVt_PVHV</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* handle a hashref */</comment>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>ret</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>td</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isdomain</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert Perl hash to non-composite type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>td</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_domain</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>td</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Did we look through a domain? */</comment>
				<expr_stmt><expr><name>isdomain</name> <operator>=</operator> <operator>(</operator><name>typid</name> <operator>!=</operator> <name><name>td</name><operator>-&gt;</operator><name>tdtypeid</name></name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Must be RECORD, try to resolve based on call info */</comment>
				<decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>funcclass</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>fcinfo</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>funcclass</name> <operator>=</operator> <call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>funcclass</name> <operator>=</operator> <name>TYPEFUNC_OTHER</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>funcclass</name> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name> <operator>&amp;&amp;</operator>
					<name>funcclass</name> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in context "</literal>
									<literal type="string">"that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isdomain</name> <operator>=</operator> <operator>(</operator><name>funcclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE_DOMAIN</name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>plperl_hash_to_datum</name><argument_list>(<argument><expr><name>sv</name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>isdomain</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>domain_check</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Release on the result of get_call_result_type is harmless */</comment>
			<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>ret</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If it's a reference to something else, such as a scalar, just
		 * recursively look through the reference.
		 */</comment>
		<return>return <expr><call><name>plperl_sv_to_datum</name><argument_list>(<argument><expr><call><name>SvRV</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>,
								  <argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>,
								  <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* handle a string/number */</comment>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* did not pass in any typeinfo? look it up */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>finfo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_sv_to_datum_finfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>finfo</name> <operator>=</operator> <operator>&amp;</operator><name>tmp</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Convert the perl SV to a string returned by the type output function */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>plperl_sv_to_literal</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>sv</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fqtypename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>str</name> <init>= <expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>fqtypename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>regtypein</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>,
				<decl><type ref="prev"/><name>isnull</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lookup failed for type %s"</literal></expr></argument>, <argument><expr><name>fqtypename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>plperl_sv_to_datum</name><argument_list>(<argument><expr><name>sv</name></expr></argument>,
							   <argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert PostgreSQL array datum to a perl array reference.
 *
 * typid is arg's OID, which must be an array type.
 */</comment>
<function><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type>
<name>plperl_ref_from_pg_array</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ar</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elementtype</name> <init>= <expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>ar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>,
				<decl><type ref="prev"/><name>typdelim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutputfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>transform_funcid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>nitems</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>dims</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_array_info</name> <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>av</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>hv</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Currently we make no effort to cache any of the stuff we look up here,
	 * which is bad.
	 */</comment>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>plperl_array_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get element type information, including output conversion function */</comment>
	<expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>elementtype</name></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutputfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for a transform function */</comment>
	<expr_stmt><expr><name>transform_funcid</name> <operator>=</operator> <call><name>get_transform_fromsql</name><argument_list>(<argument><expr><name>elementtype</name></expr></argument>,
											 <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>lang_oid</name></name></expr></argument>,
											 <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>trftypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up transform or output function as appropriate */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>transform_funcid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>transform_funcid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>transform_proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>typoutputfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>elem_is_rowtype</name></name> <operator>=</operator> <call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>elementtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the number and bounds of array dimensions */</comment>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>ndims</name></name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dims</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No dimensions? Return an empty array */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>ndims</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>av</name> <operator>=</operator> <call><name>newRV_noinc</name><argument_list>(<argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <call><name>newAV</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>ar</name></expr></argument>, <argument><expr><name>elementtype</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>,
						  <argument><expr><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get total number of elements in each dimension */</comment>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nelems</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>info</name><operator>-&gt;</operator><name>ndims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nelems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nitems</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info</name><operator>-&gt;</operator><name>ndims</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nelems</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>nelems</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name><name>dims</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name>av</name> <operator>=</operator> <call><name>split_array</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>hv</name> <operator>=</operator> <call><name>newHV</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hv_store</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"array"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>av</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hv_store</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"typeoid"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><call><name>newSVuv</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>sv_bless</name><argument_list>(<argument><expr><call><name>newRV_noinc</name><argument_list>(<argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <name>hv</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>gv_stashpv</name><argument_list>(<argument><expr><literal type="string">"PostgreSQL::InServer::ARRAY"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recursively form array references from splices of the initial array
 */</comment>
<function><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type>
<name>split_array</name><parameter_list>(<parameter><decl><type><name>plperl_array_info</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>last</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AV</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* we should only be called when we have something to split */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* since this function recurses, it could be driven to stack overflow */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Base case, return a reference to a single-dimensional array
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nest</name> <operator>&gt;=</operator> <name><name>info</name><operator>-&gt;</operator><name>ndims</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>make_array_ref</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>newAV</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>last</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name><name>info</name><operator>-&gt;</operator><name>nelems</name><index>[<expr><name>nest</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Recursively form references to arrays of lower dimensions */</comment>
		<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>ref</name> <init>= <expr><call><name>split_array</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name><name>info</name><operator>-&gt;</operator><name>nelems</name><index>[<expr><name>nest</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nest</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>av_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><call><name>newRV_noinc</name><argument_list>(<argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a Perl reference from a one-dimensional C array, converting
 * composite type elements to hash references.
 */</comment>
<function><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type>
<name>make_array_ref</name><parameter_list>(<parameter><decl><type><name>plperl_array_info</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>last</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AV</name>		   <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>newAV</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>last</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can't use &amp;PL_sv_undef here.  See "AVs, HVs and undefined
			 * values" in perlguts.
			 */</comment>
			<expr_stmt><expr><call><name>av_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>newSV</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>itemvalue</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>transform_proc</name><operator>.</operator><name>fn_oid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>av_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>FunctionCall1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>transform_proc</name></name></expr></argument>, <argument><expr><name>itemvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>elem_is_rowtype</name></name></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* Handle composite type elements */</comment>
				<expr_stmt><expr><call><name>av_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>plperl_hash_from_datum</name><argument_list>(<argument><expr><name>itemvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name>itemvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>av_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><call><name>newRV_noinc</name><argument_list>(<argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set up the arguments for a trigger call. */</comment>
<function><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type>
<name>plperl_trigger_build_args</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>when</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>hv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hv</name> <operator>=</operator> <call><name>newHV</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hv_ksplit</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* pre-grow the hash */</comment>

	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(
							<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidout</name></expr></argument>,
												<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></argument>
												)</argument_list></call></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"relid"</literal></expr></argument>, <argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: In BEFORE trigger, stored generated columns are not computed yet,
	 * so don't make them accessible in NEW row.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>event</name> <operator>=</operator> <literal type="string">"INSERT"</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>,
							<argument><expr><call><name>plperl_hash_from_tuple</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
												   <argument><expr><name>tupdesc</name></expr></argument>,
												   <argument><expr><operator>!</operator><call><name>TRIGGER_FIRED_BEFORE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>event</name> <operator>=</operator> <literal type="string">"DELETE"</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"old"</literal></expr></argument>,
							<argument><expr><call><name>plperl_hash_from_tuple</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
												   <argument><expr><name>tupdesc</name></expr></argument>,
												   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>event</name> <operator>=</operator> <literal type="string">"UPDATE"</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"old"</literal></expr></argument>,
							<argument><expr><call><name>plperl_hash_from_tuple</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
												   <argument><expr><name>tupdesc</name></expr></argument>,
												   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>,
							<argument><expr><call><name>plperl_hash_from_tuple</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr></argument>,
												   <argument><expr><name>tupdesc</name></expr></argument>,
												   <argument><expr><operator>!</operator><call><name>TRIGGER_FIRED_BEFORE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_TRUNCATE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>event</name> <operator>=</operator> <literal type="string">"TRUNCATE"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>event</name> <operator>=</operator> <literal type="string">"UNKNOWN"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"event"</literal></expr></argument>, <argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"argc"</literal></expr></argument>, <argument><expr><call><name>newSViv</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AV</name>		   <modifier>*</modifier></type><name>av</name> <init>= <expr><call><name>newAV</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>av_extend</name><argument_list>(<argument><expr><name>av</name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>av_push</name><argument_list>(<argument><expr><name>av</name></expr></argument>, <argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>, <argument><expr><call><name>newRV_noinc</name><argument_list>(<argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"relname"</literal></expr></argument>,
					<argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><call><name>SPI_getrelname</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"table_name"</literal></expr></argument>,
					<argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><call><name>SPI_getrelname</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"table_schema"</literal></expr></argument>,
					<argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><call><name>SPI_getnspname</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BEFORE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>when</name> <operator>=</operator> <literal type="string">"BEFORE"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_AFTER</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>when</name> <operator>=</operator> <literal type="string">"AFTER"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_INSTEAD</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>when</name> <operator>=</operator> <literal type="string">"INSTEAD OF"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>when</name> <operator>=</operator> <literal type="string">"UNKNOWN"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"when"</literal></expr></argument>, <argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name>when</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="string">"ROW"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_STATEMENT</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="string">"STATEMENT"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="string">"UNKNOWN"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"level"</literal></expr></argument>, <argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>newRV_noinc</name><argument_list>(<argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <name>hv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Set up the arguments for an event trigger call. */</comment>
<function><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type>
<name>plperl_event_trigger_build_args</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>hv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hv</name> <operator>=</operator> <call><name>newHV</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <operator>(</operator><name>EventTriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"event"</literal></expr></argument>, <argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><literal type="string">"tag"</literal></expr></argument>, <argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>newRV_noinc</name><argument_list>(<argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <name>hv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Construct the modified new tuple to be returned from a trigger. */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>plperl_modify_tuple</name><parameter_list>(<parameter><decl><type><name>HV</name> <modifier>*</modifier></type><name>hvTD</name></decl></parameter>, <parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>otup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SV</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>svp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>hvNew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HE</name>		   <modifier>*</modifier></type><name>he</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>rtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>modvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>modnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>modrepls</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>svp</name> <operator>=</operator> <call><name>hv_fetch_string</name><argument_list>(<argument><expr><name>hvTD</name></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>svp</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"$_TD-&gt;{new} does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SvOK</name><argument_list>(<argument><expr><operator>*</operator><name>svp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>SvROK</name><argument_list>(<argument><expr><operator>*</operator><name>svp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SvTYPE</name><argument_list>(<argument><expr><call><name>SvRV</name><argument_list>(<argument><expr><operator>*</operator><name>svp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SVt_PVHV</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"$_TD-&gt;{new} is not a hash reference"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>hvNew</name> <operator>=</operator> <operator>(</operator><name>HV</name> <operator>*</operator><operator>)</operator> <call><name>SvRV</name><argument_list>(<argument><expr><operator>*</operator><name>svp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>modvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>modnulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>modrepls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hv_iterinit</name><argument_list>(<argument><expr><name>hvNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>he</name> <operator>=</operator> <call><name>hv_iternext</name><argument_list>(<argument><expr><name>hvNew</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>hek2cstr</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>HeVAL</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attn</name> <init>= <expr><call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attn</name> <operator>==</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Perl hash contains nonexistent column \"%s\""</literal></expr></argument>,
							<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>attn</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set system attribute \"%s\""</literal></expr></argument>,
							<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set generated column \"%s\""</literal></expr></argument>,
							<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>modvalues</name><index>[<expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>plperl_sv_to_datum</name><argument_list>(<argument><expr><name>val</name></expr></argument>,
												 <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
												 <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>,
												 <argument><expr><name>InvalidOid</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name><name>modnulls</name><index>[<expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modrepls</name><index>[<expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>hv_iterinit</name><argument_list>(<argument><expr><name>hvNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rtup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>otup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>modvalues</name></expr></argument>, <argument><expr><name>modnulls</name></expr></argument>, <argument><expr><name>modrepls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>modvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>modnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>modrepls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rtup</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * There are three externally visible pieces to plperl: plperl_call_handler,
 * plperl_inline_handler, and plperl_validator.
 */</comment>

<comment type="block">/*
 * The call handler is called to run normal functions (including trigger
 * functions) that are defined in pg_proc.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plperl_call_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>plperl_call_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_call_data</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>save_call_data</name> <init>= <expr><name>current_call_data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_interp_desc</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>oldinterp</name> <init>= <expr><name>plperl_active_interp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_call_data</name></type> <name>this_call_data</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize current-call status record */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>this_call_data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>this_call_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>this_call_data</name><operator>.</operator><name>fcinfo</name></name> <operator>=</operator> <name>fcinfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>current_call_data</name> <operator>=</operator> <operator>&amp;</operator><name>this_call_data</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>plperl_trigger_handler</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>CALLED_AS_EVENT_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>plperl_event_trigger_handler</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>plperl_func_handler</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>current_call_data</name> <operator>=</operator> <name>save_call_data</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name>oldinterp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>this_call_data</name><operator>.</operator><name>prodesc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>decrement_prodesc_refcount</name><argument_list>(<argument><expr><name><name>this_call_data</name><operator>.</operator><name>prodesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>current_call_data</name> <operator>=</operator> <name>save_call_data</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name>oldinterp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>this_call_data</name><operator>.</operator><name>prodesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>decrement_prodesc_refcount</name><argument_list>(<argument><expr><name><name>this_call_data</name><operator>.</operator><name>prodesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The inline handler runs anonymous code blocks (DO blocks).
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plperl_inline_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>plperl_inline_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fake_fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>InlineCodeBlock</name> <modifier>*</modifier></type><name>codeblock</name> <init>= <expr><operator>(</operator><name>InlineCodeBlock</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_proc_desc</name></type> <name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_call_data</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>save_call_data</name> <init>= <expr><name>current_call_data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_interp_desc</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>oldinterp</name> <init>= <expr><name>plperl_active_interp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_call_data</name></type> <name>this_call_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>pl_error_context</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize current-call status record */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>this_call_data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>this_call_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up a callback for error reporting */</comment>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plperl_inline_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>pl_error_context</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up a fake fcinfo and descriptor with just enough info to satisfy
	 * plperl_call_perl_func().  In particular note that this sets things up
	 * with no arguments passed, and a result type of VOID.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>fake_fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fake_fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name> <operator>=</operator> <operator>&amp;</operator><name>flinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>flinfo</name><operator>.</operator><name>fn_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>flinfo</name><operator>.</operator><name>fn_mcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>desc</name><operator>.</operator><name>proname</name></name> <operator>=</operator> <literal type="string">"inline_code_block"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>.</operator><name>fn_readonly</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>desc</name><operator>.</operator><name>lang_oid</name></name> <operator>=</operator> <name><name>codeblock</name><operator>-&gt;</operator><name>langOid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>.</operator><name>trftypes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>.</operator><name>lanpltrusted</name></name> <operator>=</operator> <name><name>codeblock</name><operator>-&gt;</operator><name>langIsTrusted</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>desc</name><operator>.</operator><name>fn_retistuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>.</operator><name>fn_retisset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>.</operator><name>fn_retisarray</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>.</operator><name>result_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>.</operator><name>reference</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>this_call_data</name><operator>.</operator><name>fcinfo</name></name> <operator>=</operator> <name>fake_fcinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>this_call_data</name><operator>.</operator><name>prodesc</name></name> <operator>=</operator> <operator>&amp;</operator><name>desc</name></expr>;</expr_stmt>
	<comment type="block">/* we do not bother with refcounting the fake prodesc */</comment>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>perlret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>current_call_data</name> <operator>=</operator> <operator>&amp;</operator><name>this_call_data</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SPI_connect_ext</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>codeblock</name><operator>-&gt;</operator><name>atomic</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>SPI_OPT_NONATOMIC</name></expr></else></ternary></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not connect to SPI manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>select_perl_context</name><argument_list>(<argument><expr><name><name>desc</name><operator>.</operator><name>lanpltrusted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>plperl_create_sub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><name><name>codeblock</name><operator>-&gt;</operator><name>source_text</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>desc</name><operator>.</operator><name>reference</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* can this happen? */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not create internal procedure for anonymous code block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>perlret</name> <operator>=</operator> <call><name>plperl_call_perl_func</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><name>fake_fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SvREFCNT_dec_current</name><argument_list>(<argument><expr><name>perlret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>.</operator><name>reference</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SvREFCNT_dec_current</name><argument_list>(<argument><expr><name><name>desc</name><operator>.</operator><name>reference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>current_call_data</name> <operator>=</operator> <name>save_call_data</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name>oldinterp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>.</operator><name>reference</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SvREFCNT_dec_current</name><argument_list>(<argument><expr><name><name>desc</name><operator>.</operator><name>reference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>current_call_data</name> <operator>=</operator> <name>save_call_data</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name>oldinterp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>pl_error_context</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The validator is called during CREATE FUNCTION to validate the function
 * being created/replaced. The precise behavior of the validator may be
 * modified by the check_function_bodies GUC.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plperl_validator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>plperl_validator</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>functyptype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_trigger</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_event_trigger</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckFunctionValidatorAccess</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the new function's pg_proc entry */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>functyptype</name> <operator>=</operator> <call><name>get_typtype</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Disallow pseudotype result */</comment>
	<comment type="block">/* except for TRIGGER, EVTTRIGGER, RECORD, or VOID */</comment>
	<if_stmt><if>if <condition>(<expr><name>functyptype</name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we assume OPAQUE with no arguments means a trigger */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>==</operator> <name>TRIGGEROID</name> <operator>||</operator>
			<operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>==</operator> <name>OPAQUEOID</name> <operator>&amp;&amp;</operator> <name><name>proc</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>is_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>==</operator> <name>EVTTRIGGEROID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>is_event_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
				 <name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>VOIDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PL/Perl functions cannot return type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Disallow pseudotypes in arguments (either IN or OUT) */</comment>
	<expr_stmt><expr><name>numargs</name> <operator>=</operator> <call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_PSEUDO</name> <operator>&amp;&amp;</operator>
			<name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PL/Perl functions cannot accept type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Postpone body checks if !check_function_bodies */</comment>
	<if_stmt><if>if <condition>(<expr><name>check_function_bodies</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>compile_plperl_function</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>, <argument><expr><name>is_trigger</name></expr></argument>, <argument><expr><name>is_event_trigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* the result of a validator is ignored */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * plperlu likewise requires three externally visible functions:
 * plperlu_call_handler, plperlu_inline_handler, and plperlu_validator.
 * These are currently just aliases that send control to the plperl
 * handler functions, and we decide whether a particular function is
 * trusted or not by inspecting the actual pg_language tuple.
 */</comment>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plperlu_call_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>plperlu_call_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>plperl_call_handler</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plperlu_inline_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>plperlu_inline_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>plperl_inline_handler</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>plperlu_validator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>plperlu_validator</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* call plperl validator with our fcinfo so it gets our oid */</comment>
	<return>return <expr><call><name>plperl_validator</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Uses mksafefunc/mkunsafefunc to create a subroutine whose text is
 * supplied in s, and returns a reference to it
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_create_sub</name><parameter_list>(<parameter><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>fn_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dSP</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>subname</name><index>[<expr><name>NAMEDATALEN</name> <operator>+</operator> <literal type="number">40</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>pragma_hv</name> <init>= <expr><call><name>newHV</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>subref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>subname</name></expr></argument>, <argument><expr><literal type="string">"%s__%u"</literal></expr></argument>, <argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>, <argument><expr><name>fn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>plperl_use_strict</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>pragma_hv</name></expr></argument>, <argument><expr><literal type="string">"strict"</literal></expr></argument>, <argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <call><name>newAV</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ENTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SAVETMPS</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PUSHMARK</name><argument_list>(<argument><expr><name>SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXTEND</name><argument_list>(<argument><expr><name>SP</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PUSHs</name><argument_list>(<argument><expr><call><name>sv_2mortal</name><argument_list>(<argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PUSHs</name><argument_list>(<argument><expr><call><name>sv_2mortal</name><argument_list>(<argument><expr><call><name>newRV_noinc</name><argument_list>(<argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <name>pragma_hv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use 'false' for $prolog in mkfunc, which is kept for compatibility in
	 * case a module such as PostgreSQL::PLPerl::NYTprof replaces the function
	 * compiler.
	 */</comment>
	<expr_stmt><expr><call><name>PUSHs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>PL_sv_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PUSHs</name><argument_list>(<argument><expr><call><name>sv_2mortal</name><argument_list>(<argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * G_KEEPERR seems to be needed here, else we don't recognize compile
	 * errors properly.  Perhaps it's because there's another level of eval
	 * inside mksafefunc?
	 */</comment>
	<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>perl_call_pv</name><argument_list>(<argument><expr><literal type="string">"PostgreSQL::InServer::mkfunc"</literal></expr></argument>,
						 <argument><expr><name>G_SCALAR</name> <operator>|</operator> <name>G_EVAL</name> <operator>|</operator> <name>G_KEEPERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>SPAGAIN</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sub_rv</name> <init>= <expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <name>POPs</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sub_rv</name> <operator>&amp;&amp;</operator> <call><name>SvROK</name><argument_list>(<argument><expr><name>sub_rv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SvTYPE</name><argument_list>(<argument><expr><call><name>SvRV</name><argument_list>(<argument><expr><name>sub_rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>SVt_PVCV</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subref</name> <operator>=</operator> <call><name>newRV_inc</name><argument_list>(<argument><expr><call><name>SvRV</name><argument_list>(<argument><expr><name>sub_rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SvTRUE</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strip_trailing_ws</name><argument_list>(<argument><expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>subref</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"didn't get a CODE reference from compiling function \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>reference</name></name> <operator>=</operator> <name>subref</name></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 * plperl_init_shared_libs()		-
 **********************************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_init_shared_libs</name><parameter_list>(<parameter><decl><type><name>pTHX</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>file</name> <init>= <expr><name>__FILE__</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>newXS</name><argument_list>(<argument><expr><literal type="string">"DynaLoader::boot_DynaLoader"</literal></expr></argument>, <argument><expr><name>boot_DynaLoader</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>newXS</name><argument_list>(<argument><expr><literal type="string">"PostgreSQL::InServer::Util::bootstrap"</literal></expr></argument>,
		  <argument><expr><name>boot_PostgreSQL__InServer__Util</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* newXS for...::SPI::bootstrap is in select_perl_context() */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type>
<name>plperl_call_perl_func</name><parameter_list>(<parameter><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dSP</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ENTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SAVETMPS</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PUSHMARK</name><argument_list>(<argument><expr><name>SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXTEND</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get signature for true functions; inline blocks have no args. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_func_signature</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PUSHs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>PL_sv_undef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>arg_is_rowtype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sv</name> <init>= <expr><call><name>plperl_hash_from_datum</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>PUSHs</name><argument_list>(<argument><expr><call><name>sv_2mortal</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sv</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>arg_arraytype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sv</name> <operator>=</operator> <call><name>plperl_ref_from_pg_array</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>arg_arraytype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name>funcid</name> <operator>=</operator> <call><name>get_transform_fromsql</name><argument_list>(<argument><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>lang_oid</name></name></expr></argument>, <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>trftypes</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sv</name> <operator>=</operator> <operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>desc</name><operator>-&gt;</operator><name>arg_out_func</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
										 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sv</name> <operator>=</operator> <call><name>cstr2sv</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>PUSHs</name><argument_list>(<argument><expr><call><name>sv_2mortal</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>

	<comment type="block">/* Do NOT use G_KEEPERR here */</comment>
	<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>perl_call_sv</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>reference</name></name></expr></argument>, <argument><expr><name>G_SCALAR</name> <operator>|</operator> <name>G_EVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>SPAGAIN</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"didn't get a return item from function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SvTRUE</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>POPs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>
		<comment type="block">/* XXX need to find a way to determine a better errcode here */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strip_trailing_ws</name><argument_list>(<argument><expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>newSVsv</name><argument_list>(<argument><expr><name>POPs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type>
<name>plperl_call_perl_trigger_func</name><parameter_list>(<parameter><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
							  <parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>td</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dSP</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>retval</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>TDsv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>tg_trigger</name> <init>= <expr><operator>(</operator><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name><operator>)</operator><operator>-&gt;</operator><name>tg_trigger</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ENTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SAVETMPS</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>TDsv</name> <operator>=</operator> <call><name>get_sv</name><argument_list>(<argument><expr><literal type="string">"main::_TD"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TDsv</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"couldn't fetch $_TD"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>save_item</name><argument_list>(<argument><expr><name>TDsv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* local $_TD */</comment>
	<expr_stmt><expr><call><name>sv_setsv</name><argument_list>(<argument><expr><name>TDsv</name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PUSHMARK</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXTEND</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PUSHs</name><argument_list>(<argument><expr><call><name>sv_2mortal</name><argument_list>(<argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name><name>tg_trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>

	<comment type="block">/* Do NOT use G_KEEPERR here */</comment>
	<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>perl_call_sv</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>reference</name></name></expr></argument>, <argument><expr><name>G_SCALAR</name> <operator>|</operator> <name>G_EVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>SPAGAIN</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"didn't get a return item from trigger function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SvTRUE</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>POPs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>
		<comment type="block">/* XXX need to find a way to determine a better errcode here */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strip_trailing_ws</name><argument_list>(<argument><expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>newSVsv</name><argument_list>(<argument><expr><name>POPs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_call_perl_event_trigger_func</name><parameter_list>(<parameter><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>,
									<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
									<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>td</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dSP</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>retval</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>TDsv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ENTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SAVETMPS</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>TDsv</name> <operator>=</operator> <call><name>get_sv</name><argument_list>(<argument><expr><literal type="string">"main::_TD"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TDsv</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"couldn't fetch $_TD"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>save_item</name><argument_list>(<argument><expr><name>TDsv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* local $_TD */</comment>
	<expr_stmt><expr><call><name>sv_setsv</name><argument_list>(<argument><expr><name>TDsv</name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PUSHMARK</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>

	<comment type="block">/* Do NOT use G_KEEPERR here */</comment>
	<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>perl_call_sv</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>reference</name></name></expr></argument>, <argument><expr><name>G_SCALAR</name> <operator>|</operator> <name>G_EVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>SPAGAIN</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"didn't get a return item from trigger function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SvTRUE</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>POPs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>
		<comment type="block">/* XXX need to find a way to determine a better errcode here */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strip_trailing_ws</name><argument_list>(<argument><expr><call><name>sv2cstr</name><argument_list>(<argument><expr><name>ERRSV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>newSVsv</name><argument_list>(<argument><expr><name>POPs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>retval</name></expr>;</expr_stmt>				<comment type="block">/* silence compiler warning */</comment>

	<expr_stmt><expr><name>PUTBACK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>FREETMPS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>LEAVE</name></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>plperl_func_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nonatomic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>perlret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>pl_error_context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nonatomic</name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>CallContext</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>castNode</name><argument_list>(<argument><expr><name>CallContext</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atomic</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect_ext</name><argument_list>(<argument><expr><ternary><condition><expr><name>nonatomic</name></expr> ?</condition><then> <expr><name>SPI_OPT_NONATOMIC</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not connect to SPI manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>prodesc</name> <operator>=</operator> <call><name>compile_plperl_function</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name></name> <operator>=</operator> <name>prodesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>increment_prodesc_refcount</name><argument_list>(<argument><expr><name>prodesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set a callback for error reporting */</comment>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plperl_exec_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>proname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>pl_error_context</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retisset</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check context before allowing the call to go through */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that "</literal>
							<literal type="string">"cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>perlret</name> <operator>=</operator> <call><name>plperl_call_perl_func</name><argument_list>(<argument><expr><name>prodesc</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Disconnect from SPI manager and then create the return
	 * values datum (if the input function does a palloc for it
	 * this must not be allocated in the SPI memory context
	 * because SPI_finish would free it).
	 ************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retisset</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sav</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the Perl function returned an arrayref, we pretend that it
		 * called return_next() for each element of the array, to handle old
		 * SRFs that didn't know about return_next(). Any other sort of return
		 * value is an error, except undef which means return an empty set.
		 */</comment>
		<expr_stmt><expr><name>sav</name> <operator>=</operator> <call><name>get_perl_array_ref</name><argument_list>(<argument><expr><name>perlret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sav</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SV</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>svp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AV</name>		   <modifier>*</modifier></type><name>rav</name> <init>= <expr><operator>(</operator><name>AV</name> <operator>*</operator><operator>)</operator> <call><name>SvRV</name><argument_list>(<argument><expr><name>sav</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><operator>(</operator><name>svp</name> <operator>=</operator> <call><name>av_fetch</name><argument_list>(<argument><expr><name>rav</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>plperl_return_next_internal</name><argument_list>(<argument><expr><operator>*</operator><name>svp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>SvOK</name><argument_list>(<argument><expr><name>perlret</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-returning PL/Perl function must return "</literal>
							<literal type="string">"reference to array or use return_next"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>current_call_data</name><operator>-&gt;</operator><name>tuple_store</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name><name>current_call_data</name><operator>-&gt;</operator><name>tuple_store</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name><name>current_call_data</name><operator>-&gt;</operator><name>ret_tdesc</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_oid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>plperl_sv_to_datum</name><argument_list>(<argument><expr><name>perlret</name></expr></argument>,
									<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_oid</name></name></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									<argument><expr><name>fcinfo</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>prodesc</name><operator>-&gt;</operator><name>result_in_func</name></name></expr></argument>,
									<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_typioparam</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>&amp;&amp;</operator> <name>rsi</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>isDone</name></name> <operator>=</operator> <name>ExprEndResult</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Restore the previous error callback */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>pl_error_context</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SvREFCNT_dec_current</name><argument_list>(<argument><expr><name>perlret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>plperl_trigger_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>perlret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>svTD</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>hvTD</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>pl_error_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>			<name>rc</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<comment type="block">/* Connect to SPI manager */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not connect to SPI manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make transition tables visible to this SPI connection */</comment>
	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_register_trigger_data</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find or compile the function */</comment>
	<expr_stmt><expr><name>prodesc</name> <operator>=</operator> <call><name>compile_plperl_function</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name></name> <operator>=</operator> <name>prodesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>increment_prodesc_refcount</name><argument_list>(<argument><expr><name>prodesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set a callback for error reporting */</comment>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plperl_exec_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>proname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>pl_error_context</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>svTD</name> <operator>=</operator> <call><name>plperl_trigger_build_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>perlret</name> <operator>=</operator> <call><name>plperl_call_perl_trigger_func</name><argument_list>(<argument><expr><name>prodesc</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>svTD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hvTD</name> <operator>=</operator> <operator>(</operator><name>HV</name> <operator>*</operator><operator>)</operator> <call><name>SvRV</name><argument_list>(<argument><expr><name>svTD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	* Disconnect from SPI manager and then create the return
	* values datum (if the input function does a palloc for it
	* this must not be allocated in the SPI memory context
	* because SPI_finish would free it).
	************************************************************/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>perlret</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>SvOK</name><argument_list>(<argument><expr><name>perlret</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* undef result means go ahead with original tuple */</comment>
		<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name> <init>= <expr><operator>(</operator><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_TRUNCATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* can this happen? */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>trv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>sv2cstr</name><argument_list>(<argument><expr><name>perlret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"SKIP"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>trv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"MODIFY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>trv</name> <operator>=</operator> <call><name>plperl_modify_tuple</name><argument_list>(<argument><expr><name>hvTD</name></expr></argument>, <argument><expr><name>trigdata</name></expr></argument>,
										  <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>trv</name> <operator>=</operator> <call><name>plperl_modify_tuple</name><argument_list>(<argument><expr><name>hvTD</name></expr></argument>, <argument><expr><name>trigdata</name></expr></argument>,
										  <argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ignoring modified row in DELETE trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>trv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"result of PL/Perl trigger function must be undef, "</literal>
							<literal type="string">"\"SKIP\", or \"MODIFY\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>trv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>trv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Restore the previous error callback */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>pl_error_context</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SvREFCNT_dec_current</name><argument_list>(<argument><expr><name>svTD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>perlret</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SvREFCNT_dec_current</name><argument_list>(<argument><expr><name>perlret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_event_trigger_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>svTD</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>pl_error_context</name></decl>;</decl_stmt>

	<comment type="block">/* Connect to SPI manager */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not connect to SPI manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Find or compile the function */</comment>
	<expr_stmt><expr><name>prodesc</name> <operator>=</operator> <call><name>compile_plperl_function</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name></name> <operator>=</operator> <name>prodesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>increment_prodesc_refcount</name><argument_list>(<argument><expr><name>prodesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set a callback for error reporting */</comment>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plperl_exec_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pl_error_context</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>proname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>pl_error_context</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>svTD</name> <operator>=</operator> <call><name>plperl_event_trigger_build_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>plperl_call_perl_event_trigger_func</name><argument_list>(<argument><expr><name>prodesc</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>svTD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Restore the previous error callback */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>pl_error_context</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SvREFCNT_dec_current</name><argument_list>(<argument><expr><name>svTD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>validate_plperl_function</name><parameter_list>(<parameter><decl><type><name>plperl_proc_ptr</name> <modifier>*</modifier></type><name>proc_ptr</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>procTup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>proc_ptr</name> <operator>&amp;&amp;</operator> <name><name>proc_ptr</name><operator>-&gt;</operator><name>proc_ptr</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name> <init>= <expr><name><name>proc_ptr</name><operator>-&gt;</operator><name>proc_ptr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>uptodate</name></decl>;</decl_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * If it's present, must check whether it's still up to date.
		 * This is needed because CREATE OR REPLACE FUNCTION can modify the
		 * function's pg_proc entry without changing its OID.
		 ************************************************************/</comment>
		<expr_stmt><expr><name>uptodate</name> <operator>=</operator> <operator>(</operator><name><name>prodesc</name><operator>-&gt;</operator><name>fn_xmin</name></name> <operator>==</operator> <call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>procTup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prodesc</name><operator>-&gt;</operator><name>fn_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>procTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>uptodate</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Otherwise, unlink the obsoleted entry from the hashtable ... */</comment>
		<expr_stmt><expr><name><name>proc_ptr</name><operator>-&gt;</operator><name>proc_ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<comment type="block">/* ... and release the corresponding refcount, probably deleting it */</comment>
		<expr_stmt><expr><call><name>decrement_prodesc_refcount</name><argument_list>(<argument><expr><name>prodesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_plperl_function</name><parameter_list>(<parameter><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Release CODE reference, if we have one, from the appropriate interp */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>reference</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>plperl_interp_desc</name> <modifier>*</modifier></type><name>oldinterp</name> <init>= <expr><name>plperl_active_interp</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SvREFCNT_dec_current</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>reference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name>oldinterp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Release all PG-owned data for this proc */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>plperl_proc_desc</name> <modifier>*</modifier></type>
<name>compile_plperl_function</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>fn_oid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_trigger</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_event_trigger</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_proc_key</name></type> <name>proc_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_proc_ptr</name> <modifier>*</modifier></type><name>proc_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>prodesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>MemoryContext</name></type> <name>proc_cxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_interp_desc</name> <modifier>*</modifier></type><name>oldinterp</name> <init>= <expr><name>plperl_active_interp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>plperl_error_context</name></decl>;</decl_stmt>

	<comment type="block">/* We'll need the pg_proc tuple in any case... */</comment>
	<expr_stmt><expr><name>procTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>fn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>fn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to find function in plperl_proc_hash.  The reason for this
	 * overcomplicated-seeming lookup procedure is that we don't know whether
	 * it's plperl or plperlu, and don't want to spend a lookup in pg_language
	 * to find out.
	 */</comment>
	<expr_stmt><expr><name><name>proc_key</name><operator>.</operator><name>proc_id</name></name> <operator>=</operator> <name>fn_oid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc_key</name><operator>.</operator><name>is_trigger</name></name> <operator>=</operator> <name>is_trigger</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc_key</name><operator>.</operator><name>user_id</name></name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc_ptr</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>plperl_proc_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc_key</name></expr></argument>,
						   <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>validate_plperl_function</name><argument_list>(<argument><expr><name>proc_ptr</name></expr></argument>, <argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Found valid plperl entry */</comment>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>proc_ptr</name><operator>-&gt;</operator><name>proc_ptr</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If not found or obsolete, maybe it's plperlu */</comment>
	<expr_stmt><expr><name><name>proc_key</name><operator>.</operator><name>user_id</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc_ptr</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>plperl_proc_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc_key</name></expr></argument>,
						   <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>validate_plperl_function</name><argument_list>(<argument><expr><name>proc_ptr</name></expr></argument>, <argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Found valid plperlu entry */</comment>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>proc_ptr</name><operator>-&gt;</operator><name>proc_ptr</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * If we haven't found it in the hashtable, we analyze
	 * the function's arguments and return type and store
	 * the in-/out-functions in the prodesc block,
	 * then we load the procedure into the Perl interpreter,
	 * and last we create a new hashtable entry for it.
	 ************************************************************/</comment>

	<comment type="block">/* Set a callback for reporting compilation errors */</comment>
	<expr_stmt><expr><name><name>plperl_error_context</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plperl_compile_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plperl_error_context</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plperl_error_context</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>plperl_error_context</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>langTup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_language</name></type> <name>langStruct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeStruct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>protrftypes_datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>prosrcdatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proc_source</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Allocate a context that will hold all PG data for the procedure.
		 ************************************************************/</comment>
		<expr_stmt><expr><name>proc_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										 <argument><expr><literal type="string">"PL/Perl function"</literal></expr></argument>,
										 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Allocate and fill a new procedure description block.
		 * struct prodesc and subsidiary data must all live in proc_cxt.
		 ************************************************************/</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>proc_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prodesc</name> <operator>=</operator> <operator>(</operator><name>plperl_proc_desc</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>plperl_proc_desc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>proname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSetIdentifier</name><argument_list>(<argument><expr><name>proc_cxt</name></expr></argument>, <argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_cxt</name></name> <operator>=</operator> <name>proc_cxt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_refcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_xmin</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>procTup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_tid</name></name> <operator>=</operator> <name><name>procTup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name><name>procStruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_out_func</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_is_rowtype</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_arraytype</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Remember if function is STABLE/IMMUTABLE */</comment>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_readonly</name></name> <operator>=</operator>
			<operator>(</operator><name><name>procStruct</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Fetch protrftypes */</comment>
		<expr_stmt><expr><name>protrftypes_datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTup</name></expr></argument>,
											<argument><expr><name>Anum_pg_proc_protrftypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>proc_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>trftypes</name></name> <operator>=</operator> <ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><call><name>oid_array_to_list</name><argument_list>(<argument><expr><name>protrftypes_datum</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Lookup the pg_language tuple by Oid
		 ************************************************************/</comment>
		<expr_stmt><expr><name>langTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>LANGOID</name></expr></argument>,
								  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>prolang</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>langTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for language %u"</literal></expr></argument>,
				 <argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>prolang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>langStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_language</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>langTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>lang_oid</name></name> <operator>=</operator> <name><name>langStruct</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>lanpltrusted</name></name> <operator>=</operator> <name><name>langStruct</name><operator>-&gt;</operator><name>lanpltrusted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>langTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Get the required information for input conversion of the
		 * return value.
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_trigger</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_event_trigger</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name> <init>= <expr><name><name>procStruct</name><operator>-&gt;</operator><name>prorettype</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>typeTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>typeStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Disallow pseudotype result, except VOID or RECORD */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>VOIDOID</name> <operator>||</operator>
					<name>rettype</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
					 <comment type="block">/* okay */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>rettype</name> <operator>==</operator> <name>TRIGGEROID</name> <operator>||</operator>
						 <name>rettype</name> <operator>==</operator> <name>EVTTRIGGEROID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger functions can only be called "</literal>
									<literal type="string">"as triggers"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PL/Perl functions cannot return type %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_oid</name></name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retisset</name></name> <operator>=</operator> <name><name>procStruct</name><operator>-&gt;</operator><name>proretset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retistuple</name></name> <operator>=</operator> <call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retisarray</name></name> <operator>=</operator>
				<operator>(</operator><name><name>typeStruct</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typelem</name></name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typinput</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prodesc</name><operator>-&gt;</operator><name>result_in_func</name></name><operator>)</operator></expr></argument>,
						  <argument><expr><name>proc_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_typioparam</name></name> <operator>=</operator> <call><name>getTypeIOParam</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Get the required information for output conversion
		 * of all procedure arguments
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_trigger</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_event_trigger</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name> <init>= <expr><name><name>procStruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>typeTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>typeStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Disallow pseudotype argument, except RECORD */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name> <operator>&amp;&amp;</operator>
					<name>argtype</name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PL/Perl functions cannot accept type %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_is_rowtype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_is_rowtype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typoutput</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prodesc</name><operator>-&gt;</operator><name>arg_out_func</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
								  <argument><expr><name>proc_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* Identify array-type arguments */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typelem</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_arraytype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>argtype</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>arg_arraytype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * create the text of the anonymous subroutine.
		 * we do not use a named subroutine so that we can call directly
		 * through the reference.
		 ************************************************************/</comment>
		<expr_stmt><expr><name>prosrcdatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTup</name></expr></argument>,
									  <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>proc_source</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>prosrcdatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Create the procedure in the appropriate interpreter
		 ************************************************************/</comment>

		<expr_stmt><expr><call><name>select_perl_context</name><argument_list>(<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>lanpltrusted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>prodesc</name><operator>-&gt;</operator><name>interp</name></name> <operator>=</operator> <name>plperl_active_interp</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>plperl_create_sub</name><argument_list>(<argument><expr><name>prodesc</name></expr></argument>, <argument><expr><name>proc_source</name></expr></argument>, <argument><expr><name>fn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name>oldinterp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>proc_source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prodesc</name><operator>-&gt;</operator><name>reference</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* can this happen? */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not create PL/Perl internal procedure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * OK, link the procedure into the correct hashtable entry.
		 * Note we assume that the hashtable entry either doesn't exist yet,
		 * or we already cleared its proc_ptr during the validation attempts
		 * above.  So no need to decrement an old refcount here.
		 ************************************************************/</comment>
		<expr_stmt><expr><name><name>proc_key</name><operator>.</operator><name>user_id</name></name> <operator>=</operator> <ternary><condition><expr><name><name>prodesc</name><operator>-&gt;</operator><name>lanpltrusted</name></name></expr> ?</condition><then> <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name>proc_ptr</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>plperl_proc_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc_key</name></expr></argument>,
							   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We assume these two steps can't throw an error: */</comment>
		<expr_stmt><expr><name><name>proc_ptr</name><operator>-&gt;</operator><name>proc_ptr</name></name> <operator>=</operator> <name>prodesc</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>increment_prodesc_refcount</name><argument_list>(<argument><expr><name>prodesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * If we got as far as creating a reference, we should be able to use
		 * free_plperl_function() to clean up.  If not, then at most we have
		 * some PG memory resources in proc_cxt, which we can just delete.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>prodesc</name> <operator>&amp;&amp;</operator> <name><name>prodesc</name><operator>-&gt;</operator><name>reference</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free_plperl_function</name><argument_list>(<argument><expr><name>prodesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>proc_cxt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>proc_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Be sure to restore the previous interpreter, too, for luck */</comment>
		<expr_stmt><expr><call><name>activate_interpreter</name><argument_list>(<argument><expr><name>oldinterp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* restore previous error callback */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>plperl_error_context</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>prodesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Build a hash from a given composite/row datum */</comment>
<function><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type>
<name>plperl_hash_from_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tupType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tupTypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>td</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract rowtype info and find a tupdesc */</comment>
	<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a temporary HeapTuple control structure */</comment>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>sv</name> <operator>=</operator> <call><name>plperl_hash_from_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Build a hash from all attributes of a given tuple. */</comment>
<function><type><specifier>static</specifier> <name>SV</name>  <modifier>*</modifier></type>
<name>plperl_hash_from_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_generated</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>hv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* since this function recurses, it could be driven to stack overflow */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hv</name> <operator>=</operator> <call><name>newHV</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hv_ksplit</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* pre-grow the hash */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>attr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>,
					<decl><type ref="prev"/><name>typisvarlena</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't include unless requested */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>include_generated</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Store (attname =&gt; undef) and move on.  Note we can't use
			 * &amp;PL_sv_undef here; see "AVs, HVs and undefined values" in
			 * perlguts for an explanation.
			 */</comment>
			<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>newSV</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sv</name> <init>= <expr><call><name>plperl_hash_from_datum</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>sv</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sv</name> <operator>=</operator> <call><name>plperl_ref_from_pg_array</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name>funcid</name> <operator>=</operator> <call><name>get_transform_fromsql</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>lang_oid</name></name></expr></argument>, <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>trftypes</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sv</name> <operator>=</operator> <operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>outputstr</name></decl>;</decl_stmt>

				<comment type="block">/* XXX should have a way to cache these lookups */</comment>
				<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>outputstr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sv</name> <operator>=</operator> <call><name>cstr2sv</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><call><name>newRV_noinc</name><argument_list>(<argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <name>hv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_spi_usage_allowed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* see comment in plperl_fini() */</comment>
	<if_stmt><if>if <condition>(<expr><name>plperl_ending</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* simple croak as we don't want to involve PostgreSQL code */</comment>
		<expr_stmt><expr><call><name>croak</name><argument_list>(<argument><expr><literal type="string">"SPI functions can not be used in END blocks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>HV</name> <modifier>*</modifier></type>
<name>plperl_spi_exec</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>ret_hv</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Execute the query inside a sub-transaction, so we can cope with errors
	 * sanely
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_spi_usage_allowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Want to run inside function's memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>spi_rv</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_verifymbstr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>spi_rv</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>fn_readonly</name></name></expr></argument>,
							 <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret_hv</name> <operator>=</operator> <call><name>plperl_spi_execute_fetch_result</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>, <argument><expr><name>SPI_processed</name></expr></argument>,
												 <argument><expr><name>spi_rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Commit the inner transaction, return to outer xact context */</comment>
		<expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Abort the inner transaction */</comment>
		<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

		<comment type="block">/* Punt the error to Perl */</comment>
		<expr_stmt><expr><call><name>croak_cstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Can't get here, but keep compiler quiet */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret_hv</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>HV</name>  <modifier>*</modifier></type>
<name>plperl_spi_execute_fetch_result</name><parameter_list>(<parameter><decl><type><name>SPITupleTable</name> <modifier>*</modifier></type><name>tuptable</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>processed</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_spi_usage_allowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>newHV</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"status"</literal></expr></argument>,
					<argument><expr><call><name>cstr2sv</name><argument_list>(<argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"processed"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><operator>(</operator><name>processed</name> <operator>&gt;</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>UV_MAX</name><operator>)</operator></expr> ?</condition><then>
					<expr><call><name>newSVnv</name><argument_list>(<argument><expr><operator>(</operator><name>NV</name><operator>)</operator> <name>processed</name></expr></argument>)</argument_list></call></expr> </then><else>:
					<expr><call><name>newSVuv</name><argument_list>(<argument><expr><operator>(</operator><name>UV</name><operator>)</operator> <name>processed</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tuptable</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AV</name>		   <modifier>*</modifier></type><name>rows</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Prevent overflow in call to av_extend() */</comment>
		<if_stmt><if>if <condition>(<expr><name>processed</name> <operator>&gt;</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>AV_SIZE_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query result has too many rows to fit in a Perl array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rows</name> <operator>=</operator> <call><name>newAV</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>av_extend</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>processed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>row</name> <operator>=</operator> <call><name>plperl_hash_from_tuple</name><argument_list>(<argument><expr><name><name>tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>av_push</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>hv_store_string</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"rows"</literal></expr></argument>,
						<argument><expr><call><name>newRV_noinc</name><argument_list>(<argument><expr><operator>(</operator><name>SV</name> <operator>*</operator><operator>)</operator> <name>rows</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * plperl_return_next catches any error and converts it to a Perl error.
 * We assume (perhaps without adequate justification) that we need not abort
 * the current transaction if the Perl code traps the error.
 */</comment>
<function><type><name>void</name></type>
<name>plperl_return_next</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>sv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>plperl_return_next_internal</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Must reset elog.c's state */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Punt the error to Perl */</comment>
		<expr_stmt><expr><call><name>croak_cstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plperl_return_next_internal reports any errors in Postgres fashion
 * (via ereport).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_return_next_internal</name><parameter_list>(<parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>sv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>plperl_proc_desc</name> <modifier>*</modifier></type><name>prodesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sv</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>prodesc</name> <operator>=</operator> <name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <name><name>current_call_data</name><operator>-&gt;</operator><name>fcinfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retisset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use return_next in a non-SETOF function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>current_call_data</name><operator>-&gt;</operator><name>ret_tdesc</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>current_call_data</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * This is the first call to return_next in the current PL/Perl
		 * function call, so identify the output tuple type and create a
		 * tuplestore to hold the result rows.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retistuple</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>funcclass</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>funcclass</name> <operator>=</operator> <call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>funcclass</name> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name> <operator>&amp;&amp;</operator>
				<name>funcclass</name> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in context "</literal>
								<literal type="string">"that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* if domain-over-composite, remember the domain's type OID */</comment>
			<if_stmt><if>if <condition>(<expr><name>funcclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>cdomain_oid</name></name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr>;</expr_stmt>
			<comment type="block">/* Protect assumption below that we return exactly one column */</comment>
			<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected single-column result descriptor for non-composite SETOF result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Make sure the tuple_store and ret_tdesc are sufficiently
		 * long-lived.
		 */</comment>
		<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>ret_tdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>=</operator>
			<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Producing the tuple we want to return requires making plenty of
	 * palloc() allocations that are not cleaned up. Since this function can
	 * be called many times before the current memory context is reset, we
	 * need to do those allocations in a temporary context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>current_call_data</name><operator>-&gt;</operator><name>tmp_cxt</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>tmp_cxt</name></name> <operator>=</operator>
			<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"PL/Perl return_next temporary cxt"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>tmp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>fn_retistuple</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>SvOK</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SvROK</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SvTYPE</name><argument_list>(<argument><expr><call><name>SvRV</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>SVt_PVHV</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SETOF-composite-returning PL/Perl function "</literal>
							<literal type="string">"must call return_next with reference to hash"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>plperl_build_tuple_result</name><argument_list>(<argument><expr><operator>(</operator><name>HV</name> <operator>*</operator><operator>)</operator> <call><name>SvRV</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>ret_tdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>cdomain_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>domain_check</name><argument_list>(<argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						 <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>cdomain_oid</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>current_call_data</name><operator>-&gt;</operator><name>cdomain_info</name></name></expr></argument>,
						 <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_oid</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>ret</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>isNull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>ret</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>plperl_sv_to_datum</name><argument_list>(<argument><expr><name>sv</name></expr></argument>,
									<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_oid</name></name></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									<argument><expr><name>fcinfo</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>prodesc</name><operator>-&gt;</operator><name>result_in_func</name></name></expr></argument>,
									<argument><expr><name><name>prodesc</name><operator>-&gt;</operator><name>result_typioparam</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>isNull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>,
							 <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>ret_tdesc</name></name></expr></argument>,
							 <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>tmp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>SV</name> <modifier>*</modifier></type>
<name>plperl_spi_query</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Execute the query inside a sub-transaction, so we can cope with errors
	 * sanely
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_spi_usage_allowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Want to run inside function's memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

		<comment type="block">/* Make sure the query is validly encoded */</comment>
		<expr_stmt><expr><call><name>pg_verifymbstr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create a cursor for the query */</comment>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare() failed:%s"</literal></expr></argument>,
				 <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPI_freeplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open() failed:%s"</literal></expr></argument>,
				 <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cursor</name> <operator>=</operator> <call><name>cstr2sv</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PinPortal</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Commit the inner transaction, return to outer xact context */</comment>
		<expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Abort the inner transaction */</comment>
		<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

		<comment type="block">/* Punt the error to Perl */</comment>
		<expr_stmt><expr><call><name>croak_cstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Can't get here, but keep compiler quiet */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cursor</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>SV</name> <modifier>*</modifier></type>
<name>plperl_spi_fetchrow</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Execute the FETCH inside a sub-transaction, so we can cope with errors
	 * sanely
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_spi_usage_allowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Want to run inside function's memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Portal</name></type>		<name>p</name> <init>= <expr><call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>row</name> <operator>=</operator> <operator>&amp;</operator><name>PL_sv_undef</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UnpinPortal</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>row</name> <operator>=</operator> <operator>&amp;</operator><name>PL_sv_undef</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>row</name> <operator>=</operator> <call><name>plperl_hash_from_tuple</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
											 <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
											 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Commit the inner transaction, return to outer xact context */</comment>
		<expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Abort the inner transaction */</comment>
		<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

		<comment type="block">/* Punt the error to Perl */</comment>
		<expr_stmt><expr><call><name>croak_cstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Can't get here, but keep compiler quiet */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>row</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>plperl_spi_cursor_close</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_spi_usage_allowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>SPI_cursor_find</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnpinPortal</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>SV</name> <modifier>*</modifier></type>
<name>plperl_spi_prepare</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>SV</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>SPIPlanPtr</name></type> <name>plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>MemoryContext</name></type> <name>plan_cxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_query_desc</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>qdesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_query_entry</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>hash_entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>work_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_spi_usage_allowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Allocate the new querydesc structure
		 *
		 * The qdesc struct, as well as all its subsidiary data, lives in its
		 * plan_cxt.  But note that the SPIPlan does not.
		 ************************************************************/</comment>
		<expr_stmt><expr><name>plan_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										 <argument><expr><literal type="string">"PL/Perl spi_prepare query"</literal></expr></argument>,
										 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plan_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>qdesc</name> <operator>=</operator> <operator>(</operator><name>plperl_query_desc</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>plperl_query_desc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>qname</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>qname</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%p"</literal></expr></argument>, <argument><expr><name>qdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>plan_cxt</name></name> <operator>=</operator> <name>plan_cxt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypes</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>argc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>arginfuncs</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>argc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypioparams</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>argc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Do the following work in a short-lived context so that we don't
		 * leak a lot of memory in the PL/Perl function's SPI Proc context.
		 ************************************************************/</comment>
		<expr_stmt><expr><name>work_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										 <argument><expr><literal type="string">"PL/Perl spi_prepare workspace"</literal></expr></argument>,
										 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>work_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Resolve argument type names and then look them up by oid
		 * in the system cache, and remember the required information
		 * for input conversion.
		 ************************************************************/</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typId</name></decl>,
						<decl><type ref="prev"/><name>typInput</name></decl>,
						<decl><type ref="prev"/><name>typIOParam</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typstr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>typstr</name> <operator>=</operator> <call><name>sv2cstr</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>parseTypeString</name><argument_list>(<argument><expr><name>typstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>typstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>typId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIOParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>typId</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>typInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>qdesc</name><operator>-&gt;</operator><name>arginfuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>plan_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypioparams</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>typIOParam</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Make sure the query is validly encoded */</comment>
		<expr_stmt><expr><call><name>pg_verifymbstr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Prepare the plan and check for errors
		 ************************************************************/</comment>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare() failed:%s"</literal></expr></argument>,
				 <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Save the plan into permanent memory (right now it's in the
		 * SPI procCxt, which will go away at function end).
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SPI_keepplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_keepplan() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>qdesc</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Insert a hashtable entry for the plan.
		 ************************************************************/</comment>
		<expr_stmt><expr><name>hash_entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>plperl_active_interp</name><operator>-&gt;</operator><name>query_hash</name></name></expr></argument>,
								 <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>qname</name></name></expr></argument>,
								 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_entry</name><operator>-&gt;</operator><name>query_data</name></name> <operator>=</operator> <name>qdesc</name></expr>;</expr_stmt>

		<comment type="block">/* Get rid of workspace */</comment>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>work_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Commit the inner transaction, return to outer xact context */</comment>
		<expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Drop anything we managed to allocate */</comment>
		<if_stmt><if>if <condition>(<expr><name>hash_entry</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>plperl_active_interp</name><operator>-&gt;</operator><name>query_hash</name></name></expr></argument>,
						<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>qname</name></name></expr></argument>,
						<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>plan_cxt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>plan_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>plan</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SPI_freeplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Abort the inner transaction */</comment>
		<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

		<comment type="block">/* Punt the error to Perl */</comment>
		<expr_stmt><expr><call><name>croak_cstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Can't get here, but keep compiler quiet */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/************************************************************
	 * Return the query's hash key to the caller.
	 ************************************************************/</comment>
	<return>return <expr><call><name>cstr2sv</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>qname</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>HV</name> <modifier>*</modifier></type>
<name>plperl_spi_exec_prepared</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>HV</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>SV</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HV</name>		   <modifier>*</modifier></type><name>ret_hv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>sv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>limit</name></decl>,
				<decl><type ref="prev"/><name>spi_rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_query_desc</name> <modifier>*</modifier></type><name>qdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_query_entry</name> <modifier>*</modifier></type><name>hash_entry</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Execute the query inside a sub-transaction, so we can cope with errors
	 * sanely
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_spi_usage_allowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Want to run inside function's memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Fetch the saved plan descriptor, see if it's o.k.
		 ************************************************************/</comment>
		<expr_stmt><expr><name>hash_entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>plperl_active_interp</name><operator>-&gt;</operator><name>query_hash</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
								 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hash_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"spi_exec_prepared: Invalid prepared query passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>qdesc</name> <operator>=</operator> <name><name>hash_entry</name><operator>-&gt;</operator><name>query_data</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>qdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"spi_exec_prepared: plperl query_hash value vanished"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>qdesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>!=</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"spi_exec_prepared: expected %d argument(s), %d passed"</literal></expr></argument>,
				 <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Parse eventual attributes
		 ************************************************************/</comment>
		<expr_stmt><expr><name>limit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sv</name> <operator>=</operator> <call><name>hv_fetch_string</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><literal type="string">"limit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sv</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>sv</name> <operator>&amp;&amp;</operator> <call><name>SvIOK</name><argument_list>(<argument><expr><operator>*</operator><name>sv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>limit</name> <operator>=</operator> <call><name>SvIV</name><argument_list>(<argument><expr><operator>*</operator><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block" format="doxygen">/************************************************************
		 * Set up arguments
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>argvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>argc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>nulls</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>argvalues</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>argvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>plperl_sv_to_datum</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>qdesc</name><operator>-&gt;</operator><name>arginfuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypioparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><literal type="char">'n'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block" format="doxygen">/************************************************************
		 * go
		 ************************************************************/</comment>
		<expr_stmt><expr><name>spi_rv</name> <operator>=</operator> <call><name>SPI_execute_plan</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>argvalues</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
								  <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>fn_readonly</name></name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret_hv</name> <operator>=</operator> <call><name>plperl_spi_execute_fetch_result</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>, <argument><expr><name>SPI_processed</name></expr></argument>,
												 <argument><expr><name>spi_rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>argvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Commit the inner transaction, return to outer xact context */</comment>
		<expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Abort the inner transaction */</comment>
		<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

		<comment type="block">/* Punt the error to Perl */</comment>
		<expr_stmt><expr><call><name>croak_cstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Can't get here, but keep compiler quiet */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret_hv</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SV</name> <modifier>*</modifier></type>
<name>plperl_spi_query_prepared</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>SV</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>argvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_query_desc</name> <modifier>*</modifier></type><name>qdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_query_entry</name> <modifier>*</modifier></type><name>hash_entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		   <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Execute the query inside a sub-transaction, so we can cope with errors
	 * sanely
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_spi_usage_allowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Want to run inside function's memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block" format="doxygen">/************************************************************
		 * Fetch the saved plan descriptor, see if it's o.k.
		 ************************************************************/</comment>
		<expr_stmt><expr><name>hash_entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>plperl_active_interp</name><operator>-&gt;</operator><name>query_hash</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
								 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hash_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"spi_query_prepared: Invalid prepared query passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>qdesc</name> <operator>=</operator> <name><name>hash_entry</name><operator>-&gt;</operator><name>query_data</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>qdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"spi_query_prepared: plperl query_hash value vanished"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>qdesc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>!=</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"spi_query_prepared: expected %d argument(s), %d passed"</literal></expr></argument>,
				 <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block" format="doxygen">/************************************************************
		 * Set up arguments
		 ************************************************************/</comment>
		<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>argvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>argc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>nulls</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>argvalues</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>argvalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>plperl_sv_to_datum</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>qdesc</name><operator>-&gt;</operator><name>arginfuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>argtypioparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><literal type="char">'n'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block" format="doxygen">/************************************************************
		 * go
		 ************************************************************/</comment>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>argvalues</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
								 <argument><expr><name><name>current_call_data</name><operator>-&gt;</operator><name>prodesc</name><operator>-&gt;</operator><name>fn_readonly</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>argvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>portal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open() failed:%s"</literal></expr></argument>,
				 <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cursor</name> <operator>=</operator> <call><name>cstr2sv</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PinPortal</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Commit the inner transaction, return to outer xact context */</comment>
		<expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Abort the inner transaction */</comment>
		<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

		<comment type="block">/* Punt the error to Perl */</comment>
		<expr_stmt><expr><call><name>croak_cstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Can't get here, but keep compiler quiet */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cursor</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>plperl_spi_freeplan</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_query_desc</name> <modifier>*</modifier></type><name>qdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plperl_query_entry</name> <modifier>*</modifier></type><name>hash_entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_spi_usage_allowed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hash_entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>plperl_active_interp</name><operator>-&gt;</operator><name>query_hash</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
							 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hash_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"spi_freeplan: Invalid prepared query passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>qdesc</name> <operator>=</operator> <name><name>hash_entry</name><operator>-&gt;</operator><name>query_data</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>qdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"spi_freeplan: plperl query_hash value vanished"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>qdesc</name><operator>-&gt;</operator><name>plan</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * free all memory before SPI_freeplan, so if it dies, nothing will be
	 * left over
	 */</comment>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>plperl_active_interp</name><operator>-&gt;</operator><name>query_hash</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
				<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>qdesc</name><operator>-&gt;</operator><name>plan_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_freeplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>plperl_spi_commit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SPI_commit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPI_start_transaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Punt the error to Perl */</comment>
		<expr_stmt><expr><call><name>croak_cstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>plperl_spi_rollback</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SPI_rollback</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPI_start_transaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Save error info */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Punt the error to Perl */</comment>
		<expr_stmt><expr><call><name>croak_cstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Implementation of plperl's elog() function
 *
 * If the error level is less than ERROR, we'll just emit the message and
 * return.  When it is ERROR, elog() will longjmp, which we catch and
 * turn into a Perl croak().  Note we are assuming that elog() can't have
 * any internal failures that are so bad as to require a transaction abort.
 *
 * The main reason this is out-of-line is to avoid conflicts between XSUB.h
 * and the PG_TRY macros.
 */</comment>
<function><type><name>void</name></type>
<name>plperl_util_elog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier><specifier>volatile</specifier></type> <name>cmsg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>cmsg</name> <operator>=</operator> <call><name>sv2cstr</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>cmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

		<comment type="block">/* Must reset elog.c's state */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmsg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Punt the error to Perl */</comment>
		<expr_stmt><expr><call><name>croak_cstr</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Store an SV into a hash table under a key that is a string assumed to be
 * in the current database's encoding.
 */</comment>
<function><type><specifier>static</specifier> <name>SV</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>hv_store_string</name><parameter_list>(<parameter><decl><type><name>HV</name> <modifier>*</modifier></type><name>hv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>SV</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>hlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hkey</name> <operator>=</operator> <call><name>pg_server_to_any</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PG_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * hv_store() recognizes a negative klen parameter as meaning a UTF-8
	 * encoded key.
	 */</comment>
	<expr_stmt><expr><name>hlen</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>hkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hv_store</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><name>hkey</name></expr></argument>, <argument><expr><name>hlen</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hkey</name> <operator>!=</operator> <name>key</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch an SV from a hash table under a key that is a string assumed to be
 * in the current database's encoding.
 */</comment>
<function><type><specifier>static</specifier> <name>SV</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>hv_fetch_string</name><parameter_list>(<parameter><decl><type><name>HV</name> <modifier>*</modifier></type><name>hv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>hlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SV</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hkey</name> <operator>=</operator> <call><name>pg_server_to_any</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PG_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* See notes in hv_store_string */</comment>
	<expr_stmt><expr><name>hlen</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>hkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>hv_fetch</name><argument_list>(<argument><expr><name>hv</name></expr></argument>, <argument><expr><name>hkey</name></expr></argument>, <argument><expr><name>hlen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hkey</name> <operator>!=</operator> <name>key</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Provide function name for PL/Perl execution errors
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_exec_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>procname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>procname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"PL/Perl function \"%s\""</literal></expr></argument>, <argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Provide function name for PL/Perl compilation errors
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_compile_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>procname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>procname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"compilation of PL/Perl function \"%s\""</literal></expr></argument>, <argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Provide error context for the inline handler
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plperl_inline_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"PL/Perl anonymous code block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Perl's own setlocale(), copied from POSIX.xs
 * (needed because of the calls to new_*())
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>setlocale_perl</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>category</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dTHX</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>RETVAL</name> <init>= <expr><call><name>setlocale</name><argument_list>(<argument><expr><name>category</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>RETVAL</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LOCALE_CTYPE</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>category</name> <operator>==</operator> <name>LC_CTYPE</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LC_ALL</name></cpp:ifdef>
			<operator>||</operator> <name>category</name> <operator>==</operator> <name>LC_ALL</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newctype</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LC_ALL</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>category</name> <operator>==</operator> <name>LC_ALL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newctype</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>newctype</name> <operator>=</operator> <name>RETVAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>new_ctype</name><argument_list>(<argument><expr><name>newctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LOCALE_CTYPE */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LOCALE_COLLATE</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>category</name> <operator>==</operator> <name>LC_COLLATE</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LC_ALL</name></cpp:ifdef>
			<operator>||</operator> <name>category</name> <operator>==</operator> <name>LC_ALL</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newcoll</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LC_ALL</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>category</name> <operator>==</operator> <name>LC_ALL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newcoll</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_COLLATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>newcoll</name> <operator>=</operator> <name>RETVAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>new_collate</name><argument_list>(<argument><expr><name>newcoll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LOCALE_COLLATE */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LOCALE_NUMERIC</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>category</name> <operator>==</operator> <name>LC_NUMERIC</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LC_ALL</name></cpp:ifdef>
			<operator>||</operator> <name>category</name> <operator>==</operator> <name>LC_ALL</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newnum</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LC_ALL</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>category</name> <operator>==</operator> <name>LC_ALL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newnum</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_NUMERIC</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>newnum</name> <operator>=</operator> <name>RETVAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>new_numeric</name><argument_list>(<argument><expr><name>newnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LOCALE_NUMERIC */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>RETVAL</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
</unit>
