<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/port/snprintf.c"><comment type="block">/*
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *	  notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *	  notice, this list of conditions and the following disclaimer in the
 *	  documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *	  may be used to endorse or promote products derived from this software
 *	  without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * src/port/snprintf.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
 * We used to use the platform's NL_ARGMAX here, but that's a bad idea,
 * first because the point of this module is to remove platform dependencies
 * not perpetuate them, and second because some platforms use ridiculously
 * large values, leading to excessive stack consumption in dopr().
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_NL_ARGMAX</name></cpp:macro> <cpp:value>31</cpp:value></cpp:define>


<comment type="block">/*
 *	SNPRINTF, VSNPRINTF and friends
 *
 * These versions have been grabbed off the net.  They have been
 * cleaned up to compile properly and support for most of the C99
 * specification has been added.  Remaining unimplemented features are:
 *
 * 1. No locale support: the radix character is always '.' and the '
 * (single quote) format flag is ignored.
 *
 * 2. No support for the "%n" format specification.
 *
 * 3. No support for wide characters ("lc" and "ls" formats).
 *
 * 4. No support for "long double" ("Lf" and related formats).
 *
 * 5. Space and '#' flags are not implemented.
 *
 * In addition, we support some extensions over C99:
 *
 * 1. Argument order control through "%n$" and "*n$", as required by POSIX.
 *
 * 2. "%m" expands to the value of strerror(errno), where errno is the
 * value that variable had at the start of the call.  This is a glibc
 * extension, but a very useful one.
 *
 *
 * Historically the result values of sprintf/snprintf varied across platforms.
 * This implementation now follows the C99 standard:
 *
 * 1. -1 is returned if an error is detected in the format string, or if
 * a write to the target stream fails (as reported by fwrite).  Note that
 * overrunning snprintf's target buffer is *not* an error.
 *
 * 2. For successful writes to streams, the actual number of bytes written
 * to the stream is returned.
 *
 * 3. For successful sprintf/snprintf, the number of bytes that would have
 * been written to an infinite-size buffer (excluding the trailing '\0')
 * is returned.  snprintf will truncate its output to fit in the buffer
 * (ensuring a trailing '\0' unless count == 0), but this is not reflected
 * in the function result.
 *
 * snprintf buffer overrun can be detected by checking for function result
 * greater than or equal to the supplied count.
 */</comment>

<comment type="block" format="doxygen">/**************************************************************
 * Original:
 * Patrick Powell Tue Apr 11 09:48:21 PDT 1995
 * A bombproof version of doprnt (dopr) included.
 * Sigh.  This sort of thing is always nasty do deal with.  Note that
 * the version here does not include floating point. (now it does ... tgl)
 **************************************************************/</comment>

<comment type="block">/* Prevent recursion */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive>	<name>vsnprintf</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>	<name>snprintf</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>	<name>vsprintf</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>	<name>sprintf</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>	<name>vfprintf</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>	<name>fprintf</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>	<name>vprintf</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>	<name>printf</name></cpp:undef>

<comment type="block">/*
 * Info about where the formatted output is going.
 *
 * dopr and subroutines will not write at/past bufend, but snprintf
 * reserves one byte, ensuring it may place the trailing '\0' there.
 *
 * In snprintf, we use nchars to count the number of bytes dropped on the
 * floor due to buffer overrun.  The correct result of snprintf is thus
 * (bufptr - bufstart) + nchars.  (This isn't as inconsistent as it might
 * seem: nchars is the number of emitted bytes that are not in the buffer now,
 * either because we sent them to the stream or because we couldn't fit them
 * into the buffer to begin with.)
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufptr</name></decl>;</decl_stmt>			<comment type="block">/* next buffer output position */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufstart</name></decl>;</decl_stmt>		<comment type="block">/* first buffer element */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufend</name></decl>;</decl_stmt>			<comment type="block">/* last+1 buffer element, or NULL */</comment>
	<comment type="block">/* bufend == NULL is for sprintf, where we assume buf is big enough */</comment>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>stream</name></decl>;</decl_stmt>			<comment type="block">/* eventual output destination, or NULL */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nchars</name></decl>;</decl_stmt>			<comment type="block">/* # chars sent to stream, or dropped */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>failed</name></decl>;</decl_stmt>			<comment type="block">/* call is a failure; errno is set */</comment>
}</block></struct></type> <name>PrintfTarget</name>;</typedef>

<comment type="block">/*
 * Info about the type and value of a formatting parameter.  Note that we
 * don't currently support "long double", "wint_t", or "wchar_t *" data,
 * nor the '%n' formatting code; else we'd need more types.  Also, at this
 * level we need not worry about signed vs unsigned values.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>ATYPE_NONE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>ATYPE_INT</name></decl>,
	<decl><name>ATYPE_LONG</name></decl>,
	<decl><name>ATYPE_LONGLONG</name></decl>,
	<decl><name>ATYPE_DOUBLE</name></decl>,
	<decl><name>ATYPE_CHARPTR</name></decl>
}</block></enum></type> <name>PrintfArgType</name>;</typedef>

<typedef>typedef <type><union>union
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name> <name>long</name></type>	<name>ll</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cptr</name></decl>;</decl_stmt>
}</block></union></type> <name>PrintfArgValue</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flushbuffer</name><parameter_list>(<parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dopr</name><parameter_list>(<parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Externally visible entry points.
 *
 * All of these are just wrappers around dopr().  Note it's essential that
 * they not change the value of "errno" before reaching dopr().
 */</comment>

<function><type><name>int</name></type>
<name>pg_vsnprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PrintfTarget</name></type> <name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>onebyte</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * C99 allows the case str == NULL when count == 0.  Rather than
	 * special-casing this situation further down, we substitute a one-byte
	 * local buffer.  Callers cannot tell, since the function result doesn't
	 * depend on count.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <name>onebyte</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>bufstart</name></name> <operator>=</operator> <name><name>target</name><operator>.</operator><name>bufptr</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>bufend</name></name> <operator>=</operator> <name>str</name> <operator>+</operator> <name>count</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>stream</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>nchars</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>failed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dopr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>target</name><operator>.</operator><name>bufptr</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><name><name>target</name><operator>.</operator><name>failed</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name><name>target</name><operator>.</operator><name>bufptr</name></name> <operator>-</operator> <name><name>target</name><operator>.</operator><name>bufstart</name></name>
								 <operator>+</operator> <name><name>target</name><operator>.</operator><name>nchars</name></name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pg_snprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_vsnprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pg_vsprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PrintfTarget</name></type> <name>target</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>bufstart</name></name> <operator>=</operator> <name><name>target</name><operator>.</operator><name>bufptr</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>bufend</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>stream</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>nchars</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* not really used in this case */</comment>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>failed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dopr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>target</name><operator>.</operator><name>bufptr</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><name><name>target</name><operator>.</operator><name>failed</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name><name>target</name><operator>.</operator><name>bufptr</name></name> <operator>-</operator> <name><name>target</name><operator>.</operator><name>bufstart</name></name>
								 <operator>+</operator> <name><name>target</name><operator>.</operator><name>nchars</name></name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pg_sprintf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_vsprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pg_vfprintf</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PrintfTarget</name></type> <name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* size is arbitrary */</comment>

	<if_stmt><if>if <condition>(<expr><name>stream</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>bufstart</name></name> <operator>=</operator> <name><name>target</name><operator>.</operator><name>bufptr</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>bufend</name></name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>	<comment type="block">/* use the whole buffer */</comment>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>stream</name></name> <operator>=</operator> <name>stream</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>nchars</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>failed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dopr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* dump any remaining buffer contents */</comment>
	<expr_stmt><expr><call><name>flushbuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><name><name>target</name><operator>.</operator><name>failed</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name><name>target</name><operator>.</operator><name>nchars</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pg_fprintf</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_vfprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pg_vprintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_vfprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pg_printf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_vfprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to write the entire buffer to target-&gt;stream; discard the entire
 * buffer in any case.  Call this only when target-&gt;stream is defined.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flushbuffer</name><parameter_list>(<parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nc</name> <init>= <expr><name><name>target</name><operator>-&gt;</operator><name>bufptr</name></name> <operator>-</operator> <name><name>target</name><operator>-&gt;</operator><name>bufstart</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't write anything if we already failed; this is to ensure we
	 * preserve the original failure's errno.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>target</name><operator>-&gt;</operator><name>failed</name></name> <operator>&amp;&amp;</operator> <name>nc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>written</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>bufstart</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nc</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>nchars</name></name> <operator>+=</operator> <name>written</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <name>nc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>failed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>bufptr</name></name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>bufstart</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>find_arguments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>,
						   <parameter><decl><type><name>PrintfArgValue</name> <modifier>*</modifier></type><name>argvalues</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fmtstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leftjust</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxwidth</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>pointflag</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fmtptr</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fmtint</name><parameter_list>(<parameter><decl><type><name>long</name> <name>long</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forcesign</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>leftjust</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>zpad</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>precision</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointflag</name></decl></parameter>,
				   <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fmtchar</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leftjust</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fmtfloat</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forcesign</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>leftjust</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>zpad</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>precision</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointflag</name></decl></parameter>,
					 <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dostr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slen</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dopr_outch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dopr_outchmulti</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slen</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>adjust_sign</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>is_negative</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forcesign</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>signvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>compute_padlen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vallen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leftjust</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>leading_pad</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>zpad</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>signvalue</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>padlen</name></decl></parameter>,
						<parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>trailing_pad</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>padlen</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * If strchrnul exists (it's a glibc-ism), it's a good bit faster than the
 * equivalent manual loop.  If it doesn't exist, provide a replacement.
 *
 * Note: glibc declares this as returning "char *", but that would require
 * casting away const internally, so we don't follow that detail.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_STRCHRNUL</name></cpp:ifndef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>strchrnul</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/*
 * glibc's &lt;string.h&gt; declares strchrnul only if _GNU_SOURCE is defined.
 * While we typically use that on glibc platforms, configure will set
 * HAVE_STRCHRNUL whether it's used or not.  Fill in the missing declaration
 * so that this file will compile cleanly with or without _GNU_SOURCE.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_GNU_SOURCE</name></cpp:ifndef>
<function_decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>strchrnul</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_STRCHRNUL */</comment>


<comment type="block">/*
 * dopr(): the guts of *printf for all cases.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dopr</name><parameter_list>(<parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>first_pct</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_dollar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_star</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>afterstar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>accum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>longlongflag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>longflag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pointflag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftjust</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fieldwidth</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>precision</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>zpad</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>forcesign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fmtpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name> <name>long</name></type>	<name>numvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>fvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>strvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PrintfArgValue</name></type> <name><name>argvalues</name><index>[<expr><name>PG_NL_ARGMAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initially, we suppose the format string does not use %n$.  The first
	 * time we come to a conversion spec that has that, we'll call
	 * find_arguments() to check for consistent use of %n$ and fill the
	 * argvalues array with the argument values in the correct order.
	 */</comment>
	<expr_stmt><expr><name>have_dollar</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>format</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Locate next conversion specifier */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>format</name> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Scan to next '%' or end of string */</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next_pct</name> <init>= <expr><call><name>strchrnul</name><argument_list>(<argument><expr><name>format</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Dump literal data we just scanned over */</comment>
			<expr_stmt><expr><call><name>dostr</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>next_pct</name> <operator>-</operator> <name>format</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>failed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>next_pct</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>format</name> <operator>=</operator> <name>next_pct</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Remember start of first conversion spec; if we find %n$, then it's
		 * sufficient for find_arguments() to start here, without rescanning
		 * earlier literal text.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>first_pct</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>first_pct</name> <operator>=</operator> <name>format</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Process conversion spec starting at *format */</comment>
		<expr_stmt><expr><name>format</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Fast path for conversion spec that is exactly %s */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>format</name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>format</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>strvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>strvalue</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dostr</name><argument_list>(<argument><expr><name>strvalue</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>strvalue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>failed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>fieldwidth</name> <operator>=</operator> <name>precision</name> <operator>=</operator> <name>zpad</name> <operator>=</operator> <name>leftjust</name> <operator>=</operator> <name>forcesign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>longflag</name> <operator>=</operator> <name>longlongflag</name> <operator>=</operator> <name>pointflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmtpos</name> <operator>=</operator> <name>accum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>have_star</name> <operator>=</operator> <name>afterstar</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<label><name>nextch2</name>:</label>
		<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>format</name><operator>++</operator></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>ch</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'-'</literal></expr>:</case>
				<expr_stmt><expr><name>leftjust</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<goto>goto <name>nextch2</name>;</goto>
			<case>case <expr><literal type="char">'+'</literal></expr>:</case>
				<expr_stmt><expr><name>forcesign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<goto>goto <name>nextch2</name>;</goto>
			<case>case <expr><literal type="char">'0'</literal></expr>:</case>
				<comment type="block">/* set zero padding if no nonzero digits yet */</comment>
				<if_stmt><if>if <condition>(<expr><name>accum</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>pointflag</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>zpad</name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* FALL THRU */</comment>
			<case>case <expr><literal type="char">'1'</literal></expr>:</case>
			<case>case <expr><literal type="char">'2'</literal></expr>:</case>
			<case>case <expr><literal type="char">'3'</literal></expr>:</case>
			<case>case <expr><literal type="char">'4'</literal></expr>:</case>
			<case>case <expr><literal type="char">'5'</literal></expr>:</case>
			<case>case <expr><literal type="char">'6'</literal></expr>:</case>
			<case>case <expr><literal type="char">'7'</literal></expr>:</case>
			<case>case <expr><literal type="char">'8'</literal></expr>:</case>
			<case>case <expr><literal type="char">'9'</literal></expr>:</case>
				<expr_stmt><expr><name>accum</name> <operator>=</operator> <name>accum</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name>ch</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
				<goto>goto <name>nextch2</name>;</goto>
			<case>case <expr><literal type="char">'.'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>have_star</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>have_star</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>fieldwidth</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>pointflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>accum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<goto>goto <name>nextch2</name>;</goto>
			<case>case <expr><literal type="char">'*'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>have_dollar</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We'll process value after reading n$.  Note it's OK to
					 * assume have_dollar is set correctly, because in a valid
					 * format string the initial % must have had n$ if * does.
					 */</comment>
					<expr_stmt><expr><name>afterstar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* fetch and process value now */</comment>
					<decl_stmt><decl><type><name>int</name></type>			<name>starval</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>pointflag</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>starval</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>precision</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
							<expr_stmt><expr><name>pointflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>fieldwidth</name> <operator>=</operator> <name>starval</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>fieldwidth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>leftjust</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
							<expr_stmt><expr><name>fieldwidth</name> <operator>=</operator> <operator>-</operator><name>fieldwidth</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>have_star</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>accum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<goto>goto <name>nextch2</name>;</goto>
			<case>case <expr><literal type="char">'$'</literal></expr>:</case>
				<comment type="block">/* First dollar sign? */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_dollar</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Yup, so examine all conversion specs in format */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>find_arguments</name><argument_list>(<argument><expr><name>first_pct</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>argvalues</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>have_dollar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>afterstar</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* fetch and process star value */</comment>
					<decl_stmt><decl><type><name>int</name></type>			<name>starval</name> <init>= <expr><name><name>argvalues</name><index>[<expr><name>accum</name></expr>]</index></name><operator>.</operator><name>i</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>pointflag</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>starval</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>precision</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
							<expr_stmt><expr><name>pointflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>fieldwidth</name> <operator>=</operator> <name>starval</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>fieldwidth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>leftjust</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
							<expr_stmt><expr><name>fieldwidth</name> <operator>=</operator> <operator>-</operator><name>fieldwidth</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><name>afterstar</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>fmtpos</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>accum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<goto>goto <name>nextch2</name>;</goto>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>longflag</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>longlongflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>longflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<goto>goto <name>nextch2</name>;</goto>
			<case>case <expr><literal type="char">'z'</literal></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_INT_64</name></cpp:ifdef>
				<expr_stmt><expr><name>longflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG_INT_64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
				<expr_stmt><expr><name>longlongflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Don't know how to print 64bit integers"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<comment type="block">/* assume size_t is same size as int */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<goto>goto <name>nextch2</name>;</goto>
			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
			<case>case <expr><literal type="char">'\''</literal></expr>:</case>
				<comment type="block">/* ignore these */</comment>
				<goto>goto <name>nextch2</name>;</goto>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
			<case>case <expr><literal type="char">'i'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_star</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>pointflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>fieldwidth</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>have_dollar</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>longlongflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <name><name>argvalues</name><index>[<expr><name>fmtpos</name></expr>]</index></name><operator>.</operator><name>ll</name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>longflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <name><name>argvalues</name><index>[<expr><name>fmtpos</name></expr>]</index></name><operator>.</operator><name>l</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <name><name>argvalues</name><index>[<expr><name>fmtpos</name></expr>]</index></name><operator>.</operator><name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>longlongflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <macro><name>va_arg</name><argument_list>(<argument>args</argument>, <argument>long long</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>longflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>fmtint</name><argument_list>(<argument><expr><name>numvalue</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>forcesign</name></expr></argument>, <argument><expr><name>leftjust</name></expr></argument>, <argument><expr><name>fieldwidth</name></expr></argument>, <argument><expr><name>zpad</name></expr></argument>,
					   <argument><expr><name>precision</name></expr></argument>, <argument><expr><name>pointflag</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'o'</literal></expr>:</case>
			<case>case <expr><literal type="char">'u'</literal></expr>:</case>
			<case>case <expr><literal type="char">'x'</literal></expr>:</case>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_star</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>pointflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>fieldwidth</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>have_dollar</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>longlongflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <name><name>argvalues</name><index>[<expr><name>fmtpos</name></expr>]</index></name><operator>.</operator><name>ll</name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>longflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>argvalues</name><index>[<expr><name>fmtpos</name></expr>]</index></name><operator>.</operator><name>l</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>argvalues</name><index>[<expr><name>fmtpos</name></expr>]</index></name><operator>.</operator><name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>longlongflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <macro><name>va_arg</name><argument_list>(<argument>args</argument>, <argument>long long</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>longflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>numvalue</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>fmtint</name><argument_list>(<argument><expr><name>numvalue</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>forcesign</name></expr></argument>, <argument><expr><name>leftjust</name></expr></argument>, <argument><expr><name>fieldwidth</name></expr></argument>, <argument><expr><name>zpad</name></expr></argument>,
					   <argument><expr><name>precision</name></expr></argument>, <argument><expr><name>pointflag</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_star</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>pointflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>fieldwidth</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>have_dollar</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>cvalue</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>argvalues</name><index>[<expr><name>fmtpos</name></expr>]</index></name><operator>.</operator><name>i</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>cvalue</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>fmtchar</name><argument_list>(<argument><expr><name>cvalue</name></expr></argument>, <argument><expr><name>leftjust</name></expr></argument>, <argument><expr><name>fieldwidth</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_star</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>pointflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>fieldwidth</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>have_dollar</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>strvalue</name> <operator>=</operator> <name><name>argvalues</name><index>[<expr><name>fmtpos</name></expr>]</index></name><operator>.</operator><name>cptr</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>strvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<comment type="block">/* Whine if someone tries to print a NULL string */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>strvalue</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmtstr</name><argument_list>(<argument><expr><name>strvalue</name></expr></argument>, <argument><expr><name>leftjust</name></expr></argument>, <argument><expr><name>fieldwidth</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr><name>pointflag</name></expr></argument>,
					   <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<comment type="block">/* fieldwidth/leftjust are ignored ... */</comment>
				<if_stmt><if>if <condition>(<expr><name>have_dollar</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>strvalue</name> <operator>=</operator> <name><name>argvalues</name><index>[<expr><name>fmtpos</name></expr>]</index></name><operator>.</operator><name>cptr</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>strvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>fmtptr</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>strvalue</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
			<case>case <expr><literal type="char">'E'</literal></expr>:</case>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
			<case>case <expr><literal type="char">'g'</literal></expr>:</case>
			<case>case <expr><literal type="char">'G'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_star</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>pointflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>fieldwidth</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>have_dollar</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>fvalue</name> <operator>=</operator> <name><name>argvalues</name><index>[<expr><name>fmtpos</name></expr>]</index></name><operator>.</operator><name>d</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>fvalue</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>double</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>fmtfloat</name><argument_list>(<argument><expr><name>fvalue</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>forcesign</name></expr></argument>, <argument><expr><name>leftjust</name></expr></argument>,
						 <argument><expr><name>fieldwidth</name></expr></argument>, <argument><expr><name>zpad</name></expr></argument>,
						 <argument><expr><name>precision</name></expr></argument>, <argument><expr><name>pointflag</name></expr></argument>,
						 <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'m'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>errbuf</name><index>[<expr><name>PG_STRERROR_R_BUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errm</name> <init>= <expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>,
												  <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>dostr</name><argument_list>(<argument><expr><name>errm</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>errm</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><literal type="char">'%'</literal></expr>:</case>
				<expr_stmt><expr><call><name>dopr_outch</name><argument_list>(<argument><expr><literal type="char">'%'</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>

				<comment type="block">/*
				 * Anything else --- in particular, '\0' indicating end of
				 * format string --- is bogus.
				 */</comment>
				<goto>goto <name>bad_format</name>;</goto>
		</block_content>}</block></switch>

		<comment type="block">/* Check for failure after each conversion spec */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>failed</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return;</return>

<label><name>bad_format</name>:</label>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>failed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * find_arguments(): sort out the arguments for a format spec with %n$
 *
 * If format is valid, return true and fill argvalues[i] with the value
 * for the conversion spec that has %i$ or *i$.  Else return false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>find_arguments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>,
			   <parameter><decl><type><name>PrintfArgValue</name> <modifier>*</modifier></type><name>argvalues</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>afterstar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>accum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>longlongflag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>longflag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fmtpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>last_dollar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PrintfArgType</name></type> <name><name>argtypes</name><index>[<expr><name>PG_NL_ARGMAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Initialize to "no dollar arguments known" */</comment>
	<expr_stmt><expr><name>last_dollar</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This loop must accept the same format strings as the one in dopr().
	 * However, we don't need to analyze them to the same level of detail.
	 *
	 * Since we're only called if there's a dollar-type spec somewhere, we can
	 * fail immediately if we find a non-dollar spec.  Per the C99 standard,
	 * all argument references in the format string must be one or the other.
	 */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>format</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Locate next conversion specifier */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>format</name> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Unlike dopr, we can just quit if there's no more specifiers */</comment>
			<expr_stmt><expr><name>format</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>format</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Process conversion spec starting at *format */</comment>
		<expr_stmt><expr><name>format</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>longflag</name> <operator>=</operator> <name>longlongflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmtpos</name> <operator>=</operator> <name>accum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>afterstar</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<label><name>nextch1</name>:</label>
		<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>format</name><operator>++</operator></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>ch</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'-'</literal></expr>:</case>
			<case>case <expr><literal type="char">'+'</literal></expr>:</case>
				<goto>goto <name>nextch1</name>;</goto>
			<case>case <expr><literal type="char">'0'</literal></expr>:</case>
			<case>case <expr><literal type="char">'1'</literal></expr>:</case>
			<case>case <expr><literal type="char">'2'</literal></expr>:</case>
			<case>case <expr><literal type="char">'3'</literal></expr>:</case>
			<case>case <expr><literal type="char">'4'</literal></expr>:</case>
			<case>case <expr><literal type="char">'5'</literal></expr>:</case>
			<case>case <expr><literal type="char">'6'</literal></expr>:</case>
			<case>case <expr><literal type="char">'7'</literal></expr>:</case>
			<case>case <expr><literal type="char">'8'</literal></expr>:</case>
			<case>case <expr><literal type="char">'9'</literal></expr>:</case>
				<expr_stmt><expr><name>accum</name> <operator>=</operator> <name>accum</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name>ch</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
				<goto>goto <name>nextch1</name>;</goto>
			<case>case <expr><literal type="char">'.'</literal></expr>:</case>
				<expr_stmt><expr><name>accum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<goto>goto <name>nextch1</name>;</goto>
			<case>case <expr><literal type="char">'*'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>afterstar</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* previous star missing dollar */</comment>
				<expr_stmt><expr><name>afterstar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>accum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<goto>goto <name>nextch1</name>;</goto>
			<case>case <expr><literal type="char">'$'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>accum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>accum</name> <operator>&gt;</operator> <name>PG_NL_ARGMAX</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>afterstar</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>argtypes</name><index>[<expr><name>accum</name></expr>]</index></name> <operator>&amp;&amp;</operator>
						<name><name>argtypes</name><index>[<expr><name>accum</name></expr>]</index></name> <operator>!=</operator> <name>ATYPE_INT</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>accum</name></expr>]</index></name> <operator>=</operator> <name>ATYPE_INT</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>last_dollar</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>last_dollar</name></expr></argument>, <argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>afterstar</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>fmtpos</name> <operator>=</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>accum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<goto>goto <name>nextch1</name>;</goto>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>longflag</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>longlongflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>longflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<goto>goto <name>nextch1</name>;</goto>
			<case>case <expr><literal type="char">'z'</literal></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LONG_INT_64</name></cpp:ifdef>
				<expr_stmt><expr><name>longflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG_INT_64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
				<expr_stmt><expr><name>longlongflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Don't know how to print 64bit integers"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<comment type="block">/* assume size_t is same size as int */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<goto>goto <name>nextch1</name>;</goto>
			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
			<case>case <expr><literal type="char">'\''</literal></expr>:</case>
				<comment type="block">/* ignore these */</comment>
				<goto>goto <name>nextch1</name>;</goto>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
			<case>case <expr><literal type="char">'i'</literal></expr>:</case>
			<case>case <expr><literal type="char">'o'</literal></expr>:</case>
			<case>case <expr><literal type="char">'u'</literal></expr>:</case>
			<case>case <expr><literal type="char">'x'</literal></expr>:</case>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>fmtpos</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PrintfArgType</name></type> <name>atype</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>longlongflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>atype</name> <operator>=</operator> <name>ATYPE_LONGLONG</name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>longflag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>atype</name> <operator>=</operator> <name>ATYPE_LONG</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>atype</name> <operator>=</operator> <name>ATYPE_INT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>&amp;&amp;</operator>
						<name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>!=</operator> <name>atype</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>=</operator> <name>atype</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>last_dollar</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>last_dollar</name></expr></argument>, <argument><expr><name>fmtpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* non-dollar conversion spec */</comment>
				<break>break;</break>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>fmtpos</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>&amp;&amp;</operator>
						<name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>!=</operator> <name>ATYPE_INT</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>=</operator> <name>ATYPE_INT</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>last_dollar</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>last_dollar</name></expr></argument>, <argument><expr><name>fmtpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* non-dollar conversion spec */</comment>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>fmtpos</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>&amp;&amp;</operator>
						<name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>!=</operator> <name>ATYPE_CHARPTR</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>=</operator> <name>ATYPE_CHARPTR</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>last_dollar</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>last_dollar</name></expr></argument>, <argument><expr><name>fmtpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* non-dollar conversion spec */</comment>
				<break>break;</break>
			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
			<case>case <expr><literal type="char">'E'</literal></expr>:</case>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
			<case>case <expr><literal type="char">'g'</literal></expr>:</case>
			<case>case <expr><literal type="char">'G'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>fmtpos</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>&amp;&amp;</operator>
						<name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>!=</operator> <name>ATYPE_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>fmtpos</name></expr>]</index></name> <operator>=</operator> <name>ATYPE_DOUBLE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>last_dollar</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>last_dollar</name></expr></argument>, <argument><expr><name>fmtpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* non-dollar conversion spec */</comment>
				<break>break;</break>
			<case>case <expr><literal type="char">'m'</literal></expr>:</case>
			<case>case <expr><literal type="char">'%'</literal></expr>:</case>
				<break>break;</break>
			<default>default:</default>
				<return>return <expr><name>false</name></expr>;</return>	<comment type="block">/* bogus format string */</comment>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * If we finish the spec with afterstar still set, there's a
		 * non-dollar star in there.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>afterstar</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* non-dollar conversion spec */</comment>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Format appears valid so far, so collect the arguments in physical
	 * order.  (Since we rejected any non-dollar specs that would have
	 * collected arguments, we know that dopr() hasn't collected any yet.)
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>last_dollar</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ATYPE_NONE</name></expr>:</case>
				<return>return <expr><name>false</name></expr>;</return>
			<case>case <expr><name>ATYPE_INT</name></expr>:</case>
				<expr_stmt><expr><name><name>argvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>i</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ATYPE_LONG</name></expr>:</case>
				<expr_stmt><expr><name><name>argvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>l</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ATYPE_LONGLONG</name></expr>:</case>
				<expr_stmt><expr><name><name>argvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ll</name> <operator>=</operator> <macro><name>va_arg</name><argument_list>(<argument>args</argument>, <argument>long long</argument>)</argument_list></macro></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ATYPE_DOUBLE</name></expr>:</case>
				<expr_stmt><expr><name><name>argvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>double</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ATYPE_CHARPTR</name></expr>:</case>
				<expr_stmt><expr><name><name>argvalues</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cptr</name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fmtstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leftjust</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxwidth</name></decl></parameter>,
	   <parameter><decl><type><name>int</name></type> <name>pointflag</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>padlen</name></decl>,
				<decl><type ref="prev"/><name>vallen</name></decl>;</decl_stmt>			<comment type="block">/* amount to pad */</comment>

	<comment type="block">/*
	 * If a maxwidth (precision) is specified, we must not fetch more bytes
	 * than that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pointflag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>strnlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>maxwidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>padlen</name> <operator>=</operator> <call><name>compute_padlen</name><argument_list>(<argument><expr><name>minlen</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><name>leftjust</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>padlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dopr_outchmulti</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>padlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>padlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>dostr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>trailing_pad</name><argument_list>(<argument><expr><name>padlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fmtptr</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>vallen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>convert</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* we rely on regular C library's sprintf to do the basic conversion */</comment>
	<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><literal type="string">"%p"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>vallen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>failed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dostr</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fmtint</name><parameter_list>(<parameter><decl><type><name>long</name> <name>long</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forcesign</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leftjust</name></decl></parameter>,
	   <parameter><decl><type><name>int</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>zpad</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>precision</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointflag</name></decl></parameter>,
	   <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>uvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dosign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cvt</name> <init>= <expr><literal type="string">"0123456789abcdef"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>signvalue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>convert</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>vallen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>padlen</name></decl>;</decl_stmt>			<comment type="block">/* amount to pad */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>zeropad</name></decl>;</decl_stmt>		<comment type="block">/* extra leading zeroes */</comment>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'d'</literal></expr>:</case>
		<case>case <expr><literal type="char">'i'</literal></expr>:</case>
			<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dosign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'o'</literal></expr>:</case>
			<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dosign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'u'</literal></expr>:</case>
			<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dosign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'x'</literal></expr>:</case>
			<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dosign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'X'</literal></expr>:</case>
			<expr_stmt><expr><name>cvt</name> <operator>=</operator> <literal type="string">"0123456789ABCDEF"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dosign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<return>return;</return>				<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>

	<comment type="block">/* disable MSVC warning about applying unary minus to an unsigned value */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_MSC_VER</name></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name> <name>4146</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Handle +/- */</comment>
	<if_stmt><if>if <condition>(<expr><name>dosign</name> <operator>&amp;&amp;</operator> <call><name>adjust_sign</name><argument_list>(<argument><expr><operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>, <argument><expr><name>forcesign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>signvalue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <name>value</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <name>value</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_MSC_VER</name></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * SUS: the result of converting 0 with an explicit precision of 0 is no
	 * characters
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pointflag</name> <operator>&amp;&amp;</operator> <name>precision</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>vallen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* make integer string */</comment>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><name><name>convert</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>convert</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <operator>(</operator><operator>++</operator><name>vallen</name><operator>)</operator></expr>]</index></name> <operator>=</operator> <name><name>cvt</name><index>[<expr><name>uvalue</name> <operator>%</operator> <name>base</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>uvalue</name> <operator>=</operator> <name>uvalue</name> <operator>/</operator> <name>base</name></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>uvalue</name></expr>)</condition>;</do>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>zeropad</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>precision</name> <operator>-</operator> <name>vallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>padlen</name> <operator>=</operator> <call><name>compute_padlen</name><argument_list>(<argument><expr><name>minlen</name></expr></argument>, <argument><expr><name>vallen</name> <operator>+</operator> <name>zeropad</name></expr></argument>, <argument><expr><name>leftjust</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>leading_pad</name><argument_list>(<argument><expr><name>zpad</name></expr></argument>, <argument><expr><name>signvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>padlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>zeropad</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dopr_outchmulti</name><argument_list>(<argument><expr><literal type="char">'0'</literal></expr></argument>, <argument><expr><name>zeropad</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>dostr</name><argument_list>(<argument><expr><name>convert</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>convert</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>vallen</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>trailing_pad</name><argument_list>(<argument><expr><name>padlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fmtchar</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leftjust</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>padlen</name></decl>;</decl_stmt>			<comment type="block">/* amount to pad */</comment>

	<expr_stmt><expr><name>padlen</name> <operator>=</operator> <call><name>compute_padlen</name><argument_list>(<argument><expr><name>minlen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>leftjust</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>padlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dopr_outchmulti</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>padlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>padlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>dopr_outch</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>trailing_pad</name><argument_list>(<argument><expr><name>padlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fmtfloat</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forcesign</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leftjust</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>zpad</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>precision</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pointflag</name></decl></parameter>,
		 <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>signvalue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>vallen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fmt</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>convert</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>zeropadlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* amount to pad with zeroes */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>padlen</name></decl>;</decl_stmt>			<comment type="block">/* amount to pad with spaces */</comment>

	<comment type="block">/*
	 * We rely on the regular C library's sprintf to do the basic conversion,
	 * then handle padding considerations here.
	 *
	 * The dynamic range of "double" is about 1E+-308 for IEEE math, and not
	 * too wildly more than that with other hardware.  In "f" format, sprintf
	 * could therefore generate at most 308 characters to the left of the
	 * decimal point; while we need to allow the precision to get as high as
	 * 308+17 to ensure that we don't truncate significant digits from very
	 * small values.  To handle both these extremes, we use a buffer of 1024
	 * bytes and limit requested precision to 350 digits; this should prevent
	 * buffer overrun even with non-IEEE math.  If the original precision
	 * request was more than 350, separately pad with zeroes.
	 *
	 * We handle infinities and NaNs specially to ensure platform-independent
	 * output.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>precision</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* cover possible overflow of "accum" */</comment>
		<expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>prec</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>precision</name></expr></argument>, <argument><expr><literal type="number">350</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vallen</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		<comment type="block">/* no zero padding, regardless of precision spec */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Handle sign (NaNs have no sign, so we don't do this in the case
		 * above).  "value &lt; 0.0" will not be true for IEEE minus zero, so we
		 * detect that by looking for the case where value equals 0.0
		 * according to == but not according to memcmp.
		 */</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>dzero</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>adjust_sign</name><argument_list>(<argument><expr><operator>(</operator><name>value</name> <operator>&lt;</operator> <literal type="number">0.0</literal> <operator>||</operator>
						 <operator>(</operator><name>value</name> <operator>==</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator>
						  <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dzero</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr></argument>,
						<argument><expr><name>forcesign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>signvalue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>-</operator><name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><literal type="string">"Infinity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>vallen</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<comment type="block">/* no zero padding, regardless of precision spec */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>pointflag</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>zeropadlen</name> <operator>=</operator> <name>precision</name> <operator>-</operator> <name>prec</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'%'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'%'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>vallen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Windows, alone among our supported platforms, likes to emit
		 * three-digit exponent fields even when two digits would do.  Hack
		 * such results to look like the way everyone else does it.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>vallen</name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>
			<name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal> <operator>&amp;&amp;</operator>
			<name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>vallen</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>padlen</name> <operator>=</operator> <call><name>compute_padlen</name><argument_list>(<argument><expr><name>minlen</name></expr></argument>, <argument><expr><name>vallen</name> <operator>+</operator> <name>zeropadlen</name></expr></argument>, <argument><expr><name>leftjust</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>leading_pad</name><argument_list>(<argument><expr><name>zpad</name></expr></argument>, <argument><expr><name>signvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>padlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>zeropadlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If 'e' or 'E' format, inject zeroes before the exponent */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>epos</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><literal type="char">'e'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>epos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>epos</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><literal type="char">'E'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>epos</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* pad before exponent */</comment>
			<expr_stmt><expr><call><name>dostr</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><name>epos</name> <operator>-</operator> <name>convert</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>zeropadlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>dopr_outchmulti</name><argument_list>(<argument><expr><literal type="char">'0'</literal></expr></argument>, <argument><expr><name>zeropadlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>dostr</name><argument_list>(<argument><expr><name>epos</name></expr></argument>, <argument><expr><name>vallen</name> <operator>-</operator> <operator>(</operator><name>epos</name> <operator>-</operator> <name>convert</name><operator>)</operator></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* no exponent, pad after the digits */</comment>
			<expr_stmt><expr><call><name>dostr</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>zeropadlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>dopr_outchmulti</name><argument_list>(<argument><expr><literal type="char">'0'</literal></expr></argument>, <argument><expr><name>zeropadlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no zero padding, just emit the number as-is */</comment>
		<expr_stmt><expr><call><name>dostr</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>trailing_pad</name><argument_list>(<argument><expr><name>padlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>

<label><name>fail</name>:</label>
	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>failed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Nonstandard entry point to print a double value efficiently.
 *
 * This is approximately equivalent to strfromd(), but has an API more
 * adapted to what float8out() wants.  The behavior is like snprintf()
 * with a format of "%.ng", where n is the specified precision.
 * However, the target buffer must be nonempty (i.e. count &gt; 0), and
 * the precision is silently bounded to a sane range.
 */</comment>
<function><type><name>int</name></type>
<name>pg_strfromd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>precision</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PrintfTarget</name></type> <name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>signvalue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>vallen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fmt</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>convert</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Set up the target like pg_snprintf, but require nonempty buffer */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>bufstart</name></name> <operator>=</operator> <name><name>target</name><operator>.</operator><name>bufptr</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>bufend</name></name> <operator>=</operator> <name>str</name> <operator>+</operator> <name>count</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>stream</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>nchars</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>.</operator><name>failed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We bound precision to a reasonable range; the combination of this and
	 * the knowledge that we're using "g" format without padding allows the
	 * convert[] buffer to be reasonably small.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>precision</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>precision</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>precision</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The rest is just an inlined version of the fmtfloat() logic above,
	 * simplified using the knowledge that no padding is wanted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vallen</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>dzero</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">0.0</literal> <operator>||</operator>
			<operator>(</operator><name>value</name> <operator>==</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator>
			 <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dzero</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>signvalue</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>-</operator><name>value</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><literal type="string">"Infinity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>vallen</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'%'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'g'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmt</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>vallen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>target</name><operator>.</operator><name>failed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<goto>goto <name>fail</name>;</goto>
			</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>vallen</name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>
				<name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal> <operator>&amp;&amp;</operator>
				<name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>convert</name><index>[<expr><name>vallen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>vallen</name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>signvalue</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dopr_outch</name><argument_list>(<argument><expr><name>signvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>dostr</name><argument_list>(<argument><expr><name>convert</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>fail</name>:</label>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>target</name><operator>.</operator><name>bufptr</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><name><name>target</name><operator>.</operator><name>failed</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name><name>target</name><operator>.</operator><name>bufptr</name></name> <operator>-</operator> <name><name>target</name><operator>.</operator><name>bufstart</name></name>
								 <operator>+</operator> <name><name>target</name><operator>.</operator><name>nchars</name></name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>dostr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slen</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* fast path for common case of slen == 1 */</comment>
	<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dopr_outch</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>avail</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>bufend</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>bufend</name></name> <operator>-</operator> <name><name>target</name><operator>-&gt;</operator><name>bufptr</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>avail</name> <operator>=</operator> <name>slen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* buffer full, can we dump to stream? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>stream</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>nchars</name></name> <operator>+=</operator> <name>slen</name></expr>;</expr_stmt> <comment type="block">/* no, lose the data */</comment>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>flushbuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>avail</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>avail</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>bufptr</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>bufptr</name></name> <operator>+=</operator> <name>avail</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>str</name> <operator>+=</operator> <name>avail</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slen</name> <operator>-=</operator> <name>avail</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dopr_outch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>bufend</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>target</name><operator>-&gt;</operator><name>bufptr</name></name> <operator>&gt;=</operator> <name><name>target</name><operator>-&gt;</operator><name>bufend</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* buffer full, can we dump to stream? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>stream</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>nchars</name></name><operator>++</operator></expr>;</expr_stmt>	<comment type="block">/* no, lose the data */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>flushbuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>bufptr</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dopr_outchmulti</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slen</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* fast path for common case of slen == 1 */</comment>
	<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dopr_outch</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>avail</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>bufend</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>bufend</name></name> <operator>-</operator> <name><name>target</name><operator>-&gt;</operator><name>bufptr</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>avail</name> <operator>=</operator> <name>slen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* buffer full, can we dump to stream? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>stream</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>nchars</name></name> <operator>+=</operator> <name>slen</name></expr>;</expr_stmt> <comment type="block">/* no, lose the data */</comment>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>flushbuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>avail</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>avail</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>bufptr</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>bufptr</name></name> <operator>+=</operator> <name>avail</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slen</name> <operator>-=</operator> <name>avail</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>adjust_sign</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>is_negative</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forcesign</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>signvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>is_negative</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>signvalue</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>forcesign</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>signvalue</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>compute_padlen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vallen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leftjust</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>padlen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>padlen</name> <operator>=</operator> <name>minlen</name> <operator>-</operator> <name>vallen</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>padlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>padlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>leftjust</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>padlen</name> <operator>=</operator> <operator>-</operator><name>padlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>padlen</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>leading_pad</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>zpad</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>signvalue</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>padlen</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxpad</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>padlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zpad</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>signvalue</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>dopr_outch</name><argument_list>(<argument><expr><name>signvalue</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>--</operator><operator>(</operator><operator>*</operator><name>padlen</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>signvalue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>padlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>dopr_outchmulti</name><argument_list>(<argument><expr><name>zpad</name></expr></argument>, <argument><expr><operator>*</operator><name>padlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>padlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>maxpad</name> <operator>=</operator> <operator>(</operator><name>signvalue</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>padlen</name> <operator>&gt;</operator> <name>maxpad</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dopr_outchmulti</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><operator>*</operator><name>padlen</name> <operator>-</operator> <name>maxpad</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>padlen</name> <operator>=</operator> <name>maxpad</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>signvalue</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dopr_outch</name><argument_list>(<argument><expr><name>signvalue</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>padlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>--</operator><operator>(</operator><operator>*</operator><name>padlen</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>padlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><operator>(</operator><operator>*</operator><name>padlen</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>trailing_pad</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>padlen</name></decl></parameter>, <parameter><decl><type><name>PrintfTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>padlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dopr_outchmulti</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><operator>-</operator><name>padlen</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
