<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/bin/pg_waldump/pg_waldump.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_waldump.c - decode and display WAL
 *
 * Copyright (c) 2013-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		  src/bin/pg_waldump/pg_waldump.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRONTEND</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogrecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/fe_memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/logging.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rmgrdesc.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>WalSegSz</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>XLogDumpPrivate</name>
<block>{
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>timeline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>inpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>startptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>endptr_reached</name></decl>;</decl_stmt>
}</block></struct></type> <name>XLogDumpPrivate</name>;</typedef>

<typedef>typedef <type><struct>struct <name>XLogDumpConfig</name>
<block>{
	<comment type="block">/* display options */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bkp_details</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>stop_after_records</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>already_displayed_records</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>follow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>stats_per_record</name></decl>;</decl_stmt>

	<comment type="block">/* filter options */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>filter_by_rmgr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>filter_by_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>filter_by_xid_enabled</name></decl>;</decl_stmt>
}</block></struct></type> <name>XLogDumpConfig</name>;</typedef>

<typedef>typedef <type><struct>struct <name>Stats</name>
<block>{
	<decl_stmt><decl><type><name>uint64</name></type>		<name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>rec_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>fpi_len</name></decl>;</decl_stmt>
}</block></struct></type> <name>Stats</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_XLINFO_TYPES</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>XLogDumpStats</name>
<block>{
	<decl_stmt><decl><type><name>uint64</name></type>		<name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Stats</name></type>		<name><name>rmgr_stats</name><index>[<expr><name>RM_NEXT_ID</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Stats</name></type>		<name><name>record_stats</name><index>[<expr><name>RM_NEXT_ID</name></expr>]</index><index>[<expr><name>MAX_XLINFO_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>XLogDumpStats</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fatal_error</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { pg_log_fatal(__VA_ARGS__); exit(EXIT_FAILURE); } while(0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_rmgr_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>RM_MAX_ID</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>RmgrDescTable</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether directory exists and whether we can open it. Keep errno set so
 * that the caller can report errors somewhat more accurately.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>verify_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>opendir</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Split a pathname as dirname(1) and basename(1) would.
 *
 * XXX this probably doesn't do very well on Windows.  We probably need to
 * apply canonicalize_path(), at the very least.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>split_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

	<comment type="block">/* split filepath into directory &amp; filename */</comment>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* directory path */</comment>
	<if_stmt><if>if <condition>(<expr><name>sep</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>dir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>dir</name><operator>)</operator><index>[<expr><operator>(</operator><name>sep</name> <operator>-</operator> <name>path</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* no strndup */</comment>
		<expr_stmt><expr><operator>*</operator><name>fname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>sep</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* local directory */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>dir</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>fname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open the file in the valid target directory.
 *
 * return a read only fd
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>open_file_in_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>directory</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %s"</literal></expr></argument>,
					<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to find fname in the given directory. Returns true if it is found,
 * false otherwise. If fname is NULL, search the complete directory for any
 * file with a valid WAL file name. If file is successfully opened, set the
 * wal segment size.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>search_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>

	<comment type="block">/* open file if valid filename is provided */</comment>
	<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open_file_in_directory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/*
	 * A valid file name is not passed, so search the complete directory.  If
	 * we find any file whose name is a valid WAL file name then try to open
	 * it.  If we cannot open it, bail out.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>xldir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsXLogFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open_file_in_directory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fname</name> <operator>=</operator> <name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set WalSegSz if file is successfully opened */</comment>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGAlignedXLogBlock</name></type> <name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogLongPageHeader</name></type> <name>longhdr</name> <init>= <expr><operator>(</operator><name>XLogLongPageHeader</name><operator>)</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>WalSegSz</name> <operator>=</operator> <name><name>longhdr</name><operator>-&gt;</operator><name>xlp_seg_size</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidWalSegSize</name><argument_list>(<argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"WAL segment size must be a power of two between 1 MB and 1 GB, but the WAL file \"%s\" header specifies %d byte"</literal></expr></argument>,
									 <argument><expr><literal type="string">"WAL segment size must be a power of two between 1 MB and 1 GB, but the WAL file \"%s\" header specifies %d bytes"</literal></expr></argument>,
									 <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": read %d of %zu"</literal></expr></argument>,
							<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Identify the target directory and set WalSegSz.
 *
 * Try to find the file in several places:
 * if directory != NULL:
 *	 directory /
 *	 directory / XLOGDIR /
 * else
 *	 .
 *	 XLOGDIR /
 *	 $PGDATA / XLOGDIR /
 *
 * Set the valid target directory in private-&gt;inpath.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>identify_target_directory</name><parameter_list>(<parameter><decl><type><name>XLogDumpPrivate</name> <modifier>*</modifier></type><name>private</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>,
						  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>directory</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>search_directory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* directory / XLOGDIR */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>search_directory</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>datadir</name></decl>;</decl_stmt>

		<comment type="block">/* current directory */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>search_directory</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* XLOGDIR */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>search_directory</name><argument_list>(<argument><expr><name>XLOGDIR</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>datadir</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* $PGDATA / XLOGDIR */</comment>
		<if_stmt><if>if <condition>(<expr><name>datadir</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>datadir</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>search_directory</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* could not locate WAL file */</comment>
	<if_stmt><if>if <condition>(<expr><name>fname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not locate WAL file \"%s\""</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not find any WAL file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read count bytes from a segment file in the specified directory, for the
 * given timeline, containing the specified record pointer; store the data in
 * the passed buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogDumpXLogRead</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>timeline_id</name></decl></parameter>,
				 <parameter><decl><type><name>XLogRecPtr</name></type> <name>startptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nbytes</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>sendFile</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSegNo</name></type> <name>sendSegNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>sendOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <name>startptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>startoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>segbytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>readbytes</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>startoff</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>XLByteInSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>tries</name></decl>;</decl_stmt>

			<comment type="block">/* Switch to another logfile segment */</comment>
			<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>timeline_id</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In follow mode there is a short period of time after the server
			 * has written the end of the previous file before the new file is
			 * available. So we loop for 5 seconds looking for the file to
			 * appear before giving up.
			 */</comment>
			<for>for <control>(<init><expr><name>tries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tries</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>tries</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>sendFile</name> <operator>=</operator> <call><name>open_file_in_directory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* File not there yet, try again */</comment>
					<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">500</literal> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Any other error, fall through and fail */</comment>
				<break>break;</break>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not find file \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>sendOff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Need to seek in the file? */</comment>
		<if_stmt><if>if <condition>(<expr><name>sendOff</name> <operator>!=</operator> <name>startoff</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>startoff</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>timeline_id</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not seek in log file %s to offset %u: %s"</literal></expr></argument>,
							<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>startoff</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>sendOff</name> <operator>=</operator> <name>startoff</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* How many bytes are within this segment? */</comment>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <operator>(</operator><name>WalSegSz</name> <operator>-</operator> <name>startoff</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>WalSegSz</name> <operator>-</operator> <name>startoff</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>readbytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>segbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>readbytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>timeline_id</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>readbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not read from log file %s, offset %u, length %d: %s"</literal></expr></argument>,
							<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>sendOff</name></expr></argument>, <argument><expr><name>segbytes</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>readbytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not read from log file %s, offset %u: read %d of %zu"</literal></expr></argument>,
							<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>sendOff</name></expr></argument>, <argument><expr><name>readbytes</name></expr></argument>, <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>segbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update state for read */</comment>
		<expr_stmt><expr><name>recptr</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>sendOff</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>-=</operator> <name>readbytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * XLogReader read_page callback
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>XLogDumpReadPage</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>targetPagePtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reqLen</name></decl></parameter>,
				 <parameter><decl><type><name>XLogRecPtr</name></type> <name>targetPtr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>readBuff</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>curFileTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogDumpPrivate</name> <modifier>*</modifier></type><name>private</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><name>XLOG_BLCKSZ</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>private</name><operator>-&gt;</operator><name>endptr</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>targetPagePtr</name> <operator>+</operator> <name>XLOG_BLCKSZ</name> <operator>&lt;=</operator> <name><name>private</name><operator>-&gt;</operator><name>endptr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>targetPagePtr</name> <operator>+</operator> <name>reqLen</name> <operator>&lt;=</operator> <name><name>private</name><operator>-&gt;</operator><name>endptr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>private</name><operator>-&gt;</operator><name>endptr</name></name> <operator>-</operator> <name>targetPagePtr</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>endptr_reached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>XLogDumpXLogRead</name><argument_list>(<argument><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name></expr></argument>, <argument><expr><name><name>private</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
					 <argument><expr><name>readBuff</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the size of a record, split into !FPI and FPI parts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogDumpRecordLen</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>rec_len</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>fpi_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>block_id</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Calculate the amount of FPI data in the record.
	 *
	 * XXX: We peek into xlogreader's private decoded backup blocks for the
	 * bimg_len indicating the length of FPI data. It doesn't seem worth it to
	 * add an accessor macro for this.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>fpi_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>record</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockImage</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>fpi_len</name> <operator>+=</operator> <name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>bimg_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Calculate the length of the record as the total length - the length of
	 * all the block images.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>rec_len</name> <operator>=</operator> <call><name>XLogRecGetTotalLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>*</operator><name>fpi_len</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Store per-rmgr and per-record statistics for a given record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogDumpCountRecord</name><parameter_list>(<parameter><decl><type><name>XLogDumpConfig</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><name>XLogDumpStats</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
					<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RmgrId</name></type>		<name>rmid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>recid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>rec_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>fpi_len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>rmid</name> <operator>=</operator> <call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogDumpRecordLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rec_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fpi_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update per-rmgr statistics */</comment>

	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rmgr_stats</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>count</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rmgr_stats</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rec_len</name> <operator>+=</operator> <name>rec_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rmgr_stats</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>fpi_len</name> <operator>+=</operator> <name>fpi_len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update per-record statistics, where the record is identified by a
	 * combination of the RmgrId and the four bits of the xl_info field that
	 * are the rmgr's domain (resulting in sixteen possible entries per
	 * RmgrId).
	 */</comment>

	<expr_stmt><expr><name>recid</name> <operator>=</operator> <call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>record_stats</name><index>[<expr><name>rmid</name></expr>]</index><index>[<expr><name>recid</name></expr>]</index></name><operator>.</operator><name>count</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>record_stats</name><index>[<expr><name>rmid</name></expr>]</index><index>[<expr><name>recid</name></expr>]</index></name><operator>.</operator><name>rec_len</name> <operator>+=</operator> <name>rec_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>record_stats</name><index>[<expr><name>rmid</name></expr>]</index><index>[<expr><name>recid</name></expr>]</index></name><operator>.</operator><name>fpi_len</name> <operator>+=</operator> <name>fpi_len</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print a record to stdout
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogDumpDisplayRecord</name><parameter_list>(<parameter><decl><type><name>XLogDumpConfig</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RmgrDescData</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>&amp;</operator><name><name>RmgrDescTable</name><index>[<expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>rec_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>fpi_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>block_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>xl_prev</name> <init>= <expr><call><name>XLogRecGetPrev</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogDumpRecordLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rec_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fpi_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name><name>desc</name><operator>-&gt;</operator><name>rm_identify</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"UNKNOWN (%x)"</literal></expr></argument>, <argument><expr><name>info</name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"rmgr: %-11s len (rec/tot): %6u/%6u, tx: %10u, lsn: %X/%08X, prev %X/%08X, "</literal></expr></argument>,
		   <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rm_name</name></name></expr></argument>,
		   <argument><expr><name>rec_len</name></expr></argument>, <argument><expr><call><name>XLogRecGetTotalLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>,
		   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>xl_prev</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>xl_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"desc: %s "</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>desc</name><operator>-&gt;</operator><name>rm_desc</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>config</name><operator>-&gt;</operator><name>bkp_details</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* print block references (short format) */</comment>
		<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>record</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forknum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>forknum</name> <operator>!=</operator> <name>MAIN_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", blkref #%u: rel %u/%u/%u fork %s blk %u"</literal></expr></argument>,
					   <argument><expr><name>block_id</name></expr></argument>,
					   <argument><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
					   <argument><expr><name><name>forkNames</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>,
					   <argument><expr><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", blkref #%u: rel %u/%u/%u blk %u"</literal></expr></argument>,
					   <argument><expr><name>block_id</name></expr></argument>,
					   <argument><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
					   <argument><expr><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockImage</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>XLogRecBlockImageApply</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" FPW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" FPW for WAL verification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* print block references (detailed format) */</comment>
		<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>record</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forknum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\tblkref #%u: rel %u/%u/%u fork %s blk %u"</literal></expr></argument>,
				   <argument><expr><name>block_id</name></expr></argument>,
				   <argument><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
				   <argument><expr><name><name>forkNames</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>,
				   <argument><expr><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockImage</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>bimg_info</name> <operator>&amp;</operator>
					<name>BKPIMAGE_IS_COMPRESSED</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (FPW%s); hole: offset: %u, length: %u, "</literal>
						   <literal type="string">"compression saved: %u\n"</literal></expr></argument>,
						   <argument><expr><ternary><condition><expr><call><name>XLogRecBlockImageApply</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
						   <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" for WAL verification"</literal></expr></else></ternary></expr></argument>,
						   <argument><expr><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>hole_offset</name></expr></argument>,
						   <argument><expr><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>hole_length</name></expr></argument>,
						   <argument><expr><name>BLCKSZ</name> <operator>-</operator>
						   <name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>hole_length</name> <operator>-</operator>
						   <name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>bimg_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (FPW%s); hole: offset: %u, length: %u\n"</literal></expr></argument>,
						   <argument><expr><ternary><condition><expr><call><name>XLogRecBlockImageApply</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
						   <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" for WAL verification"</literal></expr></else></ternary></expr></argument>,
						   <argument><expr><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>hole_offset</name></expr></argument>,
						   <argument><expr><name><name>record</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name><operator>.</operator><name>hole_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Display a single row of record counts and sizes for an rmgr or record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogDumpStatsRow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
				 <parameter><decl><type><name>uint64</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>total_count</name></decl></parameter>,
				 <parameter><decl><type><name>uint64</name></type> <name>rec_len</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>total_rec_len</name></decl></parameter>,
				 <parameter><decl><type><name>uint64</name></type> <name>fpi_len</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>total_fpi_len</name></decl></parameter>,
				 <parameter><decl><type><name>uint64</name></type> <name>tot_len</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>total_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>n_pct</name></decl>,
				<decl><type ref="prev"/><name>rec_len_pct</name></decl>,
				<decl><type ref="prev"/><name>fpi_len_pct</name></decl>,
				<decl><type ref="prev"/><name>tot_len_pct</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n_pct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>total_count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>n_pct</name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>n</name> <operator>/</operator> <name>total_count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rec_len_pct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>total_rec_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rec_len_pct</name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>rec_len</name> <operator>/</operator> <name>total_rec_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fpi_len_pct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>total_fpi_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fpi_len_pct</name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>fpi_len</name> <operator>/</operator> <name>total_fpi_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tot_len_pct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tot_len_pct</name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>tot_len</name> <operator>/</operator> <name>total_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-27s "</literal>
		   <literal type="string">"%20"</literal> <name>INT64_MODIFIER</name> <literal type="string">"u (%6.02f) "</literal>
		   <literal type="string">"%20"</literal> <name>INT64_MODIFIER</name> <literal type="string">"u (%6.02f) "</literal>
		   <literal type="string">"%20"</literal> <name>INT64_MODIFIER</name> <literal type="string">"u (%6.02f) "</literal>
		   <literal type="string">"%20"</literal> <name>INT64_MODIFIER</name> <literal type="string">"u (%6.02f)\n"</literal></expr></argument>,
		   <argument><expr><name>name</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>n_pct</name></expr></argument>, <argument><expr><name>rec_len</name></expr></argument>, <argument><expr><name>rec_len_pct</name></expr></argument>, <argument><expr><name>fpi_len</name></expr></argument>, <argument><expr><name>fpi_len_pct</name></expr></argument>,
		   <argument><expr><name>tot_len</name></expr></argument>, <argument><expr><name>tot_len_pct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Display summary statistics about the records seen so far.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogDumpDisplayStats</name><parameter_list>(<parameter><decl><type><name>XLogDumpConfig</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><name>XLogDumpStats</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ri</name></decl>,
				<decl><type ref="prev"/><name>rj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>total_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>total_rec_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>total_fpi_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>total_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>rec_len_pct</name></decl>,
				<decl><type ref="prev"/><name>fpi_len_pct</name></decl>;</decl_stmt>

	<comment type="block">/* ---
	 * Make a first pass to calculate column totals:
	 * count(*),
	 * sum(xl_len+SizeOfXLogRecord),
	 * sum(xl_tot_len-xl_len-SizeOfXLogRecord), and
	 * sum(xl_tot_len).
	 * These are used to calculate percentages for each record type.
	 * ---
	 */</comment>

	<for>for <control>(<init><expr><name>ri</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ri</name> <operator>&lt;</operator> <name>RM_NEXT_ID</name></expr>;</condition> <incr><expr><name>ri</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>total_count</name> <operator>+=</operator> <name><name>stats</name><operator>-&gt;</operator><name>rmgr_stats</name><index>[<expr><name>ri</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_rec_len</name> <operator>+=</operator> <name><name>stats</name><operator>-&gt;</operator><name>rmgr_stats</name><index>[<expr><name>ri</name></expr>]</index></name><operator>.</operator><name>rec_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_fpi_len</name> <operator>+=</operator> <name><name>stats</name><operator>-&gt;</operator><name>rmgr_stats</name><index>[<expr><name>ri</name></expr>]</index></name><operator>.</operator><name>fpi_len</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>total_len</name> <operator>=</operator> <name>total_rec_len</name> <operator>+</operator> <name>total_fpi_len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * 27 is strlen("Transaction/COMMIT_PREPARED"), 20 is strlen(2^64), 8 is
	 * strlen("(100.00%)")
	 */</comment>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-27s %20s %8s %20s %8s %20s %8s %20s %8s\n"</literal>
		   <literal type="string">"%-27s %20s %8s %20s %8s %20s %8s %20s %8s\n"</literal></expr></argument>,
		   <argument><expr><literal type="string">"Type"</literal></expr></argument>, <argument><expr><literal type="string">"N"</literal></expr></argument>, <argument><expr><literal type="string">"(%)"</literal></expr></argument>, <argument><expr><literal type="string">"Record size"</literal></expr></argument>, <argument><expr><literal type="string">"(%)"</literal></expr></argument>, <argument><expr><literal type="string">"FPI size"</literal></expr></argument>, <argument><expr><literal type="string">"(%)"</literal></expr></argument>, <argument><expr><literal type="string">"Combined size"</literal></expr></argument>, <argument><expr><literal type="string">"(%)"</literal></expr></argument>,
		   <argument><expr><literal type="string">"----"</literal></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><literal type="string">"---"</literal></expr></argument>, <argument><expr><literal type="string">"-----------"</literal></expr></argument>, <argument><expr><literal type="string">"---"</literal></expr></argument>, <argument><expr><literal type="string">"--------"</literal></expr></argument>, <argument><expr><literal type="string">"---"</literal></expr></argument>, <argument><expr><literal type="string">"-------------"</literal></expr></argument>, <argument><expr><literal type="string">"---"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>ri</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ri</name> <operator>&lt;</operator> <name>RM_NEXT_ID</name></expr>;</condition> <incr><expr><name>ri</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>count</name></decl>,
					<decl><type ref="prev"/><name>rec_len</name></decl>,
					<decl><type ref="prev"/><name>fpi_len</name></decl>,
					<decl><type ref="prev"/><name>tot_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>RmgrDescData</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>&amp;</operator><name><name>RmgrDescTable</name><index>[<expr><name>ri</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>config</name><operator>-&gt;</operator><name>stats_per_record</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>rmgr_stats</name><index>[<expr><name>ri</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rec_len</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>rmgr_stats</name><index>[<expr><name>ri</name></expr>]</index></name><operator>.</operator><name>rec_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>fpi_len</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>rmgr_stats</name><index>[<expr><name>ri</name></expr>]</index></name><operator>.</operator><name>fpi_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tot_len</name> <operator>=</operator> <name>rec_len</name> <operator>+</operator> <name>fpi_len</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogDumpStatsRow</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rm_name</name></name></expr></argument>,
							 <argument><expr><name>count</name></expr></argument>, <argument><expr><name>total_count</name></expr></argument>, <argument><expr><name>rec_len</name></expr></argument>, <argument><expr><name>total_rec_len</name></expr></argument>,
							 <argument><expr><name>fpi_len</name></expr></argument>, <argument><expr><name>total_fpi_len</name></expr></argument>, <argument><expr><name>tot_len</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>rj</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rj</name> <operator>&lt;</operator> <name>MAX_XLINFO_TYPES</name></expr>;</condition> <incr><expr><name>rj</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>record_stats</name><index>[<expr><name>ri</name></expr>]</index><index>[<expr><name>rj</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>rec_len</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>record_stats</name><index>[<expr><name>ri</name></expr>]</index><index>[<expr><name>rj</name></expr>]</index></name><operator>.</operator><name>rec_len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>fpi_len</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>record_stats</name><index>[<expr><name>ri</name></expr>]</index><index>[<expr><name>rj</name></expr>]</index></name><operator>.</operator><name>fpi_len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tot_len</name> <operator>=</operator> <name>rec_len</name> <operator>+</operator> <name>fpi_len</name></expr>;</expr_stmt>

				<comment type="block">/* Skip undefined combinations and ones that didn't occur */</comment>
				<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* the upper four bits in xl_info are the rmgr's */</comment>
				<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name><name>desc</name><operator>-&gt;</operator><name>rm_identify</name></name><argument_list>(<argument><expr><name>rj</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"UNKNOWN (%x)"</literal></expr></argument>, <argument><expr><name>rj</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>XLogDumpStatsRow</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rm_name</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>count</name></expr></argument>, <argument><expr><name>total_count</name></expr></argument>, <argument><expr><name>rec_len</name></expr></argument>, <argument><expr><name>total_rec_len</name></expr></argument>,
								 <argument><expr><name>fpi_len</name></expr></argument>, <argument><expr><name>total_fpi_len</name></expr></argument>, <argument><expr><name>tot_len</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-27s %20s %8s %20s %8s %20s %8s %20s\n"</literal></expr></argument>,
		   <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"--------"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"--------"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"--------"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"--------"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The percentages in earlier rows were calculated against the column
	 * total, but the ones that follow are against the row total. Note that
	 * these are displayed with a % symbol to differentiate them from the
	 * earlier ones, and are thus up to 9 characters long.
	 */</comment>

	<expr_stmt><expr><name>rec_len_pct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rec_len_pct</name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>total_rec_len</name> <operator>/</operator> <name>total_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fpi_len_pct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fpi_len_pct</name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>total_fpi_len</name> <operator>/</operator> <name>total_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-27s "</literal>
		   <literal type="string">"%20"</literal> <name>INT64_MODIFIER</name> <literal type="string">"u %-9s"</literal>
		   <literal type="string">"%20"</literal> <name>INT64_MODIFIER</name> <literal type="string">"u %-9s"</literal>
		   <literal type="string">"%20"</literal> <name>INT64_MODIFIER</name> <literal type="string">"u %-9s"</literal>
		   <literal type="string">"%20"</literal> <name>INT64_MODIFIER</name> <literal type="string">"u %-6s\n"</literal></expr></argument>,
		   <argument><expr><literal type="string">"Total"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
		   <argument><expr><name>total_rec_len</name></expr></argument>, <argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"[%.02f%%]"</literal></expr></argument>, <argument><expr><name>rec_len_pct</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>total_fpi_len</name></expr></argument>, <argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"[%.02f%%]"</literal></expr></argument>, <argument><expr><name>fpi_len_pct</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>total_len</name></expr></argument>, <argument><expr><literal type="string">"[100%]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s decodes and displays PostgreSQL write-ahead logs for debugging.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s [OPTION]... [STARTSEG [ENDSEG]]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -b, --bkp-details      output detailed information about backup blocks\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -e, --end=RECPTR       stop reading at WAL location RECPTR\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -f, --follow           keep retrying after reaching end of WAL\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n, --limit=N          number of records to display\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -p, --path=PATH        directory in which to find log segment files or a\n"</literal>
			 <literal type="string">"                         directory with a ./pg_wal that contains such files\n"</literal>
			 <literal type="string">"                         (default: current directory, ./pg_wal, $PGDATA/pg_wal)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -r, --rmgr=RMGR        only show records generated by resource manager RMGR;\n"</literal>
			 <literal type="string">"                         use --rmgr=list to list valid resource manager names\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s, --start=RECPTR     start reading at WAL location RECPTR\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -t, --timeline=TLI     timeline from which to read log records\n"</literal>
			 <literal type="string">"                         (default: 1 or the value used in STARTSEG)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version          output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -x, --xid=XID          only show records with transaction ID XID\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -z, --stats[=record]   show statistics instead of records\n"</literal>
			 <literal type="string">"                         (optionally, show per-record statistics)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help             show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nReport bugs to &lt;pgsql-bugs@lists.postgresql.org&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>xlogid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>xrecoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogDumpPrivate</name></type> <name>private</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogDumpConfig</name></type> <name>config</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogDumpStats</name></type> <name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>first_record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"bkp-details"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'b'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"end"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'e'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"follow"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'f'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'?'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"limit"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"path"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"rmgr"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'r'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"start"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"timeline"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"xid"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'x'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"stats"</literal></expr>, <expr><name>optional_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'z'</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>optindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_logging_init</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"pg_waldump"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"pg_waldump (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>private</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogDumpPrivate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>config</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogDumpConfig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogDumpStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>private</name><operator>.</operator><name>timeline</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private</name><operator>.</operator><name>endptr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private</name><operator>.</operator><name>endptr_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>bkp_details</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>stop_after_records</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>already_displayed_records</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>follow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>filter_by_rmgr</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>filter_by_xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>filter_by_xid_enabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>stats</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>stats_per_record</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"no arguments specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>bad_argument</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>option</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"be:fn:p:r:s:t:x:z"</literal></expr></argument>,
								 <argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>option</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
				<expr_stmt><expr><name><name>config</name><operator>.</operator><name>bkp_details</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>xlogid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xrecoff</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not parse end WAL location \"%s\""</literal></expr></argument>,
								 <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>private</name><operator>.</operator><name>endptr</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>xlogid</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>xrecoff</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><name><name>config</name><operator>.</operator><name>follow</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>.</operator><name>stop_after_records</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not parse limit \"%s\""</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<expr_stmt><expr><name><name>private</name><operator>.</operator><name>inpath</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>print_rmgr_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>RM_MAX_ID</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name><name>RmgrDescTable</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>config</name><operator>.</operator><name>filter_by_rmgr</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>

					<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>filter_by_rmgr</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"resource manager \"%s\" does not exist"</literal></expr></argument>,
									 <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>bad_argument</name>;</goto>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>xlogid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xrecoff</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not parse start WAL location \"%s\""</literal></expr></argument>,
								 <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>xlogid</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>xrecoff</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>private</name><operator>.</operator><name>timeline</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not parse timeline \"%s\""</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'x'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>.</operator><name>filter_by_xid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not parse \"%s\" as a transaction ID"</literal></expr></argument>,
								 <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>config</name><operator>.</operator><name>filter_by_xid_enabled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'z'</literal></expr>:</case>
				<expr_stmt><expr><name><name>config</name><operator>.</operator><name>stats</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>config</name><operator>.</operator><name>stats_per_record</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>optarg</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"record"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>config</name><operator>.</operator><name>stats_per_record</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"rmgr"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"unrecognized argument to --stats: %s"</literal></expr></argument>,
									 <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>bad_argument</name>;</goto>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<goto>goto <name>bad_argument</name>;</goto>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>optind</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"too many command-line arguments (first is \"%s\")"</literal></expr></argument>,
					 <argument><expr><name><name>argv</name><index>[<expr><name>optind</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>bad_argument</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>private</name><operator>.</operator><name>inpath</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* validate path points to directory */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_directory</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"path \"%s\" could not be opened: %s"</literal></expr></argument>,
						 <argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>bad_argument</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* parse files as start/end boundaries, extract path if not specified */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>directory</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>segno</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>split_path</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>directory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>private</name><operator>.</operator><name>inpath</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>directory</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>.</operator><name>inpath</name></name> <operator>=</operator> <name>directory</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_directory</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not open directory \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>identify_target_directory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>private</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open_file_in_directory</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\""</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* parse position from file */</comment>
		<expr_stmt><expr><call><name>XLogFromFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>private</name><operator>.</operator><name>timeline</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segno</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>XLByteInSeg</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"start WAL location %X/%X is not inside file \"%s\""</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>,
						 <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>bad_argument</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* no second file specified, set end position */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>optind</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>argc</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>endptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>segno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>endptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* parse ENDSEG if passed */</comment>
		<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>endsegno</name></decl>;</decl_stmt>

			<comment type="block">/* ignore directory, already have that */</comment>
			<expr_stmt><expr><call><name>split_path</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>directory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open_file_in_directory</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\""</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* parse position from file */</comment>
			<expr_stmt><expr><call><name>XLogFromFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>private</name><operator>.</operator><name>timeline</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endsegno</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>endsegno</name> <operator>&lt;</operator> <name>segno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"ENDSEG %s is before STARTSEG %s"</literal></expr></argument>,
							<argument><expr><name><name>argv</name><index>[<expr><name>optind</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>endptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>endsegno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>,
										<argument><expr><name><name>private</name><operator>.</operator><name>endptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* set segno to endsegno for check of --end */</comment>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <name>endsegno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>


		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLByteInSeg</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>endptr</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>private</name><operator>.</operator><name>endptr</name></name> <operator>!=</operator> <operator>(</operator><name>segno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>WalSegSz</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"end WAL location %X/%X is not inside file \"%s\""</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>private</name><operator>.</operator><name>endptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>private</name><operator>.</operator><name>endptr</name></name></expr></argument>,
						 <argument><expr><name><name>argv</name><index>[<expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>bad_argument</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>identify_target_directory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>private</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* we don't know what to print */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"no start WAL location given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>bad_argument</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* done with argument parsing, do the actual work */</comment>

	<comment type="block">/* we have everything we need, start reading */</comment>
	<expr_stmt><expr><name>xlogreader_state</name> <operator>=</operator> <call><name>XLogReaderAllocate</name><argument_list>(<argument><expr><name>WalSegSz</name></expr></argument>, <argument><expr><name>XLogDumpReadPage</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlogreader_state</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* first find a valid recptr to start from */</comment>
	<expr_stmt><expr><name>first_record</name> <operator>=</operator> <call><name>XLogFindNextRecord</name><argument_list>(<argument><expr><name>xlogreader_state</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>first_record</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not find a valid record after %X/%X"</literal></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Display a message that we're skipping data if `from` wasn't a pointer
	 * to the start of a record and also wasn't a pointer to the beginning of
	 * a segment (e.g. we were used in file mode).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>first_record</name> <operator>!=</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>&amp;&amp;</operator>
		<call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"first record is after %X/%X, at %X/%X, skipping over %u byte\n"</literal></expr></argument>,
						<argument><expr><literal type="string">"first record is after %X/%X, at %X/%X, skipping over %u bytes\n"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>first_record</name> <operator>-</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>,
			   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>first_record</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>first_record</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>first_record</name> <operator>-</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* try to read the next record */</comment>
		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>xlogreader_state</name></expr></argument>, <argument><expr><name>first_record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>record</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>config</name><operator>.</operator><name>follow</name></name> <operator>||</operator> <name><name>private</name><operator>.</operator><name>endptr_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* 1 second */</comment>
				<continue>continue;</continue>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* after reading the first record, continue at next one */</comment>
		<expr_stmt><expr><name>first_record</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

		<comment type="block">/* apply all specified filters */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>filter_by_rmgr</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<name><name>config</name><operator>.</operator><name>filter_by_rmgr</name></name> <operator>!=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>filter_by_xid_enabled</name></name> <operator>&amp;&amp;</operator>
			<name><name>config</name><operator>.</operator><name>filter_by_xid</name></name> <operator>!=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_xid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* process the record */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>stats</name></name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogDumpCountRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name>config</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>, <argument><expr><name>xlogreader_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogDumpDisplayRecord</name><argument_list>(<argument><expr><operator>&amp;</operator><name>config</name></expr></argument>, <argument><expr><name>xlogreader_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* check whether we printed enough */</comment>
		<expr_stmt><expr><name><name>config</name><operator>.</operator><name>already_displayed_records</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>stop_after_records</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>config</name><operator>.</operator><name>already_displayed_records</name></name> <operator>&gt;=</operator> <name><name>config</name><operator>.</operator><name>stop_after_records</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>stats</name></name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogDumpDisplayStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name>config</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errormsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"error in WAL record at %X/%X: %s"</literal></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>xlogreader_state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>xlogreader_state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>,
					<argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>XLogReaderFree</name><argument_list>(<argument><expr><name>xlogreader_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>EXIT_SUCCESS</name></expr>;</return>

<label><name>bad_argument</name>:</label>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
</block_content>}</block></function>
</unit>
