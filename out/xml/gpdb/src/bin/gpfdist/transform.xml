<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/bin/gpfdist/transform.c"><cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/* don't build this for now */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transform.h"</cpp:file></cpp:include>

<comment type="block">/*
 * debugging/dumping/error handling
 */</comment>

<function><type><name>char</name><modifier>*</modifier></type>
<name>event_type</name><parameter_list>(<parameter><decl><type><name>yaml_event_t</name><modifier>*</modifier></type> <name>ep</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <switch>switch <condition>(<expr><name><name>ep</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> 
	<block>{<block_content>
        <case>case <expr><name>YAML_NO_EVENT</name></expr>:</case>             <return>return<expr><operator>(</operator><literal type="string">"YAML_NO_EVENT\n"</literal><operator>)</operator></expr>;</return>              <break>break;</break>
        <case>case <expr><name>YAML_STREAM_START_EVENT</name></expr>:</case>   <return>return<expr><operator>(</operator><literal type="string">"YAML_STREAM_START_EVENT\n"</literal><operator>)</operator></expr>;</return>    <break>break;</break>
        <case>case <expr><name>YAML_STREAM_END_EVENT</name></expr>:</case>     <return>return<expr><operator>(</operator><literal type="string">"YAML_STREAM_END_EVENT\n"</literal><operator>)</operator></expr>;</return>      <break>break;</break>
        <case>case <expr><name>YAML_DOCUMENT_START_EVENT</name></expr>:</case> <return>return<expr><operator>(</operator><literal type="string">"YAML_DOCUMENT_START_EVENT\n"</literal><operator>)</operator></expr>;</return>  <break>break;</break>
        <case>case <expr><name>YAML_DOCUMENT_END_EVENT</name></expr>:</case>   <return>return<expr><operator>(</operator><literal type="string">"YAML_DOCUMENT_END_EVENT\n"</literal><operator>)</operator></expr>;</return>    <break>break;</break>
        <case>case <expr><name>YAML_ALIAS_EVENT</name></expr>:</case>          <return>return<expr><operator>(</operator><literal type="string">"YAML_ALIAS_EVENT\n"</literal><operator>)</operator></expr>;</return>           <break>break;</break>
        <case>case <expr><name>YAML_SCALAR_EVENT</name></expr>:</case>         <return>return<expr><operator>(</operator><literal type="string">"YAML_SCALAR_EVENT\n"</literal><operator>)</operator></expr>;</return>          <break>break;</break>
        <case>case <expr><name>YAML_SEQUENCE_START_EVENT</name></expr>:</case> <return>return<expr><operator>(</operator><literal type="string">"YAML_SEQUENCE_START_EVENT\n"</literal><operator>)</operator></expr>;</return>  <break>break;</break>
        <case>case <expr><name>YAML_SEQUENCE_END_EVENT</name></expr>:</case>   <return>return<expr><operator>(</operator><literal type="string">"YAML_SEQUENCE_END_EVENT\n"</literal><operator>)</operator></expr>;</return>    <break>break;</break>
        <case>case <expr><name>YAML_MAPPING_START_EVENT</name></expr>:</case>  <return>return<expr><operator>(</operator><literal type="string">"YAML_MAPPING_START_EVENT\n"</literal><operator>)</operator></expr>;</return>   <break>break;</break>
        <case>case <expr><name>YAML_MAPPING_END_EVENT</name></expr>:</case>    <return>return<expr><operator>(</operator><literal type="string">"YAML_MAPPING_END_EVENT\n"</literal><operator>)</operator></expr>;</return>     <break>break;</break>
        <default>default:</default>                        <return>return<expr><operator>(</operator><literal type="string">"unknown event\n"</literal><operator>)</operator></expr>;</return>              <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>debug_event_type</name><parameter_list>(<parameter><decl><type><name>yaml_event_t</name><modifier>*</modifier></type> <name>ep</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>event_type</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* forward decl for debug_keyvalue */</comment>
<function_decl><type><name>void</name></type> 
<name>debug_mapping</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mapping</name></name><modifier>*</modifier></type> <name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indent</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>debug_keyvalue</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%*s%s: "</literal></expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>kv</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>KV_SCALAR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else 
    <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>kv</name><operator>-&gt;</operator><name>map</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>debug_mapping</name><argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><name>indent</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>debug_mapping</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mapping</name></name><modifier>*</modifier></type> <name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>kv</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>kvlist</name></name></expr>;</init> <condition><expr><name>kv</name></expr>;</condition> <incr><expr><name>kv</name><operator>=</operator><name><name>kv</name><operator>-&gt;</operator><name>nxt</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>debug_keyvalue</name><argument_list>(<argument><expr><name>kv</name></expr></argument>, <argument><expr><name>indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>


<comment type="block">/*
 * yaml structural parse errors
 */</comment>

<function><type><name>int</name></type>
<name>unexpected_event</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%zu:%zu:unexpected event: %s\n"</literal></expr></argument>,
			<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, 
			<argument><expr><call><name>event_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stp</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_parser_initialize_failed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:0:0:yaml_parser_initialize failed\n"</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_parser_parse_failed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%zu:%zu:yaml_parser_parse failed\n"</literal></expr></argument>,
           <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_invalid_stream_start</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%zu:%zu:stream_start_event but stream has already been started\n"</literal></expr></argument>,
			<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_stream_not_started</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>what</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%zu:%zu:%s but stream has not been started\n"</literal></expr></argument>,
			<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_invalid_document_start</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%zu:%zu:document_start but already within a document\n"</literal></expr></argument>,
			<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_document_not_started</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>what</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%zu:%zu:%s but not within a document\n"</literal></expr></argument>,
			<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_no_current_mapping</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>what</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%zu:%zu:%s but not within a mapping\n"</literal></expr></argument>,
			<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * parse tree construction
 */</comment>

<function><type><name>char</name><modifier>*</modifier></type> 
<name>copy_scalar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>src</name>  <init>= <expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>data</name><operator>.</operator><name>scalar</name><operator>.</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>         <name>len</name>  <init>= <expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>data</name><operator>.</operator><name>scalar</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>          <name>copy</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition> 
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>copy</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, 
				 <argument><expr><literal type="string">"%s:%zu:%zu:allocation failed for malloc(%zu)"</literal></expr></argument>, 
                 <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>copy</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type>
<name>new_keyvalue</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>nxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>keyvalue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>kv</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>kv</name><operator>-&gt;</operator><name>nxt</name></name> <operator>=</operator> <name>nxt</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, 
				 <argument><expr><literal type="string">"%s:%zu:%zu:allocation failed for calloc(1, sizeof(struct keyvalue))"</literal></expr></argument>,
                 <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>kv</name></expr>;</return>


</block_content>}</block></function>

<function><type><name><name>struct</name> <name>mapping</name></name><modifier>*</modifier></type>
<name>new_mapping</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mapping</name></name><modifier>*</modifier></type> <name>nxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>mapping</name></name><modifier>*</modifier></type> <name>map</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>mapping</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>nxt</name></name> <operator>=</operator> <name>nxt</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, 
				 <argument><expr><literal type="string">"%s:%zu:%zu:allocation failed for calloc(1, sizeof(struct mapping))"</literal></expr></argument>,
                 <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>map</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>handle_mapping_start</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>curmap</name></name> <operator>=</operator> <call><name>new_mapping</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>curmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>stp</name><operator>-&gt;</operator><name>curmap</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name> <init>= <expr><name><name>stp</name><operator>-&gt;</operator><name>curkv</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>kv</name></expr>)</condition> 
    <block>{<block_content>
        <comment type="block">/*
         * this mapping is the value for the current keyvalue
         */</comment>
        <expr_stmt><expr><name><name>kv</name><operator>-&gt;</operator><name>type</name></name>      <operator>=</operator> <name>KV_MAPPING</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>kv</name><operator>-&gt;</operator><name>map</name></name>       <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>curmap</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>kv</name><operator>-&gt;</operator><name>valuemark</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>curkv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if> 
    <else>else 
    <block>{<block_content>
        <comment type="block">/*
         * this mapping is the top level document.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>stp</name><operator>-&gt;</operator><name>document</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>document</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>curmap</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>handle_mapping_end</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>curmap</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>curmap</name><operator>-&gt;</operator><name>nxt</name></name></expr>;</expr_stmt> <comment type="block">/* pop mapping from stack */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>handle_scalar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>mapping</name></name><modifier>*</modifier></type>  <name>map</name> <init>= <expr><name><name>stp</name><operator>-&gt;</operator><name>curmap</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name>  <init>= <expr><name><name>stp</name><operator>-&gt;</operator><name>curkv</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>kv</name></expr>)</condition> 
    <block>{<block_content>
        <comment type="block">/*
         * this scalar is the value for current keyvalue
         */</comment>
        <expr_stmt><expr><name><name>kv</name><operator>-&gt;</operator><name>type</name></name>         <operator>=</operator> <name>KV_SCALAR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name>       <operator>=</operator> <call><name>copy_scalar</name><argument_list>(<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>kv</name><operator>-&gt;</operator><name>valuemark</name></name>    <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>curkv</name></name>       <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if> 
    <else>else 
    <block>{<block_content>
        <comment type="block">/*
         * this scalar is the name of a new keyvalue pair
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>data</name><operator>.</operator><name>scalar</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <name>MAX_KEYLEN</name></expr>)</condition> 
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, 
					 <argument><expr><literal type="string">"%s:%zu:%zu:key name exceeds maximum length %d"</literal></expr></argument>,
                     <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>MAX_KEYLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>kv</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>curkv</name></name>  <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>kvlist</name></name> <operator>=</operator> <call><name>new_keyvalue</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>kvlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator> <name>kv</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>kv</name><operator>-&gt;</operator><name>key</name></name>          <operator>=</operator> <call><name>copy_scalar</name><argument_list>(<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>kv</name><operator>-&gt;</operator><name>key</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name>      <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>start_mark</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>stage1_parse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>, <parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>done</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>yaml_parser_initialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stp</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>rc</name></expr>)</condition><block type="pseudo"><block_content> 
		<return>return <expr><call><name>error_parser_initialize_failed</name><argument_list>(<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>yaml_parser_set_input_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stp</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition> 
    <block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>yaml_parser_parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stp</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stp</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rc</name></expr>)</condition> 
		<block>{<block_content>
			<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>error_parser_parse_failed</name><argument_list>(<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>debug_event_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stp</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>event</name><operator>.</operator><name>type</name></name></expr>)</condition> 
        <block>{<block_content>
            <case>case <expr><name>YAML_STREAM_START_EVENT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>stream_start</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_invalid_stream_start</name><argument_list>(<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>stream_start</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>YAML_DOCUMENT_START_EVENT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>document_start</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_invalid_document_start</name><argument_list>(<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>document_start</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>YAML_MAPPING_START_EVENT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>stp</name><operator>-&gt;</operator><name>stream_start</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_stream_not_started</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><literal type="string">"mapping_start_event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator> <name><name>stp</name><operator>-&gt;</operator><name>document_start</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_document_not_started</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><literal type="string">"mapping_start_event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>handle_mapping_start</name><argument_list>(<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>


            <case>case <expr><name>YAML_MAPPING_END_EVENT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>stp</name><operator>-&gt;</operator><name>stream_start</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_stream_not_started</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><literal type="string">"mapping_end_event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator> <name><name>stp</name><operator>-&gt;</operator><name>document_start</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_document_not_started</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><literal type="string">"mapping_end_event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>curmap</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_no_current_mapping</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><literal type="string">"mapping_end_event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>handle_mapping_end</name><argument_list>(<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>YAML_SCALAR_EVENT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>stp</name><operator>-&gt;</operator><name>stream_start</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_stream_not_started</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><literal type="string">"scalar_event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator> <name><name>stp</name><operator>-&gt;</operator><name>document_start</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_document_not_started</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><literal type="string">"scalar_event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>curmap</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_no_current_mapping</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><literal type="string">"scalar_event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>handle_scalar</name><argument_list>(<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>YAML_DOCUMENT_END_EVENT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>stp</name><operator>-&gt;</operator><name>stream_start</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_stream_not_started</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><literal type="string">"document_end_event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator> <name><name>stp</name><operator>-&gt;</operator><name>document_start</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_document_not_started</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><literal type="string">"document_end_event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>document_start</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>YAML_STREAM_END_EVENT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>stp</name><operator>-&gt;</operator><name>stream_start</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>error_stream_not_started</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><literal type="string">"stream_end_event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>stream_start</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unexpected_event</name><argument_list>(<argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <expr_stmt><expr><call><name>yaml_event_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stp</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rc</name></expr>)</condition> 
        <block>{<block_content>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>yaml_parser_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stp</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>error</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * debugging/dumping/error handling
 */</comment>

<function><type><name>void</name></type>
<name>dump_transform</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>tr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s:\n"</literal></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  TYPE: %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>tr</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TR_INPUT</name></expr> ?</condition><then> <expr><literal type="string">"input"</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>tr</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TR_OUTPUT</name></expr> ?</condition><then> <expr><literal type="string">"output"</literal></expr> </then><else>: <expr><literal type="string">"unknown"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  COMMAND: %s\n"</literal></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  STDERR: %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>tr</name><operator>-&gt;</operator><name>errs</name></name> <operator>==</operator> <name>TR_ER_CONSOLE</name></expr> ?</condition><then> <expr><literal type="string">"console"</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>tr</name><operator>-&gt;</operator><name>errs</name></name> <operator>==</operator> <name>TR_ER_SERVER</name></expr> ?</condition><then> <expr><literal type="string">"server"</literal></expr> </then><else>: <expr><literal type="string">"unknown"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  CONTENTS: %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>tr</name><operator>-&gt;</operator><name>content</name></name> <operator>==</operator> <name>TR_FN_DATA</name></expr> ?</condition><then> <expr><literal type="string">"data"</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>tr</name><operator>-&gt;</operator><name>content</name></name> <operator>==</operator> <name>TR_FN_PATHS</name></expr> ?</condition><then> <expr><literal type="string">"paths"</literal></expr> </then><else>: <expr><literal type="string">"unknown"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tr</name><operator>-&gt;</operator><name>safe</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  SAFE: %s\n"</literal></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>debug_transforms</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>trlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>tr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"TRANSFORMATIONS:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>tr</name> <operator>=</operator> <name>trlist</name></expr>;</init> <condition><expr><name>tr</name></expr>;</condition> <incr><expr><name>tr</name><operator>=</operator><name><name>tr</name><operator>-&gt;</operator><name>nxt</name></name></expr></incr>)</control><block type="pseudo"><block_content> 
		<expr_stmt><expr><call><name>dump_transform</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>format_onlyfilename</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>format_key1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>yaml_mark_t</name></type> <name>mark</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>format_key2</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>yaml_mark_t</name></type> <name>mark</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>mark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>mark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_failed_to_find_transformations</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>format_onlyfilename</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><literal type="string">"%s:0:0:failed to find TRANSFORMATIONS"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_transformations_not_proper_yaml_map</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"key '%s' is not a proper YAML map\n"</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>format_key1</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_transformation_not_proper_yaml_map</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': not a proper YAML map\n"</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>format_key1</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_failed_to_find_type_for_transformation</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': failed to find TYPE\n"</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>format_key1</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_transformation_type_not_scalar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>trkv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': TYPE not a scalar (expected TYPE:input or TYPE:output)\n"</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>format_key1</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>trkv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_invalid_type_for_transformation</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>trkv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': invalid TYPE: '%s' (expected TYPE:input or TYPE:output)\n"</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>format_key2</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>trkv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_failed_to_find_command_for_transformation</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': failed to find COMMAND\n"</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>format_key1</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_invalid_command_for_transformation</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>trkv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': invalid COMMAND (expected a simple non-empty string)\n"</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>format_key1</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>trkv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_stderr_not_scalar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>trkv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': STDERR not a scalar (expected a simple non-empty string)\n"</literal></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>format_key1</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>trkv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_invalid_stderr_for_transformation</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>trkv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': invalid STDERR (expected STDERR:console or STDERR:server)\n"</literal></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>format_key1</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>trkv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_content_not_scalar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>trkv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': CONTENT not a scalar (expected CONTENT:data or CONTENT:paths)\n"</literal></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>format_key1</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>trkv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_invalid_content_for_transformation</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>trkv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': invalid CONTENT (expected CONTENT:data or CONTENT:paths)\n"</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>format_key1</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>trkv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_safe_not_scalar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>trkv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': SAFE not a scalar (expected a simple non-empty string)\n"</literal></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>format_key1</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>trkv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>error_safe_not_valid_regex</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>trkv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name> <init>= <expr><name>ERRFMT</name> <literal type="string">"transformation '%s': could not compile SAFE regex: "</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>   <name>len</name> <init>= <expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name><operator>.</operator><name>line</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>keymark</name><operator>.</operator><name>column</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>trkv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>end</name> <init>= <expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>lim</name> <init>= <expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <name>lim</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>regerror</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>lim</name><operator>-</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>end</name><operator>++</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>end</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transform validation and construction
 */</comment>

<function><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type>
<name>new_transform</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>nxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>tr</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>transform</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>tr</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>nxt</name></name> <operator>=</operator> <name>nxt</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>psp</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, 
				 <argument><expr><literal type="string">"%s:0:0:allocation failed for calloc(1, sizeof(struct transform))\n"</literal></expr></argument>,
                 <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>tr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type>
<name>find_keyvalue</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kvlist</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>kv</name> <operator>=</operator> <name>kvlist</name></expr>;</init> <condition><expr><name>kv</name></expr>;</condition> <incr><expr><name>kv</name><operator>=</operator><name><name>kv</name><operator>-&gt;</operator><name>nxt</name></name></expr></incr>)</control> 
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>kv</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>validate_transform</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>tr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mapping</name></name><modifier>*</modifier></type> <name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>kv</name> <operator>=</operator> <call><name>find_keyvalue</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>kvlist</name></name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator> <name>kv</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>error_failed_to_find_type_for_transformation</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>kv</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>KV_SCALAR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>error_transformation_type_not_scalar</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr></argument>, <argument><expr><literal type="string">"input"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TR_INPUT</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr></argument>, <argument><expr><literal type="string">"output"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TR_OUTPUT</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>error_invalid_type_for_transformation</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
    
    <expr_stmt><expr><name>kv</name> <operator>=</operator> <call><name>find_keyvalue</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>kvlist</name></name></expr></argument>, <argument><expr><literal type="string">"COMMAND"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator> <name>kv</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>error_failed_to_find_command_for_transformation</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>kv</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>KV_SCALAR</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>error_invalid_command_for_transformation</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>command</name></name> <operator>=</operator> <name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>kv</name> <operator>=</operator> <call><name>find_keyvalue</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>kvlist</name></name></expr></argument>, <argument><expr><literal type="string">"STDERR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>kv</name></expr>)</condition> 
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>kv</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>KV_SCALAR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>error_stderr_not_scalar</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr></argument>, <argument><expr><literal type="string">"console"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>errs</name></name> <operator>=</operator> <name>TR_ER_CONSOLE</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr></argument>, <argument><expr><literal type="string">"server"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>errs</name></name> <operator>=</operator> <name>TR_ER_SERVER</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><call><name>error_invalid_stderr_for_transformation</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* 'server' is the default when stderr is not specified */</comment>
		<expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>errs</name></name> <operator>=</operator> <name>TR_ER_SERVER</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>kv</name> <operator>=</operator> <call><name>find_keyvalue</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>kvlist</name></name></expr></argument>, <argument><expr><literal type="string">"CONTENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>kv</name></expr>)</condition> 
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>kv</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>KV_SCALAR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>error_content_not_scalar</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr></argument>, <argument><expr><literal type="string">"data"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>content</name></name> <operator>=</operator> <name>TR_FN_DATA</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr></argument>, <argument><expr><literal type="string">"paths"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>content</name></name> <operator>=</operator> <name>TR_FN_PATHS</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><call><name>error_invalid_content_for_transformation</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* 'data' is the default when filename_contents is not specified */</comment>
		<expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>content</name></name> <operator>=</operator> <name>TR_FN_DATA</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>kv</name> <operator>=</operator> <call><name>find_keyvalue</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>kvlist</name></name></expr></argument>, <argument><expr><literal type="string">"SAFE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>kv</name></expr>)</condition> 
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>kv</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>KV_SCALAR</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>error_safe_not_scalar</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>safe</name></name> <operator>=</operator> <name><name>kv</name><operator>-&gt;</operator><name>scalar</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>regcomp</name><argument_list>( <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tr</name><operator>-&gt;</operator><name>saferegex</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>safe</name></name></expr></argument>, <argument><expr><name>REG_EXTENDED</name><operator>|</operator><name>REG_NOSUB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>error_safe_not_valid_regex</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><name>kv</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tr</name><operator>-&gt;</operator><name>saferegex</name></name><operator>)</operator></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>validate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsestate</name></name><modifier>*</modifier></type> <name>psp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>streamstate</name></name><modifier>*</modifier></type> <name>stp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>mapping</name></name><modifier>*</modifier></type>  <name>document</name>  <init>= <expr><name><name>stp</name><operator>-&gt;</operator><name>document</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>mapping</name></name><modifier>*</modifier></type>  <name>trmapping</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>keyvalue</name></name><modifier>*</modifier></type> <name>kv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>kv</name> <operator>=</operator> <call><name>find_keyvalue</name><argument_list>(<argument><expr><name><name>document</name><operator>-&gt;</operator><name>kvlist</name></name></expr></argument>, <argument><expr><literal type="string">"TRANSFORMATIONS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator> <name>kv</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>error_failed_to_find_transformations</name><argument_list>(<argument><expr><name>psp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>kv</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>KV_MAPPING</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>error_transformations_not_proper_yaml_map</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>trmapping</name> <operator>=</operator> <name><name>kv</name><operator>-&gt;</operator><name>map</name></name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>kv</name> <operator>=</operator> <name><name>trmapping</name><operator>-&gt;</operator><name>kvlist</name></name></expr>;</init> <condition><expr><name>kv</name></expr>;</condition> <incr><expr><name>kv</name><operator>=</operator><name><name>kv</name><operator>-&gt;</operator><name>nxt</name></name></expr></incr>)</control> 
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>kv</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>KV_MAPPING</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>error_transformation_not_proper_yaml_map</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    
        <decl_stmt><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>tr</name> <init>= <expr><name><name>psp</name><operator>-&gt;</operator><name>trlist</name></name> <operator>=</operator> <call><name>new_transform</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name><name>psp</name><operator>-&gt;</operator><name>trlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name></name> <operator>=</operator> <name>kv</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>validate_transform</name><argument_list>(<argument><expr><name>psp</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * configure transforms
 */</comment>

<function><type><name>int</name></type>
<name>transform_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier><modifier>*</modifier></type> <name>trlistp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>parsestate</name></name></type> <name>ps</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ps</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ps</name><operator>.</operator><name>filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>file</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name><name>ps</name><operator>.</operator><name>filename</name></name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>file</name></expr>)</condition> 
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unable to open file %s: %s\n"</literal></expr></argument>, <argument><expr><name><name>ps</name><operator>.</operator><name>filename</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>streamstate</name></name></type> <name>st</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>st</name><operator>.</operator><name>filename</name></name> <operator>=</operator> <name><name>ps</name><operator>.</operator><name>filename</name></name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>stage1_parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>verbose</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content> 
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to parse file: %s\n"</literal></expr></argument>, <argument><expr><name><name>ps</name><operator>.</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>||</operator> <name>verbose</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>document</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>debug_mapping</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>document</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>validate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to validate file: %s\n"</literal></expr></argument>, <argument><expr><name><name>ps</name><operator>.</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>ps</name><operator>.</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>trlistp</name><operator>)</operator> <operator>=</operator> <name><name>ps</name><operator>.</operator><name>trlist</name></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * lookup transformation
 */</comment>

<function><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type>
<name>transform_lookup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>trlist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>for_write</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>tr</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>tr</name> <operator>=</operator> <name>trlist</name></expr>;</init> <condition><expr><name>tr</name></expr>;</condition> <incr><expr><name>tr</name> <operator>=</operator> <name><name>tr</name><operator>-&gt;</operator><name>nxt</name></name></expr></incr>)</control>
    <block>{<block_content>

        <comment type="block">/* ignore transforms not of proper type */</comment>
        <if_stmt><if>if <condition>(<expr><name>for_write</name></expr>)</condition> 
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>tr</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>TR_OUTPUT</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if> 
        <else>else 
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>tr</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>TR_INPUT</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* when we've found a match, return the corresponding command */</comment>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>kv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> 
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>dump_transform</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <return>return <expr><name>tr</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformation accessors
 */</comment>

<function><type><name>char</name><modifier>*</modifier></type>
<name>transform_command</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>tr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>tr</name><operator>-&gt;</operator><name>command</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>transform_stderr_server</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>tr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>tr</name><operator>-&gt;</operator><name>errs</name></name> <operator>==</operator> <name>TR_ER_SERVER</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>transform_content_paths</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>tr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>tr</name><operator>-&gt;</operator><name>content</name></name> <operator>==</operator> <name>TR_FN_PATHS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type>
<name>transform_safe</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>tr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>tr</name><operator>-&gt;</operator><name>safe</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>regex_t</name><modifier>*</modifier></type>
<name>transform_saferegex</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transform</name></name><modifier>*</modifier></type> <name>tr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><operator>(</operator><name><name>tr</name><operator>-&gt;</operator><name>saferegex</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
