<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/bin/pg_upgrade/greenplum/check_gp.c"><comment type="block">/*
 *	check_gp.c
 *
 *	Greenplum specific server checks and output routines
 *
 *	Any compatibility checks which are version dependent (testing for issues in
 *	specific versions of Greenplum) should be placed in their respective
 *	version_old_gpdb{MAJORVERSION}.c file.  The checks in this file supplement
 *	the checks present in check.c, which is the upstream file for performing
 *	checks against a PostgreSQL cluster.
 *
 *	Copyright (c) 2010, PostgreSQL Global Development Group
 *	Copyright (c) 2017-Present VMware, Inc. or its affiliates
 *	contrib/pg_upgrade/check_gp.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_upgrade_greenplum.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELSTORAGE_EXTERNAL</name></cpp:macro>	<cpp:value>'x'</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_external_partition</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_covering_aoindex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_partition_indexes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_orphaned_toastrels</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_online_expansion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_gphdfs_external_tables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_gphdfs_user_roles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_for_array_of_partition_table_types</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	check_greenplum
 *
 *	Rather than exporting all checks, we export a single API function which in
 *	turn is responsible for running Greenplum checks. This function should be
 *	executed after all PostgreSQL checks. The order of the checks should not
 *	matter.
 */</comment>
<function><type><name>void</name></type>
<name>check_greenplum</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>check_online_expansion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_external_partition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_covering_aoindex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_partition_indexes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_orphaned_toastrels</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_gphdfs_external_tables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_gphdfs_user_roles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_for_array_of_partition_table_types</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	check_online_expansion
 *
 *	Check for online expansion status and refuse the upgrade if online
 *	expansion is in progress.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_online_expansion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>expansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only need to check cluster expansion status in gpdb6 or later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>old_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">804</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We only need to check the cluster expansion status on master.
	 * On the other hand the status can not be detected correctly on segments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_greenplum_dispatcher_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking for online expansion status"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if the cluster is in expansion status */</comment>
	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>active_db</name> <init>= <expr><operator>&amp;</operator><name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>connectToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
								<argument><expr><literal type="string">"SELECT true AS expansion "</literal>
								<literal type="string">"FROM pg_catalog.gp_distribution_policy d "</literal>
								<literal type="string">"JOIN (SELECT count(*) segcount "</literal>
								<literal type="string">"      FROM pg_catalog.gp_segment_configuration "</literal>
								<literal type="string">"      WHERE content &gt;= 0 and role = 'p') s "</literal>
								<literal type="string">"ON d.numsegments &lt;&gt; s.segcount "</literal>
								<literal type="string">"LIMIT 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expansion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>expansion</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>expansion</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>, <argument><expr><literal type="string">"fatal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gp_fatal_log</name><argument_list>(
			   <argument><expr><literal type="string">"| Your installation is in progress of online expansion,\n"</literal>
			   <literal type="string">"| must complete that job before the upgrade.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	check_external_partition
 *
 *	External tables cannot be included in the partitioning hierarchy during the
 *	initial definition with CREATE TABLE, they must be defined separately and
 *	injected via ALTER TABLE EXCHANGE. The partitioning system catalogs are
 *	however not replicated onto the segments which means ALTER TABLE EXCHANGE
 *	is prohibited in utility mode. This means that pg_upgrade cannot upgrade a
 *	cluster containing external partitions, they must be handled manually
 *	before/after the upgrade.
 *
 *	Check for the existence of external partitions and refuse the upgrade if
 *	found.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_external_partition</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>output_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This was only a problem with GPDB 6 and below.
	 *
	 * GPDB_12_MERGE_FIXME: Could we support upgrading these to GPDB 7,
	 * even though it wasn't possible before? The upstream syntax used in
	 * GPDB 7 to recreate the partition hierarchy is more flexible, and
	 * could possibly handle this. If so, we could remove this check
	 * entirely.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>old_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking for external tables used in partitioning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"external_partitions.txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * We need to query the inheritance catalog rather than the partitioning
	 * catalogs since they are not available on the segments.
	 */</comment>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rowno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>active_db</name> <init>= <expr><operator>&amp;</operator><name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>connectToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
			 <argument><expr><literal type="string">"SELECT cc.relname, c.relname AS partname, c.relnamespace "</literal>
			 <literal type="string">"FROM   pg_inherits i "</literal>
			 <literal type="string">"       JOIN pg_class c ON (i.inhrelid = c.oid AND c.relstorage = '%c') "</literal>
			 <literal type="string">"       JOIN pg_class cc ON (i.inhparent = cc.oid);"</literal></expr></argument>,
			 <argument><expr><name>RELSTORAGE_EXTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>script</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Could not create necessary file:  %s\n"</literal></expr></argument>,
					   <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<for>for <control>(<init><expr><name>rowno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"External partition \"%s\" in relation \"%s\"\n"</literal></expr></argument>,
						<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"partname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>, <argument><expr><literal type="string">"fatal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gp_fatal_log</name><argument_list>(
			   <argument><expr><literal type="string">"| Your installation contains partitioned tables with external\n"</literal>
			   <literal type="string">"| tables as partitions.  These partitions need to be removed\n"</literal>
			   <literal type="string">"| from the partition hierarchy before the upgrade.  A list of\n"</literal>
			   <literal type="string">"| external partitions to remove is in the file:\n"</literal>
			   <literal type="string">"| \t%s\n\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	check_covering_aoindex
 *
 *	A partitioned AO table which had an index created on the parent relation,
 *	and an AO partition exchanged into the hierarchy without any indexes will
 *	break upgrades due to the way pg_dump generates DDL.
 *
 *	create table t (a integer, b text, c integer)
 *		with (appendonly=true)
 *		distributed by (a)
 *		partition by range(c) (start(1) end(3) every(1));
 *	create index t_idx on t (b);
 *
 *	At this point, the t_idx index has created AO blockdir relations for all
 *	partitions. We now exchange a new table into the hierarchy which has no
 *	index defined:
 *
 *	create table t_exch (a integer, b text, c integer)
 *		with (appendonly=true)
 *		distributed by (a);
 *	alter table t exchange partition for (rank(1)) with table t_exch;
 *
 *	The partition which was swapped into the hierarchy with EXCHANGE does not
 *	have any indexes and thus no AO blockdir relation. This is in itself not
 *	a problem, but when pg_dump generates DDL for the above situation it will
 *	create the index in such a way that it covers the entire hierarchy, as in
 *	its original state. The below snippet illustrates the dumped DDL:
 *
 *	create table t ( ... )
 *		...
 *		partition by (... );
 *	create index t_idx on t ( ... );
 *
 *	This creates a problem for the Oid synchronization in pg_upgrade since it
 *	expects to find a preassigned Oid for the AO blockdir relations for each
 *	partition. A longer term solution would be to generate DDL in pg_dump which
 *	creates the current state, but for the time being we disallow upgrades on
 *	cluster which exhibits this.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_covering_aoindex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>			<name><name>output_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>		   <modifier>*</modifier></type><name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>dbnum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking for non-covering indexes on partitioned AO tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"mismatched_aopartition_indexes.txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rowno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>active_db</name> <init>= <expr><operator>&amp;</operator><name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>connectToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
			 <argument><expr><literal type="string">"SELECT DISTINCT ao.relid, inh.inhrelid "</literal>
			 <literal type="string">"FROM   pg_catalog.pg_appendonly ao "</literal>
			 <literal type="string">"       JOIN pg_catalog.pg_inherits inh "</literal>
			 <literal type="string">"         ON (inh.inhparent = ao.relid) "</literal>
			 <literal type="string">"       JOIN pg_catalog.pg_appendonly aop "</literal>
			 <literal type="string">"         ON (inh.inhrelid = aop.relid AND aop.blkdirrelid = 0) "</literal>
			 <literal type="string">"       JOIN pg_catalog.pg_index i "</literal>
			 <literal type="string">"         ON (i.indrelid = ao.relid) "</literal>
			 <literal type="string">"WHERE  ao.blkdirrelid &lt;&gt; 0;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>script</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Could not create necessary file:  %s\n"</literal></expr></argument>,
					   <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<for>for <control>(<init><expr><name>rowno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"Mismatched index on partition %s in relation %s\n"</literal></expr></argument>,
						<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"inhrelid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>, <argument><expr><literal type="string">"fatal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gp_fatal_log</name><argument_list>(
			   <argument><expr><literal type="string">"| Your installation contains partitioned append-only tables\n"</literal>
			   <literal type="string">"| with an index defined on the partition parent which isn't\n"</literal>
			   <literal type="string">"| present on all partition members.  These indexes must be\n"</literal>
			   <literal type="string">"| dropped before the upgrade.  A list of relations, and the\n"</literal>
			   <literal type="string">"| partitions in question is in the file:\n"</literal>
			   <literal type="string">"| \t%s\n\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_orphaned_toastrels</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>			<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>dbnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>			<name><name>output_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>		   <modifier>*</modifier></type><name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking for orphaned TOAST relations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"orphaned_toast_tables.txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>active_db</name> <init>= <expr><operator>&amp;</operator><name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>connectToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
								<argument><expr><literal type="string">"WITH orphan_toast AS ( "</literal>
								<literal type="string">"    SELECT c.oid AS reloid, "</literal>
								<literal type="string">"           c.relname, t.oid AS toastoid, "</literal>
								<literal type="string">"           t.relname AS toastrelname "</literal>
								<literal type="string">"    FROM pg_catalog.pg_class t "</literal>
								<literal type="string">"         LEFT OUTER JOIN pg_catalog.pg_class c ON (c.reltoastrelid = t.oid) "</literal>
								<literal type="string">"    WHERE t.relname ~ '^pg_toast' AND "</literal>
								<literal type="string">"          t.relkind = 't') "</literal>
								<literal type="string">"SELECT reloid "</literal>
								<literal type="string">"FROM   orphan_toast "</literal>
								<literal type="string">"WHERE  reloid IS NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>script</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Could not create necessary file:  %s\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"Database \"%s\" has %d orphaned toast tables\n"</literal></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>, <argument><expr><name>ntups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>, <argument><expr><literal type="string">"fatal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gp_fatal_log</name><argument_list>(
			   <argument><expr><literal type="string">"| Your installation contains orphaned toast tables which\n"</literal>
			   <literal type="string">"| must be dropped before upgrade.\n"</literal>
			   <literal type="string">"| A list of the problem databases is in the file:\n"</literal>
			   <literal type="string">"| \t%s\n\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<comment type="block">/*
 *	check_partition_indexes
 *
 *	There are numerous pitfalls surrounding indexes on partition hierarchies,
 *	so rather than trying to cover all the cornercases we disallow indexes on
 *	partitioned tables altogether during the upgrade.  Since we in any case
 *	invalidate the indexes forcing a REINDEX, there is little to be gained by
 *	handling them for the end-user.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_partition_indexes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>				<name>dbnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>		   <modifier>*</modifier></type><name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>			<name><name>output_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This was only a problem with GPDB 6 and below.
	 *
	 * GPDB_12_MERGE_FIXME: Could we support upgrading these to GPDB 7,
	 * even though it wasn't possible before? The upstream syntax used in
	 * GPDB 7 to recreate the partition hierarchy is more flexible, and
	 * could possibly handle this. If so, we could remove this check
	 * entirely.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>old_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking for indexes on partitioned tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"partitioned_tables_indexes.txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>db_used</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rowno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_nspname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_relname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_indexes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>active_db</name> <init>= <expr><operator>&amp;</operator><name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>connectToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
								<argument><expr><literal type="string">"WITH partitions AS ("</literal>
								<literal type="string">"    SELECT DISTINCT n.nspname, "</literal>
								<literal type="string">"           c.relname "</literal>
								<literal type="string">"    FROM pg_catalog.pg_partition p "</literal>
								<literal type="string">"         JOIN pg_catalog.pg_class c ON (p.parrelid = c.oid) "</literal>
								<literal type="string">"         JOIN pg_catalog.pg_namespace n ON (n.oid = c.relnamespace) "</literal>
								<literal type="string">"    UNION "</literal>
								<literal type="string">"    SELECT n.nspname, "</literal>
								<literal type="string">"           partitiontablename AS relname "</literal>
								<literal type="string">"    FROM pg_catalog.pg_partitions p "</literal>
								<literal type="string">"         JOIN pg_catalog.pg_class c ON (p.partitiontablename = c.relname) "</literal>
								<literal type="string">"         JOIN pg_catalog.pg_namespace n ON (n.oid = c.relnamespace) "</literal>
								<literal type="string">") "</literal>
								<literal type="string">"SELECT nspname, "</literal>
								<literal type="string">"       relname, "</literal>
								<literal type="string">"       count(indexname) AS indexes "</literal>
								<literal type="string">"FROM partitions "</literal>
								<literal type="string">"     JOIN pg_catalog.pg_indexes ON (relname = tablename AND "</literal>
								<literal type="string">"                                    nspname = schemaname) "</literal>
								<literal type="string">"GROUP BY nspname, relname "</literal>
								<literal type="string">"ORDER BY relname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_nspname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_relname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indexes</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indexes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>rowno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>script</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Could not create necessary file:  %s\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db_used</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"Database:  %s\n"</literal></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>db_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"  %s.%s has %s index(es)\n"</literal></expr></argument>,
					<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_nspname</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_relname</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_indexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>, <argument><expr><literal type="string">"fatal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gp_fatal_log</name><argument_list>(
			   <argument><expr><literal type="string">"| Your installation contains partitioned tables with\n"</literal>
			   <literal type="string">"| indexes defined on them.  Indexes on partition parents,\n"</literal>
			   <literal type="string">"| as well as children, must be dropped before upgrade.\n"</literal>
			   <literal type="string">"| A list of the problem tables is in the file:\n"</literal>
			   <literal type="string">"| \t%s\n\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_gphdfs_external_tables
 *
 * Check if there are any remaining gphdfs external tables in the database.
 * We error if any gphdfs external tables remain and let the users know that,
 * any remaining gphdfs external tables have to be removed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_gphdfs_external_tables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>output_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>

	<comment type="block">/* GPDB only supported gphdfs in this version range */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>old_cluster</name><operator>.</operator><name>major_version</name></name> <operator>&gt;=</operator> <literal type="number">80215</literal> <operator>&amp;&amp;</operator> <name><name>old_cluster</name><operator>.</operator><name>major_version</name></name> <operator>&lt;</operator> <literal type="number">80400</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking for gphdfs external tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"gphdfs_external_tables.txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rowno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>active_db</name> <init>= <expr><operator>&amp;</operator><name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>connectToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
			 <argument><expr><literal type="string">"SELECT d.objid::regclass as tablename "</literal>
			 <literal type="string">"FROM pg_catalog.pg_depend d "</literal>
			 <literal type="string">"       JOIN pg_catalog.pg_exttable x ON ( d.objid = x.reloid ) "</literal>
			 <literal type="string">"       JOIN pg_catalog.pg_extprotocol p ON ( p.oid = d.refobjid ) "</literal>
			 <literal type="string">"       JOIN pg_catalog.pg_class c ON ( c.oid = d.objid ) "</literal>
			 <literal type="string">"       WHERE d.refclassid = 'pg_extprotocol'::regclass "</literal>
			 <literal type="string">"       AND p.ptcname = 'gphdfs';"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>script</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Could not create necessary file:  %s\n"</literal></expr></argument>,
					   <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<for>for <control>(<init><expr><name>rowno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"gphdfs external table \"%s\" in database \"%s\"\n"</literal></expr></argument>,
						<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tablename"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>, <argument><expr><literal type="string">"fatal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gp_fatal_log</name><argument_list>(
			   <argument><expr><literal type="string">"| Your installation contains gphdfs external tables.  These \n"</literal>
			   <literal type="string">"| tables need to be dropped before upgrade.  A list of\n"</literal>
			   <literal type="string">"| external gphdfs tables to remove is provided in the file:\n"</literal>
			   <literal type="string">"| \t%s\n\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_gphdfs_user_roles
 *
 * Check if there are any remaining users with gphdfs roles.
 * We error if this is the case and let the users know how to proceed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_gphdfs_user_roles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>output_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rowno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_hdfs_read</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_hdfs_write</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<comment type="block">/* GPDB only supported gphdfs in this version range */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>old_cluster</name><operator>.</operator><name>major_version</name></name> <operator>&gt;=</operator> <literal type="number">80215</literal> <operator>&amp;&amp;</operator> <name><name>old_cluster</name><operator>.</operator><name>major_version</name></name> <operator>&lt;</operator> <literal type="number">80400</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking for users assigned the gphdfs role"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"gphdfs_user_roles.txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>connectToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>, <argument><expr><literal type="string">"template1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
							<argument><expr><literal type="string">"SELECT rolname as role, "</literal>
							<literal type="string">"       rolcreaterexthdfs as hdfs_read, "</literal>
							<literal type="string">"       rolcreatewexthdfs as hdfs_write "</literal>
							<literal type="string">"FROM pg_catalog.pg_roles"</literal>
							<literal type="string">"       WHERE rolcreaterexthdfs OR rolcreatewexthdfs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>script</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Could not create necessary file:  %s\n"</literal></expr></argument>,
					<argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>i_hdfs_read</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"hdfs_read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_hdfs_write</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"hdfs_write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>rowno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>hasReadRole</name> <init>= <expr><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_hdfs_read</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>hasWriteRole</name> <init>=<expr><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_hdfs_write</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"role \"%s\" has the gphdfs privileges:"</literal></expr></argument>,
					<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"role"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>hasReadRole</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">" read(rolcreaterexthdfs)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>hasWriteRole</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">" write(rolcreatewexthdfs)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">" \n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>, <argument><expr><literal type="string">"fatal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gp_fatal_log</name><argument_list>(
			   <argument><expr><literal type="string">"| Your installation contains roles that have gphdfs privileges.\n"</literal>
			   <literal type="string">"| These privileges need to be revoked before upgrade.  A list\n"</literal>
			   <literal type="string">"| of roles and their corresponding gphdfs privileges that\n"</literal>
			   <literal type="string">"| must be revoked is provided in the file:\n"</literal>
			   <literal type="string">"| \t%s\n\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_for_array_of_partition_table_types</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>SEPARATOR</name> <init>= <expr><literal type="string">"\n"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dependee_partition_report</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * This was only a problem with GPDB 6 and below.
	 *
	 * GPDB_12_MERGE_FIXME: Could we support upgrading these to GPDB 7,
	 * even though it wasn't possible before? The upstream syntax used in
	 * GPDB 7 to recreate the partition hierarchy is more flexible, and
	 * could possibly handle this. If so, we could remove this check
	 * entirely.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>old_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking array types derived from partitions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>n_tables_to_check</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>active_db</name> <init>= <expr><operator>&amp;</operator><name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>connectToServer</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Find the arraytypes derived from partitions of partitioned tables */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
		                        <argument><expr><literal type="string">"SELECT td.typarray, ns.nspname || '.' || td.typname AS dependee_partition_qname "</literal>
		                        <literal type="string">"FROM (SELECT typarray, typname, typnamespace "</literal>
		                        <literal type="string">"FROM (SELECT pg_c.reltype AS rt "</literal>
		                        <literal type="string">"FROM pg_class AS pg_c JOIN pg_partitions AS pg_p ON pg_c.relname = pg_p.partitiontablename) "</literal>
		                        <literal type="string">"AS check_types JOIN pg_type AS pg_t ON check_types.rt = pg_t.oid WHERE pg_t.typarray != 0) "</literal>
		                        <literal type="string">"AS td JOIN pg_namespace AS ns ON td.typnamespace = ns.oid "</literal>
		                        <literal type="string">"ORDER BY td.typarray;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>n_tables_to_check</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_tables_to_check</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>array_type_oid_to_check</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dependee_partition_qname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res2</name> <init>= <expr><call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SELECT 1 FROM pg_depend WHERE refobjid = %s;"</literal></expr></argument>, <argument><expr><name>array_type_oid_to_check</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>dependee_partition_report</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(
					<argument><expr><name>dependee_partition_report</name></expr></argument>,
					<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>dependee_partition_report</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>array_type_oid_to_check</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dependee_partition_qname</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SEPARATOR</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(
					<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>dependee_partition_report</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>dependee_partition_report</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>)</operator></expr></argument>,
					<argument><expr><literal type="string">"%s %s%s"</literal></expr></argument>,
					<argument><expr><name>array_type_oid_to_check</name></expr></argument>, <argument><expr><name>dependee_partition_qname</name></expr></argument>, <argument><expr><name>SEPARATOR</name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>dependee_partition_report</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>, <argument><expr><literal type="string">"fatal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gp_fatal_log</name><argument_list>(
			<argument><expr><literal type="string">"| Array types derived from partitions of a partitioned table must not have dependants.\n"</literal>
			<literal type="string">"| OIDs of such types found and their original partitions:\n%s"</literal></expr></argument>, <argument><expr><name>dependee_partition_report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dependee_partition_report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
