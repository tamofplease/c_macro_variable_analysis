<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/bin/pg_upgrade/pg_upgrade.c"><comment type="block">/*
 *	pg_upgrade.c
 *
 *	main source file
 *
 *	Portions Copyright (c) 2016-Present, VMware, Inc. or its affiliates
 *	Copyright (c) 2010-2019, PostgreSQL Global Development Group
 *	src/bin/pg_upgrade/pg_upgrade.c
 */</comment>

<comment type="block">/*
 *	To simplify the upgrade process, we force certain system values to be
 *	identical between old and new clusters:
 *
 *	We control all assignments of pg_class.oid (and relfilenode) so toast
 *	oids are the same between old and new clusters.  This is important
 *	because toast oids are stored as toast pointers in user tables.
 *
 *	While pg_class.oid and pg_class.relfilenode are initially the same
 *	in a cluster, they can diverge due to CLUSTER, REINDEX, or VACUUM
 *	FULL.  In the new cluster, pg_class.oid and pg_class.relfilenode will
 *	be the same and will match the old pg_class.oid value.  Because of
 *	this, old/new pg_class.relfilenode values will not match if CLUSTER,
 *	REINDEX, or VACUUM FULL have been performed in the old cluster.
 *
 *	We control all assignments of pg_type.oid because these oids are stored
 *	in user composite type values.
 *
 *	We control all assignments of pg_enum.oid because these oids are stored
 *	in user tables as enum values.
 *
 *	We control all assignments of pg_authid.oid for historical reasons (the
 *	oids used to be stored in pg_largeobject_metadata, which is now copied via
 *	SQL commands), that might change at some point in the future.
 */</comment>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_upgrade.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/logging.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/restricted_token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LANGINFO_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;langinfo.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"greenplum/pg_upgrade_greenplum.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepare_new_cluster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepare_new_globals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_new_objects</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_xact_xlog_xid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_frozenxids</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>minmxid_only</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>live_check</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_subdir_files</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_subdir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_subdir</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CreateRestrictedProcess</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>PROCESS_INFORMATION</name> <modifier>*</modifier></type><name>processInfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>ClusterInfo</name></type> <name>old_cluster</name></decl>,
			<decl><type ref="prev"/><name>new_cluster</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OSInfo</name></type>		<name>os_info</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>output_files</name><index>[]</index></name> <init>= <expr><block>{
	<expr><name>SERVER_LOG_FILE</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* unique file for pg_ctl start */</comment>
	<expr><name>SERVER_START_LOG_FILE</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><name>UTILITY_LOG_FILE</name></expr>,
	<expr><name>INTERNAL_LOG_FILE</name></expr>,
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>restrict_env</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This is the database used by pg_dumpall to restore global tables */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOBAL_DUMP_DB</name></cpp:macro>	<cpp:value>"postgres"</cpp:value></cpp:define>

<decl_stmt><decl><type><name>ClusterInfo</name></type> <name>old_cluster</name></decl>,
			<decl><type ref="prev"/><name>new_cluster</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OSInfo</name></type>		<name>os_info</name></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>sequence_script_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>analyze_script_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>deletion_script_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>live_check</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_logging_init</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"pg_upgrade"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set default restrictive mask until new cluster permissions are read */</comment>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>PG_MODE_MASK_OWNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>parseCommandLine</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_restricted_token</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>adjust_data_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>is_skip_target_check</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>adjust_data_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>setup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>live_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>report_progress</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CHECK</name></expr></argument>, <argument><expr><literal type="string">"Checking cluster compatibility"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>output_check_banner</name><argument_list>(<argument><expr><name>live_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_cluster_versions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_sock_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>, <argument><expr><name>live_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>is_skip_target_check</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_sock_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* not skipped for is_skip_target_check because of some checks on
	 * old_cluster are done independently of new_cluster
	 */</comment>
	<expr_stmt><expr><call><name>check_cluster_compatibility</name><argument_list>(<argument><expr><name>live_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set mask based on PGDATA permissions */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_skip_target_check</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetDataDirectoryCreatePerm</name><argument_list>(<argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not read permissions of directory \"%s\": %s\n"</literal></expr></argument>,
					 <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>pg_mode_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_and_dump_old_cluster</name><argument_list>(<argument><expr><name>live_check</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sequence_script_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* -- NEW -- */</comment>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>is_skip_target_check</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>start_postmaster</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_new_cluster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>report_clusters_compatible</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>,
		   <argument><expr><literal type="string">"\n"</literal>
		   <literal type="string">"Performing Upgrade\n"</literal>
		   <literal type="string">"------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>prepare_new_cluster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>stop_postmaster</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Destructive Changes to New Cluster
	 */</comment>

	<expr_stmt><expr><call><name>copy_xact_xlog_xid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In upgrading from GPDB4, copy the pg_distributedlog over in vanilla.
	 * The assumption that this works needs to be verified
	 */</comment>
	<expr_stmt><expr><call><name>copy_subdir_files</name><argument_list>(<argument><expr><literal type="string">"pg_distributedlog"</literal></expr></argument>, <argument><expr><literal type="string">"pg_distributedlog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* New now using xids of the old system */</comment>

	<comment type="block">/* -- NEW -- */</comment>
	<expr_stmt><expr><call><name>start_postmaster</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_greenplum_dispatcher_mode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>prepare_new_globals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>create_new_objects</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In a segment, the data directory already contains all the objects,
	 * because the segment is initialized by taking a physical copy of the
	 * upgraded QD data directory. The auxiliary AO tables - containing
	 * information about the segment files, are different in each server,
	 * however. So we still need to restore those separately on each
	 * server.
	 */</comment>
	<expr_stmt><expr><call><name>restore_aosegment_tables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_greenplum_dispatcher_mode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* freeze master data *right before* stopping */</comment>
		<expr_stmt><expr><call><name>freeze_master_data</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>stop_postmaster</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Most failures happen in create_new_objects(), which has completed at
	 * this point.  We do this here because it is just before linking, which
	 * will link the old and new cluster data files, preventing the old
	 * cluster from being safely started once the new cluster is started.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>user_opts</name><operator>.</operator><name>transfer_mode</name></name> <operator>==</operator> <name>TRANSFER_MODE_LINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>disable_old_cluster</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>transfer_all_new_tablespaces</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>old_cluster</name><operator>.</operator><name>dbarr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>new_cluster</name><operator>.</operator><name>dbarr</name></name></expr></argument>,
								 <argument><expr><name><name>old_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>, <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assuming OIDs are only used in system tables, there is no need to
	 * restore the OID counter because we have not transferred any OIDs from
	 * the old system, but we do it anyway just in case.  We do it late here
	 * because there is no need to have the schema load use new oids.
	 */</comment>
	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Setting next OID for new cluster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			  <argument><expr><literal type="string">"\"%s/pg_resetwal\" --binary-upgrade -o %u \"%s\""</literal></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>, <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtoid</name></name></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For non-master segments, uniquify the system identifier. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_greenplum_dispatcher_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>reset_system_identifier</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Sync data directory to disk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			  <argument><expr><literal type="string">"\"%s/initdb\" --sync-only \"%s\""</literal></expr></argument>, <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>create_script_for_cluster_analyze</name><argument_list>(<argument><expr><operator>&amp;</operator><name>analyze_script_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>create_script_for_old_cluster_deletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>deletion_script_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>issue_warnings_and_set_wal_level</name><argument_list>(<argument><expr><name>sequence_script_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>,
		   <argument><expr><literal type="string">"\n"</literal>
		   <literal type="string">"Upgrade Complete\n"</literal>
		   <literal type="string">"----------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>report_progress</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DONE</name></expr></argument>, <argument><expr><literal type="string">"Upgrade complete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close_progress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>output_completion_banner</name><argument_list>(<argument><expr><name>analyze_script_file_name</name></expr></argument>,
							 <argument><expr><name>deletion_script_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>analyze_script_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>deletion_script_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<typedef>typedef <function_decl><type><name>BOOL</name></type>(<name>WINAPI</name> <modifier>*</modifier> <name>__CreateRestrictedToken</name>) <parameter_list>(<parameter><decl><type><name>HANDLE</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>PSID_AND_ATTRIBUTES</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>PLUID_AND_ATTRIBUTES</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>PSID_AND_ATTRIBUTES</name></type></decl></parameter>, <parameter><decl><type><name>PHANDLE</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* Windows API define missing from some versions of MingW headers */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive>  <name>DISABLE_MAX_PRIVILEGE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISABLE_MAX_PRIVILEGE</name></cpp:macro>	<cpp:value>0x1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
* Create a restricted token and execute the specified process with it.
*
* Returns 0 on failure, non-zero on success, same as CreateProcess().
*
* On NT4, or any other system not containing the required functions, will
* NOT execute anything.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CreateRestrictedProcess</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>PROCESS_INFORMATION</name> <modifier>*</modifier></type><name>processInfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BOOL</name></type>		<name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>STARTUPINFO</name></type> <name>si</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>origToken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>restrictedToken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SID_IDENTIFIER_AUTHORITY</name></type> <name>NtAuthority</name> <init>= <expr><block>{ <expr><name>SECURITY_NT_AUTHORITY</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SID_AND_ATTRIBUTES</name></type> <name><name>dropSids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>__CreateRestrictedToken</name></type> <name>_CreateRestrictedToken</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>Advapi32Handle</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>.</operator><name>cb</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>Advapi32Handle</name> <operator>=</operator> <call><name>LoadLibrary</name><argument_list>(<argument><expr><literal type="string">"ADVAPI32.DLL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>Advapi32Handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>_CreateRestrictedToken</name> <operator>=</operator> <operator>(</operator><name>__CreateRestrictedToken</name><operator>)</operator><call><name>GetProcAddress</name><argument_list>(<argument><expr><name>Advapi32Handle</name></expr></argument>, <argument><expr><literal type="string">"CreateRestrictedToken"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>_CreateRestrictedToken</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: WARNING: cannot create restricted tokens on this platform\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>Advapi32Handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>Advapi32Handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Open the current token to use as a base for the restricted one */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OpenProcessToken</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TOKEN_ALL_ACCESS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>origToken</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open process token: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allocate list of SIDs to remove */</comment>
	<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dropSids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dropSids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocateAndInitializeSid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NtAuthority</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
		<argument><expr><name>SECURITY_BUILTIN_DOMAIN_RID</name></expr></argument>, <argument><expr><name>DOMAIN_ALIAS_RID_ADMINS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dropSids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>AllocateAndInitializeSid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NtAuthority</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
		<argument><expr><name>SECURITY_BUILTIN_DOMAIN_RID</name></expr></argument>, <argument><expr><name>DOMAIN_ALIAS_RID_POWER_USERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dropSids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not allocate SIDs: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>_CreateRestrictedToken</name><argument_list>(<argument><expr><name>origToken</name></expr></argument>,
						<argument><expr><name>DISABLE_MAX_PRIVILEGE</name></expr></argument>,
						<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dropSids</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>dropSids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
						<argument><expr><name>dropSids</name></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>restrictedToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeSid</name><argument_list>(<argument><expr><name><name>dropSids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeSid</name><argument_list>(<argument><expr><name><name>dropSids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>origToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>Advapi32Handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create restricted token: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__CYGWIN__</name></cpp:ifndef>
	<expr_stmt><expr><call><name>AddUserToTokenDacl</name><argument_list>(<argument><expr><name>restrictedToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateProcessAsUser</name><argument_list>(<argument><expr><name>restrictedToken</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>cmd</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>TRUE</name></expr></argument>,
							<argument><expr><name>CREATE_SUSPENDED</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,
							<argument><expr><name>processInfo</name></expr></argument>)</argument_list></call></expr>)</condition>

	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not start process for command \"%s\": error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>ResumeThread</name><argument_list>(<argument><expr><name><name>processInfo</name><operator>-&gt;</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>live_check</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>exec_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* full path to my executable */</comment>

	<comment type="block">/*
	 * make sure the user has a clean environment, otherwise, we may confuse
	 * libpq when we connect to one (or both) of the servers.
	 */</comment>
	<expr_stmt><expr><call><name>check_pghost_envvar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>verify_directories</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* no postmasters should be running, except for a live check */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pid_lock_file_exists</name><argument_list>(<argument><expr><name><name>old_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we have a postmaster.pid file, try to start the server.  If it
		 * starts, the pid file was stale, so stop the server.  If it doesn't
		 * start, assume the server is running.  If the pid file is left over
		 * from a server crash, this also allows any committed transactions
		 * stored in the WAL to be replayed so they are not lost, because WAL
		 * files are not transferred from old to new servers.  We later check
		 * for a clean shutdown.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>start_postmaster</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_cluster</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>stop_postmaster</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>user_opts</name><operator>.</operator><name>check</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"There seems to be a postmaster servicing the old cluster.\n"</literal>
						 <literal type="string">"Please shutdown that postmaster and try again.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>live_check</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* same goes for the new postmaster */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_skip_target_check</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pid_lock_file_exists</name><argument_list>(<argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>start_postmaster</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>stop_postmaster</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"There seems to be a postmaster servicing the new cluster.\n"</literal>
						 <literal type="string">"Please shutdown that postmaster and try again.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get path to pg_upgrade executable */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>exec_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: could not find own program executable\n"</literal></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Trim off program name and keep just path */</comment>
	<expr_stmt><expr><operator>*</operator><call><name>last_dir_separator</name><argument_list>(<argument><expr><name>exec_path</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>os_info</name><operator>.</operator><name>exec_path</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_new_cluster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * It would make more sense to freeze after loading the schema, but that
	 * would cause us to lose the frozenids restored by the load. We use
	 * --analyze so autovacuum doesn't update statistics later
	 *
	 * GPDB: after we've copied the master data directory to the segments,
	 * AO tables can't be analyzed because their aoseg tuple counts don't match
	 * those on disk. We therefore skip this step for segments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_greenplum_dispatcher_mode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Analyzing all rows in the new cluster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
				  <argument><expr><literal type="string">"%s \"%s/vacuumdb\" %s --all --analyze %s"</literal></expr></argument>,
				  <argument><expr><call><name>PG_OPTIONS_UTILITY_MODE_VERSION</name><argument_list>(<argument><expr><name><name>new_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>, <argument><expr><call><name>cluster_conn_opts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><ternary><condition><expr><name><name>log_opts</name><operator>.</operator><name>verbose</name></name></expr> ?</condition><then> <expr><literal type="string">"--verbose"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * We do freeze after analyze so pg_statistic is also frozen. template0 is
	 * not frozen here, but data rows were frozen by initdb, and we set its
	 * datfrozenxid, relfrozenxids, and relminmxid later to match the new xid
	 * counter later.
	 */</comment>
	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Freezing all rows in the new cluster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			  <argument><expr><literal type="string">"%s \"%s/vacuumdb\" %s --all --freeze %s"</literal></expr></argument>,
			  <argument><expr><call><name>PG_OPTIONS_UTILITY_MODE_VERSION</name><argument_list>(<argument><expr><name><name>new_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>, <argument><expr><call><name>cluster_conn_opts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><ternary><condition><expr><name><name>log_opts</name><operator>.</operator><name>verbose</name></name></expr> ?</condition><then> <expr><literal type="string">"--verbose"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_new_globals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Before we restore anything, set frozenxids of initdb-created tables.
	 */</comment>
	<expr_stmt><expr><call><name>set_frozenxids</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now restore global objects (roles and tablespaces).
	 */</comment>
	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Restoring global objects in the new cluster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			  <argument><expr><literal type="string">"%s \"%s/psql\" "</literal> <name>EXEC_PSQL_ARGS</name> <literal type="string">" %s -f \"%s\""</literal></expr></argument>,
			  <argument><expr><call><name>PG_OPTIONS_UTILITY_MODE_VERSION</name><argument_list>(<argument><expr><name><name>new_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>, <argument><expr><call><name>cluster_conn_opts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><name>GLOBALS_DUMP_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_new_objects</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Restoring database schemas in the new cluster\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We cannot process the template1 database concurrently with others,
	 * because when it's transiently dropped, connection attempts would fail.
	 * So handle it in a separate non-parallelized pass.
	 */</comment>
	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sql_file_name</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>,
					<decl><type ref="prev"/><name><name>log_file_name</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>old_db</name> <init>= <expr><operator>&amp;</operator><name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>create_opts</name></decl>;</decl_stmt>

		<comment type="block">/* Process only template1 in this pass */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>, <argument><expr><literal type="string">"template1"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_STATUS</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql_file_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql_file_name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>DB_DUMP_FILE_MASK</name></expr></argument>, <argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>log_file_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_file_name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>DB_DUMP_LOG_FILE_MASK</name></expr></argument>, <argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * template1 and postgres databases will already exist in the target
		 * installation, so tell pg_restore to drop and recreate them;
		 * otherwise we would fail to propagate their database-level
		 * properties.
		 */</comment>
		<expr_stmt><expr><name>create_opts</name> <operator>=</operator> <literal type="string">"--clean --create"</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>log_file_name</name></expr></argument>,
				  <argument><expr><name>NULL</name></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>,
				  <argument><expr><literal type="string">"\"%s/pg_restore\" %s %s --exit-on-error --verbose "</literal>
				  <literal type="string">"--dbname postgres \"%s\""</literal></expr></argument>,
				  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>,
				  <argument><expr><call><name>cluster_conn_opts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>create_opts</name></expr></argument>,
				  <argument><expr><name>sql_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<break>break;</break>					<comment type="block">/* done once we've processed template1 */</comment>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sql_file_name</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>,
					<decl><type ref="prev"/><name><name>log_file_name</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>old_db</name> <init>= <expr><operator>&amp;</operator><name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>create_opts</name></decl>;</decl_stmt>

		<comment type="block">/* Skip template1 in this pass */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>, <argument><expr><literal type="string">"template1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_STATUS</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql_file_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql_file_name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>DB_DUMP_FILE_MASK</name></expr></argument>, <argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>log_file_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_file_name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>DB_DUMP_LOG_FILE_MASK</name></expr></argument>, <argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * template1 and postgres databases will already exist in the target
		 * installation, so tell pg_restore to drop and recreate them;
		 * otherwise we would fail to propagate their database-level
		 * properties.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>create_opts</name> <operator>=</operator> <literal type="string">"--clean --create"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>create_opts</name> <operator>=</operator> <literal type="string">"--create"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>parallel_exec_prog</name><argument_list>(<argument><expr><name>log_file_name</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr><literal type="string">"%s \"%s/pg_restore\" %s %s --exit-on-error --verbose "</literal>
						   <literal type="string">"--binary-upgrade "</literal>
						   <literal type="string">"--dbname template1 \"%s\""</literal></expr></argument>,
						   <argument><expr><call><name>PG_OPTIONS_UTILITY_MODE_VERSION</name><argument_list>(<argument><expr><name><name>new_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>,
						   <argument><expr><call><name>cluster_conn_opts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>create_opts</name></expr></argument>,
						   <argument><expr><name>sql_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* reap all children */</comment>
	<while>while <condition>(<expr><call><name>reap_child</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>end_progress_output</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't have minmxids for databases or relations in pre-9.3 clusters,
	 * so set those after we have restored the schema.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>old_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">903</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_frozenxids</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* update new_cluster info now that we have objects in the databases */</comment>
	<expr_stmt><expr><call><name>get_db_and_rel_infos</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* TODO: Bitmap indexes are not supported, so mark them as invalid. */</comment>
	<expr_stmt><expr><call><name>new_gpdb_invalidate_bitmap_indexes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Delete the given subdirectory contents from the new cluster
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_new_subdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subdir</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rmtopdir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>new_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Deleting files from new %s"</literal></expr></argument>, <argument><expr><name>subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>, <argument><expr><name>subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>rmtopdir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not delete directory \"%s\"\n"</literal></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy the files from the old cluster into it
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_subdir_files</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_subdir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_subdir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>old_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>new_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>remove_new_subdir</name><argument_list>(<argument><expr><name>new_subdir</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>old_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>, <argument><expr><name>old_subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>, <argument><expr><name>new_subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Copying old %s to new server"</literal></expr></argument>, <argument><expr><name>old_subdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
			  <argument><expr><literal type="string">"cp -Rf \"%s\" \"%s\""</literal></expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* flags: everything, no confirm, quiet, overwrite read-only */</comment>
			  <argument><expr><literal type="string">"xcopy /e /y /q /r \"%s\" \"%s\\\""</literal></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			  <argument><expr><name>old_path</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_xact_xlog_xid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * FIXME: Definitely need more work to make pre-gp7 to gp7 upgrade
	 * work for the 64bit gxid work.
	 */</comment>
	<comment type="block">/* set the next distributed transaction id of the new cluster */</comment>
	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Setting next distributed transaction ID for new cluster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			  <argument><expr><literal type="string">"\"%s/pg_resetwal\" --binary-upgrade -f --next-gxid "</literal><name>UINT64_FORMAT</name><literal type="string">" \"%s\""</literal></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>, <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtgxid</name></name></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy old commit logs to new data dir. pg_clog has been renamed to
	 * pg_xact in post-10 clusters.
	 */</comment>
	<expr_stmt><expr><call><name>copy_subdir_files</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>old_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1000</literal></expr> ?</condition><then>
					  <expr><literal type="string">"pg_clog"</literal></expr> </then><else>: <expr><literal type="string">"pg_xact"</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><ternary><condition><expr><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>new_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1000</literal></expr> ?</condition><then>
					  <expr><literal type="string">"pg_clog"</literal></expr> </then><else>: <expr><literal type="string">"pg_xact"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * GPDB: FIXME: If we want to support upgrades from 5X -&gt; 7X and above, we
	 * would need to construct the old_cluster.controldata.chkpnt_oldstxid
	 * ourselves as the 5X control file doesn't carry that field.
	 */</comment>
	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Setting oldest XID for new cluster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			  <argument><expr><literal type="string">"\"%s/pg_resetwal\" --binary-upgrade -f -u %u \"%s\""</literal></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>, <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_oldstxid</name></name></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set the next transaction id and epoch of the new cluster */</comment>
	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Setting next transaction ID and epoch for new cluster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			  <argument><expr><literal type="string">"\"%s/pg_resetwal\" --binary-upgrade -f -x %u \"%s\""</literal></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>, <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtxid</name></name></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			  <argument><expr><literal type="string">"\"%s/pg_resetwal\" --binary-upgrade -f -e %u \"%s\""</literal></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>, <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtepoch</name></name></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* must reset commit timestamp limits also */</comment>
	<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			  <argument><expr><literal type="string">"\"%s/pg_resetwal\" --binary-upgrade -f -c %u,%u \"%s\""</literal></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>,
			  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtxid</name></name></expr></argument>,
			  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtxid</name></name></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the old server is before the MULTIXACT_FORMATCHANGE_CAT_VER change
	 * (see pg_upgrade.h) and the new server is after, then we don't copy
	 * pg_multixact files, but we need to reset pg_control so that the new
	 * server doesn't attempt to read multis older than the cutoff value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>cat_ver</name></name> <operator>&gt;=</operator> <name>MULTIXACT_FORMATCHANGE_CAT_VER</name> <operator>&amp;&amp;</operator>
		<name><name>new_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>cat_ver</name></name> <operator>&gt;=</operator> <name>MULTIXACT_FORMATCHANGE_CAT_VER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>copy_subdir_files</name><argument_list>(<argument><expr><literal type="string">"pg_multixact/offsets"</literal></expr></argument>, <argument><expr><literal type="string">"pg_multixact/offsets"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>copy_subdir_files</name><argument_list>(<argument><expr><literal type="string">"pg_multixact/members"</literal></expr></argument>, <argument><expr><literal type="string">"pg_multixact/members"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Setting next multixact ID and offset for new cluster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * we preserve all files and contents, so we must preserve both "next"
		 * counters here and the oldest multi present on system.
		 */</comment>
		<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
				  <argument><expr><literal type="string">"\"%s/pg_resetwal\" --binary-upgrade -O %u -m %u,%u \"%s\""</literal></expr></argument>,
				  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>,
				  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtmxoff</name></name></expr></argument>,
				  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtmulti</name></name></expr></argument>,
				  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_oldstMulti</name></name></expr></argument>,
				  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>new_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>cat_ver</name></name> <operator>&gt;=</operator> <name>MULTIXACT_FORMATCHANGE_CAT_VER</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Remove offsets/0000 file created by initdb that no longer matches
		 * the new multi-xid value.  "members" starts at zero so no need to
		 * remove it.
		 */</comment>
		<expr_stmt><expr><call><name>remove_new_subdir</name><argument_list>(<argument><expr><literal type="string">"pg_multixact/offsets"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Setting oldest multixact ID in new cluster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't preserve files in this case, but it's important that the
		 * oldest multi is set to the latest value used by the old system, so
		 * that multixact.c returns the empty set for multis that might be
		 * present on disk.  We set next multi to the value following that; it
		 * might end up wrapped around (i.e. 0) if the old cluster had
		 * next=MaxMultiXactId, but multixact.c can cope with that just fine.
		 */</comment>
		<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
				  <argument><expr><literal type="string">"\"%s/pg_resetwal\" --binary-upgrade -m %u,%u \"%s\""</literal></expr></argument>,
				  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>,
				  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtmulti</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
				  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtmulti</name></name></expr></argument>,
				  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* now reset the wal archives in the new cluster */</comment>
	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Resetting WAL archives"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_prog</name><argument_list>(<argument><expr><name>UTILITY_LOG_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
	<comment type="block">/* use timeline 1 to match controldata and no WAL history file */</comment>
			  <argument><expr><literal type="string">"\"%s/pg_resetwal\" --binary-upgrade -l 00000001%s \"%s\""</literal></expr></argument>, <argument><expr><name><name>new_cluster</name><operator>.</operator><name>bindir</name></name></expr></argument>,
			  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>nextxlogfile</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>,
			  <argument><expr><name><name>new_cluster</name><operator>.</operator><name>pgdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	set_frozenxids()
 *
 * This is called on the new cluster before we restore anything, with
 * minmxid_only = false.  Its purpose is to ensure that all initdb-created
 * vacuumable tables have relfrozenxid/relminmxid matching the old cluster's
 * xid/mxid counters.  We also initialize the datfrozenxid/datminmxid of the
 * built-in databases to match.
 *
 * As we create user tables later, their relfrozenxid/relminmxid fields will
 * be restored properly by the binary-upgrade restore script.  Likewise for
 * user-database datfrozenxid/datminmxid.  However, if we're upgrading from a
 * pre-9.3 database, which does not store per-table or per-DB minmxid, then
 * the relminmxid/datminmxid values filled in by the restore script will just
 * be zeroes.
 *
 * Hence, with a pre-9.3 source database, a second call occurs after
 * everything is restored, with minmxid_only = true.  This pass will
 * initialize all tables and databases, both those made by initdb and user
 * objects, with the desired minmxid value.  frozenxid values are left alone.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_frozenxids</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>minmxid_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>conn_template1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>dbres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_datname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_datallowconn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>minmxid_only</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Setting frozenxid and minmxid counters in new cluster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Setting minmxid counter in new cluster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>conn_template1</name> <operator>=</operator> <call><name>connectToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>, <argument><expr><literal type="string">"template1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * GPDB doesn't allow hacking the catalogs without setting
	 * allow_system_table_mods first.
	 */</comment>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn_template1</name></expr></argument>,
							  <argument><expr><literal type="string">"set allow_system_table_mods=true"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>minmxid_only</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* set pg_database.datfrozenxid */</comment>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn_template1</name></expr></argument>,
								  <argument><expr><literal type="string">"UPDATE pg_catalog.pg_database "</literal>
								  <literal type="string">"SET	datfrozenxid = '%u'"</literal></expr></argument>,
								  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtxid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* set pg_database.datminmxid */</comment>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn_template1</name></expr></argument>,
							  <argument><expr><literal type="string">"UPDATE pg_catalog.pg_database "</literal>
							  <literal type="string">"SET	datminmxid = '%u'"</literal></expr></argument>,
							  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtmulti</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get database names */</comment>
	<expr_stmt><expr><name>dbres</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn_template1</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT	datname, datallowconn "</literal>
							  <literal type="string">"FROM	pg_catalog.pg_database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_datname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>dbres</name></expr></argument>, <argument><expr><literal type="string">"datname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datallowconn</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>dbres</name></expr></argument>, <argument><expr><literal type="string">"datallowconn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>dbres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>

		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>datname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>dbres</name></expr></argument>, <argument><expr><name>dbnum</name></expr></argument>, <argument><expr><name>i_datname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>datallowconn</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>dbres</name></expr></argument>, <argument><expr><name>dbnum</name></expr></argument>, <argument><expr><name>i_datallowconn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


		<comment type="block">/*
		 * We must update databases where datallowconn = false, e.g.
		 * template0, because autovacuum increments their datfrozenxids,
		 * relfrozenxids, and relminmxid even if autovacuum is turned off, and
		 * even though all the data rows are already frozen.  To enable this,
		 * we temporarily change datallowconn.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>datallowconn</name></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn_template1</name></expr></argument>,
									  <argument><expr><literal type="string">"ALTER DATABASE %s ALLOW_CONNECTIONS = true"</literal></expr></argument>,
									  <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>datname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>connectToServer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_cluster</name></expr></argument>, <argument><expr><name>datname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * GPDB doesn't allow hacking the catalogs without setting
		 * allow_system_table_mods first.
		 */</comment>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"set allow_system_table_mods=true"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Instead of assuming template0 will be frozen by initdb, its worth
		 * making sure we freeze it here before updating the relfrozenxid
		 * directly for the tables in pg_class and datfrozenxid for the
		 * database in pg_database. Its fast and safe worth than assuming for
		 * template0.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>minmxid_only</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>datallowconn</name></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"VACUUM FREEZE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>minmxid_only</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* set pg_class.relfrozenxid */</comment>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
									  <argument><expr><literal type="string">"UPDATE	pg_catalog.pg_class "</literal>
									  <literal type="string">"SET	relfrozenxid = '%u' "</literal>
			<comment type="block">/*
			 * GPDB: if we ever backport this to Greenplum 5X, remove 'm' first
			 * and then replace 'M' with 'm', because 'm' used to be RELKIND
			 * visimap in 4.3/5X, not matview
			 */</comment>
			<comment type="block">/* only heap, materialized view, and TOAST are vacuumed */</comment>
									  <literal type="string">"WHERE	relkind IN ("</literal>
									  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
									  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
									  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>)</argument_list></call> <literal type="string">")"</literal></expr></argument>,
									  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtxid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* set pg_class.relminmxid */</comment>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
								  <argument><expr><literal type="string">"UPDATE	pg_catalog.pg_class "</literal>
								  <literal type="string">"SET	relminmxid = '%u' "</literal>
		<comment type="block">/* only heap, materialized view, and TOAST are vacuumed */</comment>
								  <literal type="string">"WHERE	relkind IN ("</literal>
								  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
								  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
								  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>)</argument_list></call> <literal type="string">")"</literal></expr></argument>,
								  <argument><expr><name><name>old_cluster</name><operator>.</operator><name>controldata</name><operator>.</operator><name>chkpnt_nxtmulti</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reset datallowconn flag */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>datallowconn</name></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn_template1</name></expr></argument>,
									  <argument><expr><literal type="string">"ALTER DATABASE %s ALLOW_CONNECTIONS = false"</literal></expr></argument>,
									  <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>datname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>dbres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn_template1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>log_opts</name><operator>.</operator><name>internal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove dump and log files? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>log_opts</name><operator>.</operator><name>retain</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>filename</name> <operator>=</operator> <name>output_files</name></expr>;</init> <condition><expr><operator>*</operator><name>filename</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>filename</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><operator>*</operator><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/* remove dump files */</comment>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>GLOBALS_DUMP_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>dbs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>sql_file_name</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>,
							<decl><type ref="prev"/><name><name>log_file_name</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>old_db</name> <init>= <expr><operator>&amp;</operator><name><name>old_cluster</name><operator>.</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql_file_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql_file_name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>DB_DUMP_FILE_MASK</name></expr></argument>, <argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sql_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>log_file_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_file_name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>DB_DUMP_LOG_FILE_MASK</name></expr></argument>, <argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>log_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
