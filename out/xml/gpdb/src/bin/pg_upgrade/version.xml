<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/bin/pg_upgrade/version.c"><comment type="block">/*
 *	version.c
 *
 *	Postgres-version-specific routines
 *
 *	Copyright (c) 2010-2019, PostgreSQL Global Development Group
 *	src/bin/pg_upgrade/version.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_upgrade.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>



<comment type="block">/*
 * new_9_0_populate_pg_largeobject_metadata()
 *	new &gt;= 9.0, old &lt;= 8.4
 *	9.0 has a new pg_largeobject permission table
 */</comment>
<function><type><name>void</name></type>
<name>new_9_0_populate_pg_largeobject_metadata</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>check_mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>output_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking for large objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_largeobject.sql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_count</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>active_db</name> <init>= <expr><operator>&amp;</operator><name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>connectToServer</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* find if there are any large objects */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
								<argument><expr><literal type="string">"SELECT count(*) "</literal>
								<literal type="string">"FROM	pg_catalog.pg_largeobject "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_count</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>check_mode</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>connectbuf</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>script</name> <operator>=</operator> <call><name>fopen_priv</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %s\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>,
							 <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connectbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPsqlMetaConnect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connectbuf</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>connectbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connectbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT pg_catalog.lo_create(t.loid)\n"</literal>
						<literal type="string">"FROM (SELECT DISTINCT loid FROM pg_catalog.pg_largeobject) AS t;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>script</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_status</name><argument_list>(<argument><expr><name>PG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"warning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>check_mode</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal>
				   <literal type="string">"Your installation contains large objects.  The new database has an\n"</literal>
				   <literal type="string">"additional large object permission table.  After upgrading, you will be\n"</literal>
				   <literal type="string">"given a command to populate the pg_largeobject_metadata table with\n"</literal>
				   <literal type="string">"default permissions.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal>
				   <literal type="string">"Your installation contains large objects.  The new database has an\n"</literal>
				   <literal type="string">"additional large object permission table, so default permissions must be\n"</literal>
				   <literal type="string">"defined for all large objects.  The file\n"</literal>
				   <literal type="string">"    %s\n"</literal>
				   <literal type="string">"when executed by psql by the database superuser will set the default\n"</literal>
				   <literal type="string">"permissions.\n\n"</literal></expr></argument>,
				   <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * old_9_3_check_for_line_data_type_usage()
 *	9.3 -&gt; 9.4
 *	Fully implement the 'line' data type in 9.4, which previously returned
 *	"not enabled" by default and was only functionally enabled with a
 *	compile-time switch;  9.4 "line" has different binary and text
 *	representation formats;  checks tables and indexes.
 */</comment>
<function><type><name>void</name></type>
<name>old_9_3_check_for_line_data_type_usage</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>output_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking for incompatible \"line\" data type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"tables_using_line.txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>db_used</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rowno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_nspname</name></decl>,
					<decl><type ref="prev"/><name>i_relname</name></decl>,
					<decl><type ref="prev"/><name>i_attname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>active_db</name> <init>= <expr><operator>&amp;</operator><name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>connectToServer</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
								<argument><expr><literal type="string">"SELECT n.nspname, c.relname, a.attname "</literal>
								<literal type="string">"FROM	pg_catalog.pg_class c, "</literal>
								<literal type="string">"		pg_catalog.pg_namespace n, "</literal>
								<literal type="string">"		pg_catalog.pg_attribute a "</literal>
								<literal type="string">"WHERE	c.oid = a.attrelid AND "</literal>
								<literal type="string">"		NOT a.attisdropped AND "</literal>
								<literal type="string">"		a.atttypid = 'pg_catalog.line'::pg_catalog.regtype AND "</literal>
								<literal type="string">"		c.relnamespace = n.oid AND "</literal>
		<comment type="block">/* exclude possible orphaned temp tables */</comment>
								<literal type="string">"		n.nspname !~ '^pg_temp_' AND "</literal>
								<literal type="string">"		n.nspname !~ '^pg_toast_temp_' AND "</literal>
								<literal type="string">"		n.nspname NOT IN ('pg_catalog', 'information_schema')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_nspname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_relname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>rowno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>script</name> <operator>=</operator> <call><name>fopen_priv</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %s\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>,
						 <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db_used</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"Database: %s\n"</literal></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>db_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"  %s.%s.%s\n"</literal></expr></argument>,
					<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_nspname</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_relname</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>script</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>, <argument><expr><literal type="string">"fatal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"Your installation contains the \"line\" data type in user tables.  This\n"</literal>
				 <literal type="string">"data type changed its internal and input/output format between your old\n"</literal>
				 <literal type="string">"and new clusters so this cluster cannot currently be upgraded.  You can\n"</literal>
				 <literal type="string">"remove the problem tables and restart the upgrade.  A list of the problem\n"</literal>
				 <literal type="string">"columns is in the file:\n"</literal>
				 <literal type="string">"    %s\n\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * old_9_6_check_for_unknown_data_type_usage()
 *	9.6 -&gt; 10
 *	It's no longer allowed to create tables or views with "unknown"-type
 *	columns.  We do not complain about views with such columns, because
 *	they should get silently converted to "text" columns during the DDL
 *	dump and reload; it seems unlikely to be worth making users do that
 *	by hand.  However, if there's a table with such a column, the DDL
 *	reload will fail, so we should pre-detect that rather than failing
 *	mid-upgrade.  Worse, if there's a matview with such a column, the
 *	DDL reload will silently change it to "text" which won't match the
 *	on-disk storage (which is like "cstring").  So we *must* reject that.
 *	Also check composite types, in case they are used for table columns.
 *	We needn't check indexes, because "unknown" has no opclasses.
 */</comment>
<function><type><name>void</name></type>
<name>old_9_6_check_for_unknown_data_type_usage</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>output_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking for invalid \"unknown\" user columns"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"tables_using_unknown.txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>db_used</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rowno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_nspname</name></decl>,
					<decl><type ref="prev"/><name>i_relname</name></decl>,
					<decl><type ref="prev"/><name>i_attname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>active_db</name> <init>= <expr><operator>&amp;</operator><name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>connectToServer</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
								<argument><expr><literal type="string">"SELECT n.nspname, c.relname, a.attname "</literal>
								<literal type="string">"FROM	pg_catalog.pg_class c, "</literal>
								<literal type="string">"		pg_catalog.pg_namespace n, "</literal>
								<literal type="string">"		pg_catalog.pg_attribute a "</literal>
								<literal type="string">"WHERE	c.oid = a.attrelid AND "</literal>
								<literal type="string">"		NOT a.attisdropped AND "</literal>
								<literal type="string">"		a.atttypid = 'pg_catalog.unknown'::pg_catalog.regtype AND "</literal>
								<literal type="string">"		c.relkind IN ("</literal>
								<call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
								<call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
								<call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">") AND "</literal>
								<literal type="string">"		c.relnamespace = n.oid AND "</literal>
		<comment type="block">/* exclude possible orphaned temp tables */</comment>
								<literal type="string">"		n.nspname !~ '^pg_temp_' AND "</literal>
								<literal type="string">"		n.nspname !~ '^pg_toast_temp_' AND "</literal>
								<literal type="string">"		n.nspname NOT IN ('pg_catalog', 'information_schema')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_nspname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_relname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>rowno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>script</name> <operator>=</operator> <call><name>fopen_priv</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %s\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>,
						 <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db_used</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"Database: %s\n"</literal></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>db_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"  %s.%s.%s\n"</literal></expr></argument>,
					<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_nspname</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_relname</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>script</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_REPORT</name></expr></argument>, <argument><expr><literal type="string">"fatal\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"Your installation contains the \"unknown\" data type in user tables.  This\n"</literal>
				 <literal type="string">"data type is no longer allowed in tables, so this cluster cannot currently\n"</literal>
				 <literal type="string">"be upgraded.  You can remove the problem tables and restart the upgrade.\n"</literal>
				 <literal type="string">"A list of the problem columns is in the file:\n"</literal>
				 <literal type="string">"    %s\n\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * old_9_6_invalidate_hash_indexes()
 *	9.6 -&gt; 10
 *	Hash index binary format has changed from 9.6-&gt;10.0
 */</comment>
<function><type><name>void</name></type>
<name>old_9_6_invalidate_hash_indexes</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>check_mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>output_path</name> <init>= <expr><literal type="string">"reindex_hash.sql"</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>prep_status</name><argument_list>(<argument><expr><literal type="string">"Checking for hash indexes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>db_used</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rowno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_nspname</name></decl>,
					<decl><type ref="prev"/><name>i_relname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>active_db</name> <init>= <expr><operator>&amp;</operator><name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>connectToServer</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* find hash indexes */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
								<argument><expr><literal type="string">"SELECT n.nspname, c.relname "</literal>
								<literal type="string">"FROM	pg_catalog.pg_class c, "</literal>
								<literal type="string">"		pg_catalog.pg_index i, "</literal>
								<literal type="string">"		pg_catalog.pg_am a, "</literal>
								<literal type="string">"		pg_catalog.pg_namespace n "</literal>
								<literal type="string">"WHERE	i.indexrelid = c.oid AND "</literal>
								<literal type="string">"		c.relam = a.oid AND "</literal>
								<literal type="string">"		c.relnamespace = n.oid AND "</literal>
								<literal type="string">"		a.amname = 'hash'"</literal></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_nspname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_relname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>rowno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>check_mode</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>script</name> <operator>=</operator> <call><name>fopen_priv</name><argument_list>(<argument><expr><name>output_path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %s\n"</literal></expr></argument>, <argument><expr><name>output_path</name></expr></argument>,
							 <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db_used</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>connectbuf</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connectbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPsqlMetaConnect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connectbuf</name></expr></argument>, <argument><expr><name><name>active_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>connectbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connectbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>db_used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="string">"REINDEX INDEX %s.%s;\n"</literal></expr></argument>,
						<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><name>i_relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>check_mode</name> <operator>&amp;&amp;</operator> <name>db_used</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* mark hash indexes as invalid */</comment>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
									  <argument><expr><literal type="string">"UPDATE pg_catalog.pg_index i "</literal>
									  <literal type="string">"SET	indisvalid = false "</literal>
									  <literal type="string">"FROM	pg_catalog.pg_class c, "</literal>
									  <literal type="string">"		pg_catalog.pg_am a, "</literal>
									  <literal type="string">"		pg_catalog.pg_namespace n "</literal>
									  <literal type="string">"WHERE	i.indexrelid = c.oid AND "</literal>
									  <literal type="string">"		c.relam = a.oid AND "</literal>
									  <literal type="string">"		c.relnamespace = n.oid AND "</literal>
									  <literal type="string">"		a.amname = 'hash'"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>script</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_status</name><argument_list>(<argument><expr><name>PG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"warning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>check_mode</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal>
				   <literal type="string">"Your installation contains hash indexes.  These indexes have different\n"</literal>
				   <literal type="string">"internal formats between your old and new clusters, so they must be\n"</literal>
				   <literal type="string">"reindexed with the REINDEX command.  After upgrading, you will be given\n"</literal>
				   <literal type="string">"REINDEX instructions.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal>
				   <literal type="string">"Your installation contains hash indexes.  These indexes have different\n"</literal>
				   <literal type="string">"internal formats between your old and new clusters, so they must be\n"</literal>
				   <literal type="string">"reindexed with the REINDEX command.  The file\n"</literal>
				   <literal type="string">"    %s\n"</literal>
				   <literal type="string">"when executed by psql by the database superuser will recreate all invalid\n"</literal>
				   <literal type="string">"indexes; until then, none of these indexes will be used.\n\n"</literal></expr></argument>,
				   <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
