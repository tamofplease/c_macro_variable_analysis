<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/bin/initdb/initdb.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * initdb --- initialize a PostgreSQL installation
 *
 * initdb creates (initializes) a PostgreSQL database cluster (site,
 * instance, installation, whatever).  A database cluster is a
 * collection of PostgreSQL databases all managed by the same server.
 *
 * To create the database cluster, we create the directory that contains
 * all its data, create the files that hold the global tables, create
 * a few other control files for it, and create three databases: the
 * template databases "template0" and "template1", and a default user
 * database "postgres".
 *
 * The template databases are ordinary PostgreSQL databases.  template0
 * is never supposed to change after initdb, whereas template1 can be
 * changed to add site-local standard data.  Either one can be copied
 * to produce a new database.
 *
 * For largely-historical reasons, the template1 database is the one built
 * by the basic bootstrap process.  After it is complete, template0 and
 * the default database, postgres, are made just by copying template1.
 *
 * To create template1, we run the postgres (backend) program in bootstrap
 * mode and feed it data from the postgres.bki library file.  After this
 * initial bootstrap phase, some additional stuff is created by normal
 * SQL commands fed to a standalone backend.  Some of those commands are
 * just embedded into this program (yeah, it's ugly), but larger chunks
 * are taken from script files.
 *
 *
 * Note:
 *	 The program has some memory leakage - it isn't worth cleaning it up.
 *
 * This is a C implementation of the previous shell script for setting up a
 * PostgreSQL cluster location, and should be highly compatible with it.
 * author of C translation: Andrew Dunstan	   mailto:andrew@dunslane.net
 *
 * This code is released under the terms of the PostgreSQL License.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/bin/initdb/initdb.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SHM_OPEN</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sys/mman.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class_d.h"</cpp:file></cpp:include> <comment type="block">/* pgrminclude ignore */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/logging.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/restricted_token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/username.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getaddrinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>


<comment type="block">/* Ideally this would be in a .h file, but it hardly seems worth the trouble */</comment>
<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>select_default_timezone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>share_path</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>auth_methods_host</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"trust"</literal></expr>, <expr><literal type="string">"reject"</literal></expr>, <expr><literal type="string">"scram-sha-256"</literal></expr>, <expr><literal type="string">"md5"</literal></expr>, <expr><literal type="string">"password"</literal></expr>, <expr><literal type="string">"ident"</literal></expr>, <expr><literal type="string">"radius"</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
	<expr><literal type="string">"gss"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>
	<expr><literal type="string">"sspi"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PAM</name></cpp:ifdef>
	<expr><literal type="string">"pam"</literal></expr>, <expr><literal type="string">"pam "</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BSD_AUTH</name></cpp:ifdef>
	<expr><literal type="string">"bsd"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>
	<expr><literal type="string">"ldap"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<expr><literal type="string">"cert"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>auth_methods_local</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"trust"</literal></expr>, <expr><literal type="string">"reject"</literal></expr>, <expr><literal type="string">"scram-sha-256"</literal></expr>, <expr><literal type="string">"md5"</literal></expr>, <expr><literal type="string">"password"</literal></expr>, <expr><literal type="string">"peer"</literal></expr>, <expr><literal type="string">"radius"</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PAM</name></cpp:ifdef>
	<expr><literal type="string">"pam"</literal></expr>, <expr><literal type="string">"pam "</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BSD_AUTH</name></cpp:ifdef>
	<expr><literal type="string">"bsd"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>
	<expr><literal type="string">"ldap"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * these values are passed in by makefile defines
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>share_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* values to be obtained from arguments */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_collate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_ctype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_monetary</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_numeric</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_time</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_messages</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>default_text_search_config</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>pwprompt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pwfilename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>superuser_password</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>authmethodhost</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>authmethodlocal</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>debug</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>noclean</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>do_sync</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>sync_only</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>show_setting</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>data_checksums</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog_dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>str_wal_segment_size_mb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>wal_segment_size_mb</name></decl>;</decl_stmt>


<comment type="block">/* internal vars */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>encodingid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>bki_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>desc_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>shdesc_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>hba_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ident_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>conf_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>dictionary_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>info_schema_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>cdb_init_d_dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>features_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>system_views_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>success</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_new_pgdata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_existing_pgdata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_new_xlogdir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_existing_xlogdir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>infoversion</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>caught_signal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>output_failed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>output_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pgdata_native</name></decl>;</decl_stmt>

<comment type="block">/* defaults */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>n_connections</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>n_buffers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dynamic_shared_memory_type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>default_timezone</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Warning messages for authentication methods
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTHTRUST_WARNING</name></cpp:macro> \
<cpp:value>"# CAUTION: Configuring the system for local \"trust\" authentication\n" \
"# allows any local user to connect as any PostgreSQL user, including\n" \
"# the database superuser.  If you do not trust all your local users,\n" \
"# use another authentication method.\n"</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>authwarning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Centralized knowledge of switches to pass to backend
 *
 * Note: we run the backend with -F (fsync disabled) and then do a single
 * pass of fsync'ing at the end.  This is faster than fsync'ing each step.
 *
 * Note: in the shell-script version, we also passed PGDATA as a -D switch,
 * but here it is more convenient to pass it as an environment variable
 * (no quoting to worry about).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>boot_options</name> <init>= <expr><literal type="string">"-F"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>backend_options</name> <init>= <expr><literal type="string">"--single -F -O -j -c gp_role=utility -c search_path=pg_catalog -c exit_on_error=true"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>subdirs</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"global"</literal></expr>,
	<expr><literal type="string">"pg_wal/archive_status"</literal></expr>,
	<expr><literal type="string">"pg_commit_ts"</literal></expr>,
	<expr><literal type="string">"pg_dynshmem"</literal></expr>,
	<expr><literal type="string">"pg_notify"</literal></expr>,
	<expr><literal type="string">"pg_serial"</literal></expr>,
	<expr><literal type="string">"pg_snapshots"</literal></expr>,
	<expr><literal type="string">"pg_subtrans"</literal></expr>,
	<expr><literal type="string">"pg_twophase"</literal></expr>,
	<expr><literal type="string">"pg_multixact"</literal></expr>,
	<expr><literal type="string">"pg_multixact/members"</literal></expr>,
	<expr><literal type="string">"pg_multixact/offsets"</literal></expr>,
	<expr><literal type="string">"base"</literal></expr>,
	<expr><literal type="string">"base/1"</literal></expr>,
	<expr><literal type="string">"pg_replslot"</literal></expr>,
	<expr><literal type="string">"pg_tblspc"</literal></expr>,
	<expr><literal type="string">"pg_stat"</literal></expr>,
	<expr><literal type="string">"pg_stat_tmp"</literal></expr>,
	<expr><literal type="string">"pg_xact"</literal></expr>,
	<expr><literal type="string">"pg_logical"</literal></expr>,
	<expr><literal type="string">"pg_logical/snapshots"</literal></expr>,
	<expr><literal type="string">"pg_logical/mappings"</literal></expr>,
	<comment type="block">/* GPDB needs these directories */</comment>
	<expr><literal type="string">"pg_distributedlog"</literal></expr>,
	<expr><literal type="string">"log"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* path to 'initdb' binary directory */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>bin_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>backend_exec</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>replace_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replacement</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifndef>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filter_lines_with_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>readfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>writefile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>popen_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_id</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>get_encoding_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_version_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extrapath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_null_conf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>test_config_settings</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_config</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bootstrap_template1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_auth</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_su_pwd</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_depend</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_sysviews</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_description</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void setup_collation(FILE *cmdfd);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_dictionary</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_privileges</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_info_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_schema</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_cdb_schema</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_plpgsql</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vacuum_db</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_template0</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_postgres</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>trapsig</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_ok</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>escape_quotes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>escape_quotes_bki</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>locale_date_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_locale_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>category</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>canonname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_locale_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setlocales</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>setup_pgdata</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>setup_bin_paths</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>setup_data_file_paths</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>setup_locale_encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>setup_signals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>setup_text_search</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>create_data_directory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>create_xlog_or_symlink</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>warn_on_mount_point</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>initialize_data_directory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * macros for running pipes to postgres
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_DECL</name></cpp:macro>		<cpp:value>char cmd[MAXPGPATH]; FILE *cmdfd</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_OPEN</name></cpp:macro> \
<cpp:value>do { \
	cmdfd = popen_check(cmd, "w"); \
	if (cmdfd == NULL) \
		exit(1); <comment type="block">/* message already printed by popen_check */</comment> \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_CLOSE</name></cpp:macro> \
<cpp:value>do { \
	if (pclose_check(cmdfd)) \
		exit(1); <comment type="block">/* message already printed by pclose_check */</comment> \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_PUTS</name><parameter_list>(<parameter><type><name>line</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (fputs(line, cmdfd) &lt; 0 || fflush(cmdfd) &lt; 0) \
		output_failed = true, output_errno = errno; \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_PRINTF1</name><parameter_list>(<parameter><type><name>fmt</name></type></parameter>, <parameter><type><name>arg1</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (fprintf(cmdfd, fmt, arg1) &lt; 0 || fflush(cmdfd) &lt; 0) \
		output_failed = true, output_errno = errno; \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_PRINTF2</name><parameter_list>(<parameter><type><name>fmt</name></type></parameter>, <parameter><type><name>arg1</name></type></parameter>, <parameter><type><name>arg2</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (fprintf(cmdfd, fmt, arg1, arg2) &lt; 0 || fflush(cmdfd) &lt; 0) \
		output_failed = true, output_errno = errno; \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CMD_PRINTF3</name><parameter_list>(<parameter><type><name>fmt</name></type></parameter>, <parameter><type><name>arg1</name></type></parameter>, <parameter><type><name>arg2</name></type></parameter>, <parameter><type><name>arg3</name></type></parameter>)</parameter_list></cpp:macro>		\
<cpp:value>do { \
	if (fprintf(cmdfd, fmt, arg1, arg2, arg3) &lt; 0 || fflush(cmdfd) &lt; 0) \
		output_failed = true, output_errno = errno; \
} while (0)</cpp:value></cpp:define>

<comment type="block">/*
 * Escape single quotes and backslashes, suitably for insertions into
 * configuration files or SQL E'' strings.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>escape_quotes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>escape_single_quotes_ascii</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Escape a field value to be inserted into the BKI data.
 * Here, we first run the value through escape_quotes (which
 * will be inverted by the backend's scanstr() function) and
 * then overlay special processing of double quotes, which
 * bootscanner.l will only accept as data if converted to octal
 * representation ("\042").  We always wrap the value in double
 * quotes, even if that isn't strictly necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>escape_quotes_bki</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>resultp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>datap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nquotes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* count double quotes in data */</comment>
	<expr_stmt><expr><name>datap</name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>datap</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>datap</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nquotes</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>datap</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <name>nquotes</name> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultp</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>resultp</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>datap</name> <operator>=</operator> <name>data</name></expr>;</init> <condition><expr><operator>*</operator><name>datap</name></expr>;</condition> <incr><expr><name>datap</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>datap</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>resultp</name></expr></argument>, <argument><expr><literal type="string">"\\042"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>resultp</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>resultp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>datap</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>resultp</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>resultp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make a copy of the array of lines, with token replaced by replacement
 * the first time it occurs on each line.
 *
 * This does most of what sed was used for in the shell script, but
 * doesn't need any regexp stuff.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>replace_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replacement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numlines</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>toklen</name></decl>,
				<decl><type ref="prev"/><name>replen</name></decl>,
				<decl><type ref="prev"/><name>diff</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numlines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numlines</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>toklen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>replen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>replen</name> <operator>-</operator> <name>toklen</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numlines</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>where</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newline</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>pre</name></decl>;</decl_stmt>

		<comment type="block">/* just copy pointer if NULL or no change needed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>where</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* if we get here a change is needed - set up new line */</comment>

		<expr_stmt><expr><name>newline</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>diff</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pre</name> <operator>=</operator> <name>where</name> <operator>-</operator> <name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newline</name></expr></argument>, <argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newline</name> <operator>+</operator> <name>pre</name></expr></argument>, <argument><expr><name>replacement</name></expr></argument>, <argument><expr><name>replen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newline</name> <operator>+</operator> <name>pre</name> <operator>+</operator> <name>replen</name></expr></argument>, <argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>pre</name> <operator>+</operator> <name>toklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newline</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make a copy of lines without any that contain the token
 *
 * a sort of poor man's grep -v
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>filter_lines_with_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numlines</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>src</name></decl>,
				<decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numlines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numlines</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>src</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>dst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>src</name> <operator>&lt;</operator> <name>numlines</name></expr>;</condition> <incr><expr><name>src</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>lines</name><index>[<expr><name>src</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr><name>src</name></expr>]</index></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><index>[<expr><name>dst</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>lines</name><index>[<expr><name>src</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * get the lines from a text file
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>readfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>infile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxlength</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>linelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nlines</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>infile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for reading: %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* pass over the file twice - the first time to size the result */</comment>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>linelen</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nlines</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>linelen</name> <operator>&gt;</operator> <name>maxlength</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>maxlength</name> <operator>=</operator> <name>linelen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>linelen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* handle last line without a terminating newline (yuck) */</comment>
	<if_stmt><if>if <condition>(<expr><name>linelen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nlines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>linelen</name> <operator>&gt;</operator> <name>maxlength</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxlength</name> <operator>=</operator> <name>linelen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* set up the result and the line buffer */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>nlines</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>maxlength</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now reprocess the file and store the lines */</comment>
	<expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlength</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>infile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name>nlines</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * write an array of lines to a file
 *
 * This is only used to write text files.  Use fopen "w" not PG_BINARY_W
 * so that the resulting configuration files are nicely editable on Windows.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>writefile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>out_file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>out_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for writing: %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>lines</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fputs</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>, <argument><expr><name>out_file</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>out_file</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open a subcommand with suitable error messaging
 */</comment>
<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>popen_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>cmdfd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmdfd</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmdfd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not execute command \"%s\": %m"</literal></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>cmdfd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * clean up any files we created on failure
 * if we created the data directory remove it too
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup_directories_atexit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noclean</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>made_new_pgdata</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"removing data directory \"%s\""</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"failed to remove data directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>found_existing_pgdata</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"removing contents of data directory \"%s\""</literal></expr></argument>,
						<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"failed to remove contents of data directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>made_new_xlogdir</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"removing WAL directory \"%s\""</literal></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"failed to remove WAL directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>found_existing_xlogdir</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"removing contents of WAL directory \"%s\""</literal></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"failed to remove contents of WAL directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* otherwise died during startup, do nothing! */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>made_new_pgdata</name> <operator>||</operator> <name>found_existing_pgdata</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"data directory \"%s\" not removed at user's request"</literal></expr></argument>,
						<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>made_new_xlogdir</name> <operator>||</operator> <name>found_existing_xlogdir</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"WAL directory \"%s\" not removed at user's request"</literal></expr></argument>,
						<argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * find the current user
 *
 * on unix make sure it isn't root
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_id</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><call><name>geteuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>			<comment type="block">/* 0 is root's uid */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"cannot be run as root"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Please log in (using, e.g., \"su\") as the (unprivileged) user that will\n"</literal>
				  <literal type="string">"own the server process.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>username</name> <operator>=</operator> <call><name>get_user_name_or_exit</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>encodingid_to_string</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>result</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get the encoding id for a given encoding name
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_encoding_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>enc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>encoding_name</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>encoding_name</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>enc</name> <operator>=</operator> <call><name>pg_valid_server_encoding</name><argument_list>(<argument><expr><name>encoding_name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>enc</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a valid server encoding name"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>encoding_name</name></expr> ?</condition><then> <expr><name>encoding_name</name></expr> </then><else>: <expr><literal type="string">"(null)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Support for determining the best default text search configuration.
 * We key this off the first part of LC_CTYPE (ie, the language name).
 */</comment>
<struct>struct <name>tsearch_config_match</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tsconfname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>langname</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>tsearch_config_match</name></name></type> <name><name>tsearch_config_languages</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{<expr><literal type="string">"arabic"</literal></expr>, <expr><literal type="string">"ar"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"arabic"</literal></expr>, <expr><literal type="string">"Arabic"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"danish"</literal></expr>, <expr><literal type="string">"da"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"danish"</literal></expr>, <expr><literal type="string">"Danish"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"dutch"</literal></expr>, <expr><literal type="string">"nl"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"dutch"</literal></expr>, <expr><literal type="string">"Dutch"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"english"</literal></expr>, <expr><literal type="string">"C"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"english"</literal></expr>, <expr><literal type="string">"POSIX"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"english"</literal></expr>, <expr><literal type="string">"en"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"english"</literal></expr>, <expr><literal type="string">"English"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"finnish"</literal></expr>, <expr><literal type="string">"fi"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"finnish"</literal></expr>, <expr><literal type="string">"Finnish"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"french"</literal></expr>, <expr><literal type="string">"fr"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"french"</literal></expr>, <expr><literal type="string">"French"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"german"</literal></expr>, <expr><literal type="string">"de"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"german"</literal></expr>, <expr><literal type="string">"German"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"hungarian"</literal></expr>, <expr><literal type="string">"hu"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"hungarian"</literal></expr>, <expr><literal type="string">"Hungarian"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"indonesian"</literal></expr>, <expr><literal type="string">"id"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"indonesian"</literal></expr>, <expr><literal type="string">"Indonesian"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"irish"</literal></expr>, <expr><literal type="string">"ga"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"irish"</literal></expr>, <expr><literal type="string">"Irish"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"italian"</literal></expr>, <expr><literal type="string">"it"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"italian"</literal></expr>, <expr><literal type="string">"Italian"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"lithuanian"</literal></expr>, <expr><literal type="string">"lt"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"lithuanian"</literal></expr>, <expr><literal type="string">"Lithuanian"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"nepali"</literal></expr>, <expr><literal type="string">"ne"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"nepali"</literal></expr>, <expr><literal type="string">"Nepali"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"norwegian"</literal></expr>, <expr><literal type="string">"no"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"norwegian"</literal></expr>, <expr><literal type="string">"Norwegian"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"portuguese"</literal></expr>, <expr><literal type="string">"pt"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"portuguese"</literal></expr>, <expr><literal type="string">"Portuguese"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"romanian"</literal></expr>, <expr><literal type="string">"ro"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"russian"</literal></expr>, <expr><literal type="string">"ru"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"russian"</literal></expr>, <expr><literal type="string">"Russian"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"spanish"</literal></expr>, <expr><literal type="string">"es"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"spanish"</literal></expr>, <expr><literal type="string">"Spanish"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"swedish"</literal></expr>, <expr><literal type="string">"sv"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"swedish"</literal></expr>, <expr><literal type="string">"Swedish"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"tamil"</literal></expr>, <expr><literal type="string">"ta"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"tamil"</literal></expr>, <expr><literal type="string">"Tamil"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"turkish"</literal></expr>, <expr><literal type="string">"tr"</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"turkish"</literal></expr>, <expr><literal type="string">"Turkish"</literal></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>				<comment type="block">/* end marker */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Look for a text search configuration matching lc_ctype, and return its
 * name; return NULL if no match.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>find_matching_ts_config</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lc_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>langname</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Convert lc_ctype to a language name by stripping everything after an
	 * underscore (usual case) or a hyphen (Windows "locale name"; see
	 * comments at IsoLocaleName()).
	 *
	 * XXX Should ' ' be a stop character?	This would select "norwegian" for
	 * the Windows locale "Norwegian (Nynorsk)_Norway.1252".  If we do so, we
	 * should also accept the "nn" and "nb" Unix locales.
	 *
	 * Just for paranoia, we also stop at '.' or '@'.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lc_type</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>langname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>langname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>lc_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator>
			   <operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tsearch_config_languages</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tsconfname</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>tsearch_config_languages</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>langname</name></expr></argument>, <argument><expr><name>langname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>langname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>tsearch_config_languages</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tsconfname</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>langname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * set name of given input file variable under data directory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>share_path</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check that given input file exists
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"file \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"This might mean you have a corrupted installation or identified\n"</literal>
					  <literal type="string">"the wrong directory with the invocation option -L.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not access file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"This might mean you have a corrupted installation or identified\n"</literal>
					  <literal type="string">"the wrong directory with the invocation option -L.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"file \"%s\" is not a regular file"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"This might mean you have a corrupted installation or identified\n"</literal>
				  <literal type="string">"the wrong directory with the invocation option -L.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * write out the PG_VERSION file in the data dir, or its subdirectory
 * if extrapath is not NULL
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_version_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extrapath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>version_file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>extrapath</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/PG_VERSION"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s/PG_VERSION"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>extrapath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>version_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for writing: %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(<argument><expr><name>version_file</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>PG_MAJORVERSION</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>fclose</name><argument_list>(<argument><expr><name>version_file</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set up an empty config file so we can check config settings by launching
 * a test backend
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_null_conf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>conf_file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conf_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>conf_file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for writing: %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>conf_file</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine which dynamic shared memory implementation should be used on
 * this platform.  POSIX shared memory is preferable because the default
 * allocation limits are much higher than the limits for System V on most
 * systems that support both, but the fact that a platform has shm_open
 * doesn't guarantee that that call will succeed when attempted.  So, we
 * attempt to reproduce what the postmaster will do when allocating a POSIX
 * segment in dsm_impl.c; if it doesn't work, we assume it won't work for
 * the postmaster either, and configure the cluster for System V shared
 * memory instead.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>choose_dsm_implementation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SHM_OPEN</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntries</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Initialize random(); this function is its only user in this program. */</comment>
	<expr_stmt><expr><call><name>srandom</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><call><name>getpid</name><argument_list>()</argument_list></call> <operator>^</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>ntries</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>handle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"/PostgreSQL.%u"</literal></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>shm_open</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_RDWR</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shm_unlink</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="string">"posix"</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>--</operator><name>ntries</name></expr>;</expr_stmt>
	</block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<return>return <expr><literal type="string">"windows"</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><literal type="string">"sysv"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Determine platform-specific config settings
 *
 * Use reasonable values if kernel will let us, else scale back.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_config_settings</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This macro defines the minimum shared_buffers we want for a given
	 * max_connections value. The arrays show the settings to try.
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_BUFS_FOR_CONNS</name><parameter_list>(<parameter><type><name>nconns</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((nconns) * 10)</cpp:value></cpp:define>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>trial_conns</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="number">200</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><literal type="number">50</literal></expr>, <expr><literal type="number">40</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">10</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>trial_bufs</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="number">16384</literal></expr>, <expr><literal type="number">8192</literal></expr>, <expr><literal type="number">4096</literal></expr>, <expr><literal type="number">3584</literal></expr>, <expr><literal type="number">3072</literal></expr>, <expr><literal type="number">2560</literal></expr>, <expr><literal type="number">2048</literal></expr>, <expr><literal type="number">1536</literal></expr>,
		<expr><literal type="number">1000</literal></expr>, <expr><literal type="number">900</literal></expr>, <expr><literal type="number">800</literal></expr>, <expr><literal type="number">700</literal></expr>, <expr><literal type="number">600</literal></expr>, <expr><literal type="number">500</literal></expr>,
		<expr><literal type="number">400</literal></expr>, <expr><literal type="number">300</literal></expr>, <expr><literal type="number">200</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><literal type="number">50</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name>connslen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>trial_conns</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name>bufslen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>trial_bufs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>status</name></decl>,
				<decl><type ref="prev"/><name>test_conns</name></decl>,
				<decl><type ref="prev"/><name>test_buffs</name></decl>,
				<decl><type ref="prev"/><name>ok_buffers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Need to determine working DSM implementation first so that subsequent
	 * tests don't fail because DSM setting doesn't work.
	 */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"selecting dynamic shared memory implementation ... "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dynamic_shared_memory_type</name> <operator>=</operator> <call><name>choose_dsm_implementation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>dynamic_shared_memory_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Probe for max_connections before shared_buffers, since it is subject to
	 * more constraints than shared_buffers.
	 */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"selecting default max_connections ... "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>connslen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>test_conns</name> <operator>=</operator> <name><name>trial_conns</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n_connections</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>test_conns</name> <operator>=</operator> <name>n_connections</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>test_buffs</name> <operator>=</operator> <call><name>MIN_BUFS_FOR_CONNS</name><argument_list>(<argument><expr><name>test_conns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n_buffers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>test_buffs</name> <operator>=</operator> <name>n_buffers</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"\"%s\" --boot -x0 %s "</literal>
				 <literal type="string">"-c max_connections=%d "</literal>
				 <literal type="string">"-c shared_buffers=%d "</literal>
				 <literal type="string">"-c dynamic_shared_memory_type=%s "</literal>
				 <literal type="string">"&lt; \"%s\" &gt; \"%s\" 2&gt;&amp;1"</literal></expr></argument>,
				 <argument><expr><name>backend_exec</name></expr></argument>, <argument><expr><name>boot_options</name></expr></argument>,
				 <argument><expr><name>test_conns</name></expr></argument>, <argument><expr><name>test_buffs</name></expr></argument>,
				 <argument><expr><name>dynamic_shared_memory_type</name></expr></argument>,
				 <argument><expr><name>DEVNULL</name></expr></argument>, <argument><expr><name>DEVNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>n_connections</name> <operator>=</operator> <name>test_conns</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ok_buffers</name> <operator>=</operator> <name>test_buffs</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>n_connections</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>==</operator> <name>connslen</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"%s: error %d from: %s"</literal></expr></argument>,
						 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>n_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"selecting default shared_buffers ... "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bufslen</name> <operator>&amp;&amp;</operator> <name>n_buffers</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Use same amount of memory, independent of BLCKSZ */</comment>
		<expr_stmt><expr><name>test_buffs</name> <operator>=</operator> <operator>(</operator><name><name>trial_bufs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">8192</literal><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>test_buffs</name> <operator>&lt;=</operator> <name>ok_buffers</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>n_buffers</name> <operator>=</operator> <name>ok_buffers</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"\"%s\" --boot -x0 %s "</literal>
				 <literal type="string">"-c max_connections=%d "</literal>
				 <literal type="string">"-c shared_buffers=%d "</literal>
				 <literal type="string">"-c dynamic_shared_memory_type=%s "</literal>
				 <literal type="string">"&lt; \"%s\" &gt; \"%s\" 2&gt;&amp;1"</literal></expr></argument>,
				 <argument><expr><name>backend_exec</name></expr></argument>, <argument><expr><name>boot_options</name></expr></argument>,
				 <argument><expr><name>n_connections</name></expr></argument>, <argument><expr><name>test_buffs</name></expr></argument>,
				 <argument><expr><name>dynamic_shared_memory_type</name></expr></argument>,
				 <argument><expr><name>DEVNULL</name></expr></argument>, <argument><expr><name>DEVNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>n_buffers</name> <operator>=</operator> <name>test_buffs</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>bufslen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"%s: error %d from: %s"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator> <operator>%</operator> <literal type="number">1024</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%dMB\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%dkB\n"</literal></expr></argument>, <argument><expr><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"selecting default timezone ... "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>default_timezone</name> <operator>=</operator> <call><name>select_default_timezone</name><argument_list>(<argument><expr><name>share_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>default_timezone</name></expr> ?</condition><then> <expr><name>default_timezone</name></expr> </then><else>: <expr><literal type="string">"GMT"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the default wal_size with a "pretty" unit.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pretty_wal_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>segment_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>sz</name> <init>= <expr><name>wal_segment_size_mb</name> <operator>*</operator> <name>segment_count</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>pg_malloc</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sz</name> <operator>%</operator> <literal type="number">1024</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="string">"%dGB"</literal></expr></argument>, <argument><expr><name>sz</name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="string">"%dMB"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set up all the config files
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_config</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>conflines</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>repltok</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>autoconflines</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating configuration files ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* postgresql.conf */</comment>

	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>conf_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"max_connections = %d"</literal></expr></argument>, <argument><expr><name>n_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#max_connections = 200"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator> <operator>%</operator> <literal type="number">1024</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"shared_buffers = %dMB"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"shared_buffers = %dkB"</literal></expr></argument>,
				 <argument><expr><name>n_buffers</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#shared_buffers = 128MB"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#unix_socket_directories = '%s'"</literal></expr></argument>,
			 <argument><expr><name>DEFAULT_PGSOCKET_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#unix_socket_directories = ''"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#unix_socket_directories = '/tmp'"</literal></expr></argument>,
							  <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEF_PGPORT</name> <operator>!=</operator> <literal type="number">5432</literal></expr></cpp:if>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#port = %d"</literal></expr></argument>, <argument><expr><name>DEF_PGPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#port = 5432"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* set default max_wal_size and min_wal_size */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"min_wal_size = %s"</literal></expr></argument>,
			 <argument><expr><call><name>pretty_wal_size</name><argument_list>(<argument><expr><name>DEFAULT_MIN_WAL_SEGS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#min_wal_size = 80MB"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"max_wal_size = %s"</literal></expr></argument>,
			 <argument><expr><call><name>pretty_wal_size</name><argument_list>(<argument><expr><name>DEFAULT_MAX_WAL_SEGS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#max_wal_size = 1GB"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"lc_messages = '%s'"</literal></expr></argument>,
			 <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>lc_messages</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#lc_messages = 'C'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"lc_monetary = '%s'"</literal></expr></argument>,
			 <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>lc_monetary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#lc_monetary = 'C'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"lc_numeric = '%s'"</literal></expr></argument>,
			 <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>lc_numeric</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#lc_numeric = 'C'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"lc_time = '%s'"</literal></expr></argument>,
			 <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>lc_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#lc_time = 'C'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>locale_date_order</name><argument_list>(<argument><expr><name>lc_time</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEORDER_YMD</name></expr>:</case>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><literal type="string">"datestyle = 'iso, ymd'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DATEORDER_DMY</name></expr>:</case>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><literal type="string">"datestyle = 'iso, dmy'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DATEORDER_MDY</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><literal type="string">"datestyle = 'iso, mdy'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#datestyle = 'iso, mdy'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"default_text_search_config = 'pg_catalog.%s'"</literal></expr></argument>,
			 <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>default_text_search_config</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
							  <argument><expr><literal type="string">"#default_text_search_config = 'pg_catalog.simple'"</literal></expr></argument>,
							  <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>default_timezone</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"timezone = '%s'"</literal></expr></argument>,
				 <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>default_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#timezone = 'GMT'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"log_timezone = '%s'"</literal></expr></argument>,
				 <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>default_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#log_timezone = 'GMT'"</literal></expr></argument>, <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"dynamic_shared_memory_type = %s"</literal></expr></argument>,
			 <argument><expr><name>dynamic_shared_memory_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#dynamic_shared_memory_type = posix"</literal></expr></argument>,
							  <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEFAULT_BACKEND_FLUSH_AFTER</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#backend_flush_after = %dkB"</literal></expr></argument>,
			 <argument><expr><name>DEFAULT_BACKEND_FLUSH_AFTER</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#backend_flush_after = 0"</literal></expr></argument>,
							  <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
 * GPDB_12_MERGE_FIXME: the bgwriter section is missing from the sample
 * configuration used for this, should we keep that off the default config
 * or was it all an omission?
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEFAULT_BGWRITER_FLUSH_AFTER</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>
	snprintf(repltok, sizeof(repltok), "#bgwriter_flush_after = %dkB",
			 DEFAULT_BGWRITER_FLUSH_AFTER * (BLCKSZ / 1024));
	conflines = replace_token(conflines, "#bgwriter_flush_after = 0",
							  repltok);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEFAULT_CHECKPOINT_FLUSH_AFTER</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>repltok</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repltok</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#checkpoint_flush_after = %dkB"</literal></expr></argument>,
			 <argument><expr><name>DEFAULT_CHECKPOINT_FLUSH_AFTER</name> <operator>*</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"#checkpoint_flush_after = 0"</literal></expr></argument>,
							  <argument><expr><name>repltok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifndef>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
							  <argument><expr><literal type="string">"#effective_io_concurrency = 1"</literal></expr></argument>,
							  <argument><expr><literal type="string">"#effective_io_concurrency = 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
							  <argument><expr><literal type="string">"#update_process_title = on"</literal></expr></argument>,
							  <argument><expr><literal type="string">"#update_process_title = off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><literal type="string">"scram-sha-256"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodhost</name></expr></argument>, <argument><expr><literal type="string">"scram-sha-256"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
								  <argument><expr><literal type="string">"#password_encryption = md5"</literal></expr></argument>,
								  <argument><expr><literal type="string">"password_encryption = scram-sha-256"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If group access has been enabled for the cluster then it makes sense to
	 * ensure that the log files also allow group access.  Otherwise a backup
	 * from a user in the group would fail if the log files were not
	 * relocated.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pg_dir_create_mode</name> <operator>==</operator> <name>PG_DIR_MODE_GROUP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
								  <argument><expr><literal type="string">"#log_file_mode = 0600"</literal></expr></argument>,
								  <argument><expr><literal type="string">"log_file_mode = 0640"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/postgresql.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not change permissions of \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * create the automatic configuration file to store the configuration
	 * parameters set by ALTER SYSTEM command. The parameters present in this
	 * file will override the value of parameters that exists before parse of
	 * this file.
	 */</comment>
	<expr_stmt><expr><name><name>autoconflines</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"# Do not edit this file manually!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>autoconflines</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"# It will be overwritten by the ALTER SYSTEM command.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>autoconflines</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"%s/postgresql.auto.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>autoconflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not change permissions of \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* pg_hba.conf */</comment>

	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>hba_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifndef>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>filter_lines_with_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"@remove-line-for-nolocal@"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>, <argument><expr><literal type="string">"@remove-line-for-nolocal@"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>

	<comment type="block">/*
	 * Probe to see if there is really any platform support for IPv6, and
	 * comment out the relevant pg_hba line if not.  This avoids runtime
	 * warnings if getaddrinfo doesn't actually cope with IPv6.  Particularly
	 * useful on Windows, where executables built on a machine with IPv6 may
	 * have to run on a machine without.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>gai_result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hints</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<comment type="block">/* need to call WSAStartup before calling getaddrinfo */</comment>
		<decl_stmt><decl><type><name>WSADATA</name></type>		<name>wsaData</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>WSAStartup</name><argument_list>(<argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>wsaData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* for best results, this code should match parse_hba() */</comment>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_NUMERICHOST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addrlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_canonname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>getaddrinfo</name><argument_list>(<argument><expr><literal type="string">"::1"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gai_result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
									  <argument><expr><literal type="string">"host    all             all             ::1"</literal></expr></argument>,
									  <argument><expr><literal type="string">"#host    all             all             ::1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>getaddrinfo</name><argument_list>(<argument><expr><literal type="string">"fe80::1"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gai_result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
                                          <argument><expr><literal type="string">"host    all             all             fe80::1"</literal></expr></argument>,
                                          <argument><expr><literal type="string">"#host    all             all             fe80::1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !HAVE_IPV6 */</comment>
	<comment type="block">/* If we didn't compile IPV6 support at all, always comment it out */</comment>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
							  <argument><expr><literal type="string">"host    all             all             ::1"</literal></expr></argument>,
							  <argument><expr><literal type="string">"#host    all             all             ::1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
							  <argument><expr><literal type="string">"host    replication     all             ::1"</literal></expr></argument>,
							  <argument><expr><literal type="string">"#host    replication     all             ::1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_IPV6 */</comment>

	<comment type="block">/* Replace default authentication methods */</comment>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
							  <argument><expr><literal type="string">"@authmethodhost@"</literal></expr></argument>,
							  <argument><expr><name>authmethodhost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
							  <argument><expr><literal type="string">"@authmethodlocal@"</literal></expr></argument>,
							  <argument><expr><name>authmethodlocal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>,
							  <argument><expr><literal type="string">"@authcomment@"</literal></expr></argument>,
							  <argument><expr><ternary><condition><expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><literal type="string">"trust"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodhost</name></expr></argument>, <argument><expr><literal type="string">"trust"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>AUTHTRUST_WARNING</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/pg_hba.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not change permissions of \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_ident.conf */</comment>

	<expr_stmt><expr><name>conflines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>ident_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/pg_ident.conf"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>writefile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not change permissions of \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conflines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * run the BKI script in bootstrap mode to create template1
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bootstrap_template1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>PG_CMD_DECL</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>bki_lines</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>headerline</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"running bootstrap script ... "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>bki_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that bki file appears to be of the right version */</comment>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>headerline</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>headerline</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"# PostgreSQL %s\n"</literal></expr></argument>,
			 <argument><expr><name>PG_MAJORVERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>headerline</name></expr></argument>, <argument><expr><operator>*</operator><name>bki_lines</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"input file \"%s\" does not belong to PostgreSQL %s"</literal></expr></argument>,
					 <argument><expr><name>bki_file</name></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Check your installation or specify the correct path "</literal>
				  <literal type="string">"using the option -L.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Substitute for various symbols used in the BKI file */</comment>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"NAMEDATALEN"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pointer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"SIZEOF_POINTER"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"ALIGNOF_POINTER"</literal></expr></argument>,
							  <argument><expr><ternary><condition><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Pointer</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"i"</literal></expr> </then><else>: <expr><literal type="string">"d"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"FLOAT4PASSBYVAL"</literal></expr></argument>,
							  <argument><expr><ternary><condition><expr><name>FLOAT4PASSBYVAL</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"FLOAT8PASSBYVAL"</literal></expr></argument>,
							  <argument><expr><ternary><condition><expr><name>FLOAT8PASSBYVAL</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"POSTGRES"</literal></expr></argument>,
							  <argument><expr><call><name>escape_quotes_bki</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"ENCODING"</literal></expr></argument>,
							  <argument><expr><call><name>encodingid_to_string</name><argument_list>(<argument><expr><name>encodingid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"LC_COLLATE"</literal></expr></argument>,
							  <argument><expr><call><name>escape_quotes_bki</name><argument_list>(<argument><expr><name>lc_collate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bki_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>, <argument><expr><literal type="string">"LC_CTYPE"</literal></expr></argument>,
							  <argument><expr><call><name>escape_quotes_bki</name><argument_list>(<argument><expr><name>lc_ctype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pass correct LC_xxx environment to bootstrap.
	 *
	 * The shell script arranged to restore the LC settings afterwards, but
	 * there doesn't seem to be any compelling reason to do that.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"LC_COLLATE=%s"</literal></expr></argument>, <argument><expr><name>lc_collate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"LC_CTYPE=%s"</literal></expr></argument>, <argument><expr><name>lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"LC_ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also ensure backend isn't confused by this environment var: */</comment>
	<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"PGCLIENTENCODING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"\"%s\" --boot -x1 -X %u %s %s %s"</literal></expr></argument>,
			 <argument><expr><name>backend_exec</name></expr></argument>,
			 <argument><expr><name>wal_segment_size_mb</name> <operator>*</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>data_checksums</name></expr> ?</condition><then> <expr><literal type="string">"-k"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			 <argument><expr><name>boot_options</name></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>debug</name></expr> ?</condition><then> <expr><literal type="string">"-d 5"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><name>PG_CMD_OPEN</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>bki_lines</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>PG_CMD_CLOSE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bki_lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set up the shadow password table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_auth</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>pg_authid_setup</name><index>[]</index></name> <init>= <expr><block>{
		<comment type="block">/*
		 * The authid table shouldn't be readable except through views, to
		 * ensure passwords are not publicly visible.
		 */</comment>
		<expr><literal type="string">"REVOKE ALL on pg_authid FROM public;\n\n"</literal></expr>,
		<expr><name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>pg_authid_setup</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>superuser_password</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_CMD_PRINTF2</name><argument_list>(<argument><expr><literal type="string">"ALTER USER \"%s\" WITH PASSWORD E'%s';\n\n"</literal></expr></argument>,
					   <argument><expr><name>username</name></expr></argument>, <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>superuser_password</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get the superuser password if required
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_su_pwd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pwd1</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pwd2</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pwprompt</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Read password from terminal
		 */</comment>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Enter new superuser password: "</literal></expr></argument>, <argument><expr><name>pwd1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwd1</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Enter it again: "</literal></expr></argument>, <argument><expr><name>pwd2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwd2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pwd1</name></expr></argument>, <argument><expr><name>pwd2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Passwords didn't match.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Read password from file
		 *
		 * Ideally this should insist that the file not be world-readable.
		 * However, this option is mainly intended for use on Windows where
		 * file permissions may not exist at all, so we'll skip the paranoia
		 * for now.
		 */</comment>
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>pwf</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>pwfilename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pwf</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" for reading: %m"</literal></expr></argument>,
						 <argument><expr><name>pwfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fgets</name><argument_list>(<argument><expr><name>pwd1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwd1</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pwf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>pwf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not read password from file \"%s\": %m"</literal></expr></argument>,
							 <argument><expr><name>pwfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"password file \"%s\" is empty"</literal></expr></argument>,
							 <argument><expr><name>pwfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>pwf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pwd1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pwd1</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <name><name>pwd1</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pwd1</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>superuser_password</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>pwd1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set up pg_depend
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_depend</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>pg_depend_setup</name><index>[]</index></name> <init>= <expr><block>{
		<comment type="block">/*
		 * Make PIN entries in pg_depend for all objects made so far in the
		 * tables that the dependency code handles.  This is overkill (the
		 * system doesn't really depend on having every last weird datatype,
		 * for instance) but generating only the minimum required set of
		 * dependencies seems hard.
		 *
		 * Catalogs that are intentionally not scanned here are:
		 *
		 * pg_database: it's a feature, not a bug, that template1 is not
		 * pinned.
		 *
		 * pg_extension: a pinned extension isn't really an extension, hmm?
		 *
		 * pg_tablespace: tablespaces don't participate in the dependency
		 * code, and DropTableSpace() explicitly protects the built-in
		 * tablespaces.
		 *
		 * First delete any already-made entries; PINs override all else, and
		 * must be the only entries for their objects.
		 */</comment>
		<expr><literal type="string">"DELETE FROM pg_depend;\n\n"</literal></expr>,
		<expr><literal type="string">"VACUUM pg_depend;\n\n"</literal></expr>,
		<expr><literal type="string">"DELETE FROM pg_shdepend;\n\n"</literal></expr>,
		<expr><literal type="string">"VACUUM pg_shdepend;\n\n"</literal></expr>,

		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_class;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_proc;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_type;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_cast;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_constraint;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_conversion;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_attrdef;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_language;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_operator;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_opclass;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_opfamily;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_am;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_amop;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_amproc;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_rewrite;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_trigger;\n\n"</literal></expr>,

		<comment type="block">/*
		 * restriction here to avoid pinning the public namespace
		 */</comment>
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_namespace "</literal>
		<literal type="string">"    WHERE nspname ~ '^(pg_|gp_)';\n\n"</literal></expr>,

		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_ts_parser;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_ts_dict;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_ts_template;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_ts_config;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_collation;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_shdepend SELECT 0,0,0,0, tableoid,oid, 'p' "</literal>
		<literal type="string">" FROM pg_authid;\n\n"</literal></expr>,

		<comment type="block">/* GPDB additions */</comment>
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_foreign_data_wrapper;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_depend SELECT 0,0,0, tableoid,oid,0, 'p' "</literal>
		<literal type="string">" FROM pg_foreign_server;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_shdepend SELECT 0,0,0,0, tableoid,oid, 'p' "</literal>
		<literal type="string">" FROM pg_resgroup;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_shdepend SELECT 0,0,0,0, tableoid,oid, 'p' "</literal>
		<literal type="string">" FROM pg_resourcetype;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_shdepend SELECT 0,0,0,0, tableoid,oid, 'p' "</literal>
		<literal type="string">" FROM pg_resqueue;\n\n"</literal></expr>,

		<expr><name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>pg_depend_setup</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * set up system views
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_sysviews</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>sysviews_setup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sysviews_setup</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>system_views_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>sysviews_setup</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sysviews_setup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * load description data
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_description</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"CREATE TEMP TABLE tmp_pg_description ( "</literal>
				<literal type="string">"	objoid oid, "</literal>
				<literal type="string">"	classname name, "</literal>
				<literal type="string">"	objsubid int4, "</literal>
				<literal type="string">"	description text);\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_CMD_PRINTF1</name><argument_list>(<argument><expr><literal type="string">"COPY tmp_pg_description FROM E'%s';\n\n"</literal></expr></argument>,
				   <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>desc_file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"INSERT INTO pg_description "</literal>
				<literal type="string">" SELECT t.objoid, c.oid, t.objsubid, t.description "</literal>
				<literal type="string">"  FROM tmp_pg_description t, pg_class c "</literal>
				<literal type="string">"    WHERE c.relname = t.classname;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"CREATE TEMP TABLE tmp_pg_shdescription ( "</literal>
				<literal type="string">" objoid oid, "</literal>
				<literal type="string">" classname name, "</literal>
				<literal type="string">" description text);\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_CMD_PRINTF1</name><argument_list>(<argument><expr><literal type="string">"COPY tmp_pg_shdescription FROM E'%s';\n\n"</literal></expr></argument>,
				   <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>shdesc_file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"INSERT INTO pg_shdescription "</literal>
				<literal type="string">" SELECT t.objoid, c.oid, t.description "</literal>
				<literal type="string">"  FROM tmp_pg_shdescription t, pg_class c "</literal>
				<literal type="string">"   WHERE c.relname = t.classname;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create default descriptions for operator implementation functions */</comment>
	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"WITH funcdescs AS ( "</literal>
				<literal type="string">"SELECT p.oid as p_oid, o.oid as o_oid, oprname "</literal>
				<literal type="string">"FROM pg_proc p JOIN pg_operator o ON oprcode = p.oid ) "</literal>
				<literal type="string">"INSERT INTO pg_description "</literal>
				<literal type="string">"  SELECT p_oid, 'pg_proc'::regclass, 0, "</literal>
				<literal type="string">"    'implementation of ' || oprname || ' operator' "</literal>
				<literal type="string">"  FROM funcdescs "</literal>
				<literal type="string">"  WHERE NOT EXISTS (SELECT 1 FROM pg_description "</literal>
				<literal type="string">"   WHERE objoid = p_oid AND classoid = 'pg_proc'::regclass) "</literal>
				<literal type="string">"  AND NOT EXISTS (SELECT 1 FROM pg_description "</literal>
				<literal type="string">"   WHERE objoid = o_oid AND classoid = 'pg_operator'::regclass"</literal>
				<literal type="string">"         AND description LIKE 'deprecated%');\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Even though the tables are temp, drop them explicitly so they don't get
	 * copied into template0/postgres databases.
	 */</comment>
	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"DROP TABLE tmp_pg_description;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"DROP TABLE tmp_pg_shdescription;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
 * populate pg_collation
 *
 * GPDB: Do not create collations at database initialization time. Instead,
 * the system administrator is expected to run pg_import_system_collations() on
 * every database that needs them. This ensures that collations are synchronized
 * on all segments.
 */</comment>
static void
setup_collation(FILE *cmdfd)
{
	<comment type="block">/*
	 * Add an SQL-standard name.  We don't want to pin this, so it doesn't go
	 * in pg_collation.h.  But add it before reading system collations, so
	 * that it wins if libc defines a locale named ucs_basic.
	 */</comment>
	PG_CMD_PRINTF3("INSERT INTO pg_collation (oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype)"
				   "VALUES (pg_nextoid('pg_catalog.pg_collation', 'oid', 'pg_catalog.pg_collation_oid_index'), 'ucs_basic', 'pg_catalog'::regnamespace, %u, '%c', true, %d, 'C', 'C');\n\n",
				   BOOTSTRAP_SUPERUSERID, COLLPROVIDER_LIBC, PG_UTF8);

	<comment type="block">/* Now import all collations we can find in the operating system */</comment>
	PG_CMD_PUTS("SELECT pg_import_system_collations('pg_catalog');\n\n");
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * load extra dictionaries (Snowball stemmers)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_dictionary</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>conv_lines</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>conv_lines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>dictionary_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>conv_lines</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conv_lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set up privileges
 *
 * We mark most system catalogs as world-readable.  We don't currently have
 * to touch functions, languages, or databases, because their default
 * permissions are OK.
 *
 * Some objects may require different permissions by default, so we
 * make sure we don't overwrite privilege sets that have already been
 * set (NOT NULL).
 *
 * Also populate pg_init_privs to save what the privileges are at init
 * time.  This is used by pg_dump to allow users to change privileges
 * on catalog objects and to have those privilege changes preserved
 * across dump/reload and pg_upgrade.
 *
 * Note that pg_init_privs is only for per-database objects and therefore
 * we don't include databases or tablespaces.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_privileges</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>priv_lines</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>privileges_setup</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"UPDATE pg_class "</literal>
		<literal type="string">"  SET relacl = (SELECT array_agg(a.acl) FROM "</literal>
		<literal type="string">" (SELECT E'=r/\"$POSTGRES_SUPERUSERNAME\"' as acl "</literal>
		<literal type="string">"  UNION SELECT unnest(pg_catalog.acldefault("</literal>
		<literal type="string">"    CASE WHEN relkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN 's' "</literal>
		<literal type="string">"         ELSE 'r' END::\"char\","</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>BOOTSTRAP_SUPERUSERID</name></expr></argument>)</argument_list></call> <literal type="string">"::oid))"</literal>
		<literal type="string">" ) as a) "</literal>
		<literal type="string">"  WHERE relkind IN ("</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
		<call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
		<call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">")"</literal>
		<literal type="string">"  AND relacl IS NULL;\n\n"</literal></expr>,
		<expr><literal type="string">"GRANT USAGE ON SCHEMA pg_catalog TO PUBLIC;\n\n"</literal></expr>,
		<expr><literal type="string">"GRANT CREATE, USAGE ON SCHEMA public TO PUBLIC;\n\n"</literal></expr>,
		<expr><literal type="string">"REVOKE ALL ON pg_largeobject FROM PUBLIC;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_init_privs "</literal>
		<literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
		<literal type="string">"    SELECT"</literal>
		<literal type="string">"        oid,"</literal>
		<literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_class'),"</literal>
		<literal type="string">"        0,"</literal>
		<literal type="string">"        relacl,"</literal>
		<literal type="string">"        'i'"</literal>
		<literal type="string">"    FROM"</literal>
		<literal type="string">"        pg_class"</literal>
		<literal type="string">"    WHERE"</literal>
		<literal type="string">"        relacl IS NOT NULL"</literal>
		<literal type="string">"        AND relkind IN ("</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
		<call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
		<call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">");\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_init_privs "</literal>
		<literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
		<literal type="string">"    SELECT"</literal>
		<literal type="string">"        pg_class.oid,"</literal>
		<literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_class'),"</literal>
		<literal type="string">"        pg_attribute.attnum,"</literal>
		<literal type="string">"        pg_attribute.attacl,"</literal>
		<literal type="string">"        'i'"</literal>
		<literal type="string">"    FROM"</literal>
		<literal type="string">"        pg_class"</literal>
		<literal type="string">"        JOIN pg_attribute ON (pg_class.oid = pg_attribute.attrelid)"</literal>
		<literal type="string">"    WHERE"</literal>
		<literal type="string">"        pg_attribute.attacl IS NOT NULL"</literal>
		<literal type="string">"        AND pg_class.relkind IN ("</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
		<call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
		<call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">");\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_init_privs "</literal>
		<literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
		<literal type="string">"    SELECT"</literal>
		<literal type="string">"        oid,"</literal>
		<literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_proc'),"</literal>
		<literal type="string">"        0,"</literal>
		<literal type="string">"        proacl,"</literal>
		<literal type="string">"        'i'"</literal>
		<literal type="string">"    FROM"</literal>
		<literal type="string">"        pg_proc"</literal>
		<literal type="string">"    WHERE"</literal>
		<literal type="string">"        proacl IS NOT NULL;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_init_privs "</literal>
		<literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
		<literal type="string">"    SELECT"</literal>
		<literal type="string">"        oid,"</literal>
		<literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_type'),"</literal>
		<literal type="string">"        0,"</literal>
		<literal type="string">"        typacl,"</literal>
		<literal type="string">"        'i'"</literal>
		<literal type="string">"    FROM"</literal>
		<literal type="string">"        pg_type"</literal>
		<literal type="string">"    WHERE"</literal>
		<literal type="string">"        typacl IS NOT NULL;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_init_privs "</literal>
		<literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
		<literal type="string">"    SELECT"</literal>
		<literal type="string">"        oid,"</literal>
		<literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_language'),"</literal>
		<literal type="string">"        0,"</literal>
		<literal type="string">"        lanacl,"</literal>
		<literal type="string">"        'i'"</literal>
		<literal type="string">"    FROM"</literal>
		<literal type="string">"        pg_language"</literal>
		<literal type="string">"    WHERE"</literal>
		<literal type="string">"        lanacl IS NOT NULL;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_init_privs "</literal>
		<literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
		<literal type="string">"    SELECT"</literal>
		<literal type="string">"        oid,"</literal>
		<literal type="string">"        (SELECT oid FROM pg_class WHERE "</literal>
		<literal type="string">"		  relname = 'pg_largeobject_metadata'),"</literal>
		<literal type="string">"        0,"</literal>
		<literal type="string">"        lomacl,"</literal>
		<literal type="string">"        'i'"</literal>
		<literal type="string">"    FROM"</literal>
		<literal type="string">"        pg_largeobject_metadata"</literal>
		<literal type="string">"    WHERE"</literal>
		<literal type="string">"        lomacl IS NOT NULL;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_init_privs "</literal>
		<literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
		<literal type="string">"    SELECT"</literal>
		<literal type="string">"        oid,"</literal>
		<literal type="string">"        (SELECT oid FROM pg_class WHERE relname = 'pg_namespace'),"</literal>
		<literal type="string">"        0,"</literal>
		<literal type="string">"        nspacl,"</literal>
		<literal type="string">"        'i'"</literal>
		<literal type="string">"    FROM"</literal>
		<literal type="string">"        pg_namespace"</literal>
		<literal type="string">"    WHERE"</literal>
		<literal type="string">"        nspacl IS NOT NULL;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_init_privs "</literal>
		<literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
		<literal type="string">"    SELECT"</literal>
		<literal type="string">"        oid,"</literal>
		<literal type="string">"        (SELECT oid FROM pg_class WHERE "</literal>
		<literal type="string">"		  relname = 'pg_foreign_data_wrapper'),"</literal>
		<literal type="string">"        0,"</literal>
		<literal type="string">"        fdwacl,"</literal>
		<literal type="string">"        'i'"</literal>
		<literal type="string">"    FROM"</literal>
		<literal type="string">"        pg_foreign_data_wrapper"</literal>
		<literal type="string">"    WHERE"</literal>
		<literal type="string">"        fdwacl IS NOT NULL;\n\n"</literal></expr>,
		<expr><literal type="string">"INSERT INTO pg_init_privs "</literal>
		<literal type="string">"  (objoid, classoid, objsubid, initprivs, privtype)"</literal>
		<literal type="string">"    SELECT"</literal>
		<literal type="string">"        oid,"</literal>
		<literal type="string">"        (SELECT oid FROM pg_class "</literal>
		<literal type="string">"		  WHERE relname = 'pg_foreign_server'),"</literal>
		<literal type="string">"        0,"</literal>
		<literal type="string">"        srvacl,"</literal>
		<literal type="string">"        'i'"</literal>
		<literal type="string">"    FROM"</literal>
		<literal type="string">"        pg_foreign_server"</literal>
		<literal type="string">"    WHERE"</literal>
		<literal type="string">"        srvacl IS NOT NULL;\n\n"</literal></expr>,
		<expr><name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>priv_lines</name> <operator>=</operator> <call><name>replace_token</name><argument_list>(<argument><expr><name>privileges_setup</name></expr></argument>, <argument><expr><literal type="string">"$POSTGRES_SUPERUSERNAME"</literal></expr></argument>,
							   <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>priv_lines</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * extract the strange version of version required for information schema
 * (09.08.0007abc)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_info_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>letterversion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>major</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>minor</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>micro</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>vstr</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>vstr</name> <operator>+</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>vstr</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name><name>ptr</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <operator>*</operator><name>ptr</name></expr></argument> &gt;</argument_list></name> <literal type="char">'9'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><name>letterversion</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>major</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>minor</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>endptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>micro</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>endptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>infoversion</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>infoversion</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%02ld.%02ld.%04ld%s"</literal></expr></argument>,
			 <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>, <argument><expr><name>micro</name></expr></argument>, <argument><expr><name>letterversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * load info schema and populate from features file
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_schema</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>info_schema_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>lines</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_CMD_PRINTF1</name><argument_list>(<argument><expr><literal type="string">"UPDATE information_schema.sql_implementation_info "</literal>
				   <literal type="string">"  SET character_value = '%s' "</literal>
				   <literal type="string">"  WHERE implementation_info_name = 'DBMS VERSION';\n\n"</literal></expr></argument>,
				   <argument><expr><name>infoversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_CMD_PRINTF1</name><argument_list>(<argument><expr><literal type="string">"COPY information_schema.sql_features "</literal>
				   <literal type="string">"  (feature_id, feature_name, sub_feature_id, "</literal>
				   <literal type="string">"  sub_feature_name, is_supported, comments) "</literal>
				   <literal type="string">" FROM E'%s';\n\n"</literal></expr></argument>,
				   <argument><expr><call><name>escape_quotes</name><argument_list>(<argument><expr><name>features_file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmpstringp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator> <operator>(</operator><name>char</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p1</name></expr></argument>, <argument><expr><operator>*</operator> <operator>(</operator><name>char</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Load GPDB additions to the schema.
 *
 * These are contained in directory "cdb_init.d". We load all .sql files
 * from that directory, in alphabetical order. This modular design allows
 * extensions to put their install scripts under cdb_init.d, and have them
 * automatically installed directly in the template databases of every new
 * cluster.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_cdb_schema</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nscripts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>scriptnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>cdb_init_d_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not open cdb_init.d directory: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Collect all files with .sql suffix in array. */</comment>
	<expr_stmt><expr><name>nscripts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>file</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">".sql"</literal></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <name>namelen</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>scriptnames</name> <operator>=</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>scriptnames</name></expr></argument>,
									 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>nscripts</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scriptnames</name><index>[<expr><name>nscripts</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/*
	 * This fix is in mingw cvs (runtime/mingwex/dirent.c rev 1.4), but not in
	 * released version
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GetLastError</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ERROR_NO_MORE_FILES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* some kind of I/O error? */</comment>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"error while reading cdb_init.d directory: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Sort the array. This allows simple dependencies between scripts, by
	 * naming them like "01_before.sql" and "02_after.sql"
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nscripts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>scriptnames</name></expr></argument>, <argument><expr><name>nscripts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmpstringp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now execute each script.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nscripts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>lines</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>	    <name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>share_path</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"cdb_init.d"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>scriptnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s/cdb_init.d/%s"</literal></expr></argument>, <argument><expr><name>share_path</name></expr></argument>, <argument><expr><name><name>scriptnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reset any GUCs that the previous script might have created. Notably, search_path */</comment>
		<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"RESET ALL;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>lines</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * load PL/pgSQL server-side language
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_plpgsql</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"CREATE EXTENSION plpgsql;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * clean everything up in template1
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vacuum_db</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Run analyze before VACUUM so the statistics are frozen. */</comment>
	<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><literal type="string">"ANALYZE;\n\nVACUUM FREEZE;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * copy template1 to template0
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_template0</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>template0_setup</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"CREATE DATABASE template0 IS_TEMPLATE = true ALLOW_CONNECTIONS = false;\n\n"</literal></expr>,

		<comment type="block">/*
		 * We use the OID of template0 to determine lastsysoid
		 */</comment>
		<expr><literal type="string">"UPDATE pg_database SET datlastsysoid = "</literal>
		<literal type="string">"    (SELECT oid FROM pg_database "</literal>
		<literal type="string">"    WHERE datname = 'template0');\n\n"</literal></expr>,

		<comment type="block">/*
		 * Explicitly revoke public create-schema and create-temp-table
		 * privileges in template1 and template0; else the latter would be on
		 * by default
		 */</comment>
		<expr><literal type="string">"REVOKE CREATE,TEMPORARY ON DATABASE template1 FROM public;\n\n"</literal></expr>,
		<expr><literal type="string">"REVOKE CREATE,TEMPORARY ON DATABASE template0 FROM public;\n\n"</literal></expr>,

		<expr><literal type="string">"COMMENT ON DATABASE template0 IS 'unmodifiable empty database';\n\n"</literal></expr>,

		<comment type="block">/*
		 * Finally vacuum to clean up dead rows in pg_database
		 */</comment>
		<expr><literal type="string">"VACUUM pg_database;\n\n"</literal></expr>,
		<expr><name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>template0_setup</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * copy template1 to postgres
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_postgres</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>cmdfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>postgres_setup</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"CREATE DATABASE postgres;\n\n"</literal></expr>,
		<expr><literal type="string">"COMMENT ON DATABASE postgres IS 'default administrative connection database';\n\n"</literal></expr>,
		<comment type="block">/*
		 * Make 'postgres' a template database
		 */</comment>
		<expr><literal type="string">"UPDATE pg_database SET "</literal>
		<literal type="string">"	datistemplate = 't' "</literal>
		<literal type="string">"    WHERE datname = 'postgres';\n\n"</literal></expr>,
		<comment type="block">/*
		 * Clean out dead rows in pg_database
		 */</comment>
		<expr><literal type="string">"VACUUM FULL pg_database;\n\n"</literal></expr>,
		<expr><name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <name>postgres_setup</name></expr>;</init> <condition><expr><operator>*</operator><name>line</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_CMD_PUTS</name><argument_list>(<argument><expr><operator>*</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * signal handler in case we are interrupted.
 *
 * The Windows runtime docs at
 * http://msdn.microsoft.com/library/en-us/vclib/html/_crt_signal.asp
 * specifically forbid a number of things being done from a signal handler,
 * including IO, memory allocation and system calls, and only allow jmpbuf
 * if you are handling SIGFPE.
 *
 * I avoided doing the forbidden things by setting a flag instead of calling
 * exit() directly.
 *
 * Also note the behaviour of Windows with SIGINT, which says this:
 *	 Note	SIGINT is not supported for any Win32 application, including
 *	 Windows 98/Me and Windows NT/2000/XP. When a CTRL+C interrupt occurs,
 *	 Win32 operating systems generate a new thread to specifically handle
 *	 that interrupt. This can cause a single-thread application such as UNIX,
 *	 to become multithreaded, resulting in unexpected behavior.
 *
 * I have no idea how to handle this. (Strange they call UNIX an application!)
 * So this will need some testing on Windows.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>trapsig</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* handle systems that reset the handler, like Windows (grr) */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><name>trapsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>caught_signal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * call exit() if we got a signal, or else output "ok".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_ok</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>caught_signal</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"caught signal\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>output_failed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not write to child process: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>output_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* all seems well */</comment>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"ok\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Hack to suppress a warning about %x from some versions of gcc */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type>
<name>my_strftime</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strftime</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine likely date order from locale
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>locale_date_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type>	<name>testtime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>posD</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>posM</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>posY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DATEORDER_MDY</name></expr>;</expr_stmt>		<comment type="block">/* default */</comment>

	<expr_stmt><expr><name>save</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_TIME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>save</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>save</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_TIME</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>testtime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>testtime</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>testtime</name><operator>.</operator><name>tm_mday</name></name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>testtime</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>		<comment type="block">/* November, should come out as "11" */</comment>
	<expr_stmt><expr><name><name>testtime</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <literal type="number">133</literal></expr>;</expr_stmt>		<comment type="block">/* 2033 */</comment>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>my_strftime</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%x"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>testtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_TIME</name></expr></argument>, <argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>posM</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>posD</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"22"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>posY</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"33"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>posM</name> <operator>||</operator> <operator>!</operator><name>posD</name> <operator>||</operator> <operator>!</operator><name>posY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>posY</name> <operator>&lt;</operator> <name>posM</name> <operator>&amp;&amp;</operator> <name>posM</name> <operator>&lt;</operator> <name>posD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DATEORDER_YMD</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>posD</name> <operator>&lt;</operator> <name>posM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DATEORDER_DMY</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DATEORDER_MDY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that locale name is valid for the locale category.
 *
 * If successful, and canonname isn't NULL, a malloc'd copy of the locale's
 * canonical name is stored there.  This is especially useful for figuring out
 * what locale name "" means (ie, the environment value).  (Actually,
 * it seems that on most implementations that's the only thing it's good for;
 * we could wish that setlocale gave back a canonically spelled version of
 * the locale name, but typically it doesn't.)
 *
 * this should match the backend's check_locale() function
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_locale_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>category</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>canonname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>canonname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>canonname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* in case of failure */</comment>

	<expr_stmt><expr><name>save</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>category</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>save</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"setlocale() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* save may be pointing at a modifiable scratch variable, so copy it. */</comment>
	<expr_stmt><expr><name>save</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* for setlocale() call */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>locale</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>locale</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* set the locale with setlocale, to see if it accepts it. */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>category</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* save canonical name if requested. */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&amp;&amp;</operator> <name>canonname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>canonname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* restore old value. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setlocale</name><argument_list>(<argument><expr><name>category</name></expr></argument>, <argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"failed to restore old locale \"%s\""</literal></expr></argument>, <argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* complain if locale wasn't valid */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>locale</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid locale name \"%s\""</literal></expr></argument>, <argument><expr><name>locale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If no relevant switch was given on command line, locale is an
			 * empty string, which is not too helpful to report.  Presumably
			 * setlocale() found something it did not like in the environment.
			 * Ideally we'd report the bad environment variable, but since
			 * setlocale's behavior is implementation-specific, it's hard to
			 * be sure what it didn't like.  Print a safe generic message.
			 */</comment>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid locale settings; check LANG and LC_* environment variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check if the chosen encoding matches the encoding required by the locale
 *
 * this should match the similar check in the backend createdb() function
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_locale_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>user_enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>locale_enc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>locale_enc</name> <operator>=</operator> <call><name>pg_get_encoding_from_locale</name><argument_list>(<argument><expr><name>locale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* See notes in createdb() to understand these tests */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>locale_enc</name> <operator>==</operator> <name>user_enc</name> <operator>||</operator>
		  <name>locale_enc</name> <operator>==</operator> <name>PG_SQL_ASCII</name> <operator>||</operator>
		  <name>locale_enc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		  <name>user_enc</name> <operator>==</operator> <name>PG_UTF8</name> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		  <name>user_enc</name> <operator>==</operator> <name>PG_SQL_ASCII</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"encoding mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The encoding you selected (%s) and the encoding that the\n"</literal>
				  <literal type="string">"selected locale uses (%s) do not match.  This would lead to\n"</literal>
				  <literal type="string">"misbehavior in various character string processing functions.\n"</literal>
				  <literal type="string">"Rerun %s and either do not specify an encoding explicitly,\n"</literal>
				  <literal type="string">"or choose a matching combination.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name>user_enc</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name>locale_enc</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set up the locale variables
 *
 * assumes we have called setlocale(LC_ALL, "") -- see set_pglocale_pgservice
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setlocales</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>canonname</name></decl>;</decl_stmt>

	<comment type="block">/* set empty lc_* values to locale config if set */</comment>

	<if_stmt><if>if <condition>(<expr><name>locale</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lc_ctype</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lc_ctype</name> <operator>=</operator> <name>locale</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lc_collate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lc_collate</name> <operator>=</operator> <name>locale</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lc_numeric</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lc_numeric</name> <operator>=</operator> <name>locale</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lc_time</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lc_time</name> <operator>=</operator> <name>locale</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lc_monetary</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lc_monetary</name> <operator>=</operator> <name>locale</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lc_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lc_messages</name> <operator>=</operator> <name>locale</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * canonicalize locale names, and obtain any missing values from our
	 * current environment
	 */</comment>

	<expr_stmt><expr><call><name>check_locale_name</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>lc_ctype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>canonname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc_ctype</name> <operator>=</operator> <name>canonname</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_locale_name</name><argument_list>(<argument><expr><name>LC_COLLATE</name></expr></argument>, <argument><expr><name>lc_collate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>canonname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc_collate</name> <operator>=</operator> <name>canonname</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_locale_name</name><argument_list>(<argument><expr><name>LC_NUMERIC</name></expr></argument>, <argument><expr><name>lc_numeric</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>canonname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc_numeric</name> <operator>=</operator> <name>canonname</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_locale_name</name><argument_list>(<argument><expr><name>LC_TIME</name></expr></argument>, <argument><expr><name>lc_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>canonname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc_time</name> <operator>=</operator> <name>canonname</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_locale_name</name><argument_list>(<argument><expr><name>LC_MONETARY</name></expr></argument>, <argument><expr><name>lc_monetary</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>canonname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc_monetary</name> <operator>=</operator> <name>canonname</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LC_MESSAGES</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>check_locale_name</name><argument_list>(<argument><expr><name>LC_MESSAGES</name></expr></argument>, <argument><expr><name>lc_messages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>canonname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc_messages</name> <operator>=</operator> <name>canonname</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* when LC_MESSAGES is not available, use the LC_CTYPE setting */</comment>
	<expr_stmt><expr><call><name>check_locale_name</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>lc_messages</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>canonname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc_messages</name> <operator>=</operator> <name>canonname</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Try to parse value as an integer.  The accepted formats are the
 * usual decimal, octal, or hexadecimal formats.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>parse_long</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>blckszUnit</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>long</name></type>    <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>  <name>m</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>||</operator>
        <name>endptr</name> <operator>==</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>blckszUnit</name> <operator>&amp;&amp;</operator> <name><name>endptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name><name>endptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'k'</literal></expr>:</case>
            <case>case <expr><literal type="char">'K'</literal></expr>:</case>
                <expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'m'</literal></expr>:</case>
            <case>case <expr><literal type="char">'M'</literal></expr>:</case>
                <expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'g'</literal></expr>:</case>
            <case>case <expr><literal type="char">'G'</literal></expr>:</case>
                <expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <goto>goto <name>err</name>;</goto>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name><name>endptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'b'</literal> <operator>&amp;&amp;</operator>
            <name><name>endptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'B'</literal></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>m</name> <operator>*</operator> <name>val</name> <operator>/</operator> <name>BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* error if extra trailing chars */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>endptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <return>return <expr><name>val</name></expr>;</return>

<label><name>err</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>blckszUnit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"%s: '%s=%s' invalid; requires an integer value, "</literal>
					 <literal type="string">"optionally followed by kB/MB/GB suffix"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optname</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"%s: '%s=%s' invalid; requires an integer value"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optname</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>                               <comment type="block">/* parse_long */</comment>

<comment type="block">/*
 * print help text
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s initializes a PostgreSQL database cluster.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s [OPTION]... [DATADIR]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -A, --auth=METHOD         default authentication method for local connections\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --auth-host=METHOD    default authentication method for local TCP/IP connections\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --auth-local=METHOD   default authentication method for local-socket connections\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" [-D, --pgdata=]DATADIR     location for this database cluster\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -E, --encoding=ENCODING   set default encoding for new databases\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -g, --allow-group-access  allow group read/execute on data directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --locale=LOCALE       set default locale for new databases\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --lc-collate=, --lc-ctype=, --lc-messages=LOCALE\n"</literal>
			 <literal type="string">"      --lc-monetary=, --lc-numeric=, --lc-time=LOCALE\n"</literal>
			 <literal type="string">"                            set default locale in the respective category for\n"</literal>
			 <literal type="string">"                            new databases (default taken from environment)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --no-locale           equivalent to --locale=C\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --pwfile=FILE         read password for the new superuser from file\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -T, --text-search-config=CFG\n"</literal>
			 <literal type="string">"                            default text search configuration\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -U, --username=NAME       database superuser name\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -W, --pwprompt            prompt for a password for the new superuser\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -X, --waldir=WALDIR       location for the write-ahead log directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --wal-segsize=SIZE    size of WAL segments, in megabytes\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nShared memory allocation:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --max_connections=MAX-CONNECT  maximum number of allowed connections\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --shared_buffers=NBUFFERS number of shared buffers; or, amount of memory for\n"</literal>
			 <literal type="string">"                            shared buffers if kB/MB/GB suffix is appended\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nLess commonly used options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -d, --debug               generate lots of debugging output\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -k, --data-checksums      use data page checksums\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -L DIRECTORY              where to find the input files\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n, --no-clean            do not clean up after errors\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -N, --no-sync             do not wait for changes to be written safely to disk\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s, --show                show internal settings\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -S, --sync-only           only sync data directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOther options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version             output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --gp-version          output Greenplum version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help                show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nIf the data directory is not specified, the environment variable PGDATA\n"</literal>
			 <literal type="string">"is used.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nReport bugs to &lt;bugs@greenplum.org&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_authmethod_unspecified</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>authmethod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>authmethod</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>authwarning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>authmethod</name> <operator>=</operator> <literal type="string">"trust"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_authmethod_valid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>authmethod</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>valid_methods</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conntype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>valid_methods</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>authmethod</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<comment type="block">/* with space = param */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>authmethod</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>authmethod</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>authmethod</name> <operator>-</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>authmethod</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid authentication method \"%s\" for \"%s\" connections"</literal></expr></argument>,
				 <argument><expr><name>authmethod</name></expr></argument>, <argument><expr><name>conntype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_need_password</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>authmethodlocal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>authmethodhost</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><literal type="string">"md5"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><literal type="string">"password"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><literal type="string">"scram-sha-256"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodhost</name></expr></argument>, <argument><expr><literal type="string">"md5"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodhost</name></expr></argument>, <argument><expr><literal type="string">"password"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodhost</name></expr></argument>, <argument><expr><literal type="string">"scram-sha-256"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name>pwprompt</name> <operator>||</operator> <name>pwfilename</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"must specify a password for the superuser to enable %s authentication"</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><literal type="string">"md5"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					  <call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><literal type="string">"password"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					  <call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><literal type="string">"scram-sha-256"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>
					 ?</condition><then> <expr><name>authmethodlocal</name></expr>
					 </then><else>: <expr><name>authmethodhost</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>setup_pgdata</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pgdata_get_env</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>pgdata_set_env</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pg_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pgdata_get_env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pgdata_get_env</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pgdata_get_env</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* PGDATA found */</comment>
			<expr_stmt><expr><name>pg_data</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>pgdata_get_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"no data directory specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"You must identify the directory where the data for this database system\n"</literal>
					  <literal type="string">"will reside.  Do this with either the invocation option -D or the\n"</literal>
					  <literal type="string">"environment variable PGDATA.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pgdata_native</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we have to set PGDATA for postgres rather than pass it on the command
	 * line to avoid dumb quoting problems on Windows, and we would especially
	 * need quotes otherwise on Windows because paths there are most likely to
	 * have embedded spaces.
	 */</comment>
	<expr_stmt><expr><name>pgdata_set_env</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"PGDATA=%s"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><name>pgdata_set_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>setup_bin_paths</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>find_other_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><name>PG_BACKEND_VERSIONSTR</name></expr></argument>,
							   <argument><expr><name>backend_exec</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>full_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>full_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The program \"postgres\" is needed by %s but was not found in the\n"</literal>
						 <literal type="string">"same directory as \"%s\".\n"</literal>
						 <literal type="string">"Check your installation."</literal></expr></argument>,
						 <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The program \"postgres\" was found by \"%s\"\n"</literal>
						 <literal type="string">"but was not the same version as %s.\n"</literal>
						 <literal type="string">"Check your installation."</literal></expr></argument>,
						 <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* store binary directory */</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>bin_path</name></expr></argument>, <argument><expr><name>backend_exec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><call><name>last_dir_separator</name><argument_list>(<argument><expr><name>bin_path</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>bin_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>share_path</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>share_path</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_share_path</name><argument_list>(<argument><expr><name>backend_exec</name></expr></argument>, <argument><expr><name>share_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>share_path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"input file location must be an absolute path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>share_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>setup_locale_encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>setlocales</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>lc_ctype</name></expr></argument>, <argument><expr><name>lc_collate</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>lc_ctype</name></expr></argument>, <argument><expr><name>lc_time</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>lc_ctype</name></expr></argument>, <argument><expr><name>lc_numeric</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>lc_ctype</name></expr></argument>, <argument><expr><name>lc_monetary</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>lc_ctype</name></expr></argument>, <argument><expr><name>lc_messages</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The database cluster will be initialized with locale \"%s\".\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The database cluster will be initialized with locales\n"</literal>
				 <literal type="string">"  COLLATE:  %s\n"</literal>
				 <literal type="string">"  CTYPE:    %s\n"</literal>
				 <literal type="string">"  MESSAGES: %s\n"</literal>
				 <literal type="string">"  MONETARY: %s\n"</literal>
				 <literal type="string">"  NUMERIC:  %s\n"</literal>
				 <literal type="string">"  TIME:     %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>lc_collate</name></expr></argument>,
			   <argument><expr><name>lc_ctype</name></expr></argument>,
			   <argument><expr><name>lc_messages</name></expr></argument>,
			   <argument><expr><name>lc_monetary</name></expr></argument>,
			   <argument><expr><name>lc_numeric</name></expr></argument>,
			   <argument><expr><name>lc_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>encoding</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ctype_enc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ctype_enc</name> <operator>=</operator> <call><name>pg_get_encoding_from_locale</name><argument_list>(<argument><expr><name>lc_ctype</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ctype_enc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Couldn't recognize the locale's codeset */</comment>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not find suitable encoding for locale \"%s\""</literal></expr></argument>,
						 <argument><expr><name>lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Rerun %s with the -E option.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>pg_valid_server_encoding_id</name><argument_list>(<argument><expr><name>ctype_enc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We recognized it, but it's not a legal server encoding. On
			 * Windows, UTF-8 works with any locale, so we can fall back to
			 * UTF-8.
			 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
			<expr_stmt><expr><name>encodingid</name> <operator>=</operator> <name>PG_UTF8</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Encoding \"%s\" implied by locale is not allowed as a server-side encoding.\n"</literal>
					 <literal type="string">"The default database encoding will be set to \"%s\" instead.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name>ctype_enc</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name>encodingid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"locale \"%s\" requires unsupported encoding \"%s\""</literal></expr></argument>,
						 <argument><expr><name>lc_ctype</name></expr></argument>, <argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name>ctype_enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Encoding \"%s\" is not allowed as a server-side encoding.\n"</literal>
					  <literal type="string">"Rerun %s with a different locale selection.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name>ctype_enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>encodingid</name> <operator>=</operator> <name>ctype_enc</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The default database encoding has accordingly been set to \"%s\".\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name>encodingid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>encodingid</name> <operator>=</operator> <call><name>get_encoding_id</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_locale_encoding</name><argument_list>(<argument><expr><name>lc_ctype</name></expr></argument>, <argument><expr><name>encodingid</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>check_locale_encoding</name><argument_list>(<argument><expr><name>lc_collate</name></expr></argument>, <argument><expr><name>encodingid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>				<comment type="block">/* check_locale_encoding printed the error */</comment>

</block_content>}</block></function>


<function><type><name>void</name></type>
<name>setup_data_file_paths</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bki_file</name></expr></argument>, <argument><expr><literal type="string">"postgres.bki"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc_file</name></expr></argument>, <argument><expr><literal type="string">"postgres.description"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shdesc_file</name></expr></argument>, <argument><expr><literal type="string">"postgres.shdescription"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hba_file</name></expr></argument>, <argument><expr><literal type="string">"pg_hba.conf.sample"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ident_file</name></expr></argument>, <argument><expr><literal type="string">"pg_ident.conf.sample"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conf_file</name></expr></argument>, <argument><expr><literal type="string">"postgresql.conf.sample"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dictionary_file</name></expr></argument>, <argument><expr><literal type="string">"snowball_create.sql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info_schema_file</name></expr></argument>, <argument><expr><literal type="string">"information_schema.sql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>features_file</name></expr></argument>, <argument><expr><literal type="string">"sql_features.txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>system_views_file</name></expr></argument>, <argument><expr><literal type="string">"system_views.sql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_input</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdb_init_d_dir</name></expr></argument>, <argument><expr><literal type="string">"cdb_init.d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>show_setting</name> <operator>||</operator> <name>debug</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><literal type="string">"VERSION=%s\n"</literal>
				<literal type="string">"PGDATA=%s\nshare_path=%s\nPGPATH=%s\n"</literal>
				<literal type="string">"POSTGRES_SUPERUSERNAME=%s\nPOSTGRES_BKI=%s\n"</literal>
				<literal type="string">"POSTGRES_DESCR=%s\nPOSTGRES_SHDESCR=%s\n"</literal>
				<literal type="string">"POSTGRESQL_CONF_SAMPLE=%s\n"</literal>
				<literal type="string">"PG_HBA_SAMPLE=%s\nPG_IDENT_SAMPLE=%s\n"</literal></expr></argument>,
				<argument><expr><name>PG_VERSION</name></expr></argument>,
				<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>share_path</name></expr></argument>, <argument><expr><name>bin_path</name></expr></argument>,
				<argument><expr><name>username</name></expr></argument>, <argument><expr><name>bki_file</name></expr></argument>,
				<argument><expr><name>desc_file</name></expr></argument>, <argument><expr><name>shdesc_file</name></expr></argument>,
				<argument><expr><name>conf_file</name></expr></argument>,
				<argument><expr><name>hba_file</name></expr></argument>, <argument><expr><name>ident_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>show_setting</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>check_input</name><argument_list>(<argument><expr><name>bki_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_input</name><argument_list>(<argument><expr><name>desc_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_input</name><argument_list>(<argument><expr><name>shdesc_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_input</name><argument_list>(<argument><expr><name>hba_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_input</name><argument_list>(<argument><expr><name>ident_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_input</name><argument_list>(<argument><expr><name>conf_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_input</name><argument_list>(<argument><expr><name>dictionary_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_input</name><argument_list>(<argument><expr><name>info_schema_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_input</name><argument_list>(<argument><expr><name>features_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_input</name><argument_list>(<argument><expr><name>system_views_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>setup_text_search</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>default_text_search_config</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>default_text_search_config</name> <operator>=</operator> <call><name>find_matching_ts_config</name><argument_list>(<argument><expr><name>lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>default_text_search_config</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"could not find suitable text search configuration for locale \"%s\""</literal></expr></argument>,
						<argument><expr><name>lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>default_text_search_config</name> <operator>=</operator> <literal type="string">"simple"</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>checkmatch</name> <init>= <expr><call><name>find_matching_ts_config</name><argument_list>(<argument><expr><name>lc_ctype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>checkmatch</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"suitable text search configuration for locale \"%s\" is unknown"</literal></expr></argument>,
						   <argument><expr><name>lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>checkmatch</name></expr></argument>, <argument><expr><name>default_text_search_config</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"specified text search configuration \"%s\" might not match locale \"%s\""</literal></expr></argument>,
						   <argument><expr><name>default_text_search_config</name></expr></argument>, <argument><expr><name>lc_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The default text search configuration will be set to \"%s\".\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>default_text_search_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>


<function><type><name>void</name></type>
<name>setup_signals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* some of these are not valid on Windows */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGHUP</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>trapsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGINT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>trapsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGQUIT</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>trapsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGTERM</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>trapsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Ignore SIGPIPE when writing to backend, so we can clean up */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGPIPE</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Prevent SIGSYS so we can probe for kernel calls that might not work */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGSYS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGSYS</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>create_data_directory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>pg_check_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<comment type="block">/* PGDATA not there, must create it */</comment>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating directory %s ... "</literal></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pg_mkdir_p</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>made_new_pgdata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<comment type="block">/* Present but empty, fix permissions and use it */</comment>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"fixing permissions on existing directory %s ... "</literal></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not change permissions of directory \"%s\": %m"</literal></expr></argument>,
							 <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>found_existing_pgdata</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="number">2</literal></expr>:</case>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<comment type="block">/* Present and not empty */</comment>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"directory \"%s\" exists but is not empty"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>warn_on_mount_point</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"If you want to create a new database system, either remove or empty\n"</literal>
						  <literal type="string">"the directory \"%s\" or run %s\n"</literal>
						  <literal type="string">"with an argument other than \"%s\".\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* no further message needed */</comment>

		<default>default:</default>
			<comment type="block">/* Trouble accessing directory */</comment>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not access directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/* Create WAL directory, and symlink if required */</comment>
<function><type><name>void</name></type>
<name>create_xlog_or_symlink</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>subdirloc</name></decl>;</decl_stmt>

	<comment type="block">/* form name of the place for the subdirectory or symlink */</comment>
	<expr_stmt><expr><name>subdirloc</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/pg_wal"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>xlog_dir</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

		<comment type="block">/* clean up xlog directory name, check it's absolute */</comment>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"WAL directory location must be an absolute path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check if the specified xlog directory exists/is empty */</comment>
		<switch>switch <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>pg_check_dir</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">0</literal></expr>:</case>
				<comment type="block">/* xlog directory not there, must create it */</comment>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating directory %s ... "</literal></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>pg_mkdir_p</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": %m"</literal></expr></argument>,
								 <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>made_new_xlogdir</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<comment type="block">/* Present but empty, fix permissions and use it */</comment>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"fixing permissions on existing directory %s ... "</literal></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not change permissions of directory \"%s\": %m"</literal></expr></argument>,
								 <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>found_existing_xlogdir</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">2</literal></expr>:</case>
			<case>case <expr><literal type="number">3</literal></expr>:</case>
			<case>case <expr><literal type="number">4</literal></expr>:</case>
				<comment type="block">/* Present and not empty */</comment>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"directory \"%s\" exists but is not empty"</literal></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>warn_on_mount_point</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
							<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"If you want to store the WAL there, either remove or empty the directory\n"</literal>
							  <literal type="string">"\"%s\".\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<default>default:</default>
				<comment type="block">/* Trouble accessing directory */</comment>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not access directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><call><name>symlink</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>subdirloc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create symbolic link \"%s\": %m"</literal></expr></argument>,
						 <argument><expr><name>subdirloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"symlinks are not supported on this platform"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Without -X option, just make the subdirectory normally */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>subdirloc</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": %m"</literal></expr></argument>,
						 <argument><expr><name>subdirloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>subdirloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>warn_on_mount_point</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"It contains a dot-prefixed/invisible file, perhaps due to it being a mount point.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>error</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"It contains a lost+found directory, perhaps due to it being a mount point.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
			<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Using a mount point directly as the data directory is not recommended.\n"</literal>
			  <literal type="string">"Create a subdirectory under the mount point.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>initialize_data_directory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>PG_CMD_DECL</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>setup_signals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set mask based on requested PGDATA permissions.  pg_mode_mask, and
	 * friends like pg_dir_create_mode, are set to owner-only by default and
	 * then updated if -g is passed in by calling SetDataDirectoryCreatePerm()
	 * when parsing our options (see above).
	 */</comment>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>pg_mode_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>create_data_directory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>create_xlog_or_symlink</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create required subdirectories (other than pg_wal) */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"creating subdirectories ... "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>subdirs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name><name>subdirs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The parent directory already exists, so we only need mkdir() not
		 * pg_mkdir_p() here, which avoids some failure modes; cf bug #13853.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Top level PG_VERSION is checked by bootstrapper, so make it first */</comment>
	<expr_stmt><expr><call><name>write_version_file</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select suitable configuration settings */</comment>
	<expr_stmt><expr><call><name>set_null_conf</name><argument_list>(<argument><expr><literal type="string">"postgresql.conf"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_null_conf</name><argument_list>(<argument><expr><name>GP_INTERNAL_AUTO_CONF_FILE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_config_settings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now create all the text config files */</comment>
	<expr_stmt><expr><call><name>setup_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Bootstrap template1 */</comment>
	<expr_stmt><expr><call><name>bootstrap_template1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the per-database PG_VERSION for template1 only after init'ing it
	 */</comment>
	<expr_stmt><expr><call><name>write_version_file</name><argument_list>(<argument><expr><literal type="string">"base/1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the stuff we don't need to use bootstrap mode for, using a
	 * backend running in simple standalone mode.
	 */</comment>
	<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"performing post-bootstrap initialization ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"\"%s\" %s template1 &gt;%s"</literal></expr></argument>,
			 <argument><expr><name>backend_exec</name></expr></argument>, <argument><expr><name>backend_options</name></expr></argument>,
			 <argument><expr><name>DEVNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>PG_CMD_OPEN</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_auth</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_depend</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that no objects created after setup_depend() will be "pinned".
	 * They are all droppable at the whim of the DBA.
	 */</comment>

	<expr_stmt><expr><call><name>setup_sysviews</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_description</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	setup_collation(cmdfd);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>setup_dictionary</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_privileges</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_schema</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>load_plpgsql</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sets up the Greenplum Database admin schema */</comment>
	<expr_stmt><expr><call><name>setup_cdb_schema</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>vacuum_db</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>make_template0</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>make_postgres</name><argument_list>(<argument><expr><name>cmdfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>PG_CMD_CLOSE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"pgdata"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'D'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"encoding"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'E'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"locale"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"lc-collate"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"lc-ctype"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"lc-monetary"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"lc-numeric"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"lc-time"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"lc-messages"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-locale"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">8</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"text-search-config"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'T'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"auth"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'A'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"auth-local"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">10</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"auth-host"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">11</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"pwprompt"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'W'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"pwfile"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">9</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"username"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'U'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'?'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"show"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"noclean"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,	<comment type="block">/* for backwards compatibility */</comment>
		<expr><block>{<expr><literal type="string">"no-clean"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"nosync"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'N'</literal></expr>}</block></expr>, <comment type="block">/* for backwards compatibility */</comment>
		<expr><block>{<expr><literal type="string">"no-sync"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'N'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"sync-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"waldir"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'X'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"wal-segsize"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">12</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"data-checksums"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'k'</literal></expr>}</block></expr>,
        <expr><block>{<expr><literal type="string">"max_connections"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1001</literal></expr>}</block></expr>,     <comment type="block">/*CDB*/</comment>
        <expr><block>{<expr><literal type="string">"shared_buffers"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1003</literal></expr>}</block></expr>,      <comment type="block">/*CDB*/</comment>
		<expr><block>{<expr><literal type="string">"allow-group-access"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'g'</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * options with no short version return a low integer, the rest return
	 * their short version value
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>effective_user</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>start_db_cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pg_ctl_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ensure that buffering behavior of stdout matches what it is in
	 * interactive usage (at least on most platforms).  This prevents
	 * unexpected output ordering when, eg, output is redirected to a file.
	 * POSIX says we must do this before any other usage of these files.
	 */</comment>
	<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_logging_init</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"initdb"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"initdb (Greenplum Database) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--gp-version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"initdb (Greenplum Database) "</literal> <name>GP_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* process command-line options */</comment>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"dD:E:kL:nNU:WA:sST:X:g"</literal></expr></argument>, <argument><expr><name>long_options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>
				<expr_stmt><expr><name>authmethodlocal</name> <operator>=</operator> <name>authmethodhost</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * When ident is specified, use peer for local connections.
				 * Mirrored, when peer is specified, use ident for TCP/IP
				 * connections.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodhost</name></expr></argument>, <argument><expr><literal type="string">"ident"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>authmethodlocal</name> <operator>=</operator> <literal type="string">"peer"</literal></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><literal type="string">"peer"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>authmethodhost</name> <operator>=</operator> <literal type="string">"ident"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">10</literal></expr>:</case>
				<expr_stmt><expr><name>authmethodlocal</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">11</literal></expr>:</case>
				<expr_stmt><expr><name>authmethodhost</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><name>pg_data</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'E'</literal></expr>:</case>
				<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
				<expr_stmt><expr><name>pwprompt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'U'</literal></expr>:</case>
				<expr_stmt><expr><name>username</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<expr_stmt><expr><name>debug</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Running in debug mode.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<expr_stmt><expr><name>noclean</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Running in no-clean mode.  Mistakes will not be cleaned up.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'N'</literal></expr>:</case>
				<expr_stmt><expr><name>do_sync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'S'</literal></expr>:</case>
				<expr_stmt><expr><name>sync_only</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'k'</literal></expr>:</case>
				<expr_stmt><expr><name>data_checksums</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'L'</literal></expr>:</case>
				<expr_stmt><expr><name>share_path</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<expr_stmt><expr><name>locale</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><name>lc_collate</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">3</literal></expr>:</case>
				<expr_stmt><expr><name>lc_ctype</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">4</literal></expr>:</case>
				<expr_stmt><expr><name>lc_monetary</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">5</literal></expr>:</case>
				<expr_stmt><expr><name>lc_numeric</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">6</literal></expr>:</case>
				<expr_stmt><expr><name>lc_time</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">7</literal></expr>:</case>
				<expr_stmt><expr><name>lc_messages</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">8</literal></expr>:</case>
				<expr_stmt><expr><name>locale</name> <operator>=</operator> <literal type="string">"C"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">9</literal></expr>:</case>
				<expr_stmt><expr><name>pwfilename</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<expr_stmt><expr><name>show_setting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'T'</literal></expr>:</case>
				<expr_stmt><expr><name>default_text_search_config</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
				<expr_stmt><expr><name>xlog_dir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">1001</literal></expr>:</case>
				<expr_stmt><expr><name>n_connections</name> <operator>=</operator> <call><name>parse_long</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"max_connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">1003</literal></expr>:</case>
				<expr_stmt><expr><name>n_buffers</name> <operator>=</operator> <call><name>parse_long</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"shared_buffers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">12</literal></expr>:</case>
				<expr_stmt><expr><name>str_wal_segment_size_mb</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'g'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetDataDirectoryCreatePerm</name><argument_list>(<argument><expr><name>PG_DIR_MODE_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* getopt_long already emitted a complaint */</comment>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></while>


	<comment type="block">/*
	 * Non-option argument specifies data directory as long as it wasn't
	 * already specified with -D / --pgdata
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pg_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pg_data</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>optind</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"too many command-line arguments (first is \"%s\")"</literal></expr></argument>,
					 <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>cleanup_directories_atexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we only need to fsync, just do it and exit */</comment>
	<if_stmt><if>if <condition>(<expr><name>sync_only</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setup_pgdata</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* must check that directory is readable */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_check_dir</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not access directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"syncing data to disk ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fsync_pgdata</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>PG_VERSION_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pwprompt</name> <operator>&amp;&amp;</operator> <name>pwfilename</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"password prompt and password file cannot be specified together"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>check_authmethod_unspecified</name><argument_list>(<argument><expr><operator>&amp;</operator><name>authmethodlocal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_authmethod_unspecified</name><argument_list>(<argument><expr><operator>&amp;</operator><name>authmethodhost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_authmethod_valid</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><name>auth_methods_local</name></expr></argument>, <argument><expr><literal type="string">"local"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_authmethod_valid</name><argument_list>(<argument><expr><name>authmethodhost</name></expr></argument>, <argument><expr><name>auth_methods_host</name></expr></argument>, <argument><expr><literal type="string">"host"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_need_password</name><argument_list>(<argument><expr><name>authmethodlocal</name></expr></argument>, <argument><expr><name>authmethodhost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set wal segment size */</comment>
	<if_stmt><if>if <condition>(<expr><name>str_wal_segment_size_mb</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>wal_segment_size_mb</name> <operator>=</operator> <operator>(</operator><name>DEFAULT_XLOG_SEG_SIZE</name><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

		<comment type="block">/* check that the argument is a number */</comment>
		<expr_stmt><expr><name>wal_segment_size_mb</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>str_wal_segment_size_mb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* verify that wal segment size is valid */</comment>
		<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>str_wal_segment_size_mb</name> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"argument of --wal-segsize must be a number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidWalSegSize</name><argument_list>(<argument><expr><name>wal_segment_size_mb</name> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"argument of --wal-segsize must be a power of 2 between 1 and 1024"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>get_restricted_token</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_pgdata</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_bin_paths</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>effective_user</name> <operator>=</operator> <call><name>get_id</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>username</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>username</name> <operator>=</operator> <name>effective_user</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>username</name></expr></argument>, <argument><expr><literal type="string">"pg_"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"superuser name \"%s\" is disallowed; role names cannot begin with \"pg_\""</literal></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The files belonging to this database system will be owned "</literal>
			 <literal type="string">"by user \"%s\".\n"</literal>
			 <literal type="string">"This user must also own the server process.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>effective_user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_info_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_data_file_paths</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_locale_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setup_text_search</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>data_checksums</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Data page checksums are enabled.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Data page checksums are disabled.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pwprompt</name> <operator>||</operator> <name>pwfilename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_su_pwd</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initialize_data_directory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>do_sync</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"syncing data to disk ... "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fsync_pgdata</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>PG_VERSION_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_ok</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nSync to disk skipped.\nThe data directory might become corrupt if the operating system crashes.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>authwarning</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"enabling \"trust\" authentication for local connections"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"You can change this by editing pg_hba.conf or using the option -A, or\n"</literal>
						  <literal type="string">"--auth-local and --auth-host, the next time you run initdb.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build up a shell command to tell the user how to start the server
	 */</comment>
	<expr_stmt><expr><name>start_db_cmd</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get directory specification used to start initdb ... */</comment>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>pg_ctl_path</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_ctl_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>pg_ctl_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_parent_directory</name><argument_list>(<argument><expr><name>pg_ctl_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... and tag on pg_ctl instead */</comment>
	<expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>pg_ctl_path</name></expr></argument>, <argument><expr><name>pg_ctl_path</name></expr></argument>, <argument><expr><literal type="string">"pg_ctl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* path to pg_ctl, properly quoted */</comment>
	<expr_stmt><expr><call><name>appendShellString</name><argument_list>(<argument><expr><name>start_db_cmd</name></expr></argument>, <argument><expr><name>pg_ctl_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add -D switch, with properly quoted data directory */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>start_db_cmd</name></expr></argument>, <argument><expr><literal type="string">" -D "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendShellString</name><argument_list>(<argument><expr><name>start_db_cmd</name></expr></argument>, <argument><expr><name>pgdata_native</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add suggested -l switch and "start" command */</comment>
	<comment type="block">/* translator: This is a placeholder in a shell command. */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>start_db_cmd</name></expr></argument>, <argument><expr><literal type="string">" -l %s start"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"logfile"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nSuccess. You can now start the database server using:\n\n"</literal>
			 <literal type="string">"    %s\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>start_db_cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>start_db_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
