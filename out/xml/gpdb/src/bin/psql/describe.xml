<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/bin/psql/describe.c"><comment type="block">/*
 * psql - the PostgreSQL interactive terminal
 *
 * Support for the various \d ("describe") commands.  Note that the current
 * expectation is that all functions in this file will succeed when working
 * with servers of versions 7.4 and up.  It's okay to omit irrelevant
 * information for an old server, but not to fail outright.
 *
 * Copyright (c) 2000-2019, PostgreSQL Global Development Group
 *
 * src/bin/psql/describe.c
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_cast_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_default_acl_d.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/logging.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/mbprint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"describe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"settings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"variables.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_distribution_policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_server.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>describeOneTableDetails</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaname</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationname</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_external_table_footer</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cont</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_distributed_by_footer</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cont</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_partition_by_footer</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cont</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_tablespace_footer</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cont</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>tablespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>newline</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_role_attribute</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>listTSParsersVerbose</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>describeOneTSParser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>listTSConfigsVerbose</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>describeOneTSConfig</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cfgname</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pnspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printACLColumn</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>listOneExtensionContents</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isGPDB</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isGPDB4200OrLater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isGPDB5000OrLater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isGPDB6000OrLater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isGPDB7000OrLater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isGPDB</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<enum><specifier>static</specifier> enum
	<block>{
		<decl><name>gpdb_maybe</name></decl>,
		<decl><name>gpdb_yes</name></decl>,
		<decl><name>gpdb_no</name></decl>
	}</block> <decl><name>talking_to_gpdb</name></decl>;</enum>

	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ver</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>talking_to_gpdb</name> <operator>==</operator> <name>gpdb_yes</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>talking_to_gpdb</name> <operator>==</operator> <name>gpdb_no</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><literal type="string">"select pg_catalog.version()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ver</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>ver</name></expr></argument>, <argument><expr><literal type="string">"Greenplum"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>talking_to_gpdb</name> <operator>=</operator> <name>gpdb_yes</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>talking_to_gpdb</name> <operator>=</operator> <name>gpdb_no</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we reconnect to a GPDB system later, do the check again */</comment>
	<expr_stmt><expr><name>talking_to_gpdb</name> <operator>=</operator> <name>gpdb_maybe</name></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * A new catalog table was introduced in GPDB 4.2 (pg_catalog.pg_attribute_encoding).
 * If the database appears to be GPDB and has that table, we assume it is 4.2 or later.
 *
 * Return true if GPDB version 4.2 or later, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>isGPDB4200OrLater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>       <name>retValue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isGPDB</name><argument_list>()</argument_list></call> <operator>==</operator> <name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><literal type="string">"select oid from pg_catalog.pg_class where relnamespace = 11 and relname  = 'pg_attribute_encoding'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			 <expr_stmt><expr><name>retValue</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>retValue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>retValue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if GPDB version 4.3 or later, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isGPDB4300OrLater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>       <name>retValue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isGPDB</name><argument_list>()</argument_list></call> <operator>==</operator> <name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(
				<argument><expr><literal type="string">"select attnum from pg_catalog.pg_attribute "</literal>
				<literal type="string">"where attrelid = 'pg_catalog.pg_proc'::regclass and "</literal>
				<literal type="string">"attname = 'prodataaccess'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retValue</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>retValue</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * If GPDB version is 5.0, pg_proc has provariadic as column number 20.
 * When we have version() returns GPDB version instead of "main build dev" or
 * something similar, we'll fix this function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>isGPDB5000OrLater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>	<name>retValue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isGPDB</name><argument_list>()</argument_list></call> <operator>==</operator> <name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><literal type="string">"select attnum from pg_catalog.pg_attribute where attrelid = 1255 and attname = 'provariadic'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>retValue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>retValue</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isGPDB6000OrLater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isGPDB</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* Not Greenplum at all. */</comment>

	<comment type="block">/* GPDB 6 is based on PostgreSQL 9.4 */</comment>
	<return>return <expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isGPDB6000OrBelow</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isGPDB</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* Not Greenplum at all. */</comment>

	<comment type="block">/* GPDB 6 is based on PostgreSQL 9.4 */</comment>
	<return>return <expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;=</operator> <literal type="number">90400</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isGPDB7000OrLater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isGPDB</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* Not Greenplum at all. */</comment>

	<comment type="block">/* GPDB 7 is based on PostgreSQL v12 */</comment>
	<return>return <expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*----------------
 * Handlers for various slash commands displaying some sort of list
 * of things in the database.
 *
 * Note: try to format the queries to look nice in -E output.
 *----------------
 */</comment>


<comment type="block">/*
 * \da
 * Takes an optional regexp to select particular aggregates
 */</comment>
<function><type><name>bool</name></type>
<name>describeAggregates</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"  p.proname AS \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.format_type(p.prorettype, NULL) AS \"%s\",\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result data type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  CASE WHEN p.pronargs = 0\n"</literal>
						  <literal type="string">"    THEN CAST('*' AS pg_catalog.text)\n"</literal>
						  <literal type="string">"    ELSE pg_catalog.pg_get_function_arguments(p.oid)\n"</literal>
						  <literal type="string">"  END AS \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  CASE WHEN p.pronargs = 0\n"</literal>
						  <literal type="string">"    THEN CAST('*' AS pg_catalog.text)\n"</literal>
						  <literal type="string">"    ELSE\n"</literal>
						  <literal type="string">"    pg_catalog.array_to_string(ARRAY(\n"</literal>
						  <literal type="string">"      SELECT\n"</literal>
						  <literal type="string">"        pg_catalog.format_type(p.proargtypes[s.i], NULL)\n"</literal>
						  <literal type="string">"      FROM\n"</literal>
						  <literal type="string">"        pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)\n"</literal>
						  <literal type="string">"    ), ', ')\n"</literal>
						  <literal type="string">"  END AS \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  pg_catalog.format_type(p.proargtypes[0], NULL) AS \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  pg_catalog.obj_description(p.oid, 'pg_proc') as \"%s\"\n"</literal>
						  <literal type="string">"FROM pg_catalog.pg_proc p\n"</literal>
						  <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n"</literal>
						  <literal type="string">"WHERE p.prokind = 'a'\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  pg_catalog.obj_description(p.oid, 'pg_proc') as \"%s\"\n"</literal>
						  <literal type="string">"FROM pg_catalog.pg_proc p\n"</literal>
						  <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n"</literal>
						  <literal type="string">"WHERE p.proisagg\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"p.proname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_function_is_visible(p.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2, 4;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of aggregate functions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dA
 * Takes an optional regexp to select particular access methods
 */</comment>
<function><type><name>bool</name></type>
<name>describeAccessMethods</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support access methods."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT amname AS \"%s\",\n"</literal>
					  <literal type="string">"  CASE amtype"</literal>
					  <literal type="string">" WHEN 'i' THEN '%s'"</literal>
					  <literal type="string">" WHEN 't' THEN '%s'"</literal>
					  <literal type="string">" END AS \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Index"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Table"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  amhandler AS \"%s\",\n"</literal>
						  <literal type="string">"  pg_catalog.obj_description(oid, 'pg_am') AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Handler"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_am\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"amname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of access methods"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \db
 * Takes an optional regexp to select particular tablespaces
 */</comment>
<function><type><name>bool</name></type>
<name>describeTablespaces</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80000</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support tablespaces."</literal></expr></argument>,
					<argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal> <operator>||</operator> <call><name>isGPDB6000OrLater</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT spcname AS \"%s\",\n"</literal>
						  <literal type="string">"  pg_catalog.pg_get_userbyid(spcowner) AS \"%s\",\n"</literal>
						  <literal type="string">"  pg_catalog.pg_tablespace_location(oid) AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT spcname AS \"%s\",\n"</literal>
						  <literal type="string">"  pg_catalog.pg_get_userbyid(spcowner) AS \"%s\",\n"</literal>
						  <literal type="string">"  spclocation AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"spcacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  spcoptions AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  pg_catalog.pg_size_pretty(pg_catalog.pg_tablespace_size(oid)) AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  pg_catalog.shobj_description(oid, 'pg_tablespace') AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_tablespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"spcname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of tablespaces"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \df
 * Takes an optional regexp to select particular functions.
 *
 * As with \d, you can specify the kinds of functions you want:
 *
 * a for aggregates
 * n for normal
 * t for trigger
 * w for window
 *
 * and you can mix and match these in any order.
 */</comment>
<function><type><name>bool</name></type>
<name>describeFunctions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>functypes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showAggregate</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showNormal</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>, <argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showProcedure</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showTrigger</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>, <argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showWindow</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>, <argument><expr><literal type="char">'w'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_where</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* No "Parallel" column before 9.6 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns_pre_96</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strspn</name><argument_list>(<argument><expr><name>functypes</name></expr></argument>, <argument><expr><literal type="string">"anptwS+"</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"\\df only takes [anptwS+] as options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showProcedure</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">110000</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"\\df does not take a \"%c\" option with server version %s"</literal></expr></argument>,
					 <argument><expr><literal type="char">'p'</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showWindow</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"\\df does not take a \"%c\" option with server version %s"</literal></expr></argument>,
					 <argument><expr><literal type="char">'w'</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showAggregate</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showNormal</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showProcedure</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showTrigger</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showWindow</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>showAggregate</name> <operator>=</operator> <name>showNormal</name> <operator>=</operator> <name>showTrigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>showProcedure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>showWindow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"  p.proname as \"%s\",\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  pg_catalog.pg_get_function_result(p.oid) as \"%s\",\n"</literal>
						  <literal type="string">"  pg_catalog.pg_get_function_arguments(p.oid) as \"%s\",\n"</literal>
						  <literal type="string">" CASE p.prokind\n"</literal>
						  <literal type="string">"  WHEN 'a' THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN 'w' THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN 'p' THEN '%s'\n"</literal>
						  <literal type="string">"  ELSE '%s'\n"</literal>
						  <literal type="string">" END as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result data type"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>,
		<comment type="block">/* translator: "agg" is short for "aggregate" */</comment>
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"agg"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"window"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"proc"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"func"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  pg_catalog.pg_get_function_result(p.oid) as \"%s\",\n"</literal>
						  <literal type="string">"  pg_catalog.pg_get_function_arguments(p.oid) as \"%s\",\n"</literal>
						  <literal type="string">" CASE\n"</literal>
						  <literal type="string">"  WHEN p.proisagg THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.proiswindow THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN '%s'\n"</literal>
						  <literal type="string">"  ELSE '%s'\n"</literal>
						  <literal type="string">" END as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result data type"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>,
		<comment type="block">/* translator: "agg" is short for "aggregate" */</comment>
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"agg"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"window"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"func"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>isGPDB5000OrLater</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  pg_catalog.pg_get_function_result(p.oid) as \"%s\",\n"</literal>
						  <literal type="string">"  pg_catalog.pg_get_function_arguments(p.oid) as \"%s\",\n"</literal>
						  <literal type="string">" CASE\n"</literal>
						  <literal type="string">"  WHEN p.proisagg THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.proiswin THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN '%s'\n"</literal>
						  <literal type="string">"  ELSE '%s'\n"</literal>
						  <literal type="string">"END as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result data type"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>,
		<comment type="block">/* translator: "agg" is short for "aggregate" */</comment>
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"agg"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"window"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"normal"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  CASE WHEN p.proretset THEN 'SETOF ' ELSE '' END ||\n"</literal>
						  <literal type="string">"  pg_catalog.format_type(p.prorettype, NULL) as \"%s\",\n"</literal>
						  <literal type="string">"  CASE WHEN proallargtypes IS NOT NULL THEN\n"</literal>
						  <literal type="string">"    pg_catalog.array_to_string(ARRAY(\n"</literal>
						  <literal type="string">"      SELECT\n"</literal>
						  <literal type="string">"        CASE\n"</literal>
						  <literal type="string">"          WHEN p.proargmodes[s.i] = 'i' THEN ''\n"</literal>
						  <literal type="string">"          WHEN p.proargmodes[s.i] = 'o' THEN 'OUT '\n"</literal>
						  <literal type="string">"          WHEN p.proargmodes[s.i] = 'b' THEN 'INOUT '\n"</literal>
						  <literal type="string">"          WHEN p.proargmodes[s.i] = 'v' THEN 'VARIADIC '\n"</literal>
						  <literal type="string">"        END ||\n"</literal>
						  <literal type="string">"        CASE\n"</literal>
						  <literal type="string">"          WHEN COALESCE(p.proargnames[s.i], '') = '' THEN ''\n"</literal>
						  <literal type="string">"          ELSE p.proargnames[s.i] || ' '\n"</literal>
						  <literal type="string">"        END ||\n"</literal>
						  <literal type="string">"        pg_catalog.format_type(p.proallargtypes[s.i], NULL)\n"</literal>
						  <literal type="string">"      FROM\n"</literal>
						  <literal type="string">"        pg_catalog.generate_series(1, pg_catalog.array_upper(p.proallargtypes, 1)) AS s(i)\n"</literal>
						  <literal type="string">"    ), ', ')\n"</literal>
						  <literal type="string">"  ELSE\n"</literal>
						  <literal type="string">"    pg_catalog.array_to_string(ARRAY(\n"</literal>
						  <literal type="string">"      SELECT\n"</literal>
						  <literal type="string">"        CASE\n"</literal>
						  <literal type="string">"          WHEN COALESCE(p.proargnames[s.i+1], '') = '' THEN ''\n"</literal>
						  <literal type="string">"          ELSE p.proargnames[s.i+1] || ' '\n"</literal>
						  <literal type="string">"          END ||\n"</literal>
						  <literal type="string">"        pg_catalog.format_type(p.proargtypes[s.i], NULL)\n"</literal>
						  <literal type="string">"      FROM\n"</literal>
						  <literal type="string">"        pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)\n"</literal>
						  <literal type="string">"    ), ', ')\n"</literal>
						  <literal type="string">"  END AS \"%s\",\n"</literal>
						  <literal type="string">"  CASE\n"</literal>
						  <literal type="string">"    WHEN p.proisagg THEN '%s'\n"</literal>
						  <literal type="string">"    WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN '%s'\n"</literal>
						  <literal type="string">"    ELSE '%s'\n"</literal>
						  <literal type="string">"  END AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result data type"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>,
		<comment type="block">/* translator: "agg" is short for "aggregate" */</comment>
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"agg"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"func"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  CASE WHEN p.proretset THEN 'SETOF ' ELSE '' END ||\n"</literal>
						  <literal type="string">"  pg_catalog.format_type(p.prorettype, NULL) as \"%s\",\n"</literal>
						  <literal type="string">"  pg_catalog.oidvectortypes(p.proargtypes) as \"%s\",\n"</literal>
						  <literal type="string">"  CASE\n"</literal>
						  <literal type="string">"    WHEN p.proisagg THEN '%s'\n"</literal>
						  <literal type="string">"    WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN '%s'\n"</literal>
						  <literal type="string">"    ELSE '%s'\n"</literal>
						  <literal type="string">"  END AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result data type"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Argument data types"</literal></expr></argument>)</argument_list></call></expr></argument>,
		<comment type="block">/* translator: "agg" is short for "aggregate" */</comment>
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"agg"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"func"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isGPDB4300OrLater</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n CASE\n"</literal>
						  <literal type="string">"  WHEN p.prodataaccess = 'n' THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.prodataaccess = 'c' THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.prodataaccess = 'r' THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.prodataaccess = 'm' THEN '%s'\n"</literal>
						  <literal type="string">"END as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"no sql"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"contains sql"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"reads sql data"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"modifies sql data"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Data access"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>isGPDB6000OrLater</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n CASE\n"</literal>
						  <literal type="string">"  WHEN p.proexeclocation = 'a' THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.proexeclocation = 'c' THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.proexeclocation = 's' THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.proexeclocation = 'i' THEN '%s'\n"</literal>
						  <literal type="string">"END as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"any"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"coordinator"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"all segments"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"initplan"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Execute on"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n CASE\n"</literal>
						  <literal type="string">"  WHEN p.provolatile = 'i' THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.provolatile = 's' THEN '%s'\n"</literal>
						  <literal type="string">"  WHEN p.provolatile = 'v' THEN '%s'\n"</literal>
						  <literal type="string">" END as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"immutable"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"stable"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"volatile"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Volatility"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n CASE\n"</literal>
							  <literal type="string">"  WHEN p.proparallel = 'r' THEN '%s'\n"</literal>
							  <literal type="string">"  WHEN p.proparallel = 's' THEN '%s'\n"</literal>
							  <literal type="string">"  WHEN p.proparallel = 'u' THEN '%s'\n"</literal>
							  <literal type="string">" END as \"%s\""</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"restricted"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"safe"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"unsafe"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Parallel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n pg_catalog.pg_get_userbyid(p.proowner) as \"%s\""</literal>
						  <literal type="string">",\n CASE WHEN prosecdef THEN '%s' ELSE '%s' END AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"definer"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invoker"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Security"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.proacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n l.lanname as \"%s\""</literal>
						  <literal type="string">",\n p.prosrc as \"%s\""</literal>
						  <literal type="string">",\n pg_catalog.obj_description(p.oid, 'pg_proc') as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Language"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Source code"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_proc p"</literal>
						 <literal type="string">"\n     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"     LEFT JOIN pg_catalog.pg_language l ON l.oid = p.prolang\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>have_where</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* filter by function type, if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name>showNormal</name> <operator>&amp;&amp;</operator> <name>showAggregate</name> <operator>&amp;&amp;</operator> <name>showProcedure</name> <operator>&amp;&amp;</operator> <name>showTrigger</name> <operator>&amp;&amp;</operator> <name>showWindow</name></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* Do nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>showNormal</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showAggregate</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_where</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_where</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.prokind &lt;&gt; 'a'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOT p.proisagg\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showProcedure</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_where</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_where</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.prokind &lt;&gt; 'p'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showTrigger</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_where</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_where</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.prorettype &lt;&gt; 'pg_catalog.trigger'::pg_catalog.regtype\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showWindow</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_where</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_where</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.prokind &lt;&gt; 'w'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOT p.proiswindow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>needs_or</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE (\n       "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>have_where</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Note: at least one of these must be true ... */</comment>
		<if_stmt><if>if <condition>(<expr><name>showAggregate</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.prokind = 'a'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.proisagg\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>needs_or</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>showTrigger</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>needs_or</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"       OR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								 <argument><expr><literal type="string">"p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>needs_or</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>showProcedure</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>needs_or</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"       OR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.prokind = 'p'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>needs_or</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>showWindow</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>needs_or</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"       OR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.prokind = 'w'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"p.proiswindow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>needs_or</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      )\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>have_where</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"p.proname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_function_is_visible(p.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2, 4;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of functions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns_pre_96</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns_pre_96</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * \dT
 * describe types
 */</comment>
<function><type><name>bool</name></type>
<name>describeTypes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isGE42</name> <init>= <expr><call><name>isGPDB4200OrLater</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.format_type(t.oid, NULL) AS \"%s\",\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  t.typname AS \"%s\",\n"</literal>
						  <literal type="string">"  CASE WHEN t.typrelid != 0\n"</literal>
						  <literal type="string">"      THEN CAST('tuple' AS pg_catalog.text)\n"</literal>
						  <literal type="string">"    WHEN t.typlen &lt; 0\n"</literal>
						  <literal type="string">"      THEN CAST('var' AS pg_catalog.text)\n"</literal>
						  <literal type="string">"    ELSE CAST(t.typlen AS pg_catalog.text)\n"</literal>
						  <literal type="string">"  END AS \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Internal name"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"  pg_catalog.array_to_string(\n"</literal>
							 <literal type="string">"      ARRAY(\n"</literal>
							 <literal type="string">"          SELECT e.enumlabel\n"</literal>
							 <literal type="string">"          FROM pg_catalog.pg_enum e\n"</literal>
							 <literal type="string">"          WHERE e.enumtypid = t.oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								 <argument><expr><literal type="string">"          ORDER BY e.enumsortorder\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								 <argument><expr><literal type="string">"          ORDER BY e.oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"      ),\n"</literal>
						  <literal type="string">"      E'\\n'\n"</literal>
						  <literal type="string">"  ) AS \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Elements"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name>isGE42</name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" pg_catalog.array_to_string(te.typoptions, ',') AS \"%s\",\n"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type Options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  pg_catalog.pg_get_userbyid(t.typowner) AS \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"t.typacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"  pg_catalog.obj_description(t.oid, 'pg_type') as \"%s\"\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FROM pg_catalog.pg_type t\n"</literal>
						 <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name>isGE42</name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n   LEFT OUTER JOIN pg_catalog.pg_type_encoding te ON te.typid = t.oid "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * do not include complex types (typrelid!=0) unless they are standalone
	 * composite types
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE (t.typrelid = 0 "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OR (SELECT c.relkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>)</argument_list></call>
						 <literal type="string">" FROM pg_catalog.pg_class c "</literal>
						 <literal type="string">"WHERE c.oid = t.typrelid))\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * do not include array types (before 8.3 we have to use the assumption
	 * that their names start with underscore)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  AND t.typname !~ '^_'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Match name pattern against either internal or external name */</comment>
	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"t.typname"</literal></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.format_type(t.oid, NULL)"</literal></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_type_is_visible(t.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of data types"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \do
 * Describe operators
 */</comment>
<function><type><name>bool</name></type>
<name>describeOperators</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: before Postgres 9.1, we did not assign comments to any built-in
	 * operators, preferring to let the comment on the underlying function
	 * suffice.  The coalesce() on the obj_description() calls below supports
	 * this convention by providing a fallback lookup of a comment on the
	 * operator's function.  As of 9.1 there is a policy that every built-in
	 * operator should have a comment; so the coalesce() is no longer
	 * necessary so far as built-in operators are concerned.  We keep it
	 * anyway, for now, because (1) third-party modules may still be following
	 * the old convention, and (2) we'd need to do it anyway when talking to a
	 * pre-9.1 server.
	 */</comment>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"  o.oprname AS \"%s\",\n"</literal>
					  <literal type="string">"  CASE WHEN o.oprkind='l' THEN NULL ELSE pg_catalog.format_type(o.oprleft, NULL) END AS \"%s\",\n"</literal>
					  <literal type="string">"  CASE WHEN o.oprkind='r' THEN NULL ELSE pg_catalog.format_type(o.oprright, NULL) END AS \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.format_type(o.oprresult, NULL) AS \"%s\",\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Left arg type"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Right arg type"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Result type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  o.oprcode AS \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Function"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"  coalesce(pg_catalog.obj_description(o.oid, 'pg_operator'),\n"</literal>
					  <literal type="string">"           pg_catalog.obj_description(o.oprcode, 'pg_proc')) AS \"%s\"\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_operator o\n"</literal>
					  <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = o.oprnamespace\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"o.oprname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_operator_is_visible(o.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2, 3, 4;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of operators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * listAllDbs
 *
 * for \l, \list, and -l switch
 */</comment>
<function><type><name>bool</name></type>
<name>listAllDbs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT d.datname as \"%s\",\n"</literal>
					  <literal type="string">"       pg_catalog.pg_get_userbyid(d.datdba) as \"%s\",\n"</literal>
					  <literal type="string">"       pg_catalog.pg_encoding_to_char(d.encoding) as \"%s\",\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Encoding"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"       d.datcollate as \"%s\",\n"</literal>
						  <literal type="string">"       d.datctype as \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collate"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Ctype"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"       "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"d.datacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       CASE WHEN pg_catalog.has_database_privilege(d.datname, 'CONNECT')\n"</literal>
						  <literal type="string">"            THEN pg_catalog.pg_size_pretty(pg_catalog.pg_database_size(d.datname))\n"</literal>
						  <literal type="string">"            ELSE 'No Access'\n"</literal>
						  <literal type="string">"       END as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       t.spcname as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Tablespace"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       pg_catalog.shobj_description(d.oid, 'pg_database') as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_database d\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"  JOIN pg_catalog.pg_tablespace t on d.dattablespace = t.oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"d.datname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of databases"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * List Tables' Grant/Revoke Permissions
 * \z (now also \dp -- perhaps more mnemonic)
 */</comment>
<function><type><name>bool</name></type>
<name>permissionsList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we ignore indexes and toast tables since they have no meaningful rights
	 */</comment>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"  c.relname as \"%s\",\n"</literal>
					  <literal type="string">"  CASE c.relkind"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" END as \"%s\",\n"</literal>
					  <literal type="string">"  "</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"view"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"materialized view"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign table"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"partitioned table"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"c.relacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  pg_catalog.array_to_string(ARRAY(\n"</literal>
						  <literal type="string">"    SELECT attname || E':\\n  ' || pg_catalog.array_to_string(attacl, E'\\n  ')\n"</literal>
						  <literal type="string">"    FROM pg_catalog.pg_attribute a\n"</literal>
						  <literal type="string">"    WHERE attrelid = c.oid AND NOT attisdropped AND attacl IS NOT NULL\n"</literal>
						  <literal type="string">"  ), E'\\n') AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Column privileges"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  pg_catalog.array_to_string(ARRAY(\n"</literal>
						  <literal type="string">"    SELECT polname\n"</literal>
						  <literal type="string">"    || CASE WHEN polcmd != '*' THEN\n"</literal>
						  <literal type="string">"           E' (' || polcmd || E'):'\n"</literal>
						  <literal type="string">"       ELSE E':'\n"</literal>
						  <literal type="string">"       END\n"</literal>
						  <literal type="string">"    || CASE WHEN polqual IS NOT NULL THEN\n"</literal>
						  <literal type="string">"           E'\\n  (u): ' || pg_catalog.pg_get_expr(polqual, polrelid)\n"</literal>
						  <literal type="string">"       ELSE E''\n"</literal>
						  <literal type="string">"       END\n"</literal>
						  <literal type="string">"    || CASE WHEN polwithcheck IS NOT NULL THEN\n"</literal>
						  <literal type="string">"           E'\\n  (c): ' || pg_catalog.pg_get_expr(polwithcheck, polrelid)\n"</literal>
						  <literal type="string">"       ELSE E''\n"</literal>
						  <literal type="string">"       END"</literal>
						  <literal type="string">"    || CASE WHEN polroles &lt;&gt; '{0}' THEN\n"</literal>
						  <literal type="string">"           E'\\n  to: ' || pg_catalog.array_to_string(\n"</literal>
						  <literal type="string">"               ARRAY(\n"</literal>
						  <literal type="string">"                   SELECT rolname\n"</literal>
						  <literal type="string">"                   FROM pg_catalog.pg_roles\n"</literal>
						  <literal type="string">"                   WHERE oid = ANY (polroles)\n"</literal>
						  <literal type="string">"                   ORDER BY 1\n"</literal>
						  <literal type="string">"               ), E', ')\n"</literal>
						  <literal type="string">"       ELSE E''\n"</literal>
						  <literal type="string">"       END\n"</literal>
						  <literal type="string">"    FROM pg_catalog.pg_policy pol\n"</literal>
						  <literal type="string">"    WHERE polrelid = c.oid), E'\\n')\n"</literal>
						  <literal type="string">"    AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Policies"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  pg_catalog.array_to_string(ARRAY(\n"</literal>
						  <literal type="string">"    SELECT polname\n"</literal>
						  <literal type="string">"    || CASE WHEN NOT polpermissive THEN\n"</literal>
						  <literal type="string">"       E' (RESTRICTIVE)'\n"</literal>
						  <literal type="string">"       ELSE '' END\n"</literal>
						  <literal type="string">"    || CASE WHEN polcmd != '*' THEN\n"</literal>
						  <literal type="string">"           E' (' || polcmd || E'):'\n"</literal>
						  <literal type="string">"       ELSE E':'\n"</literal>
						  <literal type="string">"       END\n"</literal>
						  <literal type="string">"    || CASE WHEN polqual IS NOT NULL THEN\n"</literal>
						  <literal type="string">"           E'\\n  (u): ' || pg_catalog.pg_get_expr(polqual, polrelid)\n"</literal>
						  <literal type="string">"       ELSE E''\n"</literal>
						  <literal type="string">"       END\n"</literal>
						  <literal type="string">"    || CASE WHEN polwithcheck IS NOT NULL THEN\n"</literal>
						  <literal type="string">"           E'\\n  (c): ' || pg_catalog.pg_get_expr(polwithcheck, polrelid)\n"</literal>
						  <literal type="string">"       ELSE E''\n"</literal>
						  <literal type="string">"       END"</literal>
						  <literal type="string">"    || CASE WHEN polroles &lt;&gt; '{0}' THEN\n"</literal>
						  <literal type="string">"           E'\\n  to: ' || pg_catalog.array_to_string(\n"</literal>
						  <literal type="string">"               ARRAY(\n"</literal>
						  <literal type="string">"                   SELECT rolname\n"</literal>
						  <literal type="string">"                   FROM pg_catalog.pg_roles\n"</literal>
						  <literal type="string">"                   WHERE oid = ANY (polroles)\n"</literal>
						  <literal type="string">"                   ORDER BY 1\n"</literal>
						  <literal type="string">"               ), E', ')\n"</literal>
						  <literal type="string">"       ELSE E''\n"</literal>
						  <literal type="string">"       END\n"</literal>
						  <literal type="string">"    FROM pg_catalog.pg_policy pol\n"</literal>
						  <literal type="string">"    WHERE polrelid = c.oid), E'\\n')\n"</literal>
						  <literal type="string">"    AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Policies"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_class c\n"</literal>
						 <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n"</literal>
						 <literal type="string">"WHERE c.relkind IN ("</literal>
						 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
						 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
						 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
						 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
						 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
						 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unless a schema pattern is specified, we suppress system and temp
	 * tables, since they normally aren't very interesting from a permissions
	 * point of view.  You can see 'em by explicit request though, eg with \z
	 * pg_catalog.*
	 */</comment>
	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname !~ '^pg_' AND pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Access privileges"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \ddp
 *
 * List Default ACLs.  The pattern can match either schema or role name.
 */</comment>
<function><type><name>bool</name></type>
<name>listDefaultACLs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support altering default privileges."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.pg_get_userbyid(d.defaclrole) AS \"%s\",\n"</literal>
					  <literal type="string">"  n.nspname AS \"%s\",\n"</literal>
					  <literal type="string">"  CASE d.defaclobjtype WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' END AS \"%s\",\n"</literal>
					  <literal type="string">"  "</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>DEFACLOBJ_RELATION</name></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>DEFACLOBJ_SEQUENCE</name></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>DEFACLOBJ_FUNCTION</name></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"function"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>DEFACLOBJ_TYPE</name></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>DEFACLOBJ_NAMESPACE</name></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"d.defaclacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_default_acl d\n"</literal>
						 <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = d.defaclnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_get_userbyid(d.defaclrole)"</literal></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2, 3;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Default access privileges"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Get object comments
 *
 * \dd [foo]
 *
 * Note: This command only lists comments for object types which do not have
 * their comments displayed by their own backslash commands. The following
 * types of objects will be displayed: constraint, operator class,
 * operator family, rule, and trigger.
 */</comment>
<function><type><name>bool</name></type>
<name>objectDescription</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT DISTINCT tt.nspname AS \"%s\", tt.name AS \"%s\", tt.object AS \"%s\", d.description AS \"%s\"\n"</literal>
					  <literal type="string">"FROM (\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Object"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Table constraint descriptions */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"  SELECT pgc.oid as oid, pgc.tableoid AS tableoid,\n"</literal>
					  <literal type="string">"  n.nspname as nspname,\n"</literal>
					  <literal type="string">"  CAST(pgc.conname AS pg_catalog.text) as name,"</literal>
					  <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
					  <literal type="string">"  FROM pg_catalog.pg_constraint pgc\n"</literal>
					  <literal type="string">"    JOIN pg_catalog.pg_class c "</literal>
					  <literal type="string">"ON c.oid = pgc.conrelid\n"</literal>
					  <literal type="string">"    LEFT JOIN pg_catalog.pg_namespace n "</literal>
					  <literal type="string">"    ON n.oid = c.relnamespace\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table constraint"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"pgc.conname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Domain constraint descriptions */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"UNION ALL\n"</literal>
					  <literal type="string">"  SELECT pgc.oid as oid, pgc.tableoid AS tableoid,\n"</literal>
					  <literal type="string">"  n.nspname as nspname,\n"</literal>
					  <literal type="string">"  CAST(pgc.conname AS pg_catalog.text) as name,"</literal>
					  <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
					  <literal type="string">"  FROM pg_catalog.pg_constraint pgc\n"</literal>
					  <literal type="string">"    JOIN pg_catalog.pg_type t "</literal>
					  <literal type="string">"ON t.oid = pgc.contypid\n"</literal>
					  <literal type="string">"    LEFT JOIN pg_catalog.pg_namespace n "</literal>
					  <literal type="string">"    ON n.oid = t.typnamespace\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"domain constraint"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"pgc.conname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_type_is_visible(t.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * pg_opclass.opcmethod only available in 8.3+
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Operator class descriptions */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"UNION ALL\n"</literal>
						  <literal type="string">"  SELECT o.oid as oid, o.tableoid as tableoid,\n"</literal>
						  <literal type="string">"  n.nspname as nspname,\n"</literal>
						  <literal type="string">"  CAST(o.opcname AS pg_catalog.text) as name,\n"</literal>
						  <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
						  <literal type="string">"  FROM pg_catalog.pg_opclass o\n"</literal>
						  <literal type="string">"    JOIN pg_catalog.pg_am am ON "</literal>
						  <literal type="string">"o.opcmethod = am.oid\n"</literal>
						  <literal type="string">"    JOIN pg_catalog.pg_namespace n ON "</literal>
						  <literal type="string">"n.oid = o.opcnamespace\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"operator class"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
								 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"o.opcname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="string">"pg_catalog.pg_opclass_is_visible(o.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * although operator family comments have been around since 8.3,
	 * pg_opfamily_is_visible is only available in 9.2+
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Operator family descriptions */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"UNION ALL\n"</literal>
						  <literal type="string">"  SELECT opf.oid as oid, opf.tableoid as tableoid,\n"</literal>
						  <literal type="string">"  n.nspname as nspname,\n"</literal>
						  <literal type="string">"  CAST(opf.opfname AS pg_catalog.text) AS name,\n"</literal>
						  <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
						  <literal type="string">"  FROM pg_catalog.pg_opfamily opf\n"</literal>
						  <literal type="string">"    JOIN pg_catalog.pg_am am "</literal>
						  <literal type="string">"ON opf.opfmethod = am.oid\n"</literal>
						  <literal type="string">"    JOIN pg_catalog.pg_namespace n "</literal>
						  <literal type="string">"ON opf.opfnamespace = n.oid\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"operator family"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
								 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"opf.opfname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="string">"pg_catalog.pg_opfamily_is_visible(opf.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Rule descriptions (ignore rules for views) */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"UNION ALL\n"</literal>
					  <literal type="string">"  SELECT r.oid as oid, r.tableoid as tableoid,\n"</literal>
					  <literal type="string">"  n.nspname as nspname,\n"</literal>
					  <literal type="string">"  CAST(r.rulename AS pg_catalog.text) as name,"</literal>
					  <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
					  <literal type="string">"  FROM pg_catalog.pg_rewrite r\n"</literal>
					  <literal type="string">"       JOIN pg_catalog.pg_class c ON c.oid = r.ev_class\n"</literal>
					  <literal type="string">"       LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n"</literal>
					  <literal type="string">"  WHERE r.rulename != '_RETURN'\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"rule"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"r.rulename"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Trigger descriptions */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"UNION ALL\n"</literal>
					  <literal type="string">"  SELECT t.oid as oid, t.tableoid as tableoid,\n"</literal>
					  <literal type="string">"  n.nspname as nspname,\n"</literal>
					  <literal type="string">"  CAST(t.tgname AS pg_catalog.text) as name,"</literal>
					  <literal type="string">"  CAST('%s' AS pg_catalog.text) as object\n"</literal>
					  <literal type="string">"  FROM pg_catalog.pg_trigger t\n"</literal>
					  <literal type="string">"       JOIN pg_catalog.pg_class c ON c.oid = t.tgrelid\n"</literal>
					  <literal type="string">"       LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"t.tgname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">") AS tt\n"</literal>
						 <literal type="string">"  JOIN pg_catalog.pg_description d ON (tt.oid = d.objoid AND tt.tableoid = d.classoid AND d.objsubid = 0)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2, 3;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"Object descriptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * describeTableDetails (for \d)
 *
 * This routine finds the tables to be displayed, and calls
 * describeOneTableDetails for each one.
 *
 * verbose: if true, this is \d+
 */</comment>
<function><type><name>bool</name></type>
<name>describeTableDetails</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT c.oid,\n"</literal>
					  <literal type="string">"  n.nspname,\n"</literal>
					  <literal type="string">"  c.relname\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_class c\n"</literal>
					  <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 2, 3;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any relation named \"%s\"."</literal></expr></argument>,
							 <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any relations."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>describeOneTableDetails</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>verbose</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>greenplum_is_ao_row</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>olddesc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>olddesc</name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newdesc</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>newdesc</name></expr></argument>, <argument><expr><literal type="string">"ao_row"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"ao_row"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>greenplum_is_ao_column</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>olddesc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>olddesc</name> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newdesc</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>newdesc</name></expr></argument>, <argument><expr><literal type="string">"ao_column"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"ao_column"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * describeOneTableDetails (for \d)
 *
 * Unfortunately, the information presented here is so complicated that it
 * cannot be done in a single query. So we have to assemble the printed table
 * by hand and pass it to the underlying printTable() function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>describeOneTableDetails</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaname</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationname</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printTableOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printTableContent</name></type> <name>cont</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>printTableInitialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>view_def</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>headers</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>title</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>tmpbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attname_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,	<comment type="block">/* column indexes in "res" */</comment>
				<decl><type ref="prev"/><name>atttype_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>attrdef_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>attnotnull_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>attcoll_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>attidentity_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>attgenerated_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>isindexkey_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>indexdef_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>fdwopts_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>attstorage_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>attstattarget_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>attdescr_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attoptions_col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name></decl>;</decl_stmt>
	<struct>struct
	<block>{
		<decl_stmt><decl><type><name>int16</name></type>		<name>checks</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>relstorage</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hasindex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hasrules</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hastriggers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>rowsecurity</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>forcerowsecurity</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hasoids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>ispartition</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>tablespace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>reloptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>reloftype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>relpersistence</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>relreplident</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relam</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>compressionType</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>compressionLevel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>blockSize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>checksum</name></decl>;</decl_stmt>
	}</block>			<decl><name>tableinfo</name></decl>;</struct>
	<decl_stmt><decl><type><name>bool</name></type>		<name>show_column_details</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>compressionType</name></name>  <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>compressionLevel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>blockSize</name></name>        <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>checksum</name></name>         <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isGE42</name> <init>= <expr><call><name>isGPDB4200OrLater</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* This output looks confusing in expanded mode. */</comment>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>expanded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get general table info */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
						  <literal type="string">"c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, "</literal>
						  <literal type="string">"false AS relhasoids, c.relispartition, %s, c.reltablespace, "</literal>
						  <literal type="string">"CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, "</literal>
						  <literal type="string">"c.relpersistence, c.relreplident, am.amname\n"</literal>
						  <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_am am ON (c.relam = am.oid)\n"</literal>
						  <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
						   <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
						   <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
						   </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
						  <literal type="string">"c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, "</literal>
						  <literal type="string">"c.relhasoids, c.relispartition, %s, c.reltablespace, "</literal>
						  <literal type="string">"CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, "</literal>
						  <literal type="string">"c.relpersistence, c.relreplident\n"</literal>
						  <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
						  <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
						   <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
						   <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
						   </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
						  <literal type="string">"c.relhastriggers, c.relrowsecurity, c.relforcerowsecurity, "</literal>
						  <literal type="string">"c.relhasoids, false as relispartition, %s, c.reltablespace, "</literal>
						  <literal type="string">"CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, "</literal>
						  <literal type="string">"c.relpersistence, c.relreplident\n"</literal>
						  <literal type="string">", %s as relstorage "</literal>
						  <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
						  <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
						   <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
						   <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
						   </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <comment type="block">/* GPDB Only:  relstorage  */</comment>
						  <argument><expr><operator>(</operator><ternary><condition><expr><call><name>isGPDB</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"c.relstorage"</literal></expr> </then><else>: <expr><literal type="string">"'h'"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
						  <literal type="string">"c.relhastriggers, false, false, c.relhasoids, "</literal>
						  <literal type="string">"false as relispartition, %s, c.reltablespace, "</literal>
						  <literal type="string">"CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, "</literal>
						  <literal type="string">"c.relpersistence, c.relreplident\n"</literal>
						  <literal type="string">", %s as relstorage "</literal>
						  <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
						  <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
						   <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
						   <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
						   </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <comment type="block">/* GPDB Only:  relstorage  */</comment>
						  <argument><expr><operator>(</operator><ternary><condition><expr><call><name>isGPDB</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"c.relstorage"</literal></expr> </then><else>: <expr><literal type="string">"'h'"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
						  <literal type="string">"c.relhastriggers, false, false, c.relhasoids, "</literal>
						  <literal type="string">"false as relispartition, %s, c.reltablespace, "</literal>
						  <literal type="string">"CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END, "</literal>
						  <literal type="string">"c.relpersistence\n"</literal>
						  <literal type="string">", %s as relstorage "</literal>
						  <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
						  <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
						   <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
						   <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
						   </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <comment type="block">/* GPDB Only:  relstorage  */</comment>
						  <argument><expr><operator>(</operator><ternary><condition><expr><call><name>isGPDB</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"c.relstorage"</literal></expr> </then><else>: <expr><literal type="string">"'h'"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
						  <literal type="string">"c.relhastriggers, false, false, c.relhasoids, "</literal>
						  <literal type="string">"false as relispartition, %s, c.reltablespace, "</literal>
						  <literal type="string">"CASE WHEN c.reloftype = 0 THEN '' ELSE c.reloftype::pg_catalog.regtype::pg_catalog.text END\n"</literal>
						  <literal type="string">", %s as relstorage "</literal>
						  <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
						  <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
						   <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
						   <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
						   </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <comment type="block">/* GPDB Only:  relstorage  */</comment>
						  <argument><expr><operator>(</operator><ternary><condition><expr><call><name>isGPDB</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"c.relstorage"</literal></expr> </then><else>: <expr><literal type="string">"'h'"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.relchecks, c.relkind, c.relhasindex, c.relhasrules, "</literal>
						  <literal type="string">"c.relhastriggers, false, false, c.relhasoids, "</literal>
						  <literal type="string">"false as relispartition, %s, c.reltablespace\n"</literal>
						  <literal type="string">", %s as relstorage "</literal>
						  <literal type="string">"FROM pg_catalog.pg_class c\n "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid)\n"</literal>
						  <literal type="string">"WHERE c.oid = '%s';"</literal></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
						   <expr><literal type="string">"pg_catalog.array_to_string(c.reloptions || "</literal>
						   <literal type="string">"array(select 'toast.' || x from pg_catalog.unnest(tc.reloptions) x), ', ')\n"</literal></expr>
						   </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <comment type="block">/* GPDB Only:  relstorage  */</comment>
						  <argument><expr><operator>(</operator><ternary><condition><expr><call><name>isGPDB</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"c.relstorage"</literal></expr> </then><else>: <expr><literal type="string">"'h'"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT relchecks, relkind, relhasindex, relhasrules, "</literal>
						  <literal type="string">"reltriggers &lt;&gt; 0, false, false, relhasoids, "</literal>
						  <literal type="string">"false as relispartition, %s, reltablespace\n"</literal>
						  <literal type="string">", %s as relstorage "</literal>
						  <literal type="string">"FROM pg_catalog.pg_class WHERE oid = '%s';"</literal></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then>
						   <expr><literal type="string">"pg_catalog.array_to_string(reloptions, E', ')"</literal></expr> </then><else>: <expr><literal type="string">"''"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <comment type="block">/* GPDB Only:  relstorage  */</comment>
						  <argument><expr><operator>(</operator><ternary><condition><expr><call><name>isGPDB</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"relstorage"</literal></expr> </then><else>: <expr><literal type="string">"'h'"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT relchecks, relkind, relhasindex, relhasrules, "</literal>
						  <literal type="string">"reltriggers &lt;&gt; 0, false, false, relhasoids, "</literal>
						  <literal type="string">"false as relispartition, '', reltablespace\n"</literal>
						  <literal type="string">"FROM pg_catalog.pg_class WHERE oid = '%s';"</literal></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT relchecks, relkind, relhasindex, relhasrules, "</literal>
						  <literal type="string">"reltriggers &lt;&gt; 0, false, false, relhasoids, "</literal>
						  <literal type="string">"false as relispartition, '', ''\n"</literal>
						  <literal type="string">"FROM pg_catalog.pg_class WHERE oid = '%s';"</literal></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Did we get anything? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any relation with OID %s."</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<goto>goto <name>error_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>checks</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>hasindex</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>hasrules</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>hastriggers</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>forcerowsecurity</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>hasoids</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>ispartition</name></name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>reloptions</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal><operator>)</operator></expr> ?</condition><then>
		<expr><call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>tablespace</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal><operator>)</operator></expr> ?</condition><then>
		<expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>reloftype</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal> <operator>&amp;&amp;</operator>
						   <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
		<expr><call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>relpersistence</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal><operator>)</operator></expr> ?</condition><then>
		<expr><operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal><operator>)</operator></expr> ?</condition><then>
		<expr><operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>: <expr><literal type="char">'d'</literal></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>relam</name></name> <operator>=</operator> <ternary><condition><expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr> ?</condition><then>
			<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr> </then><else>: <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>relam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* GPDB Only:  relstorage  */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">120000</literal> <operator>&amp;&amp;</operator> <call><name>isGPDB</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>relstorage</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relstorage"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>relstorage</name></name> <operator>=</operator> <literal type="char">'h'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a sequence, deal with it here separately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>footers</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT pg_catalog.format_type(seqtypid, NULL) AS \"%s\",\n"</literal>
							  <literal type="string">"       seqstart AS \"%s\",\n"</literal>
							  <literal type="string">"       seqmin AS \"%s\",\n"</literal>
							  <literal type="string">"       seqmax AS \"%s\",\n"</literal>
							  <literal type="string">"       seqincrement AS \"%s\",\n"</literal>
							  <literal type="string">"       CASE WHEN seqcycle THEN '%s' ELSE '%s' END AS \"%s\",\n"</literal>
							  <literal type="string">"       seqcache AS \"%s\"\n"</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Start"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Minimum"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Increment"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Cycles?"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Cache"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"FROM pg_catalog.pg_sequence\n"</literal>
							  <literal type="string">"WHERE seqrelid = '%s';"</literal></expr></argument>,
							  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT 'bigint' AS \"%s\",\n"</literal>
							  <literal type="string">"       start_value AS \"%s\",\n"</literal>
							  <literal type="string">"       min_value AS \"%s\",\n"</literal>
							  <literal type="string">"       max_value AS \"%s\",\n"</literal>
							  <literal type="string">"       increment_by AS \"%s\",\n"</literal>
							  <literal type="string">"       CASE WHEN is_cycled THEN '%s' ELSE '%s' END AS \"%s\",\n"</literal>
							  <literal type="string">"       cache_value AS \"%s\"\n"</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Start"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Minimum"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Increment"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Cycles?"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Cache"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FROM %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* must be separate because fmtId isn't reentrant */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">".%s;"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* Footer information about a sequence */</comment>

		<comment type="block">/* Get the column that owns this sequence */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.quote_ident(nspname) || '.' ||"</literal>
						  <literal type="string">"\n   pg_catalog.quote_ident(relname) || '.' ||"</literal>
						  <literal type="string">"\n   pg_catalog.quote_ident(attname),"</literal>
						  <literal type="string">"\n   d.deptype"</literal>
						  <literal type="string">"\nFROM pg_catalog.pg_class c"</literal>
						  <literal type="string">"\nINNER JOIN pg_catalog.pg_depend d ON c.oid=d.refobjid"</literal>
						  <literal type="string">"\nINNER JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace"</literal>
						  <literal type="string">"\nINNER JOIN pg_catalog.pg_attribute a ON ("</literal>
						  <literal type="string">"\n a.attrelid=c.oid AND"</literal>
						  <literal type="string">"\n a.attnum=d.refobjsubid)"</literal>
						  <literal type="string">"\nWHERE d.classid='pg_catalog.pg_class'::pg_catalog.regclass"</literal>
						  <literal type="string">"\n AND d.refclassid='pg_catalog.pg_class'::pg_catalog.regclass"</literal>
						  <literal type="string">"\n AND d.objid='%s'"</literal>
						  <literal type="string">"\n AND d.deptype IN ('a', 'i')"</literal></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we get no rows back, don't show anything (obviously). We should
		 * never get more than one row back, but if we do, just ignore it and
		 * don't print anything.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'a'</literal></expr>:</case>
					<expr_stmt><expr><name><name>footers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Owned by: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'i'</literal></expr>:</case>
					<expr_stmt><expr><name><name>footers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Sequence for identity column: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Sequence \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>footers</name></name> <operator>=</operator> <name>footers</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>topt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>title</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>footers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>footers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<goto>goto <name>error_return</name>;</goto>		<comment type="block">/* not an error, just return early */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>greenplum_is_ao_column</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>relstorage</name></name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relam</name></name></expr></argument>)</argument_list></call>
			<operator>||</operator> <call><name>greenplum_is_ao_row</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>relstorage</name></name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relam</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Get Append Only information
		 * always have 4 bits of info: blocksize, compresstype, compresslevel and checksum
		 */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
				<argument><expr><literal type="string">"SELECT a.compresstype, a.compresslevel, a.blocksize, a.checksum\n"</literal>
					<literal type="string">"FROM pg_catalog.pg_appendonly a, pg_catalog.pg_class c\n"</literal>
					<literal type="string">"WHERE c.oid = a.relid AND c.oid = '%s'"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>compressionType</name></name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"None"</literal></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>compressionType</name></name></expr></argument>, <argument><expr><literal type="string">"None"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>compressionType</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>compressionLevel</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>blockSize</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tableinfo</name><operator>.</operator><name>checksum</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Identify whether we should print collation, nullable, default vals */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>show_column_details</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get per-column info
	 *
	 * Since the set of query columns we need varies depending on relkind and
	 * server version, we compute all the column numbers on-the-fly.  Column
	 * number variables for columns not fetched are left as -1; this avoids
	 * duplicative test logic below.
	 */</comment>
	<expr_stmt><expr><name>cols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attname_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  pg_catalog.format_type(a.atttypid, a.atttypmod)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>atttype_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>show_column_details</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use "pretty" mode for expression to avoid excessive parentheses */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">",\n  (SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid, true) for 128)"</literal>
							 <literal type="string">"\n   FROM pg_catalog.pg_attrdef d"</literal>
							 <literal type="string">"\n   WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef)"</literal>
							 <literal type="string">",\n  a.attnotnull"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attrdef_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>attnotnull_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t\n"</literal>
								 <literal type="string">"   WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation &lt;&gt; t.typcollation) AS attcollation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  NULL AS attcollation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>attcoll_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  a.attidentity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  ''::pg_catalog.char AS attidentity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>attidentity_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  a.attgenerated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  ''::pg_catalog.char AS attgenerated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>attgenerated_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  CASE WHEN a.attnum &lt;= (SELECT i.indnkeyatts FROM pg_catalog.pg_index i WHERE i.indexrelid = '%s') THEN '%s' ELSE '%s' END AS is_key"</literal></expr></argument>,
							  <argument><expr><name>oid</name></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>isindexkey_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, TRUE) AS indexdef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexdef_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* FDW options for foreign table column, only for 9.2 or later */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  CASE WHEN attfdwoptions IS NULL THEN '' ELSE "</literal>
							 <literal type="string">"  '(' || pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value)  FROM "</literal>
							 <literal type="string">"  pg_catalog.pg_options_to_table(attfdwoptions)), ', ') || ')' END AS attfdwoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fdwopts_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  a.attstorage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attstorage_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* stats target, if relevant to relkind */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  CASE WHEN a.attstattarget=-1 THEN NULL ELSE a.attstattarget END AS attstattarget"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attstattarget_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>greenplum_is_ao_column</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>relstorage</name></name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>isGE42</name> <operator>==</operator> <name>true</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  pg_catalog.array_to_string(e.attoptions, ',')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attoptions_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In 9.0+, we have column comments for: relations, views, composite
		 * types, and foreign tables (cf. CommentObject() in comment.c).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  pg_catalog.col_description(a.attrelid, a.attnum)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attdescr_col</name> <operator>=</operator> <name>cols</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_attribute a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isGE42</name> <operator>==</operator> <name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nLEFT OUTER JOIN pg_catalog.pg_attribute_encoding e"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nON   e.attrelid = a .attrelid AND e.attnum = a.attnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nWHERE a.attrelid = '%s' AND a.attnum &gt; 0 AND NOT a.attisdropped"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nORDER BY a.attnum;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>numrows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make title */</comment>
	<switch>switch <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relpersistence</name></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unlogged table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"View \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relpersistence</name></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unlogged materialized view \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Materialized view \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relpersistence</name></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unlogged index \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Index \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relpersistence</name></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unlogged partitioned index \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partitioned index \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'s'</literal></expr>:</case>
			<comment type="block">/* not used as of 8.2, but keep it for backwards compatibility */</comment>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Special relation \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"TOAST table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Composite type \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Foreign table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relpersistence</name></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unlogged partitioned table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partitioned table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_AOSEGMENTS</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Appendonly segment entry table: \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_AOVISIMAP</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Appendonly visibility map table: \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_AOBLOCKDIR</name></expr>:</case>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Appendonly block directory table: \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* untranslated unknown relkind */</comment>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><literal type="string">"?%c? \"%s.%s\""</literal></expr></argument>,
							  <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name></expr></argument>, <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>relationname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Fill headers[] with the names of the columns we will output */</comment>
	<expr_stmt><expr><name>cols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>show_column_details</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Nullable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>isindexkey_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Key?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>indexdef_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Definition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>fdwopts_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FDW options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>attstorage_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Storage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>attstattarget_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Stats target"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <call><name>greenplum_is_ao_column</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>relstorage</name></name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Compression Type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Compression Level"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Block Size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>attdescr_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>headers</name><index>[<expr><name>cols</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cols</name> <operator>&lt;=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>headers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>title</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>cols</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>printTableInitialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>headers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'l'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Generate table cells to be printed */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Column */</comment>
		<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>attname_col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Type */</comment>
		<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>atttype_col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Collation, Nullable, Default */</comment>
		<if_stmt><if>if <condition>(<expr><name>show_column_details</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>identity</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>generated</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>default_str</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>attcoll_col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>,
							  <argument><expr><ternary><condition><expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>attnotnull_col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"not null"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>identity</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>attidentity_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>generated</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>attgenerated_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>identity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_ALWAYS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>default_str</name> <operator>=</operator> <literal type="string">"generated always as identity"</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>identity</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_BY_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>default_str</name> <operator>=</operator> <literal type="string">"generated by default as identity"</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>generated</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>default_str</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"generated always as (%s) stored"</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>attrdef_col</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<comment type="block">/* (note: above we cut off the 'default' string at 128) */</comment>
				<expr_stmt><expr><name>default_str</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>attrdef_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>default_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>generated</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Info for index columns */</comment>
		<if_stmt><if>if <condition>(<expr><name>isindexkey_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>isindexkey_col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>indexdef_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>indexdef_col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* FDW options for foreign table columns */</comment>
		<if_stmt><if>if <condition>(<expr><name>fdwopts_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>fdwopts_col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Storage and Description */</comment>
		<if_stmt><if>if <condition>(<expr><name>attstorage_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>storage</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>attstorage_col</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Storage */</comment>
			<comment type="block">/* these strings are literal in our syntax, so not translated. */</comment>
			<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal></expr> ?</condition><then> <expr><literal type="string">"plain"</literal></expr> </then><else>:
									  <expr><operator>(</operator><ternary><condition><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal></expr> ?</condition><then> <expr><literal type="string">"main"</literal></expr> </then><else>:
									   <expr><operator>(</operator><ternary><condition><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal></expr> ?</condition><then> <expr><literal type="string">"extended"</literal></expr> </then><else>:
										<expr><operator>(</operator><ternary><condition><expr><name><name>storage</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr> ?</condition><then> <expr><literal type="string">"external"</literal></expr> </then><else>:
										 <expr><literal type="string">"???"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Statistics target, if the relkind supports this feature */</comment>
		<if_stmt><if>if <condition>(<expr><name>attstattarget_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>attstattarget_col</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>greenplum_is_ao_column</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>relstorage</name></name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relam</name></name></expr></argument>)</argument_list></call>
				<operator>&amp;&amp;</operator> <name>attoptions_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* The compression type, compression level, and block size are all in the next column.
			 * attributeOptions is a text array of key=value pairs retrieved as a string from the catalog.
			 * Each key=value pair is separated by a ",".
			 *
			 * If the table was created pre-4.2, then it will not have entries in the new pg_attribute_storage table.
			 * If there are no entries, we go to the pre-4.1 values stored in the pg_appendonly table.
			 */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attributeOptions</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>attributeOptions</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>attoptions_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* pg_catalog.pg_attribute_storage(attoptions) */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>strtok</name><argument_list>(<argument><expr><name>attributeOptions</name></expr></argument>, <argument><expr><literal type="string">",="</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>compressionType</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>compressionLevel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>blockSize</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">",="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"compresstype"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>compressionType</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"compresslevel"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>compressionLevel</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"blocksize"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>blockSize</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">",="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>

			<comment type="block">/* Compression Type */</comment>
			<if_stmt><if>if <condition>(<expr><name>compressionType</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>compressionType</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>compressionType</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Compression Level */</comment>
			<if_stmt><if>if <condition>(<expr><name>compressionLevel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>compressionLevel</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>compressionLevel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Block Size */</comment>
			<if_stmt><if>if <condition>(<expr><name>blockSize</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>blockSize</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>blockSize</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Column comments, if the relkind supports this feature */</comment>
		<if_stmt><if>if <condition>(<expr><name>attdescr_col</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>attdescr_col</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Make footers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get the partition information */</comment>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>parent_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>partdef</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>partconstraintdef</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT inhparent::pg_catalog.regclass,\n"</literal>
						  <literal type="string">"  pg_catalog.pg_get_expr(c.relpartbound, inhrelid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If verbose, also request the partition constraint definition */</comment>
		<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n  pg_catalog.pg_get_partition_constraintdef(inhrelid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"\nFROM pg_catalog.pg_class c"</literal>
						  <literal type="string">" JOIN pg_catalog.pg_inherits i"</literal>
						  <literal type="string">" ON c.oid = inhrelid"</literal>
						  <literal type="string">"\nWHERE c.oid = '%s' AND c.relispartition;"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>parent_name</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>partconstraintdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partition of: %s %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parent_name</name></expr></argument>,
							  <argument><expr><name>partdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* If there isn't any constraint, show that explicitly */</comment>
				<if_stmt><if>if <condition>(<expr><name>partconstraintdef</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>partconstraintdef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No partition constraint"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partition constraint: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>partconstraintdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get the partition key information  */</comment>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>partkeydef</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.pg_get_partkeydef('%s'::pg_catalog.oid);"</literal></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>partkeydef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partition key: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>partkeydef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Footer information about an index */</comment>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT i.indisunique, i.indisprimary, i.indisclustered, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"i.indisvalid,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"true AS indisvalid,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								 <argument><expr><literal type="string">"  (NOT i.indimmediate) AND "</literal>
								 <literal type="string">"EXISTS (SELECT 1 FROM pg_catalog.pg_constraint "</literal>
								 <literal type="string">"WHERE conrelid = i.indrelid AND "</literal>
								 <literal type="string">"conindid = i.indexrelid AND "</literal>
								 <literal type="string">"contype IN ('p','u','x') AND "</literal>
								 <literal type="string">"condeferrable) AS condeferrable,\n"</literal>
								 <literal type="string">"  (NOT i.indimmediate) AND "</literal>
								 <literal type="string">"EXISTS (SELECT 1 FROM pg_catalog.pg_constraint "</literal>
								 <literal type="string">"WHERE conrelid = i.indrelid AND "</literal>
								 <literal type="string">"conindid = i.indexrelid AND "</literal>
								 <literal type="string">"contype IN ('p','u','x') AND "</literal>
								 <literal type="string">"condeferred) AS condeferred,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								 <argument><expr><literal type="string">"  false AS condeferrable, false AS condeferred,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"i.indisreplident,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"false AS indisreplident,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  a.amname, c2.relname, "</literal>
						  <literal type="string">"pg_catalog.pg_get_expr(i.indpred, i.indrelid, true)\n"</literal>
						  <literal type="string">"FROM pg_catalog.pg_index i, pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_am a\n"</literal>
						  <literal type="string">"WHERE i.indexrelid = c.oid AND c.oid = '%s' AND c.relam = a.oid\n"</literal>
						  <literal type="string">"AND i.indrelid = c2.oid;"</literal></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error_return</name>;</goto>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indisunique</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indisprimary</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indisclustered</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indisvalid</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>deferrable</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>deferred</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indisreplident</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indamname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indtable</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indpred</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>indisprimary</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"primary key, "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>indisunique</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unique, "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><literal type="string">"%s, "</literal></expr></argument>, <argument><expr><name>indamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* we assume here that index and table are in same schema */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"for table \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>indtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>indpred</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", predicate (%s)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indpred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>indisclustered</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", clustered"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>indisvalid</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", invalid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", deferrable"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>deferred</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", initially deferred"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>indisreplident</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", replica identity"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_tablespace_footer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name></expr></argument>,
								  <argument><expr><name><name>tableinfo</name><operator>.</operator><name>tablespace</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			 <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			 <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
			 <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			 <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_AOSEGMENTS</name> <operator>||</operator>
			 <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_AOBLOCKDIR</name> <operator>||</operator>
			 <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_AOVISIMAP</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Footer information about a table */</comment>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* external tables were marked in catalogs like this before GPDB 7 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relstorage</name></name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_external_table_footer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* print append only table information */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>greenplum_is_ao_row</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>relstorage</name></name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relam</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>greenplum_is_ao_column</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>relstorage</name></name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relam</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>greenplum_is_ao_row</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>relstorage</name></name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Compression Type: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>compressionType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Compression Level: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>compressionLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Block Size: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>blockSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Checksum: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/* print indexes */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hasindex</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT c2.relname, i.indisprimary, i.indisunique, i.indisclustered, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"i.indisvalid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"true as indisvalid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog.pg_get_indexdef(i.indexrelid, 0, true),\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
									 <argument><expr><literal type="string">"pg_catalog.pg_get_constraintdef(con.oid, true), "</literal>
									 <literal type="string">"contype, condeferrable, condeferred"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
									 <argument><expr><literal type="string">"null AS constraintdef, null AS contype, "</literal>
									 <literal type="string">"false AS condeferrable, false AS condeferred"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", i.indisreplident"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", false AS indisreplident"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", c2.reltablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_index i\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
									 <argument><expr><literal type="string">"  LEFT JOIN pg_catalog.pg_constraint con ON (conrelid = i.indrelid AND conindid = i.indexrelid AND contype IN ('p','u','x'))\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"WHERE c.oid = '%s' AND c.oid = i.indrelid AND i.indexrelid = c2.oid\n"</literal>
							  <literal type="string">"ORDER BY i.indisprimary DESC, i.indisunique DESC, c2.relname;"</literal></expr></argument>,
							  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error_return</name>;</goto></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Indexes:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<comment type="block">/* untranslated index name */</comment>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    \"%s\""</literal></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* If exclusion constraint, print the constraintdef */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"x"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
										  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexdef</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>usingpos</name></decl>;</decl_stmt>

						<comment type="block">/* Label as primary key or unique (but not both) */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" PRIMARY KEY,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"u"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" UNIQUE CONSTRAINT,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" UNIQUE,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/* Everything after "USING" is echoed verbatim */</comment>
						<expr_stmt><expr><name>indexdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>usingpos</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>indexdef</name></expr></argument>, <argument><expr><literal type="string">" USING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>usingpos</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>indexdef</name> <operator>=</operator> <name>usingpos</name> <operator>+</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>indexdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* Need these for deferrable PK/UNIQUE indexes */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DEFERRABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" INITIALLY DEFERRED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/* Add these for all cases */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" CLUSTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" INVALID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" REPLICA IDENTITY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Print tablespace of the index on the same line */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80000</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>add_tablespace_footer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>RELKIND_INDEX</name></expr></argument>,
											  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* print table (and column) check constraints */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>checks</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT r.conname, "</literal>
							  <literal type="string">"pg_catalog.pg_get_constraintdef(r.oid, true)\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_constraint r\n"</literal>
							  <literal type="string">"WHERE r.conrelid = '%s' AND r.contype = 'c'\n"</literal>
							  <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
							  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error_return</name>;</goto></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Check constraints:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<comment type="block">/* untranslated constraint name and def */</comment>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    \"%s\" %s"</literal></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Print foreign-key constraints (there are none if no triggers,
		 * except if the table is partitioned, in which case the triggers
		 * appear in the partitions)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hastriggers</name></name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>tableinfo</name><operator>.</operator><name>ispartition</name></name> <operator>||</operator> <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Put the constraints defined in this table first, followed
				 * by the constraints defined in ancestor partitioned tables.
				 */</comment>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								  <argument><expr><literal type="string">"SELECT conrelid = '%s'::pg_catalog.regclass AS sametable,\n"</literal>
								  <literal type="string">"       conname,\n"</literal>
								  <literal type="string">"       pg_catalog.pg_get_constraintdef(oid, true) AS condef,\n"</literal>
								  <literal type="string">"       conrelid::pg_catalog.regclass AS ontable\n"</literal>
								  <literal type="string">"  FROM pg_catalog.pg_constraint,\n"</literal>
								  <literal type="string">"       pg_catalog.pg_partition_ancestors('%s')\n"</literal>
								  <literal type="string">" WHERE conrelid = relid AND contype = 'f' AND conparentid = 0\n"</literal>
								  <literal type="string">"ORDER BY sametable DESC, conname;"</literal></expr></argument>,
								  <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								  <argument><expr><literal type="string">"SELECT true as sametable, conname,\n"</literal>
								  <literal type="string">"  pg_catalog.pg_get_constraintdef(r.oid, true) as condef,\n"</literal>
								  <literal type="string">"  conrelid::pg_catalog.regclass AS ontable\n"</literal>
								  <literal type="string">"FROM pg_catalog.pg_constraint r\n"</literal>
								  <literal type="string">"WHERE r.conrelid = '%s' AND r.contype = 'f'\n"</literal></expr></argument>,
								  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"     AND conparentid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error_return</name>;</goto></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>i_sametable</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"sametable"</literal></expr></argument>)</argument_list></call></expr></init></decl>,
							<decl><type ref="prev"/><name>i_conname</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr></init></decl>,
							<decl><type ref="prev"/><name>i_condef</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"condef"</literal></expr></argument>)</argument_list></call></expr></init></decl>,
							<decl><type ref="prev"/><name>i_ontable</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"ontable"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Foreign-key constraints:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<comment type="block">/*
					 * Print untranslated constraint name and definition. Use
					 * a "TABLE tab" prefix when the constraint is defined in
					 * a parent partitioned table.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_sametable</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    TABLE \"%s\" CONSTRAINT \"%s\" %s"</literal></expr></argument>,
										  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ontable</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_condef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    \"%s\" %s"</literal></expr></argument>,
										  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_condef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* print incoming foreign-key references */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hastriggers</name></name> <operator>||</operator>
			<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								  <argument><expr><literal type="string">"SELECT conname, conrelid::pg_catalog.regclass AS ontable,\n"</literal>
								  <literal type="string">"       pg_catalog.pg_get_constraintdef(oid, true) AS condef\n"</literal>
								  <literal type="string">"  FROM pg_catalog.pg_constraint c\n"</literal>
								  <literal type="string">" WHERE confrelid IN (SELECT pg_catalog.pg_partition_ancestors('%s')\n"</literal>
								  <literal type="string">"                     UNION ALL VALUES ('%s'::pg_catalog.regclass))\n"</literal>
								  <literal type="string">"       AND contype = 'f' AND conparentid = 0\n"</literal>
								  <literal type="string">"ORDER BY conname;"</literal></expr></argument>,
								  <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								  <argument><expr><literal type="string">"SELECT conname, conrelid::pg_catalog.regclass AS ontable,\n"</literal>
								  <literal type="string">"       pg_catalog.pg_get_constraintdef(oid, true) AS condef\n"</literal>
								  <literal type="string">"  FROM pg_catalog.pg_constraint\n"</literal>
								  <literal type="string">" WHERE confrelid = %s AND contype = 'f'\n"</literal>
								  <literal type="string">"ORDER BY conname;"</literal></expr></argument>,
								  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error_return</name>;</goto></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>i_conname</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr></init></decl>,
							<decl><type ref="prev"/><name>i_ontable</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"ontable"</literal></expr></argument>)</argument_list></call></expr></init></decl>,
							<decl><type ref="prev"/><name>i_condef</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"condef"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Referenced by:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    TABLE \"%s\" CONSTRAINT \"%s\" %s"</literal></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ontable</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_condef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* print any row-level policies */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pol.polname,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								  <argument><expr><literal type="string">" pol.polpermissive,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								  <argument><expr><literal type="string">" 't' as polpermissive,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"  CASE WHEN pol.polroles = '{0}' THEN NULL ELSE pg_catalog.array_to_string(array(select rolname from pg_catalog.pg_roles where oid = any (pol.polroles) order by 1),',') END,\n"</literal>
							  <literal type="string">"  pg_catalog.pg_get_expr(pol.polqual, pol.polrelid),\n"</literal>
							  <literal type="string">"  pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid),\n"</literal>
							  <literal type="string">"  CASE pol.polcmd\n"</literal>
							  <literal type="string">"    WHEN 'r' THEN 'SELECT'\n"</literal>
							  <literal type="string">"    WHEN 'a' THEN 'INSERT'\n"</literal>
							  <literal type="string">"    WHEN 'w' THEN 'UPDATE'\n"</literal>
							  <literal type="string">"    WHEN 'd' THEN 'DELETE'\n"</literal>
							  <literal type="string">"    END AS cmd\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_policy pol\n"</literal>
							  <literal type="string">"WHERE pol.polrelid = '%s' ORDER BY 1;"</literal></expr></argument>,
							  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error_return</name>;</goto></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Handle cases where RLS is enabled and there are policies, or
			 * there aren't policies, or RLS isn't enabled but there are
			 * policies
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tableinfo</name><operator>.</operator><name>forcerowsecurity</name></name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Policies:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>forcerowsecurity</name></name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Policies (forced row security enabled):"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tableinfo</name><operator>.</operator><name>forcerowsecurity</name></name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Policies (row security enabled): (none)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>forcerowsecurity</name></name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Policies (forced row security enabled): (none)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tableinfo</name><operator>.</operator><name>rowsecurity</name></name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Policies (row security disabled):"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Might be an empty set - that's ok */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    POLICY \"%s\""</literal></expr></argument>,
								  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS RESTRICTIVE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOR %s"</literal></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n      TO %s"</literal></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n      USING (%s)"</literal></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n      WITH CHECK (%s)"</literal></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			</block_content>}</block></for>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* print any extended statistics */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT oid, "</literal>
							  <literal type="string">"stxrelid::pg_catalog.regclass, "</literal>
							  <literal type="string">"stxnamespace::pg_catalog.regnamespace AS nsp, "</literal>
							  <literal type="string">"stxname,\n"</literal>
							  <literal type="string">"  (SELECT pg_catalog.string_agg(pg_catalog.quote_ident(attname),', ')\n"</literal>
							  <literal type="string">"   FROM pg_catalog.unnest(stxkeys) s(attnum)\n"</literal>
							  <literal type="string">"   JOIN pg_catalog.pg_attribute a ON (stxrelid = a.attrelid AND\n"</literal>
							  <literal type="string">"        a.attnum = s.attnum AND NOT attisdropped)) AS columns,\n"</literal>
							  <literal type="string">"  'd' = any(stxkind) AS ndist_enabled,\n"</literal>
							  <literal type="string">"  'f' = any(stxkind) AS deps_enabled,\n"</literal>
							  <literal type="string">"  'm' = any(stxkind) AS mcv_enabled\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_statistic_ext stat "</literal>
							  <literal type="string">"WHERE stxrelid = '%s'\n"</literal>
							  <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
							  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error_return</name>;</goto></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Statistics objects:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>gotone</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* statistics object name (qualified with namespace) */</comment>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\"%s\".\"%s\" ("</literal></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* options */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ndistinct"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>gotone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%sdependencies"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>gotone</name></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>gotone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%smcv"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>gotone</name></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") ON %s FROM %s"</literal></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* print rules */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hasrules</name></name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								  <argument><expr><literal type="string">"SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true)), "</literal>
								  <literal type="string">"ev_enabled\n"</literal>
								  <literal type="string">"FROM pg_catalog.pg_rewrite r\n"</literal>
								  <literal type="string">"WHERE r.ev_class = '%s' ORDER BY 1;"</literal></expr></argument>,
								  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								  <argument><expr><literal type="string">"SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true)), "</literal>
								  <literal type="string">"'O' AS ev_enabled\n"</literal>
								  <literal type="string">"FROM pg_catalog.pg_rewrite r\n"</literal>
								  <literal type="string">"WHERE r.ev_class = '%s' ORDER BY 1;"</literal></expr></argument>,
								  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error_return</name>;</goto></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>have_heading</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>category</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>category</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>category</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>category</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name>have_heading</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ruledef</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>bool</name></type>		<name>list_rule</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

						<switch>switch <condition>(<expr><name>category</name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><literal type="number">0</literal></expr>:</case>
								<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'O'</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>list_rule</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<break>break;</break>
							<case>case <expr><literal type="number">1</literal></expr>:</case>
								<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'D'</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>list_rule</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<break>break;</break>
							<case>case <expr><literal type="number">2</literal></expr>:</case>
								<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'A'</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>list_rule</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<break>break;</break>
							<case>case <expr><literal type="number">3</literal></expr>:</case>
								<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'R'</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><name>list_rule</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<break>break;</break>
						</block_content>}</block></switch>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list_rule</name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_heading</name></expr>)</condition>
						<block>{<block_content>
							<switch>switch <condition>(<expr><name>category</name></expr>)</condition>
							<block>{<block_content>
								<case>case <expr><literal type="number">0</literal></expr>:</case>
									<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Rules:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><literal type="number">1</literal></expr>:</case>
									<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Disabled rules:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><literal type="number">2</literal></expr>:</case>
									<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Rules firing always:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><literal type="number">3</literal></expr>:</case>
									<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Rules firing on replica only:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<break>break;</break>
							</block_content>}</block></switch>
							<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>have_heading</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/* Everything after "CREATE RULE" is echoed verbatim */</comment>
						<expr_stmt><expr><name>ruledef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>ruledef</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    %s"</literal></expr></argument>, <argument><expr><name>ruledef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* print any publications */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT pubname\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_publication p\n"</literal>
							  <literal type="string">"JOIN pg_catalog.pg_publication_rel pr ON p.oid = pr.prpubid\n"</literal>
							  <literal type="string">"WHERE pr.prrelid = '%s'\n"</literal>
							  <literal type="string">"UNION ALL\n"</literal>
							  <literal type="string">"SELECT pubname\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_publication p\n"</literal>
							  <literal type="string">"WHERE p.puballtables AND pg_catalog.pg_relation_is_publishable('%s')\n"</literal>
							  <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
							  <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error_return</name>;</goto></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Publications:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Might be an empty set - that's ok */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    \"%s\""</literal></expr></argument>,
								  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get view_def if table is a view or materialized view */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
		 <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.pg_get_viewdef('%s'::pg_catalog.oid, true);"</literal></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>view_def</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>view_def</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Footer information about a view */</comment>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"View definition:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>view_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* print rules */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hasrules</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true))\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_rewrite r\n"</literal>
							  <literal type="string">"WHERE r.ev_class = '%s' AND r.rulename != '_RETURN' ORDER BY 1;"</literal></expr></argument>,
							  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Rules:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ruledef</name></decl>;</decl_stmt>

					<comment type="block">/* Everything after "CREATE RULE" is echoed verbatim */</comment>
					<expr_stmt><expr><name>ruledef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ruledef</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>ruledef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Print triggers next, if any (but only user-defined triggers).  This
	 * could apply to either a table or a view.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>hastriggers</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tuples</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT t.tgname, "</literal>
						  <literal type="string">"pg_catalog.pg_get_triggerdef(t.oid%s), "</literal>
						  <literal type="string">"t.tgenabled, %s\n"</literal>
						  <literal type="string">"FROM pg_catalog.pg_trigger t\n"</literal>
						  <literal type="string">"WHERE t.tgrelid = '%s' AND "</literal></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr> ?</condition><then> <expr><literal type="string">", true"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr> ?</condition><then> <expr><literal type="string">"t.tgisinternal"</literal></expr> </then><else>:
						   <expr><ternary><condition><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr> ?</condition><then>
						   <expr><literal type="string">"t.tgconstraint &lt;&gt; 0 AS tgisinternal"</literal></expr> </then><else>:
						   <expr><literal type="string">"false AS tgisinternal"</literal></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D') \n"</literal>
							  <literal type="string">"    OR EXISTS (SELECT 1 FROM pg_catalog.pg_depend WHERE objid = t.oid \n"</literal>
							  <literal type="string">"        AND refclassid = 'pg_catalog.pg_trigger'::pg_catalog.regclass))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* display/warn about disabled internal triggers */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(NOT t.tgisinternal OR (t.tgisinternal AND t.tgenabled = 'D'))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(t.tgconstraint = 0 OR (t.tgconstraint &lt;&gt; 0 AND t.tgenabled = 'D'))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								 <argument><expr><literal type="string">"(NOT tgisconstraint "</literal>
								 <literal type="string">" OR NOT EXISTS"</literal>
								 <literal type="string">"  (SELECT 1 FROM pg_catalog.pg_depend d "</literal>
								 <literal type="string">"   JOIN pg_catalog.pg_constraint c ON (d.refclassid = c.tableoid AND d.refobjid = c.oid) "</literal>
								 <literal type="string">"   WHERE d.classid = t.tableoid AND d.objid = t.oid AND d.deptype = 'i' AND c.contype = 'f'))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>have_heading</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>category</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * split the output into 4 different categories. Enabled triggers,
			 * disabled triggers and the two special ALWAYS and REPLICA
			 * configurations.
			 */</comment>
			<for>for <control>(<init><expr><name>category</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>category</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>category</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>have_heading</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>list_trigger</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tgdef</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>usingpos</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tgenabled</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tgisinternal</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Check if this trigger falls into the current category
					 */</comment>
					<expr_stmt><expr><name>tgenabled</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tgisinternal</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<switch>switch <condition>(<expr><name>category</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><literal type="number">0</literal></expr>:</case>
							<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'O'</literal> <operator>||</operator> <operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<break>break;</break>
						<case>case <expr><literal type="number">1</literal></expr>:</case>
							<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'D'</literal> <operator>||</operator> <operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'f'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
								<operator>*</operator><name>tgisinternal</name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<break>break;</break>
						<case>case <expr><literal type="number">2</literal></expr>:</case>
							<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'D'</literal> <operator>||</operator> <operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'f'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
								<operator>*</operator><name>tgisinternal</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

							<comment type="block">/*
							 * Foreign keys are not enforced in GPDB. All foreign
							 * key triggers are disabled, so let's not bother
							 * listing them.
							 */</comment>
							<expr_stmt><expr><name>tgdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>isGPDB</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>tgdef</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

							<break>break;</break>
						<case>case <expr><literal type="number">3</literal></expr>:</case>
							<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'A'</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<break>break;</break>
						<case>case <expr><literal type="number">4</literal></expr>:</case>
							<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tgenabled</name> <operator>==</operator> <literal type="char">'R'</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>list_trigger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
					<if_stmt><if>if <condition>(<expr><name>list_trigger</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<comment type="block">/* Print the category heading once */</comment>
					<if_stmt><if>if <condition>(<expr><name>have_heading</name> <operator>==</operator> <name>false</name></expr>)</condition>
					<block>{<block_content>
						<switch>switch <condition>(<expr><name>category</name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><literal type="number">0</literal></expr>:</case>
								<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Triggers:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><literal type="number">1</literal></expr>:</case>
								<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Disabled user triggers:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
								<else>else<block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Disabled triggers:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
								<break>break;</break>
							<case>case <expr><literal type="number">2</literal></expr>:</case>
								<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Disabled internal triggers:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><literal type="number">3</literal></expr>:</case>
								<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Triggers firing always:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><literal type="number">4</literal></expr>:</case>
								<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Triggers firing on replica only:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>

						</block_content>}</block></switch>
						<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>have_heading</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Everything after "TRIGGER" is echoed verbatim */</comment>
					<expr_stmt><expr><name>tgdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>usingpos</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>tgdef</name></expr></argument>, <argument><expr><literal type="string">" TRIGGER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>usingpos</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>tgdef</name> <operator>=</operator> <name>usingpos</name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    %s"</literal></expr></argument>, <argument><expr><name>tgdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Finish printing the footer information about a table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
		<name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tuples</name></decl>;</decl_stmt>

		<comment type="block">/* print foreign server name */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ftoptions</name></decl>;</decl_stmt>

			<comment type="block">/* Footer information about foreign table */</comment>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT s.srvname,\n"</literal>
							  <literal type="string">"  pg_catalog.array_to_string(ARRAY(\n"</literal>
							  <literal type="string">"    SELECT pg_catalog.quote_ident(option_name)"</literal>
							  <literal type="string">" || ' ' || pg_catalog.quote_literal(option_value)\n"</literal>
							  <literal type="string">"    FROM pg_catalog.pg_options_to_table(ftoptions)),  ', ')\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_foreign_table f,\n"</literal>
							  <literal type="string">"     pg_catalog.pg_foreign_server s\n"</literal>
							  <literal type="string">"WHERE f.ftrelid = '%s' AND s.oid = f.ftserver;"</literal></expr></argument>,
							  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error_return</name>;</goto></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error_return</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>GP_EXTTABLE_SERVER_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Print server name */</comment>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Server: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Print per-table FDW options, if any */</comment>
			<expr_stmt><expr><name>ftoptions</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ftoptions</name> <operator>&amp;&amp;</operator> <name><name>ftoptions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"FDW options: (%s)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ftoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* print inherited tables (exclude, if parent is a partitioned table) */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.oid::pg_catalog.regclass"</literal>
						  <literal type="string">" FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i"</literal>
						  <literal type="string">" WHERE c.oid=i.inhparent AND i.inhrelid = '%s'"</literal>
						  <literal type="string">" AND c.relkind != "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call>
						  <literal type="string">" ORDER BY inhseqno;"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Inherits"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>sw</name> <init>= <expr><call><name>pg_wcswidth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>,
									  <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s  %s"</literal></expr></argument>,
									  <argument><expr><name>sw</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>tuples</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* print child tables (with additional info if partitions) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT c.oid::pg_catalog.regclass,"</literal>
							  <literal type="string">"       pg_catalog.pg_get_expr(c.relpartbound, c.oid),"</literal>
							  <literal type="string">"       c.relkind"</literal>
							  <literal type="string">" FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i"</literal>
							  <literal type="string">" WHERE c.oid=i.inhrelid AND i.inhparent = '%s'"</literal>
							  <literal type="string">" ORDER BY pg_catalog.pg_get_expr(c.relpartbound, c.oid) = 'DEFAULT',"</literal>
							  <literal type="string">"          c.oid::pg_catalog.regclass::pg_catalog.text;"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT c.oid::pg_catalog.regclass"</literal>
							  <literal type="string">" FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i"</literal>
							  <literal type="string">" WHERE c.oid=i.inhrelid AND i.inhparent = '%s'"</literal>
							  <literal type="string">" ORDER BY c.oid::pg_catalog.regclass::pg_catalog.text;"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT c.oid::pg_catalog.regclass"</literal>
							  <literal type="string">" FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i"</literal>
							  <literal type="string">" WHERE c.oid=i.inhrelid AND i.inhparent = '%s'"</literal>
							  <literal type="string">" ORDER BY c.relname;"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * For a partitioned table with no partitions, always print the number
		 * of partitions as zero, even when verbose output is expected.
		 * Otherwise, we will not print "Partitions" section for a partitioned
		 * table without any partitions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Number of partitions: %d"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>verbose</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* print the number of child tables, if any */</comment>
			<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Number of child tables: %d (Use \\d+ to list them.)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Number of partitions: %d (Use \\d+ to list them.)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* display the list of child tables */</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr> ?</condition><then>
			<expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Child tables"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Partitions"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>ctw</name> <init>= <expr><call><name>pg_wcswidth</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>,
										  <argument><expr><name>ct</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s  %s"</literal></expr></argument>,
										  <argument><expr><name>ctw</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>partitioned_note</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>partitioned_note</name> <operator>=</operator> <literal type="string">", PARTITIONED"</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>partitioned_note</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s %s%s"</literal></expr></argument>,
										  <argument><expr><name>ct</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>partitioned_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s  %s %s%s"</literal></expr></argument>,
										  <argument><expr><name>ctw</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>partitioned_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>tuples</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Table type */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>reloftype</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Typed table of type: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			 <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator>

		<comment type="block">/*
		 * No need to display default values; we already display a REPLICA
		 * IDENTITY marker on indexes.
		 */</comment>
			<name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>!=</operator> <literal type="char">'i'</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>!=</operator> <literal type="char">'d'</literal><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>!=</operator> <literal type="char">'n'</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Replica Identity"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>,
							  <argument><expr><name>s</name></expr></argument>,
							  <argument><expr><ternary><condition><expr><name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>==</operator> <literal type="char">'f'</literal></expr> ?</condition><then> <expr><literal type="string">"FULL"</literal></expr> </then><else>:
							  <expr><ternary><condition><expr><name><name>tableinfo</name><operator>.</operator><name>relreplident</name></name> <operator>==</operator> <literal type="char">'n'</literal></expr> ?</condition><then> <expr><literal type="string">"NOTHING"</literal></expr> </then><else>:
							  <expr><literal type="string">"???"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* OIDs, if verbose and not a materialized view */</comment>
		<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>hasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Has OIDs: yes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* mpp addition start: dump distributed by clause */</comment>
		<expr_stmt><expr><call><name>add_distributed_by_footer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Still needed by legacy partitioning to print old version server's 'partition by' clause */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isGPDB7000OrLater</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>tuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_partition_by_footer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Tablespace info */</comment>
		<expr_stmt><expr><call><name>add_tablespace_footer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relkind</name></name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>tablespace</name></name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Access method info */</comment>
		<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>relam</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pset</name><operator>.</operator><name>hide_tableam</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Access method: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* reloptions, if verbose */</comment>
	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator>
		<name><name>tableinfo</name><operator>.</operator><name>reloptions</name></name> <operator>&amp;&amp;</operator> <name><name>tableinfo</name><operator>.</operator><name>reloptions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Options"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>tableinfo</name><operator>.</operator><name>reloptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<label><name>error_return</name>:</label>

	<comment type="block">/* clean up */</comment>
	<if_stmt><if>if <condition>(<expr><name>printTableInitialized</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printTableCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>view_def</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>view_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>compressionType</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>compressionType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>compressionLevel</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>compressionLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>blockSize</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>blockSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tableinfo</name><operator>.</operator><name>checksum</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tableinfo</name><operator>.</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Print footer information for an external table */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_external_table_footer</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cont</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>tmpbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	    <name>gpdb5OrLater</name> <init>= <expr><call><name>isGPDB5000OrLater</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	    <name>gpdb6OrLater</name> <init>= <expr><call><name>isGPDB6000OrLater</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>gpdb7OrLater</name> <init>= <expr><call><name>isGPDB7000OrLater</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>optionsName</name> <init>= <expr><ternary><condition><expr><name>gpdb5OrLater</name></expr> ?</condition><then> <expr><literal type="string">", x.options "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>execLocations</name> <init>= <expr><ternary><condition><expr><name>gpdb5OrLater</name></expr> ?</condition><then> <expr><literal type="string">"x.urilocation, x.execlocation"</literal></expr> </then><else>: <expr><literal type="string">"x.location"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>urislocation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>execlocation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fmttype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fmtopts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rejlim</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rejlimtype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>writable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errtblname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>extencoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errortofile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>logerrors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>format</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exttaboptions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>options</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>gpdb6OrLater</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT %s, x.fmttype, x.fmtopts, x.command, x.logerrors, "</literal>
						  <literal type="string">"x.rejectlimit, x.rejectlimittype, x.writable, "</literal>
						  <literal type="string">"pg_catalog.pg_encoding_to_char(x.encoding) "</literal>
						  <literal type="string">"%s"</literal>
						  <literal type="string">"FROM pg_catalog.pg_exttable x, pg_catalog.pg_class c "</literal>
						  <literal type="string">"WHERE x.reloid = c.oid AND c.oid = '%s'\n"</literal></expr></argument>, <argument><expr><name>execLocations</name></expr></argument>, <argument><expr><name>optionsName</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT %s, x.fmttype, x.fmtopts, x.command, "</literal>
						  <literal type="string">"x.rejectlimit, x.rejectlimittype, x.writable, "</literal>
						  <literal type="string">"(SELECT relname "</literal>
						  <literal type="string">"FROM pg_class "</literal>
						  <literal type="string">"WHERE Oid=x.fmterrtbl) AS errtblname, "</literal>
						  <literal type="string">"pg_catalog.pg_encoding_to_char(x.encoding), "</literal>
						  <literal type="string">"x.fmterrtbl = x.reloid AS errortofile "</literal>
						  <literal type="string">"%s"</literal>
						  <literal type="string">"FROM pg_catalog.pg_exttable x, pg_catalog.pg_class c "</literal>
						  <literal type="string">"WHERE x.reloid = c.oid AND c.oid = '%s'\n"</literal></expr></argument>, <argument><expr><name>execLocations</name></expr></argument>, <argument><expr><name>optionsName</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>gpdb7OrLater</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>exttaboptions</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>gpdb6OrLater</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>urislocation</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>execlocation</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmtopts</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>logerrors</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rejlim</name> <operator>=</operator>  <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rejlimtype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>writable</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>extencoding</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>gpdb5OrLater</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>urislocation</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>execlocation</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmtopts</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rejlim</name> <operator>=</operator>  <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rejlimtype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>writable</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errtblname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>extencoding</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errortofile</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>urislocation</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmtopts</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rejlim</name> <operator>=</operator>  <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rejlimtype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>writable</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errtblname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>extencoding</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errortofile</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>execlocation</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Writable/Readable */</comment>
	<if_stmt><if>if <condition>(<expr><name>writable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Type: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name><name>writable</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr> ?</condition><then> <expr><literal type="string">"writable"</literal></expr> </then><else>: <expr><literal type="string">"readable"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* encoding */</comment>
	<if_stmt><if>if <condition>(<expr><name>extencoding</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Encoding: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>extencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fmttype</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* format type */</comment>
		<switch>switch <condition>( <expr><name><name>fmttype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition>
		<block>{<block_content>
		<case>case <expr><literal type="char">'t'</literal></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="string">"text"</literal></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><literal type="char">'c'</literal></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="string">"csv"</literal></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><literal type="char">'b'</literal></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="string">"custom"</literal></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<block>{<block_content>
				<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unknown fmttype value: %c\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fmttype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		</block_content>}</block></switch><empty_stmt>;</empty_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Format type: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* format options */</comment>
	<if_stmt><if>if <condition>(<expr><name>fmtopts</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Format options: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fmtopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>gpdb7OrLater</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* external table options */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"External options: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exttaboptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>gpdb5OrLater</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* external table options */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"External options: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>command</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* EXECUTE type table - show command and command location */</comment>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Command: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>on_clause</name> <init>= <expr><ternary><condition><expr><name>gpdb5OrLater</name></expr> ?</condition><then> <expr><name>execlocation</name></expr> </then><else>: <expr><name>urislocation</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>on_clause</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> <comment type="block">/* don't print the '}' character */</comment>
		<expr_stmt><expr><name>on_clause</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* don't print the '{' character */</comment>

		<if_stmt><if>if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"HOST:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"HOST:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: host '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>on_clause</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"HOST:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"PER_HOST"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"PER_HOST"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: one segment per host"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"MASTER_ONLY"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"MASTER_ONLY"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: master segment"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: coordinator"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: segment %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>on_clause</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: %s random segments"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>on_clause</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"ALL_SEGMENTS"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"ALL_SEGMENTS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: all segments"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: ERROR: invalid catalog entry (describe.c)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>urislocation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* LOCATION type table - show external location */</comment>

		<expr_stmt><expr><name><name>urislocation</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>urislocation</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> <comment type="block">/* don't print the '}' character */</comment>
		<expr_stmt><expr><name>urislocation</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* don't print the '{' character */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"External location: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>urislocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>gpdb5OrLater</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>execlocation</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>execlocation</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> <comment type="block">/* don't print the '}' character */</comment>
			<expr_stmt><expr><name>execlocation</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* don't print the '{' character */</comment>

			<if_stmt><if>if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>execlocation</name></expr></argument>, <argument><expr><literal type="string">"HOST:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"HOST:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: host '%s'"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>execlocation</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"HOST:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>execlocation</name></expr></argument>, <argument><expr><literal type="string">"PER_HOST"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"PER_HOST"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: one segment per host"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>execlocation</name></expr></argument>, <argument><expr><literal type="string">"MASTER_ONLY"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"MASTER_ONLY"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: master segment"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>execlocation</name></expr></argument>, <argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: coordinator"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>execlocation</name></expr></argument>, <argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: segment %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>execlocation</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>execlocation</name></expr></argument>, <argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: %s random segments"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>execlocation</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>execlocation</name></expr></argument>, <argument><expr><literal type="string">"ALL_SEGMENTS"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"ALL_SEGMENTS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: all segments"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Execute on: ERROR: invalid catalog entry (describe.c)"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Single row error handling */</comment>
	<if_stmt><if>if <condition>(<expr><name>rejlim</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>rejlim</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* reject limit and type */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Segment reject limit: %s %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>rejlim</name></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name><name>rejlimtype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal></expr> ?</condition><then> <expr><literal type="string">"percent"</literal></expr> </then><else>: <expr><literal type="string">"rows"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>errortofile</name> <operator>&amp;&amp;</operator> <name><name>errortofile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>logerrors</name> <operator>&amp;&amp;</operator> <name><name>logerrors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Error Log in File"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>logerrors</name> <operator>&amp;&amp;</operator> <name><name>logerrors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Error Log in Persistent File"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name>errtblname</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errtblname</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Error table: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>errtblname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<label><name>error_return</name>:</label>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_distributed_by_footer</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cont</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>tempbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result1</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>result2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>is_distributed</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isGPDB6000OrLater</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempbuf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.pg_get_table_distributedby('%s')"</literal></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result1</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>tempbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result1</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Error:  Well, so what?  Best to continue */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>distributedby</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>distributedby</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>distributedby</name></expr></argument>, <argument><expr><literal type="string">"DISTRIBUTED RANDOMLY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Distributed randomly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>distributedby</name></expr></argument>, <argument><expr><literal type="string">"DISTRIBUTED REPLICATED"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Distributed Replicated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>distributedby</name></expr></argument>, <argument><expr><literal type="string">"DISTRIBUTED BY "</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"DISTRIBUTED BY "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Distributed by: %s"</literal></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>distributedby</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"DISTRIBUTED BY "</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * This probably prints something silly like "Distributed by: DISTRIBUTED ...".
				 * But if we don't recognize it, it's the best we can do.
				 */</comment>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Distributed by: %s"</literal></expr></argument>, <argument><expr><name>distributedby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return> <comment type="block">/* success */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempbuf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT attrnums \n"</literal>
						  <literal type="string">"FROM pg_catalog.gp_distribution_policy t\n"</literal>
						  <literal type="string">"WHERE localoid = '%s'"</literal></expr></argument>,
						  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result1</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>tempbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result1</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Error:  Well, so what?  Best to continue */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>is_distributed</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_distributed</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dist_columns</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dist_colname</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>dist_columns</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dist_columns</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>dist_columns</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>dist_columns</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> <comment type="block">/* remove '}' */</comment>
				<expr_stmt><expr><name>dist_columns</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* skip '{' */</comment>

				<comment type="block">/* Get the attname for the first distribution column.*/</comment>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempbuf</name></expr></argument>,
								  <argument><expr><literal type="string">"SELECT attname FROM pg_catalog.pg_attribute \n"</literal>
								  <literal type="string">"WHERE attrelid = '%s' \n"</literal>
								  <literal type="string">"AND attnum = '%d' "</literal></expr></argument>,
								  <argument><expr><name>oid</name></expr></argument>,
								  <argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>dist_columns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result2</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>tempbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result2</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>dist_colname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dist_colname</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Distributed by: (%s"</literal></expr></argument>,
								  <argument><expr><name>dist_colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dist_colname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isGPDB6000OrLater</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>dist_columns</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>dist_columns</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<while>while <condition>(<expr><name>col</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>col</name><operator>++</operator></expr>;</expr_stmt>
					<comment type="block">/* Get the attname for next distribution columns.*/</comment>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempbuf</name></expr></argument>,
									  <argument><expr><literal type="string">"SELECT attname FROM pg_catalog.pg_attribute \n"</literal>
									  <literal type="string">"WHERE attrelid = '%s' \n"</literal>
									  <literal type="string">"AND attnum = '%d' "</literal></expr></argument>,
									  <argument><expr><name>oid</name></expr></argument>,
									  <argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result2</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>tempbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result2</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>dist_colname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dist_colname</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", %s"</literal></expr></argument>, <argument><expr><name>dist_colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isGPDB6000OrLater</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></while>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Distributed randomly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return> <comment type="block">/* success */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a 'partition by' description to the footer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_partition_by_footer</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cont</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nRows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nPartKey</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check if current relation is root partition, if it is root partition, at least 1 row returns */</comment>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT parrelid FROM pg_catalog.pg_partition WHERE parrelid = '%s'"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nRows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nRows</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* query partition key on the root partition */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
			<argument><expr><literal type="string">"WITH att_arr AS (SELECT unnest(paratts) \n"</literal>
			<literal type="string">"	FROM pg_catalog.pg_partition p \n"</literal>
			<literal type="string">"	WHERE p.parrelid = '%s' AND p.parlevel = 0 AND p.paristemplate = false), \n"</literal>
			<literal type="string">"idx_att AS (SELECT row_number() OVER() AS idx, unnest AS att_num FROM att_arr) \n"</literal>
			<literal type="string">"SELECT attname FROM pg_catalog.pg_attribute, idx_att \n"</literal>
			<literal type="string">"	WHERE attrelid='%s' AND attnum = att_num ORDER BY idx "</literal></expr></argument>,
			<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* query partition key on the intermediate partition */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
			<argument><expr><literal type="string">"WITH att_arr AS (SELECT unnest(paratts) FROM pg_catalog.pg_partition p, \n"</literal>
			<literal type="string">"	(SELECT parrelid, parlevel \n"</literal>
			<literal type="string">"		FROM pg_catalog.pg_partition p, pg_catalog.pg_partition_rule pr \n"</literal>
			<literal type="string">"		WHERE pr.parchildrelid='%s' AND p.oid = pr.paroid) AS v \n"</literal>
			<literal type="string">"	WHERE p.parrelid = v.parrelid AND p.parlevel = v.parlevel+1 AND p.paristemplate = false), \n"</literal>
			<literal type="string">"idx_att AS (SELECT row_number() OVER() AS idx, unnest AS att_num FROM att_arr) \n"</literal>
			<literal type="string">"SELECT attname FROM pg_catalog.pg_attribute, idx_att \n"</literal>
			<literal type="string">"	WHERE attrelid='%s' AND attnum = att_num ORDER BY idx "</literal></expr></argument>,
			<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nPartKey</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nPartKey</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>partColName</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Partition by: ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nPartKey</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>partColName</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partColName</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>partColName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>		<comment type="block">/* success */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Add a tablespace description to a footer.  If 'newline' is true, it is added
 * in a new line; otherwise it's appended to the current value of the last
 * footer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_tablespace_footer</name><parameter_list>(<parameter><decl><type><name>printTableContent</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cont</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>tablespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>newline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* relkinds for which we support tablespaces */</comment>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		<name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
		<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We ignore the database default tablespace so that users not using
		 * tablespaces don't need to know about them.  This case also covers
		 * pre-8.0 servers, for which tablespace will always be 0.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tablespace</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT spcname FROM pg_catalog.pg_tablespace\n"</literal>
							  <literal type="string">"WHERE oid = '%u';"</literal></expr></argument>, <argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Should always be the case, but.... */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>newline</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Add the tablespace as a new footer */</comment>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Tablespace: \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Append the tablespace to the latest footer */</comment>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>cont</name><operator>-&gt;</operator><name>footer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*-------
					   translator: before this string there's an index description like
					   '"foo_pkey" PRIMARY KEY, btree (a)' */</comment>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">", tablespace \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>printTableSetFooter</name><argument_list>(<argument><expr><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * \du or \dg
 *
 * Describes roles.  Any schema portion of the pattern is ignored.
 */</comment>
<function><type><name>bool</name></type>
<name>describeRoles</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printTableContent</name></type> <name>cont</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printTableOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncols</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>conns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type>	<name>align</name> <init>= <expr><literal type="char">'l'</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>   <name>numgreenplumspecificattrs</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT r.rolname, r.rolsuper, r.rolinherit,\n"</literal>
						  <literal type="string">"  r.rolcreaterole, r.rolcreatedb, r.rolcanlogin,\n"</literal>
						  <literal type="string">"  r.rolconnlimit, r.rolvaliduntil,\n"</literal>
						  <literal type="string">"  ARRAY(SELECT b.rolname\n"</literal>
						  <literal type="string">"        FROM pg_catalog.pg_auth_members m\n"</literal>
						  <literal type="string">"        JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)\n"</literal>
						  <literal type="string">"        WHERE m.member = r.oid) as memberof"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* add Greenplum specific attributes */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n, r.rolcreaterextgpfd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n, r.rolcreatewextgpfd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n, r.rolcreaterexthttp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n, pg_catalog.shobj_description(r.oid, 'pg_authid') AS description"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ncols</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n, r.rolreplication"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n, r.rolbypassrls"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_roles r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE r.rolname !~ '^pg_'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"r.rolname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT u.usename AS rolname,\n"</literal>
						  <literal type="string">"  u.usesuper AS rolsuper,\n"</literal>
						  <literal type="string">"  true AS rolinherit, false AS rolcreaterole,\n"</literal>
						  <literal type="string">"  u.usecreatedb AS rolcreatedb, true AS rolcanlogin,\n"</literal>
						  <literal type="string">"  -1 AS rolconnlimit,"</literal>
						  <literal type="string">"  u.valuntil as rolvaliduntil,\n"</literal>
						  <literal type="string">"  ARRAY(SELECT g.groname FROM pg_catalog.pg_group g WHERE u.usesysid = ANY(g.grolist)) as memberof"</literal>
						  <literal type="string">"\nFROM pg_catalog.pg_user u\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"u.usename"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nrows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><name>nrows</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>attr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of roles"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Role name"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Attributes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Member of"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Superuser"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No inheritance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Create role"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Create DB"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


		<comment type="block">/* output Greenplum specific attributes */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Ext gpfdist Table"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Wri Ext gpfdist Table"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Ext http Table"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* end Greenplum specific attributes */</comment>


		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot login"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* +numgreenplumspecificattrs is due to additional Greenplum specific attributes */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then> <expr><literal type="number">10</literal> <operator>+</operator> <name>numgreenplumspecificattrs</name></expr> </then><else>: <expr><literal type="number">9</literal> <operator>+</operator> <name>numgreenplumspecificattrs</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Replication"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then> <expr><literal type="number">11</literal></expr> </then><else>: <expr><literal type="number">10</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>add_role_attribute</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Bypass RLS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>conns</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>conns</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>conns</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No connections"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%d connection"</literal></expr></argument>,
												 <argument><expr><literal type="string">"%d connections"</literal></expr></argument>,
												 <argument><expr><name>conns</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>conns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Password valid until "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">9</literal> <operator>+</operator> <name>numgreenplumspecificattrs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printTableCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_role_attribute</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * \drds
 */</comment>
<function><type><name>bool</name></type>
<name>listDbRoleSettings</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>havewhere</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support per-database role settings."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT rolname AS \"%s\", datname AS \"%s\",\n"</literal>
					  <literal type="string">"pg_catalog.array_to_string(setconfig, E'\\n') AS \"%s\"\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_db_role_setting s\n"</literal>
					  <literal type="string">"LEFT JOIN pg_catalog.pg_database d ON d.oid = setdatabase\n"</literal>
					  <literal type="string">"LEFT JOIN pg_catalog.pg_roles r ON r.oid = setrole\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Role"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Database"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Settings"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>havewhere</name> <operator>=</operator> <call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"r.rolname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern2</name></expr></argument>, <argument><expr><name>havewhere</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"d.datname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Most functions in this file are content to print an empty table when
	 * there are no matching objects.  We intentionally deviate from that
	 * here, but only in !quiet mode, because of the possibility that the user
	 * is confused about what the two pattern arguments mean.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&amp;&amp;</operator> <name>pattern2</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any settings for role \"%s\" and database \"%s\"."</literal></expr></argument>,
						 <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any settings for role \"%s\"."</literal></expr></argument>,
						 <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any settings."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of settings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * listTables()
 *
 * handler for \dt, \di, etc.
 *
 * tabtypes is an array of characters, specifying what info is desired:
 * t - tables
 * i - indexes
 * v - views
 * m - materialized views
 * s - sequences
 * E - foreign table (Note: different from 'f', the relkind value)
 * (any order of the above is fine)
 */</comment>
<function><type><name>bool</name></type>
<name>listTables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tabtypes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showChildren</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showTables</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showIndexes</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showViews</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'v'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showMatViews</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'m'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showSeq</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showForeign</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'E'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr> <comment type="block">/* Storage */</comment>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If tabtypes is empty, we default to \dtvmsE (but see also command.c) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>showTables</name> <operator>||</operator> <name>showIndexes</name> <operator>||</operator> <name>showViews</name> <operator>||</operator> <name>showMatViews</name> <operator>||</operator> <name>showSeq</name> <operator>||</operator> <name>showForeign</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>showTables</name> <operator>=</operator> <name>showViews</name> <operator>=</operator> <name>showMatViews</name> <operator>=</operator> <name>showSeq</name> <operator>=</operator> <name>showForeign</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>showExternal</name> <init>= <expr><name>showForeign</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>tabtypes</name></expr></argument>, <argument><expr><literal type="char">'P'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>showTables</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>showChildren</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: as of Pg 8.2, we no longer use relkind 's' (special), but we keep
	 * it here for backwards compatibility.
	 */</comment>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"  c.relname as \"%s\",\n"</literal>
					  <literal type="string">"  CASE c.relkind"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN 's' THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
					  <literal type="string">" END as \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.pg_get_userbyid(c.relowner) as \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"view"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"materialized view"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"special"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign table"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"partitioned table"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"partitioned index"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Show Storage type for tables */</comment>
	<if_stmt><if>if <condition>(<expr><name>showTables</name> <operator>&amp;&amp;</operator> <call><name>isGPDB</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isGPDB7000OrLater</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* In GPDB7, we can have user defined access method, display the access method name directly */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", a.amname as \"%s\"\n"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Storage"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", CASE c.relstorage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHEN 'h' THEN '%s'"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"heap"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHEN 'x' THEN '%s'"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"external"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHEN 'a' THEN '%s'"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"append only"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHEN 'v' THEN '%s'"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHEN 'c' THEN '%s'"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"append only columnar"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHEN 'p' THEN '%s'"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Apache Parquet"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHEN 'f' THEN '%s'"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" END as \"%s\"\n"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Storage"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n c2.relname as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Table"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * As of PostgreSQL 9.0, use pg_table_size() to show a more accurate
		 * size of a table, including FSM, VM and TOAST tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n  pg_catalog.pg_size_pretty(pg_catalog.pg_table_size(c.oid)) as \"%s\""</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n  pg_catalog.pg_size_pretty(pg_catalog.pg_relation_size(c.oid)) as \"%s\""</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  pg_catalog.obj_description(c.oid, 'pg_class') as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_class c"</literal>
						 <literal type="string">"\n     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>showTables</name> <operator>&amp;&amp;</operator> <call><name>isGPDB7000OrLater</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							<argument><expr><literal type="string">"\n     LEFT JOIN pg_catalog.pg_am a ON a.oid = c.relam"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"\n     LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid"</literal>
							 <literal type="string">"\n     LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nWHERE c.relkind IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>showTables</name> <operator>||</operator>
		<operator>(</operator><name>showExternal</name> <operator>&amp;&amp;</operator> <call><name>isGPDB6000OrBelow</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
							 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>showViews</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>showMatViews</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
							 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>showSeq</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>showSystem</name> <operator>||</operator> <name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'s',"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* was RELKIND_SPECIAL */</comment>
	<if_stmt><if>if <condition>(<expr><name>showForeign</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"''"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* dummy */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * GPDB 6 and earlier versions had pg_class.relstorage column, to distinguish
	 * external and other kinds of tables. It's gone in GPDB 6, we use relkind and
	 * relam fields now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isGPDB6000OrBelow</name><argument_list>()</argument_list></call></expr>)</condition>   <comment type="block">/* GPDB? */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"AND c.relstorage IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>showTables</name> <operator>||</operator> <name>showIndexes</name> <operator>||</operator> <name>showSeq</name> <operator>||</operator> <operator>(</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <name>showTables</name><operator>)</operator> <operator>||</operator> <name>showMatViews</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'h', 'a', 'c',"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>showExternal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'x',"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>showForeign</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'f',"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>showViews</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'v',"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"''"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* dummy */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * TOAST objects are suppressed unconditionally.  Since we don't provide
	 * any way to select RELKIND_TOASTVALUE above, we would never show toast
	 * tables in any case; it seems a bit confusing to allow their indexes to
	 * be shown.  Use plain \d if you really need to look at a TOAST
	 * table/index.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname !~ '^pg_toast'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showChildren</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND c.oid NOT IN (select inhrelid from pg_catalog.pg_inherits)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1,2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Most functions in this file are content to print an empty table when
	 * there are no matching objects.  We intentionally deviate from that
	 * here, but only in !quiet mode, for historical reasons.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any relation named \"%s\"."</literal></expr></argument>,
						 <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any relations."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of relations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dP
 * Takes an optional regexp to select particular relations
 *
 * As with \d, you can specify the kinds of relations you want:
 *
 * t for tables
 * i for indexes
 *
 * And there's additional flags:
 *
 * n to list non-leaf partitioned tables
 *
 * and you can mix and match these in any order.
 */</comment>
<function><type><name>bool</name></type>
<name>listPartitionedTables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reltypes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showTables</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>reltypes</name></expr></argument>, <argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showIndexes</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>reltypes</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>showNested</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>reltypes</name></expr></argument>, <argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>title</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tabletitle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mixed_output</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: Declarative table partitioning is only supported as of Pg 10.0.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support declarative table partitioning."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If no relation kind was selected, show them all */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showTables</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>showTables</name> <operator>=</operator> <name>showIndexes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showIndexes</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showTables</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tabletitle</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of partitioned indexes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* \dPi */</comment>
	<if type="elseif">else if <condition>(<expr><name>showTables</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tabletitle</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of partitioned tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* \dPt */</comment>
	<else>else
	<block>{<block_content>
		<comment type="block">/* show all kinds */</comment>
		<expr_stmt><expr><name>tabletitle</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of partitioned relations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mixed_output</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"  c.relname as \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.pg_get_userbyid(c.relowner) as \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mixed_output</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  CASE c.relkind"</literal>
						  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
						  <literal type="string">" WHEN "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">" THEN '%s'"</literal>
						  <literal type="string">" END as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"partitioned table"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"partitioned index"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>translate_columns</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showNested</name> <operator>||</operator> <name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  inh.inhparent::regclass as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Parent name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n c2.oid::regclass as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Table"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>showNested</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n  s.dps as \"%s\""</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Leaf partition size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n  s.tps as \"%s\""</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Total size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="block">/* Sizes of all partitions are considered in this case. */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n  s.tps as \"%s\""</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Total size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  pg_catalog.obj_description(c.oid, 'pg_class') as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_class c"</literal>
						 <literal type="string">"\n     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"\n     LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid"</literal>
							 <literal type="string">"\n     LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showNested</name> <operator>||</operator> <name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"\n     LEFT JOIN pg_catalog.pg_inherits inh ON c.oid = inh.inhrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">120000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n     LATERAL (WITH RECURSIVE d\n"</literal>
							  <literal type="string">"                AS (SELECT inhrelid AS oid, 1 AS level\n"</literal>
							  <literal type="string">"                      FROM pg_catalog.pg_inherits\n"</literal>
							  <literal type="string">"                     WHERE inhparent = c.oid\n"</literal>
							  <literal type="string">"                    UNION ALL\n"</literal>
							  <literal type="string">"                    SELECT inhrelid, level + 1\n"</literal>
							  <literal type="string">"                      FROM pg_catalog.pg_inherits i\n"</literal>
							  <literal type="string">"                           JOIN d ON i.inhparent = d.oid)\n"</literal>
							  <literal type="string">"                SELECT pg_catalog.pg_size_pretty(sum(pg_catalog.pg_table_size("</literal>
							  <literal type="string">"d.oid))) AS tps,\n"</literal>
							  <literal type="string">"                       pg_catalog.pg_size_pretty(sum("</literal>
							  <literal type="string">"\n             CASE WHEN d.level = 1"</literal>
							  <literal type="string">" THEN pg_catalog.pg_table_size(d.oid) ELSE 0 END)) AS dps\n"</literal>
							  <literal type="string">"               FROM d) s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* PostgreSQL 12 has pg_partition_tree function */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n     LATERAL (SELECT pg_catalog.pg_size_pretty(sum("</literal>
							  <literal type="string">"\n                 CASE WHEN ppt.isleaf AND ppt.level = 1"</literal>
							  <literal type="string">"\n                      THEN pg_catalog.pg_table_size(ppt.relid)"</literal>
							  <literal type="string">" ELSE 0 END)) AS dps"</literal>
							  <literal type="string">",\n                     pg_catalog.pg_size_pretty(sum("</literal>
							  <literal type="string">"pg_catalog.pg_table_size(ppt.relid))) AS tps"</literal>
							  <literal type="string">"\n              FROM pg_catalog.pg_partition_tree(c.oid) ppt) s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nWHERE c.relkind IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>showTables</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>showIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call> <literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"''"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* dummy */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>!</operator><name>showNested</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr> ?</condition><then>
						 <expr><literal type="string">" AND NOT c.relispartition\n"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * TOAST objects are suppressed unconditionally.  Since we don't provide
	 * any way to select RELKIND_TOASTVALUE above, we would never show toast
	 * tables in any case; it seems a bit confusing to allow their indexes to
	 * be shown.  Use plain \d if you really need to look at a TOAST
	 * table/index.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname !~ '^pg_toast'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY \"Schema\", %s%s\"Name\";"</literal></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>mixed_output</name></expr> ?</condition><then> <expr><literal type="string">"\"Type\" DESC, "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>showNested</name> <operator>||</operator> <name>pattern</name></expr> ?</condition><then> <expr><literal type="string">"\"Parent name\" NULLS FIRST, "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>tabletitle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>title</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dL
 *
 * Describes languages.
 */</comment>
<function><type><name>bool</name></type>
<name>listLanguages</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT l.lanname AS \"%s\",\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"       pg_catalog.pg_get_userbyid(l.lanowner) as \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"       l.lanpltrusted AS \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Trusted"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       NOT l.lanispl AS \"%s\",\n"</literal>
						  <literal type="string">"       l.lanplcallfoid::pg_catalog.regprocedure AS \"%s\",\n"</literal>
						  <literal type="string">"       l.lanvalidator::pg_catalog.regprocedure AS \"%s\",\n       "</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Internal language"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Call handler"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Validator"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"l.laninline::pg_catalog.regprocedure AS \"%s\",\n       "</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Inline handler"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"l.lanacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">",\n       d.description AS \"%s\""</literal>
					  <literal type="string">"\nFROM pg_catalog.pg_language l\n"</literal>
					  <literal type="string">"LEFT JOIN pg_catalog.pg_description d\n"</literal>
					  <literal type="string">"  ON d.classoid = l.tableoid AND d.objoid = l.oid\n"</literal>
					  <literal type="string">"  AND d.objsubid = 0\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"l.lanname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE l.lanplcallfoid != 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of languages"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dD
 *
 * Describes domains.
 */</comment>
<function><type><name>bool</name></type>
<name>listDomains</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"       t.typname as \"%s\",\n"</literal>
					  <literal type="string">"       pg_catalog.format_type(t.typbasetype, t.typtypmod) as \"%s\",\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"       (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type bt\n"</literal>
						  <literal type="string">"        WHERE c.oid = t.typcollation AND bt.oid = t.typbasetype AND t.typcollation &lt;&gt; bt.typcollation) as \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collation"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"       CASE WHEN t.typnotnull THEN 'not null' END as \"%s\",\n"</literal>
					  <literal type="string">"       t.typdefault as \"%s\",\n"</literal>
					  <literal type="string">"       pg_catalog.array_to_string(ARRAY(\n"</literal>
					  <literal type="string">"         SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM pg_catalog.pg_constraint r WHERE t.oid = r.contypid\n"</literal>
					  <literal type="string">"       ), ' ') as \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Nullable"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Default"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Check"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"t.typacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       d.description as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_type t\n"</literal>
						 <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"     LEFT JOIN pg_catalog.pg_description d "</literal>
							 <literal type="string">"ON d.classoid = t.tableoid AND d.objoid = t.oid "</literal>
							 <literal type="string">"AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE t.typtype = 'd'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"t.typname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_type_is_visible(t.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of domains"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dc
 *
 * Describes conversions.
 */</comment>
<function><type><name>bool</name></type>
<name>listConversions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>=
	<expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname AS \"%s\",\n"</literal>
					  <literal type="string">"       c.conname AS \"%s\",\n"</literal>
					  <literal type="string">"       pg_catalog.pg_encoding_to_char(c.conforencoding) AS \"%s\",\n"</literal>
					  <literal type="string">"       pg_catalog.pg_encoding_to_char(c.contoencoding) AS \"%s\",\n"</literal>
					  <literal type="string">"       CASE WHEN c.condefault THEN '%s'\n"</literal>
					  <literal type="string">"       ELSE '%s' END AS \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Source"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Destination"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Default?"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       d.description AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_conversion c\n"</literal>
						 <literal type="string">"     JOIN pg_catalog.pg_namespace n "</literal>
						 <literal type="string">"ON n.oid = c.connamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"LEFT JOIN pg_catalog.pg_description d "</literal>
							 <literal type="string">"ON d.classoid = c.tableoid\n"</literal>
							 <literal type="string">"          AND d.objoid = c.oid "</literal>
							 <literal type="string">"AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE true\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"  AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.conname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_conversion_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of conversions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dy
 *
 * Describes Event Triggers.
 */</comment>
<function><type><name>bool</name></type>
<name>listEventTriggers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>=
	<expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT evtname as \"%s\", "</literal>
					  <literal type="string">"evtevent as \"%s\", "</literal>
					  <literal type="string">"pg_catalog.pg_get_userbyid(e.evtowner) as \"%s\",\n"</literal>
					  <literal type="string">" case evtenabled when 'O' then '%s'"</literal>
					  <literal type="string">"  when 'R' then '%s'"</literal>
					  <literal type="string">"  when 'A' then '%s'"</literal>
					  <literal type="string">"  when 'D' then '%s' end as \"%s\",\n"</literal>
					  <literal type="string">" e.evtfoid::pg_catalog.regproc as \"%s\", "</literal>
					  <literal type="string">"pg_catalog.array_to_string(array(select x"</literal>
					  <literal type="string">" from pg_catalog.unnest(evttags) as t(x)), ', ') as \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Event"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enabled"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"replica"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"always"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"disabled"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enabled"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Function"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Tags"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\npg_catalog.obj_description(e.oid, 'pg_event_trigger') as \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_event_trigger e "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"evtname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of event triggers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dC
 *
 * Describes casts.
 */</comment>
<function><type><name>bool</name></type>
<name>listCasts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.format_type(castsource, NULL) AS \"%s\",\n"</literal>
					  <literal type="string">"       pg_catalog.format_type(casttarget, NULL) AS \"%s\",\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Source type"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Target type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't attempt to localize '(binary coercible)' or '(with inout)',
	 * because there's too much risk of gettext translating a function name
	 * that happens to match some string in the PO database.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"       CASE WHEN c.castmethod = '%c' THEN '(binary coercible)'\n"</literal>
						  <literal type="string">"            WHEN c.castmethod = '%c' THEN '(with inout)'\n"</literal>
						  <literal type="string">"            ELSE p.proname\n"</literal>
						  <literal type="string">"       END AS \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><name>COERCION_METHOD_BINARY</name></expr></argument>,
						  <argument><expr><name>COERCION_METHOD_INOUT</name></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Function"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"       CASE WHEN c.castfunc = 0 THEN '(binary coercible)'\n"</literal>
						  <literal type="string">"            ELSE p.proname\n"</literal>
						  <literal type="string">"       END AS \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Function"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"       CASE WHEN c.castcontext = '%c' THEN '%s'\n"</literal>
					  <literal type="string">"            WHEN c.castcontext = '%c' THEN '%s'\n"</literal>
					  <literal type="string">"            ELSE '%s'\n"</literal>
					  <literal type="string">"       END AS \"%s\""</literal></expr></argument>,
					  <argument><expr><name>COERCION_CODE_EXPLICIT</name></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>COERCION_CODE_ASSIGNMENT</name></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"in assignment"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Implicit?"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       d.description AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We need a left join to pg_proc for binary casts; the others are just
	 * paranoia.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_cast c LEFT JOIN pg_catalog.pg_proc p\n"</literal>
						 <literal type="string">"     ON c.castfunc = p.oid\n"</literal>
						 <literal type="string">"     LEFT JOIN pg_catalog.pg_type ts\n"</literal>
						 <literal type="string">"     ON c.castsource = ts.oid\n"</literal>
						 <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace ns\n"</literal>
						 <literal type="string">"     ON ns.oid = ts.typnamespace\n"</literal>
						 <literal type="string">"     LEFT JOIN pg_catalog.pg_type tt\n"</literal>
						 <literal type="string">"     ON c.casttarget = tt.oid\n"</literal>
						 <literal type="string">"     LEFT JOIN pg_catalog.pg_namespace nt\n"</literal>
						 <literal type="string">"     ON nt.oid = tt.typnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"     LEFT JOIN pg_catalog.pg_description d\n"</literal>
							 <literal type="string">"     ON d.classoid = c.tableoid AND d.objoid = "</literal>
							 <literal type="string">"c.oid AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHERE ( (true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Match name pattern against either internal or external name of either
	 * castsource or casttarget
	 */</comment>
	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"ns.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"ts.typname"</literal></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.format_type(ts.oid, NULL)"</literal></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_type_is_visible(ts.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") OR (true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"nt.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"tt.typname"</literal></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.format_type(tt.oid, NULL)"</literal></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_type_is_visible(tt.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") )\nORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of casts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dO
 *
 * Describes collations.
 */</comment>
<function><type><name>bool</name></type>
<name>listCollations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>true</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support collations."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname AS \"%s\",\n"</literal>
					  <literal type="string">"       c.collname AS \"%s\",\n"</literal>
					  <literal type="string">"       c.collcollate AS \"%s\",\n"</literal>
					  <literal type="string">"       c.collctype AS \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collate"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Ctype"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       CASE c.collprovider WHEN 'd' THEN 'default' WHEN 'c' THEN 'libc' WHEN 'i' THEN 'icu' END AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Provider"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       'libc' AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Provider"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       CASE WHEN c.collisdeterministic THEN '%s' ELSE '%s' END AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Deterministic?"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       '%s' AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Deterministic?"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n       pg_catalog.obj_description(c.oid, 'pg_collation') AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_collation c, pg_catalog.pg_namespace n\n"</literal>
						 <literal type="string">"WHERE n.oid = c.collnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND n.nspname &lt;&gt; 'pg_catalog'\n"</literal>
							 <literal type="string">"      AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Hide collations that aren't usable in the current database's encoding.
	 * If you think to change this, note that pg_collation_is_visible rejects
	 * unusable collations, so you will need to hack name pattern processing
	 * somehow to avoid inconsistent behavior.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"      AND c.collencoding IN (-1, pg_catalog.pg_char_to_encoding(pg_catalog.getdatabaseencoding()))\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.collname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_collation_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of collations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dn
 *
 * Describes schemas (namespaces)
 */</comment>
<function><type><name>bool</name></type>
<name>listSchemas</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showSystem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname AS \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.pg_get_userbyid(n.nspowner) AS \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"n.nspacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  pg_catalog.obj_description(n.oid, 'pg_namespace') AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"\nFROM pg_catalog.pg_namespace n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"WHERE n.nspname !~ '^pg_' AND n.nspname &lt;&gt; 'information_schema'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>,
						  <argument><expr><operator>!</operator><name>showSystem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of schemas"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dFp
 * list text search parsers
 */</comment>
<function><type><name>bool</name></type>
<name>listTSParsers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support full text search."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>listTSParsersVerbose</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT\n"</literal>
					  <literal type="string">"  n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"  p.prsname as \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.obj_description(p.oid, 'pg_ts_parser') as \"%s\"\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_ts_parser p\n"</literal>
					  <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.prsnamespace\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"p.prsname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_ts_parser_is_visible(p.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of text search parsers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * full description of parsers
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>listTSParsersVerbose</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT p.oid,\n"</literal>
					  <literal type="string">"  n.nspname,\n"</literal>
					  <literal type="string">"  p.prsname\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_ts_parser p\n"</literal>
					  <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.prsnamespace\n"</literal></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"p.prsname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_ts_parser_is_visible(p.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any text search parser named \"%s\"."</literal></expr></argument>,
							 <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any text search parsers."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>prsname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>describeOneTSParser</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>describeOneTSParser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>title</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>true</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT '%s' AS \"%s\",\n"</literal>
					  <literal type="string">"   p.prsstart::pg_catalog.regproc AS \"%s\",\n"</literal>
					  <literal type="string">"   pg_catalog.obj_description(p.prsstart, 'pg_proc') as \"%s\"\n"</literal>
					  <literal type="string">" FROM pg_catalog.pg_ts_parser p\n"</literal>
					  <literal type="string">" WHERE p.oid = '%s'\n"</literal>
					  <literal type="string">"UNION ALL\n"</literal>
					  <literal type="string">"SELECT '%s',\n"</literal>
					  <literal type="string">"   p.prstoken::pg_catalog.regproc,\n"</literal>
					  <literal type="string">"   pg_catalog.obj_description(p.prstoken, 'pg_proc')\n"</literal>
					  <literal type="string">" FROM pg_catalog.pg_ts_parser p\n"</literal>
					  <literal type="string">" WHERE p.oid = '%s'\n"</literal>
					  <literal type="string">"UNION ALL\n"</literal>
					  <literal type="string">"SELECT '%s',\n"</literal>
					  <literal type="string">"   p.prsend::pg_catalog.regproc,\n"</literal>
					  <literal type="string">"   pg_catalog.obj_description(p.prsend, 'pg_proc')\n"</literal>
					  <literal type="string">" FROM pg_catalog.pg_ts_parser p\n"</literal>
					  <literal type="string">" WHERE p.oid = '%s'\n"</literal>
					  <literal type="string">"UNION ALL\n"</literal>
					  <literal type="string">"SELECT '%s',\n"</literal>
					  <literal type="string">"   p.prsheadline::pg_catalog.regproc,\n"</literal>
					  <literal type="string">"   pg_catalog.obj_description(p.prsheadline, 'pg_proc')\n"</literal>
					  <literal type="string">" FROM pg_catalog.pg_ts_parser p\n"</literal>
					  <literal type="string">" WHERE p.oid = '%s'\n"</literal>
					  <literal type="string">"UNION ALL\n"</literal>
					  <literal type="string">"SELECT '%s',\n"</literal>
					  <literal type="string">"   p.prslextype::pg_catalog.regproc,\n"</literal>
					  <literal type="string">"   pg_catalog.obj_description(p.prslextype, 'pg_proc')\n"</literal>
					  <literal type="string">" FROM pg_catalog.pg_ts_parser p\n"</literal>
					  <literal type="string">" WHERE p.oid = '%s';"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Start parse"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Method"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Function"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>oid</name></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Get next token"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>oid</name></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"End parse"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>oid</name></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Get headline"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>oid</name></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Get token types"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Text search parser \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Text search parser \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>title</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>footers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>topt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT t.alias as \"%s\",\n"</literal>
					  <literal type="string">"  t.description as \"%s\"\n"</literal>
					  <literal type="string">"FROM pg_catalog.ts_token_type( '%s'::pg_catalog.oid ) as t\n"</literal>
					  <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Token name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Token types for parser \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Token types for parser \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>title</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>footers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>topt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dFd
 * list text search dictionaries
 */</comment>
<function><type><name>bool</name></type>
<name>listTSDictionaries</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support full text search."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT\n"</literal>
					  <literal type="string">"  n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"  d.dictname as \"%s\",\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  ( SELECT COALESCE(nt.nspname, '(null)')::pg_catalog.text || '.' || t.tmplname FROM\n"</literal>
						  <literal type="string">"    pg_catalog.pg_ts_template t\n"</literal>
						  <literal type="string">"    LEFT JOIN pg_catalog.pg_namespace nt ON nt.oid = t.tmplnamespace\n"</literal>
						  <literal type="string">"    WHERE d.dicttemplate = t.oid ) AS  \"%s\",\n"</literal>
						  <literal type="string">"  d.dictinitoption as \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Template"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Init options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"  pg_catalog.obj_description(d.oid, 'pg_ts_dict') as \"%s\"\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FROM pg_catalog.pg_ts_dict d\n"</literal>
						 <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = d.dictnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"d.dictname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_ts_dict_is_visible(d.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of text search dictionaries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dFt
 * list text search templates
 */</comment>
<function><type><name>bool</name></type>
<name>listTSTemplates</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support full text search."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT\n"</literal>
						  <literal type="string">"  n.nspname AS \"%s\",\n"</literal>
						  <literal type="string">"  t.tmplname AS \"%s\",\n"</literal>
						  <literal type="string">"  t.tmplinit::pg_catalog.regproc AS \"%s\",\n"</literal>
						  <literal type="string">"  t.tmpllexize::pg_catalog.regproc AS \"%s\",\n"</literal>
						  <literal type="string">"  pg_catalog.obj_description(t.oid, 'pg_ts_template') AS \"%s\"\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Init"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Lexize"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT\n"</literal>
						  <literal type="string">"  n.nspname AS \"%s\",\n"</literal>
						  <literal type="string">"  t.tmplname AS \"%s\",\n"</literal>
						  <literal type="string">"  pg_catalog.obj_description(t.oid, 'pg_ts_template') AS \"%s\"\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FROM pg_catalog.pg_ts_template t\n"</literal>
						 <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.tmplnamespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"t.tmplname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_ts_template_is_visible(t.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of text search templates"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dF
 * list text search configurations
 */</comment>
<function><type><name>bool</name></type>
<name>listTSConfigs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support full text search."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>listTSConfigsVerbose</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT\n"</literal>
					  <literal type="string">"   n.nspname as \"%s\",\n"</literal>
					  <literal type="string">"   c.cfgname as \"%s\",\n"</literal>
					  <literal type="string">"   pg_catalog.obj_description(c.oid, 'pg_ts_config') as \"%s\"\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_ts_config c\n"</literal>
					  <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.cfgnamespace\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.cfgname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_ts_config_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of text search configurations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>listTSConfigsVerbose</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT c.oid, c.cfgname,\n"</literal>
					  <literal type="string">"   n.nspname,\n"</literal>
					  <literal type="string">"   p.prsname,\n"</literal>
					  <literal type="string">"   np.nspname as pnspname\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_ts_config c\n"</literal>
					  <literal type="string">"   LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.cfgnamespace,\n"</literal>
					  <literal type="string">" pg_catalog.pg_ts_parser p\n"</literal>
					  <literal type="string">"   LEFT JOIN pg_catalog.pg_namespace np ON np.oid = p.prsnamespace\n"</literal>
					  <literal type="string">"WHERE  p.oid = c.cfgparser\n"</literal></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.cfgname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_ts_config_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 3, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any text search configuration named \"%s\"."</literal></expr></argument>,
							 <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any text search configurations."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cfgname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pnspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cfgname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>prsname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pnspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>describeOneTSConfig</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>cfgname</name></expr></argument>, <argument><expr><name>pnspname</name></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>describeOneTSConfig</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cfgname</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pnspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prsname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>,
				<decl><type ref="prev"/><name>title</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT\n"</literal>
					  <literal type="string">"  ( SELECT t.alias FROM\n"</literal>
					  <literal type="string">"    pg_catalog.ts_token_type(c.cfgparser) AS t\n"</literal>
					  <literal type="string">"    WHERE t.tokid = m.maptokentype ) AS \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.btrim(\n"</literal>
					  <literal type="string">"    ARRAY( SELECT mm.mapdict::pg_catalog.regdictionary\n"</literal>
					  <literal type="string">"           FROM pg_catalog.pg_ts_config_map AS mm\n"</literal>
					  <literal type="string">"           WHERE mm.mapcfg = m.mapcfg AND mm.maptokentype = m.maptokentype\n"</literal>
					  <literal type="string">"           ORDER BY mapcfg, maptokentype, mapseqno\n"</literal>
					  <literal type="string">"    ) :: pg_catalog.text,\n"</literal>
					  <literal type="string">"  '{}') AS \"%s\"\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_ts_config AS c, pg_catalog.pg_ts_config_map AS m\n"</literal>
					  <literal type="string">"WHERE c.oid = '%s' AND m.mapcfg = c.oid\n"</literal>
					  <literal type="string">"GROUP BY m.mapcfg, m.maptokentype, c.cfgparser\n"</literal>
					  <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Token"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Dictionaries"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Text search configuration \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>cfgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Text search configuration \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>cfgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pnspname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nParser: \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>pnspname</name></expr></argument>, <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nParser: \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>title</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>footers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>topt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * \dew
 *
 * Describes foreign-data wrappers
 */</comment>
<function><type><name>bool</name></type>
<name>listForeignDataWrappers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support foreign-data wrappers."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT fdw.fdwname AS \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.pg_get_userbyid(fdw.fdwowner) AS \"%s\",\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"  fdw.fdwhandler::pg_catalog.regproc AS \"%s\",\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Handler"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"  fdw.fdwvalidator::pg_catalog.regproc AS \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Validator"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"fdwacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n CASE WHEN fdwoptions IS NULL THEN '' ELSE "</literal>
						  <literal type="string">"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "</literal>
						  <literal type="string">"  pg_catalog.quote_ident(option_name) ||  ' ' || "</literal>
						  <literal type="string">"  pg_catalog.quote_literal(option_value)  FROM "</literal>
						  <literal type="string">"  pg_catalog.pg_options_to_table(fdwoptions)),  ', ') || ')' "</literal>
						  <literal type="string">"  END AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FDW options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">",\n  d.description AS \"%s\" "</literal></expr></argument>,
							  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_foreign_data_wrapper fdw\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"LEFT JOIN pg_catalog.pg_description d\n"</literal>
							 <literal type="string">"       ON d.classoid = fdw.tableoid "</literal>
							 <literal type="string">"AND d.objoid = fdw.oid AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"fdwname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of foreign-data wrappers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \des
 *
 * Describes foreign servers.
 */</comment>
<function><type><name>bool</name></type>
<name>listForeignServers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support foreign servers."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT s.srvname AS \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.pg_get_userbyid(s.srvowner) AS \"%s\",\n"</literal>
					  <literal type="string">"  f.fdwname AS \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Foreign-data wrapper"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printACLColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"s.srvacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n"</literal>
						  <literal type="string">"  s.srvtype AS \"%s\",\n"</literal>
						  <literal type="string">"  s.srvversion AS \"%s\",\n"</literal>
						  <literal type="string">"  CASE WHEN srvoptions IS NULL THEN '' ELSE "</literal>
						  <literal type="string">"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "</literal>
						  <literal type="string">"  pg_catalog.quote_ident(option_name) ||  ' ' || "</literal>
						  <literal type="string">"  pg_catalog.quote_literal(option_value)  FROM "</literal>
						  <literal type="string">"  pg_catalog.pg_options_to_table(srvoptions)),  ', ') || ')' "</literal>
						  <literal type="string">"  END AS \"%s\",\n"</literal>
						  <literal type="string">"  d.description AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Type"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Version"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FDW options"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_foreign_server s\n"</literal>
						 <literal type="string">"     JOIN pg_catalog.pg_foreign_data_wrapper f ON f.oid=s.srvfdw\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"LEFT JOIN pg_catalog.pg_description d\n       "</literal>
							 <literal type="string">"ON d.classoid = s.tableoid AND d.objoid = s.oid "</literal>
							 <literal type="string">"AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"s.srvname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of foreign servers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \deu
 *
 * Describes user mappings.
 */</comment>
<function><type><name>bool</name></type>
<name>listUserMappings</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support user mappings."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT um.srvname AS \"%s\",\n"</literal>
					  <literal type="string">"  um.usename AS \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Server"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"User name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n CASE WHEN umoptions IS NULL THEN '' ELSE "</literal>
						  <literal type="string">"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "</literal>
						  <literal type="string">"  pg_catalog.quote_ident(option_name) ||  ' ' || "</literal>
						  <literal type="string">"  pg_catalog.quote_literal(option_value)  FROM "</literal>
						  <literal type="string">"  pg_catalog.pg_options_to_table(umoptions)),  ', ') || ')' "</literal>
						  <literal type="string">"  END AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FDW options"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\nFROM pg_catalog.pg_user_mappings um\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"um.srvname"</literal></expr></argument>, <argument><expr><literal type="string">"um.usename"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of user mappings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \det
 *
 * Describes foreign tables.
 */</comment>
<function><type><name>bool</name></type>
<name>listForeignTables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support foreign tables."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT n.nspname AS \"%s\",\n"</literal>
					  <literal type="string">"  c.relname AS \"%s\",\n"</literal>
					  <literal type="string">"  s.srvname AS \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Table"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Server"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n CASE WHEN ftoptions IS NULL THEN '' ELSE "</literal>
						  <literal type="string">"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "</literal>
						  <literal type="string">"  pg_catalog.quote_ident(option_name) ||  ' ' || "</literal>
						  <literal type="string">"  pg_catalog.quote_literal(option_value)  FROM "</literal>
						  <literal type="string">"  pg_catalog.pg_options_to_table(ftoptions)),  ', ') || ')' "</literal>
						  <literal type="string">"  END AS \"%s\",\n"</literal>
						  <literal type="string">"  d.description AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FDW options"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_foreign_table ft\n"</literal>
						 <literal type="string">"  INNER JOIN pg_catalog.pg_class c"</literal>
						 <literal type="string">" ON c.oid = ft.ftrelid\n"</literal>
						 <literal type="string">"  INNER JOIN pg_catalog.pg_namespace n"</literal>
						 <literal type="string">" ON n.oid = c.relnamespace\n"</literal>
						 <literal type="string">"  INNER JOIN pg_catalog.pg_foreign_server s"</literal>
						 <literal type="string">" ON s.oid = ft.ftserver\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							 <argument><expr><literal type="string">"   LEFT JOIN pg_catalog.pg_description d\n"</literal>
							 <literal type="string">"          ON d.classoid = c.tableoid AND "</literal>
							 <literal type="string">"d.objoid = c.oid AND d.objsubid = 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1, 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of foreign tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dx
 *
 * Briefly describes installed extensions.
 */</comment>
<function><type><name>bool</name></type>
<name>listExtensions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support extensions."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT e.extname AS \"%s\", "</literal>
					  <literal type="string">"e.extversion AS \"%s\", n.nspname AS \"%s\", c.description AS \"%s\"\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_extension e "</literal>
					  <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = e.extnamespace "</literal>
					  <literal type="string">"LEFT JOIN pg_catalog.pg_description c ON c.objoid = e.oid "</literal>
					  <literal type="string">"AND c.classoid = 'pg_catalog.pg_extension'::pg_catalog.regclass\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Version"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Schema"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"e.extname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of installed extensions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dx+
 *
 * List contents of installed extensions.
 */</comment>
<function><type><name>bool</name></type>
<name>listExtensionContents</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In PostgreSQL, extension support added in 9.1, but it was backported
	 * to GPDB 5, which is based on 8.3.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support extensions."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The pg_desribe_object function is is needed \dx+. It was introduced
	 * in PostgreSQL 9.1. That means that GPDB 5 didn't have it, even though
	 * extensions support was backported. If we can't use pg_describe_object,
	 * print the same as plain \dx does.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>listExtensions</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT e.extname, e.oid\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_extension e\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"e.extname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any extension named \"%s\"."</literal></expr></argument>,
							 <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any extensions."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>extname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>listOneExtensionContents</name><argument_list>(<argument><expr><name>extname</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>cancel_pressed</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>listOneExtensionContents</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>title</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.pg_describe_object(classid, objid, 0) AS \"%s\"\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_depend\n"</literal>
					  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_extension'::pg_catalog.regclass AND refobjid = '%s' AND deptype = 'e'\n"</literal>
					  <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Object description"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Objects in extension \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <name><name>title</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dRp
 * Lists publications.
 *
 * Takes an optional regexp to select particular publications
 */</comment>
<function><type><name>bool</name></type>
<name>listPublications</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support publications."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pubname AS \"%s\",\n"</literal>
					  <literal type="string">"  pg_catalog.pg_get_userbyid(pubowner) AS \"%s\",\n"</literal>
					  <literal type="string">"  puballtables AS \"%s\",\n"</literal>
					  <literal type="string">"  pubinsert AS \"%s\",\n"</literal>
					  <literal type="string">"  pubupdate AS \"%s\",\n"</literal>
					  <literal type="string">"  pubdelete AS \"%s\""</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"All tables"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Inserts"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Updates"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Deletes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",\n  pubtruncate AS \"%s\""</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Truncates"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_catalog.pg_publication\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"pubname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of publications"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dRp+
 * Describes publications including the contents.
 *
 * Takes an optional regexp to select particular publications
 */</comment>
<function><type><name>bool</name></type>
<name>describePublications</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_pubtruncate</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support publications."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>has_pubtruncate</name> <operator>=</operator> <operator>(</operator><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT oid, pubname,\n"</literal>
					  <literal type="string">"  pg_catalog.pg_get_userbyid(pubowner) AS owner,\n"</literal>
					  <literal type="string">"  puballtables, pubinsert, pubupdate, pubdelete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>has_pubtruncate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">", pubtruncate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"\nFROM pg_catalog.pg_publication\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"pubname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 2;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>pattern</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any publication named \"%s\"."</literal></expr></argument>,
							 <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Did not find any publications."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type>	<name>align</name> <init>= <expr><literal type="char">'l'</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ncols</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nrows</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tables</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>tabres</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pubid</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pubname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>puballtables</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>title</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>printTableOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>printTableContent</name></type> <name>cont</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>has_pubtruncate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ncols</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Publication %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>title</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>ncols</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"All tables"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Inserts"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Updates"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Deletes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>has_pubtruncate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Truncates"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>has_pubtruncate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printTableAddCell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>puballtables</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT n.nspname, c.relname\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_class c,\n"</literal>
							  <literal type="string">"     pg_catalog.pg_namespace n,\n"</literal>
							  <literal type="string">"     pg_catalog.pg_publication_rel pr\n"</literal>
							  <literal type="string">"WHERE c.relnamespace = n.oid\n"</literal>
							  <literal type="string">"  AND c.oid = pr.prrelid\n"</literal>
							  <literal type="string">"  AND pr.prpubid = '%s'\n"</literal>
							  <literal type="string">"ORDER BY 1,2"</literal></expr></argument>, <argument><expr><name>pubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tabres</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tabres</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printTableCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tables</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>tabres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>tables</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Tables:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>tables</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"    \"%s.%s\""</literal></expr></argument>,
								  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>tabres</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>tabres</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>printTableAddFooter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>tabres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>printTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printTableCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * \dRs
 * Describes subscriptions.
 *
 * Takes an optional regexp to select particular subscriptions
 */</comment>
<function><type><name>bool</name></type>
<name>describeSubscriptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>myopt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>translate_columns</name><index>[]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>,
	<expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sverbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The server (version %s) does not support subscriptions."</literal></expr></argument>,
					 <argument><expr><call><name>formatPGVersionNumber</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>sversion</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>sverbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sverbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT subname AS \"%s\"\n"</literal>
					  <literal type="string">",  pg_catalog.pg_get_userbyid(subowner) AS \"%s\"\n"</literal>
					  <literal type="string">",  subenabled AS \"%s\"\n"</literal>
					  <literal type="string">",  subpublications AS \"%s\"\n"</literal></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Owner"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enabled"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Publication"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">",  subsynccommit AS \"%s\"\n"</literal>
						  <literal type="string">",  subconninfo AS \"%s\"\n"</literal></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Synchronous commit"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Conninfo"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Only display subscriptions in current database. */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"FROM pg_catalog.pg_subscription\n"</literal>
						 <literal type="string">"WHERE subdbid = (SELECT oid\n"</literal>
						 <literal type="string">"                 FROM pg_catalog.pg_database\n"</literal>
						 <literal type="string">"                 WHERE datname = pg_catalog.current_database())"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"subname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>nullPrint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>title</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"List of subscriptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>translate_columns</name></name> <operator>=</operator> <name>translate_columns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myopt</name><operator>.</operator><name>n_translate_columns</name></name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>translate_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printQuery</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myopt</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * printACLColumn
 *
 * Helper function for consistently formatting ACL (privilege) columns.
 * The proper targetlist entry is appended to buf.  Note lack of any
 * whitespace or comma decoration.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printACLColumn</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.array_to_string(%s, E'\\n') AS \"%s\""</literal></expr></argument>,
						  <argument><expr><name>colname</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Access privileges"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_catalog.array_to_string(%s, '\\n') AS \"%s\""</literal></expr></argument>,
						  <argument><expr><name>colname</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Access privileges"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
