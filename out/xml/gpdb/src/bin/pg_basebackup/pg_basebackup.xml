<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/bin/pg_basebackup/pg_basebackup.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_basebackup.c - receive a base backup using streaming replication protocol
 *
 * Author: Magnus Hagander &lt;magnus@hagander.net&gt;
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		  src/bin/pg_basebackup/pg_basebackup.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/logging.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/recovery_gen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqexpbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"receivelog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/basebackup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"streamutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_DATA_CORRUPTED</name></cpp:macro>	<cpp:value>"XX001"</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>TablespaceListCell</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>TablespaceListCell</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>old_dir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>new_dir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>TablespaceListCell</name>;</typedef>

<typedef>typedef <type><struct>struct <name>TablespaceList</name>
<block>{
	<decl_stmt><decl><type><name>TablespaceListCell</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TablespaceListCell</name> <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>
}</block></struct></type> <name>TablespaceList</name>;</typedef>

<comment type="block">/*
 * pg_xlog has been renamed to pg_wal in version 10.  This version number
 * should be compared with PQserverVersion().
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINIMUM_VERSION_FOR_PG_WAL</name></cpp:macro>	<cpp:value>100000</cpp:value></cpp:define>

<comment type="block">/*
 * Temporary replication slots are supported from version 10.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINIMUM_VERSION_FOR_TEMP_SLOTS</name></cpp:macro> <cpp:value>100000</cpp:value></cpp:define>

<comment type="block">/*
 * Different ways to include WAL
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>NO_WAL</name></decl>,
	<decl><name>FETCH_WAL</name></decl>,
	<decl><name>STREAM_WAL</name></decl>
}</block></enum></type> <name>IncludeWal</name>;</typedef>

<comment type="block">/* Global options */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>basedir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TablespaceList</name></type> <name>tablespace_dirs</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog_dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name>format</name> <init>= <expr><literal type="char">'p'</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* p(lain)/t(ar) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><literal type="string">"pg_basebackup base backup"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>noclean</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>checksum_failure</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>showprogress</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>verbose</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>compresslevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>IncludeWal</name></type> <name>includewal</name> <init>= <expr><name>STREAM_WAL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>fastcheckpoint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>writerecoveryconf</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>do_sync</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>standby_message_timeout</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 10 sec = default */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pg_time_t</name></type> <name>last_progress_report</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int32</name></type> <name>maxrate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* no limit by default */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>replication_slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>temp_replication_slot</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>create_slot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>no_slot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>verify_checksums</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>success</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_new_pgdata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_existing_pgdata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_new_xlogdir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_existing_xlogdir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_tablespace_dirs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_tablespace_dirs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>forceoverwrite</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_EXCLUDE</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_exclude</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>excludes</name><index>[<expr><name>MAX_EXCLUDE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_exclude_from</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>excludefroms</name><index>[<expr><name>MAX_EXCLUDE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>target_gp_dbid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Progress counters */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>totalsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>totaldone</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>tablespacecount</name></decl>;</decl_stmt>

<comment type="block">/* Pipe to communicate with background wal receiver process */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name><name>bgpipe</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Handle to child process */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>bgchild</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>in_log_streamer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* End position for xlog streaming, empty string if unknown yet */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>xlogendptr</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>has_xlogendptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>LONG</name></type> <name>has_xlogendptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Contents of configuration file to be generated */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PQExpBuffer</name></type> <name>recoveryconfcontents</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Function headers */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>verify_dir_is_empty_or_create</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>created</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>progress_report</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tablespacenum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReceiveTarFile</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReceiveAndUnpackTarFile</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BaseBackup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>reached_end_position</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>segendpos</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>timeline</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>segment_finished</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_tablespace_mapping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tablespace_list_append</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WriteInternalConfFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup_directories_atexit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>success</name> <operator>||</operator> <name>in_log_streamer</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noclean</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>checksum_failure</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>made_new_pgdata</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"removing data directory \"%s\""</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"failed to remove data directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>found_existing_pgdata</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"removing contents of data directory \"%s\""</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"failed to remove contents of data directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>made_new_xlogdir</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"removing WAL directory \"%s\""</literal></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"failed to remove WAL directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>found_existing_xlogdir</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"removing contents of WAL directory \"%s\""</literal></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"failed to remove contents of WAL directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>made_new_pgdata</name> <operator>||</operator> <name>found_existing_pgdata</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>checksum_failure</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"data directory \"%s\" not removed at user's request"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>made_new_xlogdir</name> <operator>||</operator> <name>found_existing_xlogdir</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"WAL directory \"%s\" not removed at user's request"</literal></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>made_tablespace_dirs</name> <operator>||</operator> <name>found_tablespace_dirs</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>checksum_failure</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"changes to tablespace directories will not be undone"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>disconnect_atexit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<comment type="block">/*
 * On windows, our background thread dies along with the process. But on
 * Unix, if we have started a subprocess, we want to kill it off so it
 * doesn't remain running trying to stream data.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>kill_bgchild_atexit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>bgchild</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>bgchild</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Split argument into old_dir and new_dir and append to tablespace mapping
 * list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tablespace_list_append</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TablespaceListCell</name> <modifier>*</modifier></type><name>cell</name> <init>= <expr><operator>(</operator><name>TablespaceListCell</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TablespaceListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dst_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg_ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dst_ptr</name> <operator>=</operator> <name>dst</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>arg_ptr</name> <operator>=</operator> <name>arg</name></expr>;</init> <condition><expr><operator>*</operator><name>arg_ptr</name></expr>;</condition> <incr><expr><name>arg_ptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>dst_ptr</name> <operator>-</operator> <name>dst</name> <operator>&gt;=</operator> <name>MAXPGPATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"directory name too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg_ptr</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>arg_ptr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
			<empty_stmt>;</empty_stmt></block_content></block></if>					<comment type="block">/* skip backslash escaping = */</comment>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>arg_ptr</name> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>arg_ptr</name> <operator>==</operator> <name>arg</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name>arg_ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'\\'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"multiple \"=\" signs in tablespace mapping"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>dst_ptr</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>dst_ptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>arg_ptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name> <operator>||</operator> <operator>!</operator><operator>*</operator><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid tablespace mapping format \"%s\", must be \"OLDDIR=NEWDIR\""</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This check isn't absolutely necessary.  But all tablespaces are created
	 * with absolute directories, so specifying a non-absolute path here would
	 * just never match, possibly confusing users.  It's also good to be
	 * consistent with the new_dir check.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"old directory is not an absolute path in tablespace mapping: %s"</literal></expr></argument>,
					 <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"new directory is not an absolute path in tablespace mapping: %s"</literal></expr></argument>,
					 <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Comparisons done with these values should involve similarly
	 * canonicalized path values.  This is particularly sensitive on Windows
	 * where path values may not necessarily use Unix slashes.
	 */</comment>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tablespace_dirs</name><operator>.</operator><name>tail</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tablespace_dirs</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tablespace_dirs</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>tablespace_dirs</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_gz_error</name><parameter_list>(<parameter><decl><type><name>gzFile</name></type> <name>gzf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>errnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>gzerror</name><argument_list>(<argument><expr><name>gzf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errnum</name> <operator>==</operator> <name>Z_ERRNO</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>errmsg</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s takes a base backup of a running PostgreSQL server.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s [OPTION]...\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions controlling the output:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -D, --pgdata=DIRECTORY receive base backup into directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -F, --format=p|t       output format (plain (default), tar (Unsupported in GPDB))\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -r, --max-rate=RATE    maximum transfer rate to transfer data directory\n"</literal>
			 <literal type="string">"                         (in kB/s, or use suffix \"k\" or \"M\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -R, --write-recovery-conf\n"</literal>
			 <literal type="string">"                         write configuration for replication\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -T, --tablespace-mapping=OLDDIR=NEWDIR\n"</literal>
			 <literal type="string">"                         relocate tablespace in OLDDIR to NEWDIR\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --waldir=WALDIR    location for the write-ahead log directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -X, --wal-method=none|fetch|stream\n"</literal>
			 <literal type="string">"                         include required WAL files with specified method\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -z, --gzip             compress tar output\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -Z, --compress=0-9     compress tar output with given compression level\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --target-gp-dbid       create tablespace subdirectories with given dbid\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nGeneral options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -c, --checkpoint=fast|spread\n"</literal>
			 <literal type="string">"                         set fast or spread checkpointing\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -C, --create-slot      create replication slot\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -l, --label=LABEL      set backup label\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n, --no-clean         do not clean up after errors\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -N, --no-sync          do not wait for changes to be written safely to disk\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -P, --progress         show progress information\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -S, --slot=SLOTNAME    replication slot to use\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -v, --verbose          output verbose messages\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version          output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --no-slot          prevent creation of temporary replication slot\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --no-verify-checksums\n"</literal>
			 <literal type="string">"                         do not verify checksums\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help             show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nConnection options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -d, --dbname=CONNSTR   connection string\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -h, --host=HOSTNAME    database server host or socket directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -p, --port=PORT        database server port number\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s, --status-interval=INTERVAL\n"</literal>
			 <literal type="string">"                         time between status packets sent to server (in seconds)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -U, --username=NAME    connect as specified database user\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -w, --no-password      never prompt for password\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -W, --password         force password prompt (should happen automatically)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -E, --exclude          exclude path names\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --exclude-from=FILE\n"</literal>
			 <literal type="string">"                         get path names to exclude from FILE\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nReport bugs to &lt;bugs@greenplum.org&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Called in the background process every time data is received.
 * On Unix, we check to see if there is any data on our pipe
 * (which would mean we have a stop position), and if it is, check if
 * it is time to stop.
 * On Windows, we are in a single process, so we can just check if it's
 * time to stop.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>reached_end_position</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>segendpos</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>timeline</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>segment_finished</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_xlogendptr</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>fd_set</name></type>		<name>fds</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Don't have the end pointer yet - check our pipe to see if it has
		 * been sent yet.
		 */</comment>
		<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>bgpipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name><name>bgpipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogend</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>hi</name></decl>,
						<decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>bgpipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>xlogend</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not read from ready pipe: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not parse write-ahead log location \"%s\""</literal></expr></argument>,
							 <argument><expr><name>xlogend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>xlogendptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>has_xlogendptr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Fall through to check if we've reached the point further
			 * already.
			 */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * No data received on the pipe means we don't know the end
			 * position yet - so just say it's not time to stop yet.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

		<comment type="block">/*
		 * On win32, has_xlogendptr is set by the main thread, so if it's not
		 * set here, we just go back and wait until it shows up.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At this point we have an end pointer, so compare it to the current
	 * position to figure out if it's time to stop.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>segendpos</name> <operator>&gt;=</operator> <name>xlogendptr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Have end pointer, but haven't reached it yet - so tell the caller to
	 * keep streaming.
	 */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>bgconn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>startptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlog</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* directory or tarfile depending on mode */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sysidentifier</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>timeline</name></decl>;</decl_stmt>
}</block></struct></type> <name>logstreamer_param</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>LogStreamerMain</name><parameter_list>(<parameter><decl><type><name>logstreamer_param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StreamCtl</name></type>	<name>stream</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>in_log_streamer</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>startpos</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>startptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>timeline</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>timeline</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>sysidentifier</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>sysidentifier</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>stream_stop</name></name> <operator>=</operator> <name>reached_end_position</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>stop_socket</name></name> <operator>=</operator> <name><name>bgpipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>stop_socket</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>standby_message_timeout</name></name> <operator>=</operator> <name>standby_message_timeout</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>synchronous</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>do_sync</name></name> <operator>=</operator> <name>do_sync</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>mark_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>partial_suffix</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>replication_slot</name></name> <operator>=</operator> <name>replication_slot</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>walmethod</name></name> <operator>=</operator> <call><name>CreateWalDirectoryMethod</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>xlog</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>do_sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>walmethod</name></name> <operator>=</operator> <call><name>CreateWalTarMethod</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>xlog</name></name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr><name>do_sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReceiveXlogStream</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

		<comment type="block">/*
		 * Any errors will already have been reported in the function process,
		 * but we need to tell the parent that we didn't shutdown in a nice
		 * way.
		 */</comment>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>stream</name><operator>.</operator><name>walmethod</name><operator>-&gt;</operator><name>finish</name></name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not finish writing WAL files: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeWalDirectoryMethod</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeWalTarMethod</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>stream</name><operator>.</operator><name>walmethod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initiate background process for receiving xlog during the backup.
 * The background stream will use its own database connection so we can
 * stream the logfile in parallel with the backups.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartLogStreamer</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>startpos</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>timeline</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sysidentifier</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>logstreamer_param</name> <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hi</name></decl>,
				<decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>statusdir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>logstreamer_param</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>timeline</name></name> <operator>=</operator> <name>timeline</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>sysidentifier</name></name> <operator>=</operator> <name>sysidentifier</name></expr>;</expr_stmt>

	<comment type="block">/* Convert the starting position */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>startpos</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not parse write-ahead log location \"%s\""</literal></expr></argument>,
					 <argument><expr><name>startpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>startptr</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
	<comment type="block">/* Round off to even segment position */</comment>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>startptr</name></name> <operator>-=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>startptr</name></name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<comment type="block">/* Create our background pipe */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>bgpipe</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create pipe for background process: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Get a second connection */</comment>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name> <operator>=</operator> <call><name>GetConnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Error message already written in GetConnection() */</comment>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* In post-10 cluster, pg_xlog has been renamed to pg_wal */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>xlog</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>xlog</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
			 <argument><expr><name>basedir</name></expr></argument>,
			 <argument><expr><ternary><condition><expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MINIMUM_VERSION_FOR_PG_WAL</name></expr> ?</condition><then>
			 <expr><literal type="string">"pg_xlog"</literal></expr> </then><else>: <expr><literal type="string">"pg_wal"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Temporary replication slots are only supported in 10 and newer */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MINIMUM_VERSION_FOR_TEMP_SLOTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>temp_replication_slot</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create replication slot if requested
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>temp_replication_slot</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>replication_slot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>replication_slot</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"pg_basebackup_%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>PQbackendPID</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>temp_replication_slot</name> <operator>||</operator> <name>create_slot</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateReplicationSlot</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name></expr></argument>, <argument><expr><name>replication_slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>temp_replication_slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>temp_replication_slot</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"created temporary replication slot \"%s\""</literal></expr></argument>,
							<argument><expr><name>replication_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"created replication slot \"%s\""</literal></expr></argument>,
							<argument><expr><name>replication_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Create pg_wal/archive_status or pg_xlog/archive_status (and thus
		 * pg_wal or pg_xlog) depending on the target server so we can write
		 * to basedir/pg_wal or basedir/pg_xlog as the directory entry in the
		 * tar file may arrive later.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>statusdir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>statusdir</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s/archive_status"</literal></expr></argument>,
				 <argument><expr><name>basedir</name></expr></argument>,
				 <argument><expr><ternary><condition><expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MINIMUM_VERSION_FOR_PG_WAL</name></expr> ?</condition><then>
				 <expr><literal type="string">"pg_xlog"</literal></expr> </then><else>: <expr><literal type="string">"pg_wal"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_mkdir_p</name><argument_list>(<argument><expr><name>statusdir</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EEXIST</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>statusdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Start a child process and tell it to start streaming. On Unix, this is
	 * a fork(). On Windows, we create a thread.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>bgchild</name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bgchild</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* in child process */</comment>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><call><name>LogStreamerMain</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>bgchild</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create background process: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Else we are in the parent process and all is well.
	 */</comment>
	<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>kill_bgchild_atexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
	<expr_stmt><expr><name>bgchild</name> <operator>=</operator> <call><name>_beginthreadex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>LogStreamerMain</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bgchild</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create background thread: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that the given directory exists and is empty. If it does not
 * exist, it is created. If it exists but is not empty, an error will
 * be given and the process ended.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verify_dir_is_empty_or_create</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>created</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>pg_check_dir</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>

			<comment type="block">/*
			 * Does not exist, so create
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pg_mkdir_p</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>created</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>created</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		<case>case <expr><literal type="number">1</literal></expr>:</case>

			<comment type="block">/*
			 * Exists, empty
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
		<case>case <expr><literal type="number">4</literal></expr>:</case>

			<comment type="block">/*
			 * Exists, not empty
			 *
			 * In GPDB, we may force pg_basebackup to continue even if the
			 * directory already exists. This is needed to preserve important
			 * things that should not be deleted such as pg_log files if we
			 * are doing segment recovery.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>forceoverwrite</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"directory \"%s\" exists but is not empty"</literal></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>

			<comment type="block">/*
			 * Access problem
			 */</comment>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not access directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * Print a progress report based on the global variables. If verbose output
 * is enabled, also print the current file name.
 *
 * Progress report is written at maximum once per second, unless the
 * force parameter is set to true.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>progress_report</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tablespacenum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>percent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>totaldone_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>totalsize_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>now</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showprogress</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>now</name> <operator>==</operator> <name>last_progress_report</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>force</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* Max once per second */</comment>

	<expr_stmt><expr><name>last_progress_report</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>percent</name> <operator>=</operator> <ternary><condition><expr><name>totalsize</name></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>totaldone</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>/</operator> <name>totalsize</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid overflowing past 100% or the full size. This may make the total
	 * size number change as we approach the end of the backup (the estimate
	 * will always be wrong if WAL is included), but that's better than having
	 * the done column be bigger than the total.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>percent</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>percent</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>totaldone</name> <operator>/</operator> <literal type="number">1024</literal> <operator>&gt;</operator> <name>totalsize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>totalsize</name> <operator>=</operator> <name>totaldone</name> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Separate step to keep platform-dependent format code out of
	 * translatable strings.  And we only test for INT64_FORMAT availability
	 * in snprintf, not fprintf.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>totaldone_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>totaldone_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>,
			 <argument><expr><name>totaldone</name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>totalsize_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>totalsize_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>totalsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERBOSE_FILENAME_LENGTH</name></cpp:macro> <cpp:value>35</cpp:value></cpp:define>
	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>filename</name></expr>)</condition><block type="pseudo"><block_content>

			<comment type="block">/*
			 * No filename given, so clear the status line (used for last
			 * call)
			 */</comment>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%*s/%s kB (100%%), %d/%d tablespace %*s"</literal></expr></argument>,
							 <argument><expr><literal type="string">"%*s/%s kB (100%%), %d/%d tablespaces %*s"</literal></expr></argument>,
							 <argument><expr><name>tablespacecount</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>totalsize_str</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>totaldone_str</name></expr></argument>, <argument><expr><name>totalsize_str</name></expr></argument>,
					<argument><expr><name>tablespacenum</name></expr></argument>, <argument><expr><name>tablespacecount</name></expr></argument>,
					<argument><expr><name>VERBOSE_FILENAME_LENGTH</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>truncate</name> <init>= <expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>VERBOSE_FILENAME_LENGTH</name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%*s/%s kB (%d%%), %d/%d tablespace (%s%-*.*s)"</literal></expr></argument>,
							 <argument><expr><literal type="string">"%*s/%s kB (%d%%), %d/%d tablespaces (%s%-*.*s)"</literal></expr></argument>,
							 <argument><expr><name>tablespacecount</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>totalsize_str</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>totaldone_str</name></expr></argument>, <argument><expr><name>totalsize_str</name></expr></argument>, <argument><expr><name>percent</name></expr></argument>,
					<argument><expr><name>tablespacenum</name></expr></argument>, <argument><expr><name>tablespacecount</name></expr></argument>,
			<comment type="block">/* Prefix with "..." if we do leading truncation */</comment>
					<argument><expr><ternary><condition><expr><name>truncate</name></expr> ?</condition><then> <expr><literal type="string">"..."</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					<argument><expr><ternary><condition><expr><name>truncate</name></expr> ?</condition><then> <expr><name>VERBOSE_FILENAME_LENGTH</name> <operator>-</operator> <literal type="number">3</literal></expr> </then><else>: <expr><name>VERBOSE_FILENAME_LENGTH</name></expr></else></ternary></expr></argument>,
					<argument><expr><ternary><condition><expr><name>truncate</name></expr> ?</condition><then> <expr><name>VERBOSE_FILENAME_LENGTH</name> <operator>-</operator> <literal type="number">3</literal></expr> </then><else>: <expr><name>VERBOSE_FILENAME_LENGTH</name></expr></else></ternary></expr></argument>,
			<comment type="block">/* Truncate filename at beginning if it's too long */</comment>
					<argument><expr><ternary><condition><expr><name>truncate</name></expr> ?</condition><then> <expr><name>filename</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VERBOSE_FILENAME_LENGTH</name> <operator>+</operator> <literal type="number">3</literal></expr> </then><else>: <expr><name>filename</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%*s/%s kB (%d%%), %d/%d tablespace"</literal></expr></argument>,
						 <argument><expr><literal type="string">"%*s/%s kB (%d%%), %d/%d tablespaces"</literal></expr></argument>,
						 <argument><expr><name>tablespacecount</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>totalsize_str</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>totaldone_str</name></expr></argument>, <argument><expr><name>totalsize_str</name></expr></argument>, <argument><expr><name>percent</name></expr></argument>,
				<argument><expr><name>tablespacenum</name></expr></argument>, <argument><expr><name>tablespacecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32</name></type>
<name>parse_max_rate</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>after_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>suffix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>after_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>after_num</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"transfer rate \"%s\" is not a valid value"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid transfer rate \"%s\": %m"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Reject obviously wrong values here.
		 */</comment>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"transfer rate must be greater than zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Evaluate suffix, after skipping over possible whitespace. Lack of
	 * suffix means kilobytes.
	 */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>after_num</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>after_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>after_num</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>after_num</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>suffix</name> <operator>=</operator> <name>after_num</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>after_num</name> <operator>==</operator> <literal type="char">'k'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* kilobyte is the expected unit. */</comment>
			<expr_stmt><expr><name>after_num</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>after_num</name> <operator>==</operator> <literal type="char">'M'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>after_num</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>*=</operator> <literal type="number">1024.0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The rest can only consist of white space. */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>after_num</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>after_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>after_num</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>after_num</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid --max-rate unit: \"%s\""</literal></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Valid integer? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>result</name> <operator>!=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>uint32</name><operator>)</operator> <name>result</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"transfer rate \"%s\" exceeds integer range"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The range is checked on the server side too, but avoid the server
	 * connection if a nonsensical value was passed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name> <argument_list type="generic">&lt; <argument><expr><name>MAX_RATE_LOWER</name> <operator>||</operator> <name>result</name></expr></argument> &gt;</argument_list></name> <name>MAX_RATE_UPPER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"transfer rate \"%s\" is out of range"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>int32</name><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a piece of tar data
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>writeTarData</name><parameter_list>(
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
			 <parameter><decl><type><name>gzFile</name></type> <name>ztarfile</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			 <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>tarfile</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>current_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>ztarfile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>gzwrite</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>r</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not write to compressed file \"%s\": %s"</literal></expr></argument>,
						 <argument><expr><name>current_file</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tarfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>current_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_TAR_DATA</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>writeTarData(ztarfile, tarfile, buf, sz, filename)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_TAR_DATA</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>writeTarData(tarfile, buf, sz, filename)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Receive a tar format file from the connection to the server, and write
 * the data from this file directly into a tar file. If compression is
 * enabled, the data will be compressed while written to the file.
 *
 * The file will be named base.tar[.gz] if it's for the main data directory
 * or &lt;tablespaceoid&gt;.tar[.gz] if it's for another tablespace.
 *
 * No attempt to inspect or validate the contents of the file is done.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReceiveTarFile</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copybuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>tarfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tarhdr</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>basetablespace</name> <init>= <expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_tarhdr</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skip_file</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_recovery_guc_supported</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_postgresql_auto_conf</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_postgresql_auto_conf</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>file_padding_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>tarhdrsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>filesz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
	<decl_stmt><decl><type><name>gzFile</name></type>		<name>ztarfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* recovery.conf is integrated into postgresql.conf in 12 and newer */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MINIMUM_VERSION_FOR_RECOVERY_GUC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>is_recovery_guc_supported</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>basetablespace</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Base tablespaces
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
			<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ztarfile</name> <operator>=</operator> <call><name>gzdopen</name><argument_list>(<argument><expr><call><name>dup</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>gzsetparams</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>,
								<argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not set compression level %d: %s"</literal></expr></argument>,
								 <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>tarfile</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/base.tar.gz"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ztarfile</name> <operator>=</operator> <call><name>gzopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>gzsetparams</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>,
								<argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not set compression level %d: %s"</literal></expr></argument>,
								 <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/base.tar"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tarfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Specific tablespace
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s.tar.gz"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>,
					 <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ztarfile</name> <operator>=</operator> <call><name>gzopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>gzsetparams</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>,
							<argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not set compression level %d: %s"</literal></expr></argument>,
							 <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s.tar"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>,
					 <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tarfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ztarfile</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Compression is in use */</comment>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create compressed file \"%s\": %s"</literal></expr></argument>,
						 <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<comment type="block">/* Either no zlib support, or zlib support but compresslevel = 0 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tarfile</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Get the COPY data stream
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not get COPY data stream: %s"</literal></expr></argument>,
					 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>copybuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copybuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * End of chunk. If requested, and this is the base tablespace,
			 * write configuration file into the tarfile. When done, close the
			 * file (but not stdout).
			 *
			 * Also, write two completely empty blocks at the end of the tar
			 * file, as required by some tar programs.
			 */</comment>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>zerobuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zerobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>basetablespace</name> <operator>&amp;&amp;</operator> <name>writerecoveryconf</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>header</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If postgresql.auto.conf has not been found in the streamed
				 * data, add recovery configuration to postgresql.auto.conf if
				 * recovery parameters are GUCs.  If the instance connected to
				 * is older than 12, create recovery.conf with this data
				 * otherwise.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_postgresql_auto_conf</name> <operator>||</operator> <operator>!</operator><name>is_recovery_guc_supported</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>padding</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>tarCreateHeader</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
									<argument><expr><ternary><condition><expr><name>is_recovery_guc_supported</name></expr> ?</condition><then> <expr><literal type="string">"postgresql.auto.conf"</literal></expr> </then><else>: <expr><literal type="string">"recovery.conf"</literal></expr></else></ternary></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
									<argument><expr><name>pg_file_create_mode</name></expr></argument>, <argument><expr><literal type="number">04000</literal></expr></argument>, <argument><expr><literal type="number">02000</literal></expr></argument>,
									<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>padding</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">511</literal><operator>)</operator> <operator>-</operator> <name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								   <argument><expr><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>padding</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><name>padding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * standby.signal is supported only if recovery parameters are
				 * GUCs.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_recovery_guc_supported</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>tarCreateHeader</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"standby.signal"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* zero-length file */</comment>
									<argument><expr><name>pg_file_create_mode</name></expr></argument>, <argument><expr><literal type="number">04000</literal></expr></argument>, <argument><expr><literal type="number">02000</literal></expr></argument>,
									<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><literal type="number">511</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* 2 * 512 bytes empty data at end of file */</comment>
			<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zerobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>ztarfile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>gzclose</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not close compressed file \"%s\": %s"</literal></expr></argument>,
								 <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>tarfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>,
									 <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not read COPY data: %s"</literal></expr></argument>,
						 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>writerecoveryconf</name> <operator>||</operator> <operator>!</operator><name>basetablespace</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When not writing config file, or when not working on the base
			 * tablespace, we never have to look for an existing configuration
			 * file in the stream.
			 */</comment>
			<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Look for a config file in the existing tar stream. If it's
			 * there, we must skip it so we can later overwrite it with our
			 * own version of the file.
			 *
			 * To do this, we have to process the individual files inside the
			 * TAR stream. The stream consists of a header and zero or more
			 * chunks, all 512 bytes long. The stream from the server is
			 * broken up into smaller pieces, so we have to track the size of
			 * the files to find the next header structure.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>rr</name> <init>= <expr><name>r</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>rr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>in_tarhdr</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We're currently reading a header structure inside the
					 * TAR stream, i.e. the file metadata.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>tarhdrsz</name> <operator>&lt;</operator> <literal type="number">512</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Copy the header structure into tarhdr in case the
						 * header is not aligned to 512 bytes or it's not
						 * returned in whole by the last PQgetCopyData call.
						 */</comment>
						<decl_stmt><decl><type><name>int</name></type>			<name>hdrleft</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>bytes2copy</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>hdrleft</name> <operator>=</operator> <literal type="number">512</literal> <operator>-</operator> <name>tarhdrsz</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>bytes2copy</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>rr</name> <operator>&gt;</operator> <name>hdrleft</name></expr> ?</condition><then> <expr><name>hdrleft</name></expr> </then><else>: <expr><name>rr</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><name>tarhdrsz</name></expr>]</index></name></expr></argument>, <argument><expr><name>copybuf</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>bytes2copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>rr</name> <operator>-=</operator> <name>bytes2copy</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>bytes2copy</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>tarhdrsz</name> <operator>+=</operator> <name>bytes2copy</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * We have the complete header structure in tarhdr,
						 * look at the file metadata: we may want append
						 * recovery info into postgresql.auto.conf and skip
						 * standby.signal file if recovery parameters are
						 * integrated as GUCs, and recovery.conf otherwise. In
						 * both cases we must calculate tar padding.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>is_recovery_guc_supported</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>skip_file</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"standby.signal"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
							<expr_stmt><expr><name>is_postgresql_auto_conf</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"postgresql.auto.conf"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>skip_file</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"recovery.conf"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

						<expr_stmt><expr><name>filesz</name> <operator>=</operator> <call><name>read_tar_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">124</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>file_padding_len</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>filesz</name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">511</literal><operator>)</operator> <operator>-</operator> <name>filesz</name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>is_recovery_guc_supported</name> <operator>&amp;&amp;</operator>
							<name>is_postgresql_auto_conf</name> <operator>&amp;&amp;</operator>
							<name>writerecoveryconf</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* replace tar header */</comment>
							<decl_stmt><decl><type><name>char</name></type>		<name><name>header</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>tarCreateHeader</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"postgresql.auto.conf"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name>filesz</name> <operator>+</operator> <name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
											<argument><expr><name>pg_file_create_mode</name></expr></argument>, <argument><expr><literal type="number">04000</literal></expr></argument>, <argument><expr><literal type="number">02000</literal></expr></argument>,
											<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* copy stream with padding */</comment>
							<expr_stmt><expr><name>filesz</name> <operator>+=</operator> <name>file_padding_len</name></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_file</name></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/*
								 * If we're not skipping the file, write the
								 * tar header unmodified.
								 */</comment>
								<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>tarhdr</name></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></else></if_stmt>

						<comment type="block">/* Next part is the file, not the header */</comment>
						<expr_stmt><expr><name>in_tarhdr</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * We're processing a file's contents.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>filesz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * We still have data to read (and possibly write).
						 */</comment>
						<decl_stmt><decl><type><name>int</name></type>			<name>bytes2write</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>bytes2write</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>filesz</name> <operator>&gt;</operator> <name>rr</name></expr> ?</condition><then> <expr><name>rr</name></expr> </then><else>: <expr><name>filesz</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_file</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>copybuf</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>bytes2write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>rr</name> <operator>-=</operator> <name>bytes2write</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>bytes2write</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>filesz</name> <operator>-=</operator> <name>bytes2write</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>is_recovery_guc_supported</name> <operator>&amp;&amp;</operator>
							 <name>is_postgresql_auto_conf</name> <operator>&amp;&amp;</operator>
							 <name>writerecoveryconf</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* append recovery config to postgresql.auto.conf */</comment>
						<decl_stmt><decl><type><name>int</name></type>			<name>padding</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>tailsize</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>tailsize</name> <operator>=</operator> <operator>(</operator><literal type="number">512</literal> <operator>-</operator> <name>file_padding_len</name><operator>)</operator> <operator>+</operator> <name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>padding</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>tailsize</name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">511</literal><operator>)</operator> <operator>-</operator> <name>tailsize</name></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>padding</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>char</name></type>		<name><name>zerobuf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zerobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><name>padding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/* skip original file padding */</comment>
						<expr_stmt><expr><name>is_postgresql_auto_conf</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>skip_file</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>filesz</name> <operator>+=</operator> <name>file_padding_len</name></expr>;</expr_stmt>

						<expr_stmt><expr><name>found_postgresql_auto_conf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * No more data in the current file, the next piece of
						 * data (if any) will be a new file header structure.
						 */</comment>
						<expr_stmt><expr><name>in_tarhdr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>skip_file</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>is_postgresql_auto_conf</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>tarhdrsz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>filesz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>totaldone</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>progress_report</name><argument_list>(<argument><expr><name>rownum</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>							<comment type="block">/* while (1) */</comment>
	<expr_stmt><expr><call><name>progress_report</name><argument_list>(<argument><expr><name>rownum</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* sync the resulting tar file, errors are not considered fatal */</comment>
	<if_stmt><if>if <condition>(<expr><name>do_sync</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fsync_fname</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Retrieve tablespace path, either relocated or original depending on whether
 * -T was passed or not.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_tablespace_mapping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TablespaceListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>canon_dir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Canonicalize path for comparison consistency */</comment>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>canon_dir</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>canon_dir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>canon_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>tablespace_dirs</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>canon_dir</name></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><name>dir</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Receive a tar format stream from the connection to the server, and unpack
 * the contents of it into a directory. Only files, directories and
 * symlinks are supported, no other kinds of special files.
 *
 * If the data is for the main data directory, it will be restored in the
 * specified directory. If it's for another tablespace, it will be restored
 * in the original or mapped directory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReceiveAndUnpackTarFile</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>current_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>gp_tablespace_filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mapped_tblspc_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>current_len_left</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>current_padding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>basetablespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copybuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>basetablespace</name> <operator>=</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>basetablespace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>current_path</name></expr></argument>, <argument><expr><name>basedir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>current_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>current_path</name></expr></argument>,
				<argument><expr><call><name>get_tablespace_mapping</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>current_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>target_gp_dbid</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"cannot restore user-defined tablespaces without the --target-gp-dbid option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		
		<comment type="block">/* 
		 * Construct the new tablespace path using the given target gp dbid
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>gp_tablespace_filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%d/%s"</literal></expr></argument>,
				<argument><expr><name>current_path</name></expr></argument>,
				<argument><expr><name>target_gp_dbid</name></expr></argument>,
				<argument><expr><name>GP_TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Get the COPY data
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not get COPY data stream: %s"</literal></expr></argument>,
					 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>copybuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copybuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * End of chunk
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>file</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not read COPY data: %s"</literal></expr></argument>,
						 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>filemode</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * No current file, so this must be the header for a new file
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">512</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid tar block header size: %d"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>totaldone</name> <operator>+=</operator> <literal type="number">512</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>current_len_left</name> <operator>=</operator> <call><name>read_tar_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copybuf</name><index>[<expr><literal type="number">124</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Set permissions on the file */</comment>
			<expr_stmt><expr><name>filemode</name> <operator>=</operator> <call><name>read_tar_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copybuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * All files are padded up to 512 bytes
			 */</comment>
			<expr_stmt><expr><name>current_padding</name> <operator>=</operator>
				<operator>(</operator><operator>(</operator><name>current_len_left</name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">511</literal><operator>)</operator> <operator>-</operator> <name>current_len_left</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * First part of header is zero terminated filename
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>basetablespace</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Append relfile path to --target-gp-dbid tablespace path.
				 *
				 * For example, copybuf can be
				 * "&lt;GP_TABLESPACE_VERSION_DIRECTORY&gt;_db&lt;dbid&gt;/16384/16385".
				 * We create a pointer to the dbid and relfile "/16384/16385",
				 * construct the new tablespace with provided dbid, and append
				 * the dbid and relfile on top.
				 */</comment>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>copybuf_dbid_relfile</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
						 <argument><expr><name>gp_tablespace_filename</name></expr></argument>,
						 <argument><expr><name>copybuf_dbid_relfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>current_path</name></expr></argument>,
						 <argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>filename</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Ends in a slash means directory or symlink to directory
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>copybuf</name><index>[<expr><literal type="number">156</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'5'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Directory
					 */</comment>
					<expr_stmt><expr><name><name>filename</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* Remove trailing slash */</comment>

					<comment type="block">/*
					 * Since the forceoverwrite flag is being used, the
					 * directories still exist. Remove them so that
					 * pg_basebackup can create them. Skip when we detect
					 * pg_log because we want to retain its contents.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>forceoverwrite</name> <operator>&amp;&amp;</operator> <call><name>pg_check_dir</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * We want to retain the contents of pg_log. And for
						 * pg_xlog we assume is deleted at the start of
						 * pg_basebackup. We cannot delete pg_xlog because if
						 * streammode was used then it may have already copied
						 * new xlog files into pg_xlog directory.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>pg_str_endswith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"/pg_log"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
							<call><name>pg_str_endswith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"/log"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
							<call><name>pg_str_endswith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"/pg_wal"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
							<call><name>pg_str_endswith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"/pg_xlog"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>

						<expr_stmt><expr><call><name>rmtree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					</block_content>}</block></if></if_stmt>

					<decl_stmt><decl><type><name>bool</name></type> <name>is_gp_tablespace_directory</name> <init>= <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>gp_tablespace_filename</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>is_gp_tablespace_directory</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forceoverwrite</name></expr>)</condition> <block>{<block_content>
						<comment type="block">/*
						 * This directory has already been created during beginning of BaseBackup().
						 */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * When streaming WAL, pg_wal (or pg_xlog for pre-9.6
						 * clusters) will have been created by the wal
						 * receiver process. Also, when the WAL directory
						 * location was specified, pg_wal (or pg_xlog) has
						 * already been created as a symbolic link before
						 * starting the actual backup. So just ignore creation
						 * failures on related directories.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><call><name>pg_str_endswith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"/pg_wal"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
							   <call><name>pg_str_endswith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"/pg_xlog"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
							   <call><name>pg_str_endswith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"/archive_status"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
							  <name>errno</name> <operator>==</operator> <name>EEXIST</name><operator>)</operator></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": %m"</literal></expr></argument>,
										 <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
					<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>(</operator><name>mode_t</name><operator>)</operator> <name>filemode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not set permissions on directory \"%s\": %m"</literal></expr></argument>,
									 <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>copybuf</name><index>[<expr><literal type="number">156</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'2'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Symbolic link
					 *
					 * It's most likely a link in pg_tblspc directory, to the
					 * location of a tablespace. Apply any tablespace mapping
					 * given on the command line (--tablespace-mapping). (We
					 * blindly apply the mapping without checking that the
					 * link really is inside pg_tblspc. We don't expect there
					 * to be other symlinks in a data directory, but if there
					 * are, you can call it an undocumented feature that you
					 * can map them too.)
					 */</comment>
					<expr_stmt><expr><name><name>filename</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* Remove trailing slash */</comment>

					<expr_stmt><expr><name>mapped_tblspc_path</name> <operator>=</operator> <call><name>get_tablespace_mapping</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copybuf</name><index>[<expr><literal type="number">157</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mapped_tblspc_path_with_dbid</name> <init>= <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%d"</literal></expr></argument>, <argument><expr><name>mapped_tblspc_path</name></expr></argument>, <argument><expr><name>target_gp_dbid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>symlink</name><argument_list>(<argument><expr><name>mapped_tblspc_path_with_dbid</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create symbolic link from \"%s\" to \"%s\": %m"</literal></expr></argument>,
									 <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mapped_tblspc_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mapped_tblspc_path_with_dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"unrecognized link indicator \"%c\""</literal></expr></argument>,
								 <argument><expr><name><name>copybuf</name><index>[<expr><literal type="number">156</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<continue>continue;</continue>		<comment type="block">/* directory or link handled */</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * regular file
			 *
			 * In GPDB, we may need to remove the file first if we are forcing
			 * an overwrite instead of starting with a blank directory. Some
			 * files may have had their permissions changed to read only.
			 * Remove the file instead of literally overwriting them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>forceoverwrite</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>remove</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>file</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
			<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>(</operator><name>mode_t</name><operator>)</operator> <name>filemode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not set permissions on file \"%s\": %m"</literal></expr></argument>,
							 <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<if_stmt><if>if <condition>(<expr><name>current_len_left</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Done with this file, next one will be a new tar header
				 */</comment>
				<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>						<comment type="block">/* new file */</comment>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Continuing blocks in existing file
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>current_len_left</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>r</name> <operator>==</operator> <name>current_padding</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Received the padding block for this file, ignore it and
				 * close the file, then move on to the next tar header.
				 */</comment>
				<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>totaldone</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>totaldone</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>progress_report</name><argument_list>(<argument><expr><name>rownum</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>current_len_left</name> <operator>-=</operator> <name>r</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>current_len_left</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>current_padding</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Received the last block, and there is no padding to be
				 * expected. Close the file and move on to the next tar
				 * header.
				 */</comment>
				<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>						<comment type="block">/* continuing data in existing file */</comment>
	</block_content>}</block></while>							<comment type="block">/* loop over all data blocks */</comment>
	<expr_stmt><expr><call><name>progress_report</name><argument_list>(<argument><expr><name>rownum</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"COPY stream ended before last file was finished"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>basetablespace</name> <operator>&amp;&amp;</operator> <name>writerecoveryconf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WriteRecoveryConfig</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>recoveryconfcontents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>basetablespace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WriteInternalConfFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No data is synced here, everything is done for all tablespaces at the
	 * end.
	 */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_to_exclude_list</name><parameter_list>(<parameter><decl><type><name>PQExpBufferData</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>exclude</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>quoted</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>error</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>error</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>PQescapeStringConn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>, <argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>error</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not process exclude \"%s\": %s"</literal></expr></argument>,
					 <argument><expr><name>exclude</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" EXCLUDE '%s'"</literal></expr></argument>, <argument><expr><name>quoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>build_exclude_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type>	<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_exclude</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>num_exclude_from</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_exclude</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>add_to_exclude_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>excludes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_exclude_from</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><name><name>excludefroms</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>str</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not open exclude-from file \"%s\": %m"</literal></expr></argument>,
						 <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Each line contains a pathname to exclude.
		 *
		 * We must use fgets() instead of fscanf("%s") to correctly handle the
		 * spaces in the filenames.
		 */</comment>
		<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Remove all trailing \r and \n */</comment>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</init>
				 <condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>str</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <name><name>str</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator></expr>;</condition>
				 <incr><expr><name>len</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>str</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></for>

			<expr_stmt><expr><call><name>add_to_exclude_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>BaseBackup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sysidentifier</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>latesttli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>starttli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>basebkp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>escaped_label</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>maxrate_clause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogstart</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogend</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>minServerMajor</name></decl>,
				<decl><type ref="prev"/><name>maxServerMajor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> 	   <modifier>*</modifier></type><name>exclude_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serverVersion</name></decl>,
				<decl><type ref="prev"/><name>serverMajor</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check server version. BASE_BACKUP command was introduced in 9.1, so we
	 * can't work with servers older than 9.1.
	 */</comment>
	<expr_stmt><expr><name>minServerMajor</name> <operator>=</operator> <literal type="number">901</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxServerMajor</name> <operator>=</operator> <name>PG_VERSION_NUM</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>serverVersion</name> <operator>=</operator> <call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>serverMajor</name> <operator>=</operator> <name>serverVersion</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>serverMajor</name> <argument_list type="generic">&lt; <argument><expr><name>minServerMajor</name> <operator>||</operator> <name>serverMajor</name></expr></argument> &gt;</argument_list></name> <name>maxServerMajor</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>serverver</name> <init>= <expr><call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"server_version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"incompatible server version %s"</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>serverver</name></expr> ?</condition><then> <expr><name>serverver</name></expr> </then><else>: <expr><literal type="string">"'unknown'"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If WAL streaming was requested, also check that the server is new
	 * enough for that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>includewal</name> <operator>==</operator> <name>STREAM_WAL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CheckServerVersionForStreaming</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Error message already written in CheckServerVersionForStreaming(),
		 * but add a hint about using -X none.
		 */</comment>
		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"HINT: use -X none or -X fetch to disable log streaming"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build contents of configuration file if requested
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>writerecoveryconf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recoveryconfcontents</name> <operator>=</operator> <call><name>GenerateRecoveryConfig</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>replication_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Run IDENTIFY_SYSTEM so we can get the timeline
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RunIdentifySystem</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sysidentifier</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>latesttli</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start the actual backup
	 */</comment>
	<expr_stmt><expr><call><name>PQescapeStringConn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>escaped_label</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>escaped_label</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>maxrate</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxrate_clause</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"MAX_RATE %u"</literal></expr></argument>, <argument><expr><name>maxrate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>exclude_list</name> <operator>=</operator> <call><name>build_exclude_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"initiating base backup, waiting for checkpoint to complete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showprogress</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"waiting for checkpoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>basebkp</name> <operator>=</operator>
		<call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"BASE_BACKUP LABEL '%s' %s %s %s %s %s %s %s %s"</literal></expr></argument>,
				 <argument><expr><name>escaped_label</name></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>showprogress</name></expr> ?</condition><then> <expr><literal type="string">"PROGRESS"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>includewal</name> <operator>==</operator> <name>FETCH_WAL</name></expr> ?</condition><then> <expr><literal type="string">"WAL"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>fastcheckpoint</name></expr> ?</condition><then> <expr><literal type="string">"FAST"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>includewal</name> <operator>==</operator> <name>NO_WAL</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"NOWAIT"</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>maxrate_clause</name></expr> ?</condition><then> <expr><name>maxrate_clause</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal></expr> ?</condition><then> <expr><literal type="string">"TABLESPACE_MAP"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>verify_checksums</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"NOVERIFY_CHECKSUMS"</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name>exclude_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>exclude_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>exclude_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>basebkp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not send replication command \"%s\": %s"</literal></expr></argument>,
					 <argument><expr><literal type="string">"BASE_BACKUP"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the starting WAL location
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not initiate base backup: %s"</literal></expr></argument>,
					 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"server returned unexpected response to BASE_BACKUP command; got %d rows and %d fields, expected %d rows and %d fields"</literal></expr></argument>,
					 <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>xlogstart</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlogstart</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"checkpoint completed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 9.3 and later sends the TLI of the starting point. With older servers,
	 * assume it's the same as the latest timeline reported by
	 * IDENTIFY_SYSTEM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>starttli</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>starttli</name> <operator>=</operator> <name>latesttli</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name>includewal</name> <operator>!=</operator> <name>NO_WAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"write-ahead log start point: %s on timeline %u"</literal></expr></argument>,
					<argument><expr><name>xlogstart</name></expr></argument>, <argument><expr><name>starttli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the header
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not get backup header: %s"</literal></expr></argument>,
					 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"no data returned from server"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Sum up the total size, for progress reporting
	 */</comment>
	<expr_stmt><expr><name>totalsize</name> <operator>=</operator> <name>totaldone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>tablespacecount</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <call><name>atol</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Verify tablespace directories are empty. Don't bother with the
		 * first once since it can be relocated, and it will be checked before
		 * we do anything anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><call><name>get_tablespace_mapping</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name><name>path_with_subdir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path_with_subdir</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%d/%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>target_gp_dbid</name></expr></argument>, <argument><expr><name>GP_TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>verify_dir_is_empty_or_create</name><argument_list>(<argument><expr><name>path_with_subdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>made_tablespace_dirs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_tablespace_dirs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * When writing to stdout, require a single tablespace
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"can only write single tablespace to stdout, database has %d"</literal></expr></argument>,
					 <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In the case of forceoverwrite the base directory may already exist. In
	 * this case we need to wipeout the old pg_xlog directory. This is done
	 * before StartLogStreamer and ReceiveAndUnpackTarFile so that either can
	 * create pg_xlog directory and begin populating new contents to it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>forceoverwrite</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>xlog_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>xlog_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>,
			<argument><expr><ternary><condition><expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MINIMUM_VERSION_FOR_PG_WAL</name></expr> ?</condition><then> <expr><literal type="string">"pg_xlog"</literal></expr> </then><else>: <expr><literal type="string">"pg_wal"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_check_dir</name><argument_list>(<argument><expr><name>xlog_path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>rmtree</name><argument_list>(<argument><expr><name>xlog_path</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're streaming WAL, start the streaming session before we start
	 * receiving the actual data chunks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>includewal</name> <operator>==</operator> <name>STREAM_WAL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"starting background WAL receiver"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>StartLogStreamer</name><argument_list>(<argument><expr><name>xlogstart</name></expr></argument>, <argument><expr><name>starttli</name></expr></argument>, <argument><expr><name>sysidentifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Start receiving chunks
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReceiveTarFile</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReceiveAndUnpackTarFile</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>							<comment type="block">/* Loop over all tablespaces */</comment>

	<if_stmt><if>if <condition>(<expr><name>showprogress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>progress_report</name><argument_list>(<argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* Need to move to next line */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the stop position
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not get write-ahead log end position from server: %s"</literal></expr></argument>,
					 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"no write-ahead log end position returned from server"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name>includewal</name> <operator>!=</operator> <name>NO_WAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"write-ahead log end point: %s"</literal></expr></argument>, <argument><expr><name>xlogend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlstate</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sqlstate</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>, <argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"checksum error occurred"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>checksum_failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"final receive failed: %s"</literal></expr></argument>,
						 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>bgchild</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pid_t</name></type>		<name>r</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>DWORD</name></type>		<name>status</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * get a pointer sized version of bgchild to avoid warnings about
		 * casting to a different size on WIN64.
		 */</comment>
		<decl_stmt><decl><type><name>intptr_t</name></type>	<name>bgchild_handle</name> <init>= <expr><name>bgchild</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>hi</name></decl>,
					<decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"waiting for background process to finish streaming ..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>bgpipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>xlogend</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"could not send command to background pipe: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Just wait for the background process to exit */</comment>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>waitpid</name><argument_list>(<argument><expr><name>bgchild</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>(</operator><name>pid_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not wait for child process: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>bgchild</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"child %d died, expected %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>bgchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>wait_result_to_str</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Exited normally, we're happy! */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>

		<comment type="block">/*
		 * On Windows, since we are in the same process, we can just store the
		 * value directly in the variable, and then set the flag that says
		 * it's there.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not parse write-ahead log location \"%s\""</literal></expr></argument>,
						 <argument><expr><name>xlogend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>xlogendptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InterlockedIncrement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>has_xlogendptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* First wait for the thread to exit */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>WaitForSingleObjectEx</name><argument_list>(<argument><expr><operator>(</operator><name>HANDLE</name><operator>)</operator> <name>bgchild_handle</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>!=</operator>
			<name>WAIT_OBJECT_0</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not wait for child thread: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>GetExitCodeThread</name><argument_list>(<argument><expr><operator>(</operator><name>HANDLE</name><operator>)</operator> <name>bgchild_handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not get child thread exit status: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"child thread exited with error %u"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Exited normally, we're happy */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Free the configuration file contents */</comment>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>recoveryconfcontents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * End of copy data. Final result is already checked inside the loop.
	 */</comment>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make data persistent on disk once backup is completed. For tar format
	 * once syncing the parent directory is fine, each tar file created per
	 * tablespace has been already synced. In plain format, all the data of
	 * the base directory is synced, taking into account all the tablespaces.
	 * Errors are not considered fatal.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>do_sync</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"syncing data to disk ..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fsync_fname</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fsync_pgdata</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>serverVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"base backup completed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'?'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"pgdata"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'D'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"format"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'F'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"checkpoint"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'c'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"create-slot"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'C'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"max-rate"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'r'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"write-recovery-conf"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'R'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"slot"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"tablespace-mapping"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'T'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"wal-method"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'X'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"gzip"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'z'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"compress"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'Z'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"label"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'l'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-clean"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-sync"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'N'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"dbname"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"host"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"username"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'U'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'w'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'W'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"status-interval"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"verbose"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'v'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"progress"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'P'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"waldir"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-slot"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-verify-checksums"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"exclude"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'E'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"force-overwrite"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">128</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"target-gp-dbid"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">129</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"exclude-from"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">130</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>option_index</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_logging_init</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"pg_basebackup"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
				 <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"pg_basebackup (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>num_exclude</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_exclude_from</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>cleanup_directories_atexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"CD:F:r:RT:xX:l:zZ:d:c:h:p:U:s:S:wWvPE:"</literal></expr></argument>,
							<argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option_index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'C'</literal></expr>:</case>
				<expr_stmt><expr><name>create_slot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><name>basedir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"plain"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"tar"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid output format \"%s\", must be \"plain\" or \"tar\""</literal></expr></argument>,
								 <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<expr_stmt><expr><name>maxrate</name> <operator>=</operator> <call><name>parse_max_rate</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<expr_stmt><expr><name>writerecoveryconf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'S'</literal></expr>:</case>

				<comment type="block">/*
				 * When specifying replication slot name, use a permanent
				 * slot.
				 */</comment>
				<expr_stmt><expr><name>replication_slot</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>temp_replication_slot</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><name>no_slot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'T'</literal></expr>:</case>
				<expr_stmt><expr><call><name>tablespace_list_append</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"n"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>includewal</name> <operator>=</operator> <name>NO_WAL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
						 <call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"fetch"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>includewal</name> <operator>=</operator> <name>FETCH_WAL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
						 <call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"stream"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>includewal</name> <operator>=</operator> <name>STREAM_WAL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid wal-method option \"%s\", must be \"fetch\", \"stream\", or \"none\""</literal></expr></argument>,
								 <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<expr_stmt><expr><name>xlog_dir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<expr_stmt><expr><name>noclean</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'N'</literal></expr>:</case>
				<expr_stmt><expr><name>do_sync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'z'</literal></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
				<expr_stmt><expr><name>compresslevel</name> <operator>=</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><name>compresslevel</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* will be rejected below */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<break>break;</break>
			<case>case <expr><literal type="char">'Z'</literal></expr>:</case>
				<expr_stmt><expr><name>compresslevel</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>compresslevel</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>compresslevel</name></expr></argument> &gt;</argument_list></name> <literal type="number">9</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid compression level \"%s\""</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"fast"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>fastcheckpoint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"spread"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>fastcheckpoint</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid checkpoint argument \"%s\", must be \"fast\" or \"spread\""</literal></expr></argument>,
								 <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<expr_stmt><expr><name>connection_string</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
				<expr_stmt><expr><name>dbhost</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<expr_stmt><expr><name>dbport</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'U'</literal></expr>:</case>
				<expr_stmt><expr><name>dbuser</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'w'</literal></expr>:</case>
				<expr_stmt><expr><name>dbgetpassword</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
				<expr_stmt><expr><name>dbgetpassword</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<expr_stmt><expr><name>standby_message_timeout</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>standby_message_timeout</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid status interval \"%s\""</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'v'</literal></expr>:</case>
				<expr_stmt><expr><name>verbose</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'P'</literal></expr>:</case>
				<expr_stmt><expr><name>showprogress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">3</literal></expr>:</case>
				<expr_stmt><expr><name>verify_checksums</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'E'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>num_exclude</name> <operator>&gt;=</operator> <name>MAX_EXCLUDE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"too many elements in exclude list: max is %d"</literal></expr></argument>,
								 <argument><expr><name>MAX_EXCLUDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"HINT: use --exclude-from to load a large exclude list from a file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>excludes</name><index>[<expr><name>num_exclude</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">128</literal></expr>:</case>
				<expr_stmt><expr><name>forceoverwrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">129</literal></expr>:</case>
				<expr_stmt><expr><name>target_gp_dbid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">130</literal></expr>:</case>			<comment type="block">/* --exclude-from=FILE */</comment>
				<if_stmt><if>if <condition>(<expr><name>num_exclude_from</name> <operator>&gt;=</operator> <name>MAX_EXCLUDE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"too many elements in exclude-from list: max is %d"</literal></expr></argument>,
								 <argument><expr><name>MAX_EXCLUDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>excludefroms</name><index>[<expr><name>num_exclude_from</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>

				<comment type="block">/*
				 * getopt_long already emitted a complaint
				 */</comment>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Any non-option arguments?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"too many command-line arguments (first is \"%s\")"</literal></expr></argument>,
					 <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Required arguments
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>basedir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"no target directory specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>target_gp_dbid</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"no target dbid specified, --target-gp-dbid is required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Mutually exclusive arguments
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"only tar mode backups can be compressed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name>includewal</name> <operator>==</operator> <name>STREAM_WAL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"cannot stream write-ahead logs in tar mode to stdout"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>replication_slot</name> <operator>&amp;&amp;</operator> <name>includewal</name> <operator>!=</operator> <name>STREAM_WAL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"replication slots can only be used with WAL streaming"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>no_slot</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>replication_slot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"--no-slot cannot be used with slot name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>temp_replication_slot</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>create_slot</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replication_slot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"%s needs a slot to be specified using --slot"</literal></expr></argument>,
						 <argument><expr><literal type="string">"--create-slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>no_slot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"--create-slot and --no-slot are incompatible options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>xlog_dir</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>format</name> <operator>!=</operator> <literal type="char">'p'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"WAL directory location can only be specified in plain mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* clean up xlog directory name, check it's absolute */</comment>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"WAL directory location must be an absolute path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"this build does not support compression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* connection in replication mode to server */</comment>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>GetConnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Error message already written in GetConnection() */</comment>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>disconnect_atexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set umask so that directories/files are created with the same
	 * permissions as directories/files in the source data directory.
	 *
	 * pg_mode_mask is set to owner-only by default and then updated in
	 * GetConnection() where we get the mode from the server-side with
	 * RetrieveDataDirCreatePerm() and then call SetDataDirectoryCreatePerm().
	 */</comment>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>pg_mode_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify that the target directory exists, or create it. For plaintext
	 * backups, always require the directory. For tar backups, require it
	 * unless we are writing to stdout.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>verify_dir_is_empty_or_create</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>made_new_pgdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_existing_pgdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * GPDB: Backups in tar mode will not have the internal.auto.conf file,
	 * nor will any tablespaces have the dbid appended to their symlinks in
	 * pg_tblspc. The backups are still, in theory, valid, but the tablespace
	 * mapping and internal.auto.conf files will need to be added manually
	 * when extracting the backups.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"WARNING: tar backups are not supported on GPDB"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* determine remote server's xlog segment size */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RetrieveWalSegSize</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Create pg_wal symlink, if required */</comment>
	<if_stmt><if>if <condition>(<expr><name>xlog_dir</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>linkloc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>verify_dir_is_empty_or_create</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>made_new_xlogdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_existing_xlogdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Form name of the place where the symlink must go. pg_xlog has been
		 * renamed to pg_wal in post-10 clusters.
		 */</comment>
		<expr_stmt><expr><name>linkloc</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>,
						   <argument><expr><ternary><condition><expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MINIMUM_VERSION_FOR_PG_WAL</name></expr> ?</condition><then>
						   <expr><literal type="string">"pg_xlog"</literal></expr> </then><else>: <expr><literal type="string">"pg_wal"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><call><name>symlink</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>linkloc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create symbolic link \"%s\": %m"</literal></expr></argument>, <argument><expr><name>linkloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"symlinks are not supported on this platform"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>linkloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>BaseBackup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>WriteInternalConfFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>cf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>line_to_write</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>GP_INTERNAL_AUTO_CONF_FILE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>line_to_write</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="string">"gp_dbid=%d\n"</literal></expr></argument>, <argument><expr><name>target_gp_dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>line_to_write</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
