<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/bin/pg_dump/dumputils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * Utility routines for SQL dumping
 *
 * Basically this is stuff that is useful in both pg_dump and pg_dumpall.
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/bin/pg_dump/dumputils.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dumputils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>parseAclItem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remoteVersion</name></decl></parameter>,
						 <parameter><decl><type><name>PQExpBuffer</name></type> <name>grantee</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>grantor</name></decl></parameter>,
						 <parameter><decl><type><name>PQExpBuffer</name></type> <name>privs</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>privswgo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>dequoteAclUserName</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddAcl</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>aclbuf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Build GRANT/REVOKE command(s) for an object.
 *
 *	name: the object name, in the form to use in the commands (already quoted)
 *	subname: the sub-object name, if any (already quoted); NULL if none
 *	nspname: the namespace the object is in (NULL if none); not pre-quoted
 *	type: the object type (as seen in GRANT command: must be one of
 *		TABLE, SEQUENCE, FUNCTION, PROCEDURE, LANGUAGE, SCHEMA, DATABASE, TABLESPACE,
 *		FOREIGN DATA WRAPPER, SERVER, or LARGE OBJECT)
 *	acls: the ACL string fetched from the database
 *	baseacls: the initial ACL string for this object; can be
 *		NULL or empty string to indicate "not available from server"
 *	owner: username of object owner (will be passed through fmtId); can be
 *		NULL or empty string to indicate "no owner known"
 *	prefix: string to prefix to each generated command; typically empty
 *	remoteVersion: version of database
 *
 * Returns true if okay, false if could not parse the acl string.
 * The resulting commands (if any) are appended to the contents of 'sql'.
 *
 * baseacls is typically the result of acldefault() for the object's type
 * and owner.  However, if there is a pg_init_privs entry for the object,
 * it should instead be the initprivs ACLs.  When acls is itself a
 * pg_init_privs entry, baseacls is what to dump that relative to; then
 * it can be either an acldefault() value or an empty ACL "{}".
 *
 * Note: when processing a default ACL, prefix is "ALTER DEFAULT PRIVILEGES "
 * or something similar, and name is an empty string.
 *
 * Note: beware of passing a fmtId() result directly as 'name' or 'subname',
 * since this routine uses fmtId() internally.
 */</comment>
<function><type><name>bool</name></type>
<name>buildACLCommands</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>baseacls</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remoteVersion</name></decl></parameter>,
				 <parameter><decl><type><name>PQExpBuffer</name></type> <name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>aclitems</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>baseitems</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>grantitems</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>revokeitems</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>naclitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbaseitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ngrantitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nrevokeitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>grantee</name></decl>,
				<decl><type ref="prev"/><name>grantor</name></decl>,
				<decl><type ref="prev"/><name>privs</name></decl>,
				<decl><type ref="prev"/><name>privswgo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>firstsql</name></decl>,
				<decl><type ref="prev"/><name>secondsql</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the acl was NULL (initial default state), we need do nothing.  Note
	 * that this is distinguishable from all-privileges-revoked, which will
	 * look like an empty array ("{}").
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>acls</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>acls</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* object has default permissions */</comment>

	<comment type="block">/* treat empty-string owner same as NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>owner</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>owner</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>owner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Parse the acls array */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name>acls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aclitems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>naclitems</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>aclitems</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aclitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Parse the baseacls, if provided */</comment>
	<if_stmt><if>if <condition>(<expr><name>baseacls</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>baseacls</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name>baseacls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseitems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbaseitems</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>aclitems</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aclitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>baseitems</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>baseitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compare the actual ACL with the base ACL, extracting the privileges
	 * that need to be granted (i.e., are in the actual ACL but not the base
	 * ACL) and the ones that need to be revoked (the reverse).  We use plain
	 * string comparisons to check for matches.  In principle that could be
	 * fooled by extraneous issues such as whitespace, but since all these
	 * strings are the work of aclitemout(), it should be OK in practice.
	 * Besides, a false mismatch will just cause the output to be a little
	 * more verbose than it really needed to be.
	 *
	 * (If we weren't given a base ACL, this stanza winds up with all the
	 * ACL's items in grantitems and nothing in revokeitems.  It's not worth
	 * special-casing that.)
	 */</comment>
	<expr_stmt><expr><name>grantitems</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>naclitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>naclitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nbaseitems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>aclitems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>baseitems</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>grantitems</name><index>[<expr><name>ngrantitems</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>aclitems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>revokeitems</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>nbaseitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbaseitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>naclitems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>baseitems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>aclitems</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>revokeitems</name><index>[<expr><name>nrevokeitems</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>baseitems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Prepare working buffers */</comment>
	<expr_stmt><expr><name>grantee</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>grantor</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>privs</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>privswgo</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * At the end, these two will be pasted together to form the result.
	 */</comment>
	<expr_stmt><expr><name>firstsql</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>secondsql</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we weren't given baseacls information, we just revoke everything and
	 * then grant what's listed in the ACL.  This avoids having to embed
	 * detailed knowledge about what the defaults are/were, and it's not very
	 * expensive since servers lacking acldefault() are now rare.
	 *
	 * Otherwise, we need only revoke what's listed in revokeitems.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>baseacls</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>baseacls</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We assume the old defaults only involved the owner and PUBLIC */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%sREVOKE ALL"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">" ON %s "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s FROM PUBLIC;\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>owner</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%sREVOKE ALL"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">" ON %s "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s FROM %s;\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Scan individual REVOKE ACL items */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrevokeitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parseAclItem</name><argument_list>(<argument><expr><name><name>revokeitems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							  <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>remoteVersion</name></expr></argument>,
							  <argument><expr><name>grantee</name></expr></argument>, <argument><expr><name>grantor</name></expr></argument>, <argument><expr><name>privs</name></expr></argument>, <argument><expr><name>privswgo</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>privs</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>privswgo</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>privs</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%sREVOKE %s ON %s "</literal></expr></argument>,
									  <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>privs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s FROM "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>grantee</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"PUBLIC;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"group "</literal></expr></argument>,
									 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"GROUP %s;\n"</literal></expr></argument>,
										  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>,
										  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>privswgo</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>,
									  <argument><expr><literal type="string">"%sREVOKE GRANT OPTION FOR %s ON %s "</literal></expr></argument>,
									  <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>privswgo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"%s FROM "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>grantee</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"PUBLIC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"group "</literal></expr></argument>,
									 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><literal type="string">"GROUP %s"</literal></expr></argument>,
										  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Scan individual ACL items to be granted.
	 *
	 * The order in which privileges appear in the ACL string (the order they
	 * have been GRANT'd in, which the backend maintains) must be preserved to
	 * ensure that GRANTs WITH GRANT OPTION and subsequent GRANTs based on
	 * those are dumped in the correct order.  However, some old server
	 * versions will show grants to PUBLIC before the owner's own grants; for
	 * consistency's sake, force the owner's grants to be output first.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ngrantitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>parseAclItem</name><argument_list>(<argument><expr><name><name>grantitems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>remoteVersion</name></expr></argument>,
						 <argument><expr><name>grantee</name></expr></argument>, <argument><expr><name>grantor</name></expr></argument>, <argument><expr><name>privs</name></expr></argument>, <argument><expr><name>privswgo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the grantor isn't the owner, we'll need to use SET SESSION
			 * AUTHORIZATION to become the grantor.  Issue the SET/RESET only
			 * if there's something useful to do.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>privs</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>privswgo</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>thissql</name></decl>;</decl_stmt>

				<comment type="block">/* Set owner as grantor if that's not explicit in the ACL */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>grantor</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>owner</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>grantor</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Make sure owner's own grants are output before others */</comment>
				<if_stmt><if>if <condition>(<expr><name>owner</name> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>grantor</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>thissql</name> <operator>=</operator> <name>firstsql</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>thissql</name> <operator>=</operator> <name>secondsql</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>grantor</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
					<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>owner</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name><name>grantor</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"SET SESSION AUTHORIZATION %s;\n"</literal></expr></argument>,
									  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantor</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>privs</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"%sGRANT %s ON %s "</literal></expr></argument>,
									  <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>privs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"%s TO "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>grantee</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"PUBLIC;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"group "</literal></expr></argument>,
									 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"GROUP %s;\n"</literal></expr></argument>,
										  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>privswgo</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"%sGRANT %s ON %s "</literal></expr></argument>,
									  <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>privswgo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"%s TO "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>grantee</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"PUBLIC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"group "</literal></expr></argument>,
									 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"GROUP %s"</literal></expr></argument>,
										  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"group "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>grantee</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">" WITH GRANT OPTION;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>grantor</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
					<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>owner</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name><name>grantor</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>thissql</name></expr></argument>, <argument><expr><literal type="string">"RESET SESSION AUTHORIZATION;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* parseAclItem failed, give up */</comment>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>grantee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>grantor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>privs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>privswgo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>firstsql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>secondsql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>firstsql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>secondsql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>aclitems</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aclitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>baseitems</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>baseitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>grantitems</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>grantitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>revokeitems</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>revokeitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ok</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build ALTER DEFAULT PRIVILEGES command(s) for a single pg_default_acl entry.
 *
 *	type: the object type (TABLES, FUNCTIONS, etc)
 *	nspname: schema name, or NULL for global default privileges
 *	acls: the ACL string fetched from the database
 *	acldefault: the appropriate default ACL for the object type and owner
 *	owner: username of privileges owner (will be passed through fmtId)
 *	remoteVersion: version of database
 *
 * Returns true if okay, false if could not parse the acl string.
 * The resulting commands (if any) are appended to the contents of 'sql'.
 */</comment>
<function><type><name>bool</name></type>
<name>buildDefaultACLCommands</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acldefault</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>remoteVersion</name></decl></parameter>,
						<parameter><decl><type><name>PQExpBuffer</name></type> <name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>prefix</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We incorporate the target role directly into the command, rather than
	 * playing around with SET ROLE or anything like that.  This is so that a
	 * permissions error leads to nothing happening, rather than changing
	 * default privileges for the wrong user.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"ALTER DEFAULT PRIVILEGES FOR ROLE %s "</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"IN SCHEMA %s "</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * There's no such thing as initprivs for a default ACL, so the base ACL
	 * is always just the object-type-specific default.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>buildACLCommands</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
						  <argument><expr><name>acls</name></expr></argument>, <argument><expr><name>acldefault</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>,
						  <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>remoteVersion</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This will parse an aclitem string, having the general form
 *		username=privilegecodes/grantor
 * or
 *		group groupname=privilegecodes/grantor
 * (the "group" case occurs only with servers before 8.1).
 *
 * Returns true on success, false on parse error.  On success, the components
 * of the string are returned in the PQExpBuffer parameters.
 *
 * The returned grantee string will be the dequoted username or groupname
 * (preceded with "group " in the latter case).  Note that a grant to PUBLIC
 * is represented by an empty grantee string.  The returned grantor is the
 * dequoted grantor name.  Privilege characters are decoded and split between
 * privileges with grant option (privswgo) and without (privs).
 *
 * Note: for cross-version compatibility, it's important to use ALL to
 * represent the privilege sets whenever appropriate.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parseAclItem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remoteVersion</name></decl></parameter>,
			 <parameter><decl><type><name>PQExpBuffer</name></type> <name>grantee</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>grantor</name></decl></parameter>,
			 <parameter><decl><type><name>PQExpBuffer</name></type> <name>privs</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>privswgo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_with_go</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_without_go</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>eqpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>slpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* user or group name is string up to = */</comment>
	<expr_stmt><expr><name>eqpos</name> <operator>=</operator> <call><name>dequoteAclUserName</name><argument_list>(<argument><expr><name>grantee</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>eqpos</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* grantor should appear after / */</comment>
	<expr_stmt><expr><name>slpos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>eqpos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slpos</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>slpos</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>slpos</name> <operator>=</operator> <call><name>dequoteAclUserName</name><argument_list>(<argument><expr><name>grantor</name></expr></argument>, <argument><expr><name>slpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>slpos</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* privilege codes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERT_PRIV</name><parameter_list>(<parameter><type><name>code</name></type></parameter>, <parameter><type><name>keywd</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if ((pos = strchr(eqpos + 1, code))) \
	{ \
		if (*(pos + 1) == '*') \
		{ \
			AddAcl(privswgo, keywd, subname); \
			all_without_go = false; \
		} \
		else \
		{ \
			AddAcl(privs, keywd, subname); \
			all_with_go = false; \
		} \
	} \
	else \
		all_with_go = all_without_go = false; \
} while (0)</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>privs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>privswgo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TABLES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* sequence only */</comment>
			<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* table only */</comment>
			<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'x'</literal></expr></argument>, <argument><expr><literal type="string">"REFERENCES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* rest are not applicable to columns */</comment>
			<if_stmt><if>if <condition>(<expr><name>subname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'t'</literal></expr></argument>, <argument><expr><literal type="string">"TRIGGER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>remoteVersion</name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'D'</literal></expr></argument>, <argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* UPDATE */</comment>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'w'</literal></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FUNCTION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FUNCTIONS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'X'</literal></expr></argument>, <argument><expr><literal type="string">"EXECUTE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"PROCEDURE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"PROCEDURES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'X'</literal></expr></argument>, <argument><expr><literal type="string">"EXECUTE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"LANGUAGE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"SCHEMAS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"CREATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"CREATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><literal type="string">"CONNECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'T'</literal></expr></argument>, <argument><expr><literal type="string">"TEMPORARY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TABLESPACE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"CREATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"TYPES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN SERVER"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'w'</literal></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"PROTOCOL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CONVERT_PRIV</name><argument_list>(<argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONVERT_PRIV</name></cpp:undef>

	<if_stmt><if>if <condition>(<expr><name>all_with_go</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>privs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>privswgo</name></expr></argument>, <argument><expr><literal type="string">"ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>privswgo</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>all_without_go</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>privswgo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>privs</name></expr></argument>, <argument><expr><literal type="string">"ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>privs</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transfer the role name at *input into the output buffer, adding
 * quoting according to the same rules as putid() in backend's acl.c.
 */</comment>
<function><type><name>void</name></type>
<name>quoteAclUserName</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>output</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>safe</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>src</name> <operator>=</operator> <name>input</name></expr>;</init> <condition><expr><operator>*</operator><name>src</name></expr>;</condition> <incr><expr><name>src</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* This test had better match what putid() does */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isalnum</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>src</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>src</name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>safe</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>safe</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>src</name> <operator>=</operator> <name>input</name></expr>;</init> <condition><expr><operator>*</operator><name>src</name></expr>;</condition> <incr><expr><name>src</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* A double quote character in a username is encoded as "" */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>src</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><operator>*</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>safe</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transfer a user or group name starting at *input into the output buffer,
 * dequoting if needed.  Returns a pointer to just past the input name.
 * The name is taken to end at an unquoted '=' or end of string.
 * Note: unlike quoteAclUserName(), this first clears the output buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>dequoteAclUserName</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>input</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>input</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If user name isn't quoted, then just add it to the output buffer
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><operator>*</operator><name>input</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Otherwise, it's a quoted username */</comment>
			<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* Loop until we come across an unescaped quote */</comment>
			<while>while <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>input</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'"'</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>input</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* really a syntax error... */</comment>

				<comment type="block">/*
				 * Quoting convention is to escape " as "".  Keep this code in
				 * sync with putid() in backend's acl.c.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>input</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><operator>*</operator><name>input</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>input</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Append a privilege keyword to a keyword list, inserting comma if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddAcl</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>aclbuf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>aclbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>aclbuf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>aclbuf</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>aclbuf</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * buildShSecLabelQuery
 *
 * Build a query to retrieve security labels for a shared object.
 * The object is identified by its OID plus the name of the catalog
 * it can be found in (e.g., "pg_database" for database names).
 * The query is appended to "sql".  (We don't execute it here so as to
 * keep this file free of assumptions about how to deal with SQL errors.)
 */</comment>
<function><type><name>void</name></type>
<name>buildShSecLabelQuery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>catalog_name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>,
					 <parameter><decl><type><name>PQExpBuffer</name></type> <name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT provider, label FROM pg_catalog.pg_shseclabel "</literal>
					  <literal type="string">"WHERE classoid = 'pg_catalog.%s'::pg_catalog.regclass "</literal>
					  <literal type="string">"AND objoid = '%u'"</literal></expr></argument>, <argument><expr><name>catalog_name</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * emitShSecLabels
 *
 * Construct SECURITY LABEL commands using the data retrieved by the query
 * generated by buildShSecLabelQuery, and append them to "buffer".
 * Here, the target object is identified by its type name (e.g. "DATABASE")
 * and its name (not pre-quoted).
 */</comment>
<function><type><name>void</name></type>
<name>emitShSecLabels</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>provider</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* must use fmtId result before calling it again */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
						  <argument><expr><literal type="string">"SECURITY LABEL FOR %s ON %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
						  <argument><expr><literal type="string">" %s IS "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralConn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Detect whether the given GUC variable is of GUC_LIST_QUOTE type.
 *
 * It'd be better if we could inquire this directly from the backend; but even
 * if there were a function for that, it could only tell us about variables
 * currently known to guc.c, so that it'd be unsafe for extensions to declare
 * GUC_LIST_QUOTE variables anyway.  Lacking a solution for that, it doesn't
 * seem worth the work to do more than have this list, which must be kept in
 * sync with the variables actually marked GUC_LIST_QUOTE in guc.c.
 */</comment>
<function><type><name>bool</name></type>
<name>variable_is_guc_list_quote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"temp_tablespaces"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"session_preload_libraries"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"shared_preload_libraries"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"local_preload_libraries"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"search_path"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SplitGUCList --- parse a string containing identifiers or file names
 *
 * This is used to split the value of a GUC_LIST_QUOTE GUC variable, without
 * presuming whether the elements will be taken as identifiers or file names.
 * See comparable code in src/backend/utils/adt/varlena.c.
 *
 * Inputs:
 *	rawstring: the input string; must be overwritable!	On return, it's
 *			   been modified to contain the separated identifiers.
 *	separator: the separator punctuation expected between identifiers
 *			   (typically '.' or ',').  Whitespace may also appear around
 *			   identifiers.
 * Outputs:
 *	namelist: receives a malloc'd, null-terminated array of pointers to
 *			  identifiers within rawstring.  Caller should free this
 *			  even on error return.
 *
 * Returns true if okay, false if there is a syntax error in the string.
 */</comment>
<function><type><name>bool</name></type>
<name>SplitGUCList</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rawstring</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>separator</name></decl></parameter>,
			 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>namelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nextp</name> <init>= <expr><name>rawstring</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>nextptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since we disallow empty identifiers, this is a conservative
	 * overestimate of the number of pointers we could need.  Allow one for
	 * list terminator.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>namelist</name> <operator>=</operator> <name>nextptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>pg_malloc</name><argument_list>(<argument><expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nextptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>				<comment type="block">/* skip leading whitespace */</comment>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* allow empty string */</comment>

	<comment type="block">/* At the top of the loop, we are at start of a new identifier. */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Quoted name --- collapse quote-quote pairs */</comment>
			<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>nextp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>nextp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* mismatched quotes */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>endp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* found end of quoted name */</comment>
				<comment type="block">/* Collapse adjacent quotes into one quote, and look again */</comment>
				<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>endp</name></expr></argument>, <argument><expr><name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>endp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nextp</name> <operator>=</operator> <name>endp</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<comment type="block">/* endp now points at the terminating quote */</comment>
			<expr_stmt><expr><name>nextp</name> <operator>=</operator> <name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Unquoted name --- extends to separator or whitespace */</comment>
			<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>*</operator><name>nextp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nextp</name> <operator>!=</operator> <name>separator</name> <operator>&amp;&amp;</operator>
				   <operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>nextp</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* empty unquoted name not allowed */</comment>
		</block_content>}</block></else></if_stmt>

		<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>			<comment type="block">/* skip trailing whitespace */</comment>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <name>separator</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>		<comment type="block">/* skip leading whitespace for next */</comment>
			<comment type="block">/* we expect another name, so done remains false */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>		<comment type="block">/* invalid syntax */</comment>

		<comment type="block">/* Now safe to overwrite separator with a null */</comment>
		<expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Finished isolating current name --- add it to output array
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>nextptr</name><operator>++</operator> <operator>=</operator> <name>curname</name></expr>;</expr_stmt>

		<comment type="block">/* Loop back if we didn't reach end of string */</comment>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

	<expr_stmt><expr><operator>*</operator><name>nextptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function for dumping "ALTER DATABASE/ROLE SET ..." commands.
 *
 * Parse the contents of configitem (a "name=value" string), wrap it in
 * a complete ALTER command, and append it to buf.
 *
 * type is DATABASE or ROLE, and name is the name of the database or role.
 * If we need an "IN" clause, type2 and name2 similarly define what to put
 * there; otherwise they should be NULL.
 * conn is used only to determine string-literal quoting conventions.
 */</comment>
<function><type><name>void</name></type>
<name>makeAlterConfigCommand</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>configitem</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name2</name></decl></parameter>,
					   <parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>mine</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>

	<comment type="block">/* Parse the configitem.  If we can't find an "=", silently do nothing. */</comment>
	<expr_stmt><expr><name>mine</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>configitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>mine</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>mine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>pos</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* Build the command, with suitable quoting for everything. */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ALTER %s %s "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>type2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>name2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"IN %s %s "</literal></expr></argument>, <argument><expr><name>type2</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>name2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SET %s TO "</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>mine</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Variables that are marked GUC_LIST_QUOTE were already fully quoted by
	 * flatten_set_variable_args() before they were put into the setconfig
	 * array.  However, because the quoting rules used there aren't exactly
	 * like SQL's, we have to break the list value apart and then quote the
	 * elements as string literals.  (The elements may be double-quoted as-is,
	 * but we can't just feed them to the SQL parser; it would do the wrong
	 * thing with elements that are zero-length or longer than NAMEDATALEN.)
	 *
	 * Variables that are not so marked should just be emitted as simple
	 * string literals.  If the variable is not known to
	 * variable_is_guc_list_quote(), we'll do that; this makes it unsafe to
	 * use GUC_LIST_QUOTE for extension variables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>variable_is_guc_list_quote</name><argument_list>(<argument><expr><name>mine</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>nameptr</name></decl>;</decl_stmt>

		<comment type="block">/* Parse string into list of identifiers */</comment>
		<comment type="block">/* this shouldn't fail really */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SplitGUCList</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelist</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>nameptr</name> <operator>=</operator> <name>namelist</name></expr>;</init> <condition><expr><operator>*</operator><name>nameptr</name></expr>;</condition> <incr><expr><name>nameptr</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>nameptr</name> <operator>!=</operator> <name>namelist</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringLiteralConn</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>nameptr</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringLiteralConn</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>mine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
