<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/bin/pg_dump/pg_dump.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_dump.c
 *	  pg_dump is a utility for dumping out a postgres database
 *	  into a script file.
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *	pg_dump will read the system catalogs in a database and dump out a
 *	script that reproduces the schema in terms of SQL that is understood
 *	by PostgreSQL
 *
 *	Note that pg_dump runs in a transaction-snapshot mode transaction,
 *	so it sees a consistent snapshot of the database including system
 *	catalogs. However, it relies in part on various specialized backend
 *	functions like pg_get_indexdef(), and those things tend to look at
 *	the currently committed state.  So it is possible to get 'cache
 *	lookup failed' error if someone performs DDL changes while a dump is
 *	happening. The window for this sort of thing is from the acquisition
 *	of the transaction snapshot to getSchemaData() (when pg_dump acquires
 *	AccessShareLock on every table it intends to dump). It isn't very large,
 *	but it can happen.
 *
 *	http://archives.postgresql.org/pgsql-bugs/2010-02/msg00187.php
 *
 * IDENTIFICATION
 *	  src/bin/pg_dump/pg_dump.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TERMIOS_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;termios.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/attnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_cast_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_default_acl_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_server_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject_metadata_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_magic_oid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/block.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dumputils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/connect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_db.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_dump.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/connect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleoid</name></decl>;</decl_stmt>		<comment type="block">/* role's OID */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rolename</name></decl>;</decl_stmt>		<comment type="block">/* role's name */</comment>
}</block></struct></type> <name>RoleNameItem</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>			<comment type="block">/* comment for an object */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>classoid</name></decl>;</decl_stmt>		<comment type="block">/* object class (catalog OID) */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>objoid</name></decl>;</decl_stmt>			<comment type="block">/* object OID */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>objsubid</name></decl>;</decl_stmt>		<comment type="block">/* subobject (table column #) */</comment>
}</block></struct></type> <name>CommentItem</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>provider</name></decl>;</decl_stmt>		<comment type="block">/* label provider of this security label */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>			<comment type="block">/* security label for an object */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>classoid</name></decl>;</decl_stmt>		<comment type="block">/* object class (catalog OID) */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>objoid</name></decl>;</decl_stmt>			<comment type="block">/* object OID */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>objsubid</name></decl>;</decl_stmt>		<comment type="block">/* subobject (table column #) */</comment>
}</block></struct></type> <name>SecLabelItem</name>;</typedef>

<typedef>typedef <type><enum>enum <name>OidOptions</name>
<block>{
	<decl><name>zeroAsOpaque</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>zeroAsAny</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
	<decl><name>zeroAsStar</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
	<decl><name>zeroAsNone</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>
}</block></enum></type> <name>OidOptions</name>;</typedef>

<comment type="block">/* global decls */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>dosync</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* Issue fsync() to make dump durable on disk. */</comment>

<comment type="block">/* END MPP ADDITION */</comment>

<comment type="block">/*
 * For 8.0 and earlier servers, pulled from pg_database, for 8.1+ we use
 * FirstNormalObjectId - 1.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>g_last_builtin_oid</name></decl>;</decl_stmt> <comment type="block">/* value of the last builtin oid */</comment>

<comment type="block">/* The specified names/patterns should to match at least one entity */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>strict_names</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Object inclusion/exclusion lists
 *
 * The string lists record the patterns given by command-line switches,
 * which we then convert to lists of OIDs of matching objects.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>schema_include_patterns</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>schema_include_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>schema_exclude_patterns</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>schema_exclude_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>table_include_patterns</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>table_include_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>table_exclude_patterns</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>table_exclude_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>tabledata_exclude_patterns</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>tabledata_exclude_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>relid_string_list</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>funcid_string_list</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>function_include_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>preassigned_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type>		<name><name>g_opaque_type</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* name for the opaque type */</comment>

<comment type="block">/* placeholders for the delimiters for comments */</comment>
<decl_stmt><decl><type><name>char</name></type>		<name><name>g_comment_start</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type>		<name><name>g_comment_end</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CatalogId</name></type> <name>nilCatalogId</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>EXT_PARTITION_NAME_POSTFIX</name> <init>= <expr><literal type="string">"_external_partition__"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* pg_class.relstorage value used in GPDB 6.x and below to mark external tables. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELSTORAGE_EXTERNAL</name></cpp:macro> <cpp:value>'x'</cpp:value></cpp:define>

<comment type="block">/* override for standard extra_float_digits setting */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>have_extra_float_digits</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>extra_float_digits</name></decl>;</decl_stmt>

<comment type="block">/* sorted table of role names */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>RoleNameItem</name> <modifier>*</modifier></type><name>rolenames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nrolenames</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* sorted table of comments */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>CommentItem</name> <modifier>*</modifier></type><name>comments</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>ncomments</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* sorted table of security labels */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SecLabelItem</name> <modifier>*</modifier></type><name>seclabels</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nseclabels</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * The default number of rows per INSERT when
 * --inserts is specified without --rows-per-insert
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_DEFAULT_ROWS_PER_INSERT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/*
 * Macro for producing quoted, schema-qualified name of a dumpable object.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fmtQualifiedDumpable</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>fmtQualifiedId((obj)-&gt;dobj.namespace-&gt;dobj.name, \
				   (obj)-&gt;dobj.name)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>help</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_connection</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpencoding</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpsnapshot</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>use_role</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ArchiveFormat</name></type> <name>parseArchiveFormat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>ArchiveMode</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_schema_name_patterns</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
										<parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>patterns</name></decl></parameter>,
										<parameter><decl><type><name>SimpleOidList</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>strict_names</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_table_name_patterns</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
									   <parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>patterns</name></decl></parameter>,
									   <parameter><decl><type><name>SimpleOidList</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>strict_names</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NamespaceInfo</name> <modifier>*</modifier></type><name>findNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nsoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTableData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>refreshMatViewData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>guessConstraintInheritance</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpComment</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
						<parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getRoleName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>roleoid_str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>collectRoleNames</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getAdditionalACLs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>findComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>,
						 <parameter><decl><type><name>CommentItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>collectComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpSecLabel</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
						 <parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>findSecLabels</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>,
						  <parameter><decl><type><name>SecLabelItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>collectSecLabels</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpDumpableObject</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpNamespace</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamespaceInfo</name> <modifier>*</modifier></type><name>nspinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpExtension</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExtensionInfo</name> <modifier>*</modifier></type><name>extinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpBaseType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpEnumType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpRangeType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpUndefinedType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpDomain</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpCompositeType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpCompositeTypeColComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpShellType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ShellTypeInfo</name> <modifier>*</modifier></type><name>stinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpProcLang</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProcLangInfo</name> <modifier>*</modifier></type><name>plang</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpFunc</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpCast</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CastInfo</name> <modifier>*</modifier></type><name>cast</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTransform</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TransformInfo</name> <modifier>*</modifier></type><name>transform</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpOpr</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OprInfo</name> <modifier>*</modifier></type><name>oprinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpAccessMethod</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AccessMethodInfo</name> <modifier>*</modifier></type><name>oprinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpOpclass</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OpclassInfo</name> <modifier>*</modifier></type><name>opcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpOpfamily</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OpfamilyInfo</name> <modifier>*</modifier></type><name>opfinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpCollation</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CollInfo</name> <modifier>*</modifier></type><name>collinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpConversion</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConvInfo</name> <modifier>*</modifier></type><name>convinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpRule</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RuleInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpAgg</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggInfo</name> <modifier>*</modifier></type><name>agginfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTrigger</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TriggerInfo</name> <modifier>*</modifier></type><name>tginfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpEventTrigger</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>EventTriggerInfo</name> <modifier>*</modifier></type><name>evtinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTable</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTableSchema</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTableAttach</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableAttachInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpAttrDef</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttrDefInfo</name> <modifier>*</modifier></type><name>adinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpSequence</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpSequenceData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpIndex</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndxInfo</name> <modifier>*</modifier></type><name>indxinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpIndexAttach</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexAttachInfo</name> <modifier>*</modifier></type><name>attachinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpStatisticsExt</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StatsExtInfo</name> <modifier>*</modifier></type><name>statsextinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpConstraint</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConstraintInfo</name> <modifier>*</modifier></type><name>coninfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTableConstraintComment</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConstraintInfo</name> <modifier>*</modifier></type><name>coninfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTSParser</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TSParserInfo</name> <modifier>*</modifier></type><name>prsinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTSDictionary</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TSDictInfo</name> <modifier>*</modifier></type><name>dictinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTSTemplate</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TSTemplateInfo</name> <modifier>*</modifier></type><name>tmplinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTSConfig</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TSConfigInfo</name> <modifier>*</modifier></type><name>cfginfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpForeignDataWrapper</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FdwInfo</name> <modifier>*</modifier></type><name>fdwinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpForeignServer</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignServerInfo</name> <modifier>*</modifier></type><name>srvinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpUserMappings</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>servername</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>, <parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpDefaultACL</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DefaultACLInfo</name> <modifier>*</modifier></type><name>daclinfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>DumpId</name></type> <name>dumpACL</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>objDumpId</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>altDumpId</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>DumpableAcl</name> <modifier>*</modifier></type><name>dacl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BuildArchiveDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>findDumpableDependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>,
									 <parameter><decl><type><name>DumpId</name> <modifier>*</modifier><modifier>*</modifier></type><name>dependencies</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nDeps</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>allocDeps</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier></type><name>createBoundaryObjects</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addBoundaryDependencies</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>dobjs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>,
									<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>boundaryObjs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addConstrChildIdxDeps</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndxInfo</name> <modifier>*</modifier></type><name>refidx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getDomainConstraints</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getTableData</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>makeTableDataInfo</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>buildMatViewRefreshDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getTableDataFKConstraints</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_function_arguments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcargs</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>is_agg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_function_signature</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>honor_quotes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>convertRegProcReference</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getFormattedOperatorName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oproid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>convertTSFunction</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getFormattedTypeName</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>OidOptions</name></type> <name>opts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getBlobs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpBlob</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BlobInfo</name> <modifier>*</modifier></type><name>binfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>dumpBlobs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpPolicy</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PolicyInfo</name> <modifier>*</modifier></type><name>polinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpPublication</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PublicationInfo</name> <modifier>*</modifier></type><name>pubinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpPublicationTable</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PublicationRelInfo</name> <modifier>*</modifier></type><name>pubrinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpSubscription</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubscriptionInfo</name> <modifier>*</modifier></type><name>subinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpDatabase</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpDatabaseConfig</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>outbuf</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpEncoding</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpStdStrings</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>binary_upgrade_set_namespace_oid</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
								<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>pg_namespace_oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpSearchPath</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>binary_upgrade_set_type_oids_by_type_oid</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
													 <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
													 <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>,
													 <parameter><decl><type><name>bool</name></type> <name>force_array_type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>binary_upgrade_set_type_oids_by_rel</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
													<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
													<parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>binary_upgrade_set_pg_class_oids</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
											 <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
											 <parameter><decl><type><name>Oid</name></type> <name>pg_class_oid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>binary_upgrade_set_rel_ao_oids</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
											<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>binary_upgrade_set_bitmap_index_oids</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
											<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>IndxInfo</name> <modifier>*</modifier></type><name>idxinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>binary_upgrade_set_toast_oids_by_rel</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
											<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>binary_upgrade_extension_member</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objname</name></decl></parameter>,
											<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objnamespace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getAttrName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>attrnum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tblInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmtCopyColumnList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>nonemptyReloptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendReloptionsArrayAH</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_synchronized_snapshot</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setupDumpWorker</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>getRootTableInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* START MPP ADDITION */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpExtProtocol</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ExtProtInfo</name> <modifier>*</modifier></type><name>ptcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTypeStorageOptions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpPreassignedOidArchiveEntry</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>BinaryUpgradeInfo</name> <modifier>*</modifier></type><name>binfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpPreassignedOidDefinition</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>BinaryUpgradeInfo</name> <modifier>*</modifier></type><name>binfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setExtPartDependency</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_table_function_columns</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nallargs</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>allargtypes</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argmodes</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_oid_patterns</name><parameter_list>(<parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>patterns</name></decl></parameter>,
						   <parameter><decl><type><name>SimpleOidList</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_returns_table_function</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nallargs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argmodes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>testGPbackend</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>nextToken</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>stringp</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delim</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addDistributedBy</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>actual_atts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addDistributedByOld</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>actual_atts</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* END MPP ADDITION */</comment>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name> <init>= <expr><literal type="string">"p"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tblinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numTables</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>dobjs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numObjs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>boundaryObjs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>optindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Archive</name>    <modifier>*</modifier></type><name>fout</name></decl>;</decl_stmt>			<comment type="block">/* the script file */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>g_verbose</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpencoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpsnapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>use_role</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>rowsPerInsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numWorkers</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>trivalue</name></type>	<name>prompt_password</name> <init>= <expr><name>TRI_DEFAULT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>compressLevel</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>plainText</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArchiveFormat</name></type> <name>archiveFormat</name> <init>= <expr><name>archUnknown</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArchiveMode</name></type> <name>archiveMode</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>DumpOptions</name></type> <name>dopt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The default value for gp_syntax_option depends upon whether or not the
	 * backend is a GP or non-GP backend -- a GP backend defaults to ENABLED.
	 */</comment>
	<enum><specifier>static</specifier> enum
	<block>{
		<decl><name>GPS_NOT_SPECIFIED</name></decl>, <decl><name>GPS_DISABLED</name></decl>, <decl><name>GPS_ENABLED</name></decl>
	}</block>			<decl><name>gp_syntax_option</name> <init>= <expr><name>GPS_NOT_SPECIFIED</name></expr></init></decl>;</enum>

	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"data-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'a'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"blobs"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'b'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-blobs"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'B'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"clean"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'c'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"create"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'C'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"dbname"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"file"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'f'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"format"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'F'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"host"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"jobs"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'j'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-reconnect"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'R'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-owner"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'O'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"schema"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"exclude-schema"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'N'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"schema-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"superuser"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"table"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"exclude-table"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'T'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'w'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'W'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"username"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'U'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"verbose"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'v'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-privileges"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'x'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-acl"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'x'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"compress"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'Z'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"encoding"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'E'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'?'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,

		<comment type="block">/*
		 * the following options don't have an equivalent short option letter
		 */</comment>
		<expr><block>{<expr><literal type="string">"attribute-inserts"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>column_inserts</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"binary-upgrade"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>binary_upgrade</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"column-inserts"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>column_inserts</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"disable-dollar-quoting"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>disable_dollar_quoting</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"disable-triggers"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>disable_triggers</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"enable-row-security"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>enable_row_security</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"exclude-table-data"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"extra-float-digits"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">8</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"if-exists"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>if_exists</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"inserts"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">9</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"lock-wait-timeout"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-tablespaces"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>outputNoTablespaces</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"quote-all-identifiers"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name>quote_all_identifiers</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"load-via-partition-root"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>load_via_partition_root</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"role"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"section"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"serializable-deferrable"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>serializable_deferrable</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"snapshot"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"strict-names"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name>strict_names</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"use-set-session-authorization"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>use_setsessauth</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-comments"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_comments</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-publications"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_publications</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-security-labels"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_security_labels</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-synchronized-snapshots"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_synchronized_snapshots</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-unlogged-table-data"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_unlogged_table_data</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-subscriptions"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_subscriptions</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-sync"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"on-conflict-do-nothing"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>do_nothing</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"rows-per-insert"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">10</literal></expr>}</block></expr>,

		<comment type="block">/* START MPP ADDITION */</comment>

		<comment type="block">/*
		 * the following are mpp specific, and don't have an equivalent short
		 * option
		 */</comment>
		<expr><block>{<expr><literal type="string">"gp-syntax"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1000</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-gp-syntax"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1001</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"function-oids"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1002</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"relation-oids"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1003</literal></expr>}</block></expr>,
		<comment type="block">/* END MPP ADDITION */</comment>
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_logging_init</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_logging_set_level</name><argument_list>(<argument><expr><name>PG_LOG_WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"pg_dump"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize what we need for parallel execution, especially for thread
	 * support on Windows.
	 */</comment>
	<expr_stmt><expr><call><name>init_parallel_dump_utils</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>g_comment_start</name></expr></argument>, <argument><expr><literal type="string">"-- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g_comment_end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>g_opaque_type</name></expr></argument>, <argument><expr><literal type="string">"opaque"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>help</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"pg_dump (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InitDumpOptions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"abBcCd:E:f:F:h:j:n:N:oOp:RsS:t:T:U:vwWxZ:"</literal></expr></argument>,
							<argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'a'</literal></expr>:</case>			<comment type="block">/* Dump data only */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dataOnly</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'b'</literal></expr>:</case>			<comment type="block">/* Dump blobs */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputBlobs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'B'</literal></expr>:</case>			<comment type="block">/* Don't dump blobs */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dontOutputBlobs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'c'</literal></expr>:</case>			<comment type="block">/* clean (i.e., drop) schema prior to create */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputClean</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'C'</literal></expr>:</case>			<comment type="block">/* Create DB */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputCreateDB</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'d'</literal></expr>:</case>			<comment type="block">/* database name */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dbname</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'E'</literal></expr>:</case>			<comment type="block">/* Dump encoding */</comment>
				<expr_stmt><expr><name>dumpencoding</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
				<expr_stmt><expr><name>format</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'h'</literal></expr>:</case>			<comment type="block">/* server host */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>pghost</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'j'</literal></expr>:</case>			<comment type="block">/* number of dump jobs */</comment>
				<expr_stmt><expr><name>numWorkers</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'n'</literal></expr>:</case>			<comment type="block">/* include schema(s) */</comment>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema_include_patterns</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>include_everything</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'N'</literal></expr>:</case>			<comment type="block">/* exclude schema(s) */</comment>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema_exclude_patterns</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'O'</literal></expr>:</case>			<comment type="block">/* Don't reconnect to match owner */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputNoOwner</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'p'</literal></expr>:</case>			<comment type="block">/* server port */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>pgport</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<comment type="block">/* no-op, still accepted for backwards compatibility */</comment>
				<break>break;</break>

			<case>case <expr><literal type="char">'s'</literal></expr>:</case>			<comment type="block">/* dump schema only */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'S'</literal></expr>:</case>			<comment type="block">/* Username for superuser in plain text output */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputSuperuser</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'t'</literal></expr>:</case>			<comment type="block">/* include table(s) */</comment>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_include_patterns</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>include_everything</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'T'</literal></expr>:</case>			<comment type="block">/* exclude table(s) */</comment>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_exclude_patterns</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'U'</literal></expr>:</case>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>username</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'v'</literal></expr>:</case>			<comment type="block">/* verbose */</comment>
				<expr_stmt><expr><name>g_verbose</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_logging_set_level</name><argument_list>(<argument><expr><name>PG_LOG_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'w'</literal></expr>:</case>
				<expr_stmt><expr><name>prompt_password</name> <operator>=</operator> <name>TRI_NO</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
				<expr_stmt><expr><name>prompt_password</name> <operator>=</operator> <name>TRI_YES</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'x'</literal></expr>:</case>			<comment type="block">/* skip ACL dump */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>aclsSkip</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'Z'</literal></expr>:</case>			<comment type="block">/* Compression Level */</comment>
				<expr_stmt><expr><name>compressLevel</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>compressLevel</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>compressLevel</name></expr></argument> &gt;</argument_list></name> <literal type="number">9</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"compression level must be in range 0..9"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">0</literal></expr>:</case>
				<comment type="block">/* This covers the long options. */</comment>
				<break>break;</break>

			<case>case <expr><literal type="number">2</literal></expr>:</case>				<comment type="block">/* lock-wait-timeout */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>lockWaitTimeout</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">3</literal></expr>:</case>				<comment type="block">/* SET ROLE */</comment>
				<expr_stmt><expr><name>use_role</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">4</literal></expr>:</case>				<comment type="block">/* exclude table(s) data */</comment>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tabledata_exclude_patterns</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">5</literal></expr>:</case>				<comment type="block">/* section */</comment>
				<expr_stmt><expr><call><name>set_dump_section</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>dumpSections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">6</literal></expr>:</case>				<comment type="block">/* snapshot */</comment>
				<expr_stmt><expr><name>dumpsnapshot</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">7</literal></expr>:</case>				<comment type="block">/* no-sync */</comment>
				<expr_stmt><expr><name>dosync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="number">8</literal></expr>:</case>
                <expr_stmt><expr><name>have_extra_float_digits</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>extra_float_digits</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>extra_float_digits</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">15</literal> <operator>||</operator> <name>extra_float_digits</name></expr></argument> &gt;</argument_list></name> <literal type="number">3</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"extra_float_digits must be in range -15..3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="number">9</literal></expr>:</case>				<comment type="block">/* inserts */</comment>

                <comment type="block">/*
                 * dump_inserts also stores --rows-per-insert, careful not to
                 * overwrite that.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>dump_inserts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dump_inserts</name></name> <operator>=</operator> <name>DUMP_DEFAULT_ROWS_PER_INSERT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <case>case <expr><literal type="number">10</literal></expr>:</case>			<comment type="block">/* rows per insert */</comment>
                <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>rowsPerInsert</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>optarg</name> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator>
                        <name>rowsPerInsert</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>rowsPerInsert</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator>
                        <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"rows-per-insert must be in range %d..%d"</literal></expr></argument>,
                                 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dump_inserts</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>rowsPerInsert</name></expr>;</expr_stmt>
                <break>break;</break>

			<case>case <expr><literal type="number">1000</literal></expr>:</case>				<comment type="block">/* gp-syntax */</comment>
				<if_stmt><if>if <condition>(<expr><name>gp_syntax_option</name> <operator>!=</operator> <name>GPS_NOT_SPECIFIED</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"options \"--gp-syntax\" and \"--no-gp-syntax\" cannot be used together"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>gp_syntax_option</name> <operator>=</operator> <name>GPS_ENABLED</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">1001</literal></expr>:</case>				<comment type="block">/* no-gp-syntax */</comment>
				<if_stmt><if>if <condition>(<expr><name>gp_syntax_option</name> <operator>!=</operator> <name>GPS_NOT_SPECIFIED</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"options \"--gp-syntax\" and \"--no-gp-syntax\" cannot be used together"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>gp_syntax_option</name> <operator>=</operator> <name>GPS_DISABLED</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">1002</literal></expr>:</case>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>funcid_string_list</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>include_everything</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">1003</literal></expr>:</case>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relid_string_list</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>include_everything</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Non-option argument specifies database name as long as it wasn't
	 * already specified with -d / --dbname
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>.</operator><name>dbname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dbname</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Complain if any arguments remain */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"too many command-line arguments (first is \"%s\")"</literal></expr></argument>,
					 <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* --column-inserts implies --inserts */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>column_inserts</name></name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>.</operator><name>dump_inserts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dump_inserts</name></name> <operator>=</operator> <name>DUMP_DEFAULT_ROWS_PER_INSERT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Binary upgrade mode implies dumping sequence data even in schema-only
	 * mode.  This is not exposed as a separate option, but kept separate
	 * internally for clarity.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>sequence_data</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>dataOnly</name></name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"options -s/--schema-only and -a/--data-only cannot be used together"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>dataOnly</name></name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>.</operator><name>outputClean</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"options -c/--clean and -a/--data-only cannot be used together"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>if_exists</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>.</operator><name>outputClean</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"option --if-exists requires option -c/--clean"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * --inserts are already implied above if --column-inserts or
	 * --rows-per-insert were specified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>do_nothing</name></name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>.</operator><name>dump_inserts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"option --on-conflict-do-nothing requires option --inserts, --rows-per-insert, or --column-inserts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Identify archive format to emit */</comment>
	<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <call><name>parseArchiveFormat</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>archiveMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* archiveFormat specific setup */</comment>
	<if_stmt><if>if <condition>(<expr><name>archiveFormat</name> <operator>==</operator> <name>archNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>plainText</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Custom and directory formats are compressed by default, others not */</comment>
	<if_stmt><if>if <condition>(<expr><name>compressLevel</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>archiveFormat</name> <operator>==</operator> <name>archCustom</name> <operator>||</operator> <name>archiveFormat</name> <operator>==</operator> <name>archDirectory</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>compressLevel</name> <operator>=</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>compressLevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name>compressLevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"requested compression not available in this installation -- archive will be uncompressed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>compressLevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If emitting an archive format, we always want to emit a DATABASE item,
	 * in case --create is specified at pg_restore time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plainText</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputCreateDB</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On Windows we can only have at most MAXIMUM_WAIT_OBJECTS (= 64 usually)
	 * parallel jobs because that's the maximum limit for the
	 * WaitForMultipleObjects() call.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numWorkers</name> <operator>&lt;=</operator> <literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<operator>||</operator> <name>numWorkers</name> <operator>&gt;</operator> <name>MAXIMUM_WAIT_OBJECTS</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"invalid number of parallel jobs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Parallel backup only in the directory archive format so far */</comment>
	<if_stmt><if>if <condition>(<expr><name>archiveFormat</name> <operator>!=</operator> <name>archDirectory</name> <operator>&amp;&amp;</operator> <name>numWorkers</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"parallel backup only supported by the directory format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Open the output file */</comment>
	<expr_stmt><expr><name>fout</name> <operator>=</operator> <call><name>CreateArchive</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>archiveFormat</name></expr></argument>, <argument><expr><name>compressLevel</name></expr></argument>, <argument><expr><name>dosync</name></expr></argument>,
						 <argument><expr><name>archiveMode</name></expr></argument>, <argument><expr><name>setupDumpWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make dump options accessible right away */</comment>
	<expr_stmt><expr><call><name>SetArchiveOptions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Register the cleanup hook */</comment>
	<expr_stmt><expr><call><name>on_exit_close_archive</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Let the archiver know how noisy to be */</comment>
	<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <name>g_verbose</name></expr>;</expr_stmt>


	<comment type="block">/*
	 * We allow the server to be back to 8.3, and up to any minor release of
	 * our own major version.  (See also version check in pg_dumpall.c.)
	 */</comment>
	<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>minRemoteVersion</name></name> <operator>=</operator> <name>GPDB5_MAJOR_PGVERSION</name></expr>;</expr_stmt>	<comment type="block">/* we can handle back to 8.3 */</comment>
	<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>maxRemoteVersion</name></name> <operator>=</operator> <operator>(</operator><name>PG_VERSION_NUM</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <literal type="number">99</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>numWorkers</name></name> <operator>=</operator> <name>numWorkers</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the database using the Archiver, so it knows about it. Errors mean
	 * death.
	 */</comment>
	<expr_stmt><expr><call><name>ConnectDatabase</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>dopt</name><operator>.</operator><name>dbname</name></name></expr></argument>, <argument><expr><name><name>dopt</name><operator>.</operator><name>pghost</name></name></expr></argument>, <argument><expr><name><name>dopt</name><operator>.</operator><name>pgport</name></name></expr></argument>, <argument><expr><name><name>dopt</name><operator>.</operator><name>username</name></name></expr></argument>, <argument><expr><name>prompt_password</name></expr></argument>, <argument><expr><name><name>dopt</name><operator>.</operator><name>binary_upgrade</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setup_connection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>dumpencoding</name></expr></argument>, <argument><expr><name>dumpsnapshot</name></expr></argument>, <argument><expr><name>use_role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine whether or not we're interacting with a GP backend.
	 */</comment>
	<expr_stmt><expr><call><name>testGPbackend</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that the type of backend is known, determine the gp-syntax option
	 * value and set processing accordingly.
	 */</comment>
	<switch>switch <condition>(<expr><name>gp_syntax_option</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GPS_NOT_SPECIFIED</name></expr>:</case>
			<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dumpGpPolicy</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>isGPbackend</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GPS_DISABLED</name></expr>:</case>
			<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dumpGpPolicy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GPS_ENABLED</name></expr>:</case>
			<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dumpGpPolicy</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>isGPbackend</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>.</operator><name>isGPbackend</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"server is not a Greenplum Database instance; --gp-syntax option ignored"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Disable security label support if server version &lt; v9.1.x (prevents
	 * access to nonexistent pg_seclabel catalog)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>no_security_labels</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On hot standbys, never try to dump unlogged table data, since it will
	 * just throw an error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>isStandby</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>no_unlogged_table_data</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check the version for the synchronized snapshots feature */</comment>
	<if_stmt><if>if <condition>(<expr><name>numWorkers</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90200</literal>
		<operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>.</operator><name>no_synchronized_snapshots</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Synchronized snapshots are not supported by this server version.\n"</literal>
			  <literal type="string">"Run with --no-synchronized-snapshots instead if you do not need\n"</literal>
			  <literal type="string">"synchronized snapshots."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check the version when a snapshot is explicitly specified by user */</comment>
	<if_stmt><if>if <condition>(<expr><name>dumpsnapshot</name> <operator>&amp;&amp;</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Exported snapshots are not supported by this server version."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>g_last_builtin_oid</name> <operator>=</operator> <name>FirstNormalObjectId</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"last built-in OID is %u"</literal></expr></argument>, <argument><expr><name>g_last_builtin_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Expand schema selection patterns into OID lists */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>schema_include_patterns</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>expand_schema_name_patterns</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schema_include_patterns</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>schema_include_oids</name></expr></argument>,
									<argument><expr><name>strict_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>schema_include_oids</name><operator>.</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"no matching schemas were found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>expand_schema_name_patterns</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schema_exclude_patterns</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>schema_exclude_oids</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* non-matching exclusion patterns aren't an error */</comment>

	<comment type="block">/* Expand table selection patterns into OID lists */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>table_include_patterns</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>expand_table_name_patterns</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_include_patterns</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>table_include_oids</name></expr></argument>,
								   <argument><expr><name>strict_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>table_include_oids</name><operator>.</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"no matching tables were found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>expand_table_name_patterns</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_exclude_patterns</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>table_exclude_oids</name></expr></argument>,
							   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>expand_table_name_patterns</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tabledata_exclude_patterns</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>tabledata_exclude_oids</name></expr></argument>,
							   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* non-matching exclusion patterns aren't an error */</comment>


	<expr_stmt><expr><call><name>expand_oid_patterns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relid_string_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_include_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expand_oid_patterns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>funcid_string_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>function_include_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Dumping blobs is the default for dumps where an inclusion switch is not
	 * used (an "include everything" dump).  -B can be used to exclude blobs
	 * from those dumps.  -b can be used to include blobs even when an
	 * inclusion switch is used.
	 *
	 * -s means "schema only" and blobs are data, not schema, so we never
	 * include blobs when -s is used.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>include_everything</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>.</operator><name>dontOutputBlobs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputBlobs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Collect role names so we can map object owner OIDs to names.
	 */</comment>
	<expr_stmt><expr><call><name>collectRoleNames</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now scan the database and create DumpableObject structs for all the
	 * objects we intend to dump.
	 */</comment>
	<expr_stmt><expr><name>tblinfo</name> <operator>=</operator> <call><name>getSchemaData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>guessConstraintInheritance</name><argument_list>(<argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>getTableData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopt</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>buildMatViewRefreshDependencies</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTableDataFKConstraints</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>.</operator><name>sequence_data</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>getTableData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopt</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * In binary-upgrade mode, we do not have to worry about the actual blob
	 * data or the associated metadata that resides in the pg_largeobject and
	 * pg_largeobject_metadata tables, respectively.
	 *
	 * However, we do need to collect blob information as there may be
	 * comments or other information on blobs that we do need to dump out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>outputBlobs</name></name> <operator>||</operator> <name><name>dopt</name><operator>.</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>getBlobs</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Collect dependency data to assist in ordering the objects.
	 */</comment>
	<expr_stmt><expr><call><name>getDependencies</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setExtPartDependency</name><argument_list>(<argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Collect ACLs, comments, and security labels, if wanted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>.</operator><name>aclsSkip</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>getAdditionalACLs</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>.</operator><name>no_comments</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>collectComments</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>.</operator><name>no_security_labels</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>collectSecLabels</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Lastly, create dummy objects to represent the section boundaries */</comment>
	<expr_stmt><expr><name>boundaryObjs</name> <operator>=</operator> <call><name>createBoundaryObjects</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get pointers to all the known DumpableObjects */</comment>
	<expr_stmt><expr><call><name>getDumpableObjects</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dobjs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add dummy dependencies to enforce the dump section ordering.
	 */</comment>
	<expr_stmt><expr><call><name>addBoundaryDependencies</name><argument_list>(<argument><expr><name>dobjs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>, <argument><expr><name>boundaryObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sort the objects into a safe dump order (no forward references).
	 *
	 * We rely on dependency information to help us determine a safe order, so
	 * the initial sort is mostly for cosmetic purposes: we sort by name to
	 * ensure that logically identical schemas will dump identically.
	 */</comment>
	<expr_stmt><expr><call><name>sortDumpableObjectsByTypeName</name><argument_list>(<argument><expr><name>dobjs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sortDumpableObjects</name><argument_list>(<argument><expr><name>dobjs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>,
						<argument><expr><name><name>boundaryObjs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>dumpId</name></expr></argument>, <argument><expr><name><name>boundaryObjs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>dumpId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create archive TOC entries for all the objects to be dumped, in a safe
	 * order.
	 */</comment>

	<comment type="block">/* First the special ENCODING, STDSTRINGS, and SEARCHPATH entries. */</comment>
	<expr_stmt><expr><call><name>dumpEncoding</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dumpStdStrings</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dumpSearchPath</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The database items are always next, unless we don't want them at all */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>outputCreateDB</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpDatabase</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>binfo_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Now the rearrangeable objects. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numObjs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dumpDumpableObject</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>dobjs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dobjs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_BINARY_UPGRADE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>binfo_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Amend the Oid preassignment TOC with the actual Oids gathered */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator> <name>binfo_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpPreassignedOidDefinition</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>BinaryUpgradeInfo</name> <operator>*</operator><operator>)</operator> <name><name>dobjs</name><index>[<expr><name>binfo_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set up options info to ensure we dump what we want.
	 */</comment>
	<expr_stmt><expr><name>ropt</name> <operator>=</operator> <call><name>NewRestoreOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>

	<comment type="block">/* if you change this list, see dumpOptionsFromRestoreOptions */</comment>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>dropSchema</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>outputClean</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>dataOnly</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>schemaOnly</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>if_exists</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>if_exists</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>column_inserts</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>column_inserts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>dumpSections</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>dumpSections</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>aclsSkip</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>aclsSkip</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>superuser</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>outputSuperuser</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>createDB</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>outputCreateDB</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>noOwner</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>outputNoOwner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>noTablespace</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>outputNoTablespaces</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>disable_triggers</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>disable_triggers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>use_setsessauth</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>use_setsessauth</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>disable_dollar_quoting</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>disable_dollar_quoting</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>dump_inserts</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>dump_inserts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>no_comments</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>no_comments</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>no_publications</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>no_publications</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>no_security_labels</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>no_security_labels</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>no_subscriptions</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>no_subscriptions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>lockWaitTimeout</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>lockWaitTimeout</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>include_everything</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>include_everything</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>enable_row_security</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>enable_row_security</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>sequence_data</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>sequence_data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>binary_upgrade</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>compressLevel</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <name>compressLevel</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>suppressDumpWarnings</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* We've already shown them */</comment>

	<expr_stmt><expr><call><name>SetArchiveOptions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopt</name></expr></argument>, <argument><expr><name>ropt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark which entries should be output */</comment>
	<expr_stmt><expr><call><name>ProcessArchiveRestoreOptions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The archive's TOC entries are now marked as to which ones will actually
	 * be output, so we can set up their dependency lists properly. This isn't
	 * necessary for plain-text output, though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plainText</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BuildArchiveDependencies</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * And finally we can do the actual output.
	 *
	 * Note: for non-plain-text output formats, the output file is written
	 * inside CloseArchive().  This is, um, bizarre; but not worth changing
	 * right now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plainText</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RestoreArchive</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CloseArchive</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>help</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s dumps a database as a text file or to other formats.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s [OPTION]... [DBNAME]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nGeneral options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -f, --file=FILENAME          output file or directory name\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -F, --format=c|d|t|p         output file format (custom, directory, tar,\n"</literal>
			 <literal type="string">"                               plain text (default))\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -j, --jobs=NUM               use this many parallel jobs to dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -v, --verbose                verbose mode\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version                output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -Z, --compress=0-9           compression level for compressed formats\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --lock-wait-timeout=TIMEOUT  fail after waiting TIMEOUT for a table lock\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-sync                    do not wait for changes to be written safely to disk\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help                   show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions controlling the output content:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -a, --data-only              dump only the data, not the schema\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -b, --blobs                  include large objects in dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -B, --no-blobs               exclude large objects in dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -c, --clean                  clean (drop) database objects before recreating\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -C, --create                 include commands to create database in dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -E, --encoding=ENCODING      dump the data in encoding ENCODING\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n, --schema=SCHEMA          dump the named schema(s) only\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -N, --exclude-schema=SCHEMA  do NOT dump the named schema(s)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -O, --no-owner               skip restoration of object ownership in\n"</literal>
			 <literal type="string">"                               plain-text format\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s, --schema-only            dump only the schema, no data\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -S, --superuser=NAME         superuser user name to use in plain-text format\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -t, --table=TABLE            dump the named table(s) only\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -T, --exclude-table=TABLE    do NOT dump the named table(s)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -x, --no-privileges          do not dump privileges (grant/revoke)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --binary-upgrade             for use by upgrade utilities only\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --column-inserts             dump data as INSERT commands with column names\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --disable-dollar-quoting     disable dollar quoting, use SQL standard quoting\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --disable-triggers           disable triggers during data-only restore\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --enable-row-security        enable row security (dump only content user has\n"</literal>
			 <literal type="string">"                               access to)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --exclude-table-data=TABLE   do NOT dump data for the named table(s)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --extra-float-digits=NUM     override default setting for extra_float_digits\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --if-exists                  use IF EXISTS when dropping objects\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --inserts                    dump data as INSERT commands, rather than COPY\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --load-via-partition-root    load partitions via the root table\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-comments                do not dump comments\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-publications            do not dump publications\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-security-labels         do not dump security label assignments\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-subscriptions           do not dump subscriptions\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-synchronized-snapshots  do not use synchronized snapshots in parallel jobs\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-tablespaces             do not dump tablespace assignments\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-unlogged-table-data     do not dump unlogged table data\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --on-conflict-do-nothing     add ON CONFLICT DO NOTHING to INSERT commands\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --quote-all-identifiers      quote all identifiers, even if not key words\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --rows-per-insert=NROWS      number of rows per INSERT; implies --inserts\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --section=SECTION            dump named section (pre-data, data, or post-data)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --serializable-deferrable    wait until the dump can run without anomalies\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --snapshot=SNAPSHOT          use given snapshot for the dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --strict-names               require table and/or schema include patterns to\n"</literal>
			 <literal type="string">"                               match at least one entity each\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --use-set-session-authorization\n"</literal>
			 <literal type="string">"                               use SET SESSION AUTHORIZATION commands instead of\n"</literal>
			 <literal type="string">"                               ALTER OWNER commands to set ownership\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* START MPP ADDITION */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --gp-syntax                  dump with Greenplum Database syntax (default if gpdb)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-gp-syntax               dump without Greenplum Database syntax (default if postgresql)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --function-oids              dump only function(s) of given list of oids\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --relation-oids              dump only relation(s) of given list of oids\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* END MPP ADDITION */</comment>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nConnection options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -d, --dbname=DBNAME      database to dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -h, --host=HOSTNAME      database server host or socket directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -p, --port=PORT          database server port number\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -U, --username=NAME      connect as specified database user\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -w, --no-password        never prompt for password\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -W, --password           force password prompt (should happen automatically)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --role=ROLENAME          do SET ROLE before dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nIf no database name is supplied, then the PGDATABASE environment\n"</literal>
			 <literal type="string">"variable value is used.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Report bugs to &lt;bugs@greenplum.org&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_connection</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpencoding</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpsnapshot</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>use_role</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>std_strings</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>ALWAYS_SECURE_SEARCH_PATH_SQL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the client encoding if requested.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dumpencoding</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PQsetClientEncoding</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>dumpencoding</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"invalid client encoding \"%s\" specified"</literal></expr></argument>,
				  <argument><expr><name>dumpencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the active encoding and the standard_conforming_strings setting, so
	 * we know how to escape strings.
	 */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <call><name>PQclientEncoding</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>std_strings</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"standard_conforming_strings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>std_strings</name></name> <operator>=</operator> <operator>(</operator><name>std_strings</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>std_strings</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the role if requested.  In a parallel dump worker, we'll be passed
	 * use_role == NULL, but AH-&gt;use_role is already set (if user specified it
	 * originally) and we should use that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_role</name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>use_role</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_role</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>use_role</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set the role if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_role</name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SET ROLE %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>use_role</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* save it for possible later use by parallel workers */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>use_role</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>use_role</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>use_role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set the datestyle to ISO to ensure the dump's portability */</comment>
	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET DATESTYLE = ISO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Likewise, avoid using sql_standard intervalstyle */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET INTERVALSTYLE = POSTGRES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Use an explicitly specified extra_float_digits if it has been provided.
	 * Otherwise, set extra_float_digits so that we can dump float data
	 * exactly (given correctly implemented float I/O code, anyway).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_extra_float_digits</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET extra_float_digits TO %d"</literal></expr></argument>,
						  <argument><expr><name>extra_float_digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET extra_float_digits TO 3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET extra_float_digits TO 2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Disable synchronized scanning to prevent unpredictable
	 * changes in row ordering across a dump and reload.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET synchronize_seqscans TO off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The default for enable_nestloop is off in GPDB. However, many of the queries
	 * that we issue best run with nested loop joins, so enable it.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET enable_nestloop TO on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Disable timeouts if supported.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET statement_timeout = 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET lock_timeout = 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET idle_in_transaction_session_timeout = 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Quote all identifiers, if requested.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>quote_all_identifiers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET quote_all_identifiers = true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Adjust row-security mode, if supported.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>enable_row_security</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET row_security = on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET row_security = off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize prepared-query state to "nothing prepared".  We do this here
	 * so that a parallel dump worker will have its own state.
	 */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>is_prepared</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>NUM_PREP_QUERIES</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start transaction-snapshot mode transaction to dump consistent data.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * To support the combination of serializable_deferrable with the jobs
		 * option we use REPEATABLE READ for the worker connections that are
		 * passed a snapshot.  As long as the snapshot is acquired in a
		 * SERIALIZABLE, READ ONLY, DEFERRABLE transaction, its use within a
		 * REPEATABLE READ transaction provides the appropriate integrity
		 * guarantees.  This is a kluge, but safe for back-patching.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>serializable_deferrable</name></name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>sync_snapshot_id</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
								<argument><expr><literal type="string">"SET TRANSACTION ISOLATION LEVEL "</literal>
								<literal type="string">"SERIALIZABLE, READ ONLY, DEFERRABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
								<argument><expr><literal type="string">"SET TRANSACTION ISOLATION LEVEL "</literal>
								<literal type="string">"REPEATABLE READ, READ ONLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
							<argument><expr><literal type="string">"SET TRANSACTION ISOLATION LEVEL "</literal>
							<literal type="string">"SERIALIZABLE, READ ONLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If user specified a snapshot to use, select that.  In a parallel dump
	 * worker, we'll be passed dumpsnapshot == NULL, but AH-&gt;sync_snapshot_id
	 * is already set (if the server can handle it) and we should use that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dumpsnapshot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sync_snapshot_id</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>dumpsnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>sync_snapshot_id</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SET TRANSACTION SNAPSHOT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralConn</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>sync_snapshot_id</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>numWorkers</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			 <name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal> <operator>&amp;&amp;</operator>
			 <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>no_synchronized_snapshots</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>isStandby</name></name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"Synchronized snapshots on standby servers are not supported by this server version.\n"</literal>
				  <literal type="string">"Run with --no-synchronized-snapshots instead if you do not need\n"</literal>
				  <literal type="string">"synchronized snapshots."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sync_snapshot_id</name></name> <operator>=</operator> <call><name>get_synchronized_snapshot</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Set up connection for a parallel worker process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setupDumpWorker</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We want to re-select all the same values the master connection is
	 * using.  We'll have inherited directly-usable values in
	 * AH-&gt;sync_snapshot_id and AH-&gt;use_role, but we need to translate the
	 * inherited encoding value back to a string to pass to setup_connection.
	 */</comment>
	<expr_stmt><expr><call><name>setup_connection</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
					 <argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_synchronized_snapshot</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><literal type="string">"SELECT pg_catalog.pg_export_snapshot()"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ArchiveFormat</name></type>
<name>parseArchiveFormat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>ArchiveMode</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveFormat</name></type> <name>archiveFormat</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>mode</name> <operator>=</operator> <name>archModeWrite</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"append"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This is used by pg_dumpall, and is not documented */</comment>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archNull</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>mode</name> <operator>=</operator> <name>archModeAppend</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"c"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archCustom</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"custom"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archCustom</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"d"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archDirectory</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"directory"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archDirectory</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archNull</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"plain"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archNull</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archTar</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"tar"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archTar</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"invalid output format \"%s\" specified"</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>archiveFormat</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the OIDs of all schemas matching the given list of patterns,
 * and append them to the given OID list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_schema_name_patterns</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
							<parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>patterns</name></decl></parameter>,
							<parameter><decl><type><name>SimpleOidList</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>strict_names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>patterns</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The loop below runs multiple SELECTs might sometimes result in
	 * duplicate entries in the OID list, but we don't care.
	 */</comment>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>patterns</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT oid FROM pg_catalog.pg_namespace n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strict_names</name> <operator>&amp;&amp;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"no matching schemas were found for pattern \"%s\""</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find the OIDs of all tables matching the given list of patterns,
 * and append them to the given OID list. See also expand_dbname_patterns()
 * in pg_dumpall.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_table_name_patterns</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
						   <parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>patterns</name></decl></parameter>, <parameter><decl><type><name>SimpleOidList</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>strict_names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>patterns</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * this might sometimes result in duplicate entries in the OID list, but
	 * we don't care.
	 */</comment>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>patterns</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Query must remain ABSOLUTELY devoid of unqualified names.  This
		 * would be unnecessary given a pg_table_is_visible() variant taking a
		 * search_path argument.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.oid"</literal>
						  <literal type="string">"\nFROM pg_catalog.pg_class c"</literal>
						  <literal type="string">"\n     LEFT JOIN pg_catalog.pg_namespace n"</literal>
						  <literal type="string">"\n     ON n.oid OPERATOR(pg_catalog.=) c.relnamespace"</literal>
						  <literal type="string">"\nWHERE c.relkind OPERATOR(pg_catalog.=) ANY"</literal>
						  <literal type="string">"\n    (array['%c', '%c', '%c', '%c', '%c', '%c'])\n"</literal></expr></argument>,
						  <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>, <argument><expr><name>RELKIND_VIEW</name></expr></argument>,
						  <argument><expr><name>RELKIND_MATVIEW</name></expr></argument>, <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>,
						  <argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"RESET search_path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
											<argument><expr><name>ALWAYS_SECURE_SEARCH_PATH_SQL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strict_names</name> <operator>&amp;&amp;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"no matching tables were found for pattern \"%s\""</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse the OIDs matching the given list of patterns separated by non-digit
 * characters, and append them to the given OID list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_oid_patterns</name><parameter_list>(<parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>patterns</name></decl></parameter>, <parameter><decl><type><name>SimpleOidList</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SimpleStringListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>patterns</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>patterns</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>seperator</name> <init>= <expr><literal type="string">","</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oidstr</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name> <init>= <expr><call><name>strtok</name><argument_list>(<argument><expr><name>oidstr</name></expr></argument>, <argument><expr><name>seperator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>token</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>seperator</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>seperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oidstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * checkExtensionMembership
 *		Determine whether object is an extension member, and if so,
 *		record an appropriate dependency and set the object's dump flag.
 *
 * It's important to call this for each object that could be an extension
 * member.  Generally, we integrate this with determining the object's
 * to-be-dumped-ness, since extension membership overrides other rules for that.
 *
 * Returns true if object is an extension member, else false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkExtensionMembership</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>ext</name> <init>= <expr><call><name>findOwningExtension</name><argument_list>(<argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>catId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>ext_member</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Record dependency so that getDependencies needn't deal with that */</comment>
	<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>ext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In 9.6 and above, mark the member object to have any non-initial ACL,
	 * policies, and security labels dumped.
	 *
	 * Note that any initial ACLs (see pg_init_privs) will be removed when we
	 * extract the information about the object.  We don't provide support for
	 * initial policies and security labels and it seems unlikely for those to
	 * ever exist, but we may have to revisit this later.
	 *
	 * Prior to 9.6, we do not include any extension member components.
	 *
	 * In binary upgrades, we still dump all components of the members
	 * individually, since the idea is to exactly reproduce the database
	 * contents rather than replace the extension contents with something
	 * different.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <name><name>ext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <name><name>ext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>&amp;</operator> <operator>(</operator><name>DUMP_COMPONENT_ACL</name> <operator>|</operator>
													<name>DUMP_COMPONENT_SECLABEL</name> <operator>|</operator>
													<name>DUMP_COMPONENT_POLICY</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableNamespace: policy-setting subroutine
 *		Mark a namespace as to be dumped or not
 *
 * Normally, we dump all extensions, or none of them if include_everything
 * is false (i.e., a --schema or --table switch was given).  However, in
 * binary-upgrade mode it's necessary to skip built-in extensions, since we
 * assume those will already be installed in the target database.  We identify
 * such extensions by their having OIDs in the range reserved for initdb.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableNamespace</name><parameter_list>(<parameter><decl><type><name>NamespaceInfo</name> <modifier>*</modifier></type><name>nsinfo</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If specific tables are being dumped, do not dump any complete
	 * namespaces. If specific namespaces are being dumped, dump just those
	 * namespaces. Otherwise, dump all non-system namespaces.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>table_include_oids</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>schema_include_oids</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator>
			<ternary><condition><expr><call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema_include_oids</name></expr></argument>,
								   <argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal> <operator>&amp;&amp;</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In 9.6 and above, we dump out any ACLs defined in pg_catalog, if
		 * they are interesting (and not the original ACLs which were set at
		 * initdb time, see pg_init_privs).
		 */</comment>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"pg_"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"information_schema"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"gp_toolkit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Other system schemas don't get dumped */</comment>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"public"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The public schema is a strange beast that sits in a sort of
		 * no-mans-land between being a system object and a user object.  We
		 * don't want to dump creation or comment commands for it, because
		 * that complicates matters for non-superuser use of pg_dump.  But we
		 * should dump any ACL changes that have occurred for it, and of
		 * course we should dump contained objects.
		 *
		 * In Greenplum binary upgrades, we need to dump the public schema in
		 * order to maintain its Oid.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ALL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ALL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Also, make like it has a comment even if it doesn't; this is so
		 * that we'll emit a command to drop the comment, if appropriate.
		 * (Without this, we'd not call dumpComment for it.)
		 */</comment>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * In any case, a namespace can be excluded by an exclusion switch
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>&amp;&amp;</operator>
		<call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema_exclude_oids</name></expr></argument>,
							   <argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the schema belongs to an extension, allow extension membership to
	 * override the dump decision for the schema itself.  However, this does
	 * not change dump_contains, so this won't change what we do with objects
	 * within the schema.  (If they belong to the extension, they'll get
	 * suppressed by it, otherwise not.)
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableTable: policy-setting subroutine
 *		Mark a table as to be dumped or not
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableTable</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/*
	 * If specific tables are being dumped, dump just those tables; else, dump
	 * according to the parent namespace's dump flag.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>table_include_oids</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_include_oids</name></expr></argument>,
												   <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * In any case, a table can be excluded by an exclusion switch
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;&amp;</operator>
		<call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_exclude_oids</name></expr></argument>,
							   <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableType: policy-setting subroutine
 *		Mark a type as to be dumped or not
 *
 * If it's a table's rowtype or an autogenerated array type, we also apply a
 * special type code to facilitate sorting into the desired order.  (We don't
 * want to consider those to be ordinary types because that would bring tables
 * up into the datatype part of the dump order.)  We still set the object's
 * dump flag; that's not going to cause the dummy type to be dumped, but we
 * need it so that casts involving such types will be dumped correctly -- see
 * dumpCast.  This means the flag should be set the same as for the underlying
 * object (the table or base type).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableType</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* skip complex types, except for standalone composite types */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>tyinfo</name><operator>-&gt;</operator><name>typrelkind</name></name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tytable</name> <init>= <expr><call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_DUMMY_TYPE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tytable</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tytable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* skip auto-generated array types */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>isArray</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_DUMMY_TYPE</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fall through to set the dump flag; we assume that the subsequent
		 * rules will do the same thing as they would for the array's base
		 * type.  (We cannot reliably look up the base type here, since
		 * getTypes may not have processed it yet.)
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/* Dump based on if the contents of the namespace are being dumped */</comment>
	<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableFunction: policy-setting subroutine
 *		Mark a function as to be dumped or not
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableFunction</name><parameter_list>(<parameter><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If specific functions are being dumped, dump just those functions; else, dump
	 * according to the parent namespace's dump flag if parent namespace is not null;
	 * else, always dump the function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>function_include_oids</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>function_include_oids</name></expr></argument>,
												   <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableDefaultACL: policy-setting subroutine
 *		Mark a default ACL as to be dumped or not
 *
 * For per-schema default ACLs, dump if the schema is to be dumped.
 * Otherwise dump if we are dumping "everything".  Note that dataOnly
 * and aclsSkip are checked separately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableDefaultACL</name><parameter_list>(<parameter><decl><type><name>DefaultACLInfo</name> <modifier>*</modifier></type><name>dinfo</name></decl></parameter>, <parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Default ACLs can't be extension members */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>dinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* default ACLs are considered part of the namespace */</comment>
		<expr_stmt><expr><name><name>dinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>dinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableCast: policy-setting subroutine
 *		Mark a cast as to be dumped or not
 *
 * Casts do not belong to any particular namespace (since they haven't got
 * names), nor do they have identifiable owners.  To distinguish user-defined
 * casts from built-in ones, we must resort to checking whether the cast's
 * OID is in the range reserved for initdb.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableCast</name><parameter_list>(<parameter><decl><type><name>CastInfo</name> <modifier>*</modifier></type><name>cast</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cast</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/*
	 * This would be DUMP_COMPONENT_ACL for from-initdb casts, but they do not
	 * support ACLs currently.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>&lt;=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>g_last_builtin_oid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableProcLang: policy-setting subroutine
 *		Mark a procedural language as to be dumped or not
 *
 * Procedural languages do not belong to any particular namespace.  To
 * identify built-in languages, we must resort to checking whether the
 * language's OID is in the range reserved for initdb.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableProcLang</name><parameter_list>(<parameter><decl><type><name>ProcLangInfo</name> <modifier>*</modifier></type><name>plang</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plang</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/*
	 * Only include procedural languages when we are dumping everything.
	 *
	 * For from-initdb procedural languages, only include ACLs, as we do for
	 * the pg_catalog namespace.  We need this because procedural languages do
	 * not live in any namespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>&lt;=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>g_last_builtin_oid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90600</literal></expr> ?</condition><then>
				<expr><name>DUMP_COMPONENT_NONE</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_ACL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableAccessMethod: policy-setting subroutine
 *		Mark an access method as to be dumped or not
 *
 * Access methods do not belong to any particular namespace.  To identify
 * built-in access methods, we must resort to checking whether the
 * method's OID is in the range reserved for initdb.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableAccessMethod</name><parameter_list>(<parameter><decl><type><name>AccessMethodInfo</name> <modifier>*</modifier></type><name>method</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>method</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/*
	 * This would be DUMP_COMPONENT_ACL for from-initdb access methods, but
	 * they do not support ACLs currently.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>method</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>&lt;=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>g_last_builtin_oid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>method</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>method</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableExtension: policy-setting subroutine
 *		Mark an extension as to be dumped or not
 *
 * Built-in extensions should be skipped except for checking ACLs, since we
 * assume those will already be installed in the target database.  We identify
 * such extensions by their having OIDs in the range reserved for initdb.
 * We dump all user-added extensions by default, or none of them if
 * include_everything is false (i.e., a --schema or --table switch was given).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableExtension</name><parameter_list>(<parameter><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>extinfo</name></decl></parameter>, <parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Use DUMP_COMPONENT_ACL for built-in extensions, to allow users to
	 * change permissions on their member objects, if they wish to, and have
	 * those changes preserved.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>&lt;=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>g_last_builtin_oid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator>
			<ternary><condition><expr><name><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then> <expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>:
			<expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpablePublicationTable: policy-setting subroutine
 *		Mark a publication table as to be dumped or not
 *
 * Publication tables have schemas, but those are ignored in decision making,
 * because publications are only dumped when we are dumping everything.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpablePublicationTable</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then>
		<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableObject: policy-setting subroutine
 *		Mark a generic dumpable object as to be dumped or not
 *
 * Use this only for object types without a special-case routine above.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableObject</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/*
	 * Default policy is to dump if parent namespace is dumpable, or for
	 * non-namespace-associated items, dump if we're dumping "everything".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>namespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <name><name>dobj</name><operator>-&gt;</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	Dump a table's contents for loading using the COPY command
 *	- this routine is called by the Archiver when it wants the table
 *	  to be dumped.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dumpTableData_copy</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>dcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name> <init>= <expr><operator>(</operator><name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>dcontext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>classname</name> <init>= <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: can't use getThreadLocalPQExpBuffer() here, we're calling fmtId
	 * which uses it already.
	 */</comment>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>clistBuf</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copybuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>column_list</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"dumping contents of table \"%s.%s\""</literal></expr></argument>,
				<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Specify the column list explicitly so that we have no possibility of
	 * retrieving data in the wrong column order.  (The default column
	 * ordering of COPY will not be what we want in certain corner cases
	 * involving ADD COLUMN and inheritance.)
	 */</comment>
	<expr_stmt><expr><name>column_list</name> <operator>=</operator> <call><name>fmtCopyColumnList</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>clistBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tdinfo</name><operator>-&gt;</operator><name>filtercond</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"COPY (SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* klugery to get rid of parens in column list */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>column_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>column_list</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>q</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"* "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"FROM %s %s) TO stdout;"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>filtercond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"COPY %s %s TO stdout;"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>column_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_COPY_OUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>clistBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copybuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* done or error */</comment>

		<if_stmt><if>if <condition>(<expr><name>copybuf</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WriteData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>copybuf</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* ----------
		 * THROTTLE:
		 *
		 * There was considerable discussion in late July, 2000 regarding
		 * slowing down pg_dump when backing up large tables. Users with both
		 * slow &amp; fast (multi-processor) machines experienced performance
		 * degradation when doing a backup.
		 *
		 * Initial attempts based on sleeping for a number of ms for each ms
		 * of work were deemed too complex, then a simple 'sleep in each loop'
		 * implementation was suggested. The latter failed because the loop
		 * was too tight. Finally, the following was implemented:
		 *
		 * If throttle is non-zero, then
		 *		See how long since the last sleep.
		 *		Work out how long to sleep (based on ratio).
		 *		If sleep is more than 100ms, then
		 *			sleep
		 *			reset timer
		 *		EndIf
		 * EndIf
		 *
		 * where the throttle value was the number of ms to sleep per ms of
		 * work. The calculation was done in each loop.
		 *
		 * Most of the hard work is done in the backend, and this solution
		 * still did not work particularly well: on slow machines, the ratio
		 * was 50:1, and on medium paced machines, 1:1, and on fast
		 * multi-processor machines, it had little or no effect, for reasons
		 * that were unclear.
		 *
		 * Further discussion ensued, and the proposal was dropped.
		 *
		 * For those people who want this feature, it can be implemented using
		 * gettimeofday in each loop, calculating the time since last sleep,
		 * multiplying that by the sleep ratio, then if the result is more
		 * than a preset 'minimum sleep time' (say 100ms), call the 'select'
		 * function to sleep for a subsecond period ie.
		 *
		 * select(0, NULL, NULL, NULL, &amp;tvi);
		 *
		 * This will return after the interval specified in the structure tvi.
		 * Finally, call gettimeofday again to save the 'last sleep time'.
		 * ----------
		 */</comment>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>archprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"\\.\n\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* copy data transfer failed */</comment>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Dumping the contents of table \"%s\" failed: PQgetCopyData() failed."</literal></expr></argument>, <argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Error message from server: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The command was: %s"</literal></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check command status and return to normal libpq state */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Dumping the contents of table \"%s\" failed: PQgetResult() failed."</literal></expr></argument>, <argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"Error message from server: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"The command was: %s"</literal></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do this to ensure we've pumped libpq back to idle state */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"unexpected extra results during COPY of table \"%s\""</literal></expr></argument>,
					   <argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Dump table data using INSERT commands.
 *
 * Caution: when we restore from an archive file direct to database, the
 * INSERT commands emitted by this function have to be parsed by
 * pg_backup_db.c's ExecuteSimpleCommands(), which will not handle comments,
 * E'' strings, or dollar-quoted strings.  So don't emit anything like that.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dumpTableData_insert</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>dcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name> <init>= <expr><operator>(</operator><name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>dcontext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>insertStmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rows_per_statement</name> <init>= <expr><name><name>dopt</name><operator>-&gt;</operator><name>dump_inserts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rows_this_statement</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"DECLARE _pg_dump_cursor CURSOR FOR "</literal>
					  <literal type="string">"SELECT * FROM ONLY %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tdinfo</name><operator>-&gt;</operator><name>filtercond</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>filtercond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"FETCH 100 FROM _pg_dump_cursor"</literal></expr></argument>,
							  <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nfields</name> <operator>=</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * First time through, we build as much of the INSERT statement as
		 * possible in "insertStmt", which we can then just print for each
		 * statement. If the table happens to have zero columns then this will
		 * be a complete statement, otherwise it will end in "VALUES" and be
		 * ready to have the row's column values printed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>insertStmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>targettab</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>insertStmt</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * When load-via-partition-root is set, get the root table name
			 * for the partition table, so that we can reload data through the
			 * root table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>load_via_partition_root</name></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>targettab</name> <operator>=</operator> <call><name>getRootTableInfo</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>targettab</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %s "</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>targettab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* corner case for zero-column table */</comment>
			<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT VALUES;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* append the list of column names if required */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>column_inserts</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<for>for <control>(<init><decl><type><name>int</name></type> <name>field</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>field</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>field</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>field</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>,
											 <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><call><name>PQfname</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>needs_override</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">"OVERRIDING SYSTEM VALUE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">"VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>tuple</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>tuple</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>tuple</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Write the INSERT if not in the middle of a multi-row INSERT. */</comment>
			<if_stmt><if>if <condition>(<expr><name>rows_this_statement</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><name><name>insertStmt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If it is zero-column table then we've already written the
			 * complete statement, which will mean we've disobeyed
			 * --rows-per-insert when it's set greater than 1.  We do support
			 * a way to make this multi-row with: SELECT UNION ALL SELECT
			 * UNION ALL ... but that's non-standard so we should avoid it
			 * given that using INSERTs is mostly only ever needed for
			 * cross-database exports.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Emit a row heading */</comment>
			<if_stmt><if>if <condition>(<expr><name>rows_per_statement</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">" ("</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>rows_this_statement</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">",\n\t("</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">"\n\t("</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<for>for <control>(<init><decl><type><name>int</name></type> <name>field</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>field</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>field</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>field</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attgenerated</name><index>[<expr><name>field</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* XXX This code is partially duplicated in ruleutils.c */</comment>
				<switch>switch <condition>(<expr><call><name>PQftype</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>INT2OID</name></expr>:</case>
					<case>case <expr><name>INT4OID</name></expr>:</case>
					<case>case <expr><name>INT8OID</name></expr>:</case>
					<case>case <expr><name>OIDOID</name></expr>:</case>
					<case>case <expr><name>FLOAT4OID</name></expr>:</case>
					<case>case <expr><name>FLOAT8OID</name></expr>:</case>
					<case>case <expr><name>NUMERICOID</name></expr>:</case>
						<block>{<block_content>
							<comment type="block">/*
							 * These types are printed without quotes unless
							 * they contain values that aren't accepted by the
							 * scanner unquoted (e.g., 'NaN').  Note that
							 * strtod() and friends might accept NaN, so we
							 * can't use that to test.
							 *
							 * In reality we only need to defend against
							 * infinity and NaN, so we need not get too crazy
							 * about pattern matching here.
							 */</comment>
							<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"0123456789 +-eE."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>archprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						</block_content>}</block>
						<break>break;</break>

					<case>case <expr><name>BITOID</name></expr>:</case>
					<case>case <expr><name>VARBITOID</name></expr>:</case>
						<expr_stmt><expr><call><name>archprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"B'%s'"</literal></expr></argument>,
								   <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>BOOLOID</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<break>break;</break>

					<default>default:</default>
						<comment type="block">/* All other types are printed as string literals. */</comment>
						<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
											  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></for>

			<comment type="block">/* Terminate the row ... */</comment>
			<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* ... and the statement, if the target no. of rows is reached */</comment>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>rows_this_statement</name> <operator>&gt;=</operator> <name>rows_per_statement</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>do_nothing</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">" ON CONFLICT DO NOTHING;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">";\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<comment type="block">/* Reset the row counter */</comment>
				<expr_stmt><expr><name>rows_this_statement</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Terminate any statements that didn't make the row count. */</comment>
	<if_stmt><if>if <condition>(<expr><name>rows_this_statement</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>do_nothing</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">" ON CONFLICT DO NOTHING;\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">";\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">"\n\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"CLOSE _pg_dump_cursor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>insertStmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getRootTableInfo:
 *     get the root TableInfo for the given partition table.
 */</comment>
<function><type><specifier>static</specifier> <name>TableInfo</name> <modifier>*</modifier></type>
<name>getRootTableInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parentTbinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>numParents</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>parentTbinfo</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>parents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>parentTbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parentTbinfo</name><operator>-&gt;</operator><name>numParents</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentTbinfo</name> <operator>=</operator> <name><name>parentTbinfo</name><operator>-&gt;</operator><name>parents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>parentTbinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTableData -
 *	  dump the contents of a single table
 *
 * Actually, this just makes an ArchiveEntry for the table contents.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTableData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>copyBuf</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>clistBuf</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DataDumperPtr</name></type> <name>dumpFn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copyStmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>copyFrom</name></decl>;</decl_stmt>

	<comment type="block">/* We had better have loaded per-column details about this table */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>interesting</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dump_inserts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Dump/restore using COPY */</comment>
		<expr_stmt><expr><name>dumpFn</name> <operator>=</operator> <name>dumpTableData_copy</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When load-via-partition-root is set, get the root table name for
		 * the partition table, so that we can reload data through the root
		 * table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>load_via_partition_root</name></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parentTbinfo</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>parentTbinfo</name> <operator>=</operator> <call><name>getRootTableInfo</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>copyFrom</name> <operator>=</operator> <call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>parentTbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>copyFrom</name> <operator>=</operator> <call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* must use 2 steps here 'cause fmtId is nonreentrant */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>copyBuf</name></expr></argument>, <argument><expr><literal type="string">"COPY %s "</literal></expr></argument>,
						  <argument><expr><name>copyFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>copyBuf</name></expr></argument>, <argument><expr><literal type="string">"%s FROM stdin;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtCopyColumnList</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>clistBuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>copyStmt</name> <operator>=</operator> <name><name>copyBuf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Restore using INSERT */</comment>
		<expr_stmt><expr><name>dumpFn</name> <operator>=</operator> <name>dumpTableData_insert</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>copyStmt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Note: although the TableDataInfo is a full DumpableObject, we treat its
	 * dependency on its table as "special" and pass it to ArchiveEntry now.
	 * See comments for BuildArchiveDependencies.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DATA</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
						  <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									   <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									   <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
									   <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TABLE DATA"</literal></expr></argument>,
									   <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_DATA</name></expr></argument>,
									   <argument><expr><operator>.</operator><name>copyStmt</name> <operator>=</operator> <name>copyStmt</name></expr></argument>,
									   <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>,
									   <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>,
									   <argument><expr><operator>.</operator><name>dumpFn</name> <operator>=</operator> <name>dumpFn</name></expr></argument>,
									   <argument><expr><operator>.</operator><name>dumpArg</name> <operator>=</operator> <name>tdinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set the TocEntry's dataLength in case we are doing a parallel dump
		 * and want to order dump jobs by table size.  We choose to measure
		 * dataLength in table pages during dump, so no scaling is needed.
		 * However, relpages is declared as "integer" in pg_class, and hence
		 * also in TableInfo, but it's really BlockNumber a/k/a unsigned int.
		 * Cast so that we get the right interpretation of table sizes
		 * exceeding INT_MAX pages.
		 */</comment>
		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>copyBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>clistBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * refreshMatViewData -
 *	  load or refresh the contents of a single materialized view
 *
 * Actually, this just makes an ArchiveEntry for the REFRESH MATERIALIZED VIEW
 * statement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>refreshMatViewData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>

	<comment type="block">/* If the materialized view is not flagged as populated, skip this. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relispopulated</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"REFRESH MATERIALIZED VIEW %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DATA</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
					 <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>,	<comment type="block">/* catalog ID */</comment>
					 <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,	<comment type="block">/* dump ID */</comment>
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"MATERIALIZED VIEW DATA"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dependencies</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>nDeps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTableData -
 *	  set up dumpable objects representing the contents of tables
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getTableData</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DATA</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>!</operator><name>relkind</name> <operator>||</operator> <name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>==</operator> <name>relkind</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>makeTableDataInfo</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Make a dumpable object for the data of this specific table
 *
 * Note: we make a TableDataInfo if and only if we are going to dump the
 * table data; the "dump" field in such objects isn't very interesting.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>makeTableDataInfo</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Nothing to do if we already decided to dump the table.  This will
	 * happen for "config" tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Skip VIEWs (no data to dump) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Skip FOREIGN TABLEs (no data to dump) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Skip EXTERNAL TABLEs (like foreign tables in GPDB 6.x and below) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relstorage</name></name> <operator>==</operator> <name>RELSTORAGE_EXTERNAL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Skip partitioned tables (data in partitions) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Don't dump data in unlogged tables, if so requested */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name> <operator>&amp;&amp;</operator>
		<name><name>dopt</name><operator>-&gt;</operator><name>no_unlogged_table_data</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check that the data is not explicitly excluded */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tabledata_exclude_oids</name></expr></argument>,
							   <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* OK, let's dump it */</comment>
	<expr_stmt><expr><name>tdinfo</name> <operator>=</operator> <operator>(</operator><name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TableDataInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_REFRESH_MATVIEW</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_SEQUENCE_SET</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TABLE_DATA</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Note: use tableoid 0 so that this object won't be mistaken for
	 * something that pg_depend entries apply to.
	 */</comment>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>filtercond</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* might get set later */</comment>
	<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* A TableDataInfo contains data, of course */</comment>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_DATA</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>=</operator> <name>tdinfo</name></expr>;</expr_stmt>

	<comment type="block">/* Make sure that we'll collect per-column info for this table. */</comment>
	<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>interesting</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The refresh for a materialized view must be dependent on the refresh for
 * any materialized view that this one is dependent on.
 *
 * This must be called after all the objects are created, but before they are
 * sorted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>buildMatViewRefreshDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_classid</name></decl>,
				<decl><type ref="prev"/><name>i_objid</name></decl>,
				<decl><type ref="prev"/><name>i_refobjid</name></decl>;</decl_stmt>

	<comment type="block">/* No Mat Views before 9.3. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90300</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"WITH RECURSIVE w AS "</literal>
						 <literal type="string">"( "</literal>
						 <literal type="string">"SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind "</literal>
						 <literal type="string">"FROM pg_depend d1 "</literal>
						 <literal type="string">"JOIN pg_class c1 ON c1.oid = d1.objid "</literal>
						 <literal type="string">"AND c1.relkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call>
						 <literal type="string">" JOIN pg_rewrite r1 ON r1.ev_class = d1.objid "</literal>
						 <literal type="string">"JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass "</literal>
						 <literal type="string">"AND d2.objid = r1.oid "</literal>
						 <literal type="string">"AND d2.refobjid &lt;&gt; d1.objid "</literal>
						 <literal type="string">"JOIN pg_class c2 ON c2.oid = d2.refobjid "</literal>
						 <literal type="string">"AND c2.relkind IN ("</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
						 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">") "</literal>
						 <literal type="string">"WHERE d1.classid = 'pg_class'::regclass "</literal>
						 <literal type="string">"UNION "</literal>
						 <literal type="string">"SELECT w.objid, d3.refobjid, c3.relkind "</literal>
						 <literal type="string">"FROM w "</literal>
						 <literal type="string">"JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid "</literal>
						 <literal type="string">"JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass "</literal>
						 <literal type="string">"AND d3.objid = r3.oid "</literal>
						 <literal type="string">"AND d3.refobjid &lt;&gt; w.refobjid "</literal>
						 <literal type="string">"JOIN pg_class c3 ON c3.oid = d3.refobjid "</literal>
						 <literal type="string">"AND c3.relkind IN ("</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
						 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">") "</literal>
						 <literal type="string">") "</literal>
						 <literal type="string">"SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid "</literal>
						 <literal type="string">"FROM w "</literal>
						 <literal type="string">"WHERE refrelkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_classid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"classid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_refobjid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"refobjid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>objId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>refobjId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>refdobj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>reftbinfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refobjId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <name><name>objId</name><operator>.</operator><name>tableoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refobjId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_refobjid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dobj</name> <operator>=</operator> <call><name>findObjectByCatalogId</name><argument_list>(<argument><expr><name>objId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tbinfo</name> <operator>=</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dobj</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>)</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dataObj</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_REFRESH_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>refdobj</name> <operator>=</operator> <call><name>findObjectByCatalogId</name><argument_list>(<argument><expr><name>refobjId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>refdobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>refdobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reftbinfo</name> <operator>=</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>refdobj</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reftbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>refdobj</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>)</operator> <name><name>reftbinfo</name><operator>-&gt;</operator><name>dataObj</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>refdobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>refdobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_REFRESH_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>refdobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>reftbinfo</name><operator>-&gt;</operator><name>relispopulated</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relispopulated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTableDataFKConstraints -
 *	  add dump-order dependencies reflecting foreign key constraints
 *
 * This code is executed only in a data-only dump --- in schema+data dumps
 * we handle foreign key issues by not creating the FK constraints until
 * after the data is loaded.  In a data-only dump, however, we want to
 * order the table data objects in such a way that a table's referenced
 * tables are restored first.  (In the presence of circular references or
 * self-references this may be impossible; we'll detect and complain about
 * that during the dependency sorting step.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getTableDataFKConstraints</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>dobjs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numObjs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Search through all the dumpable objects for FK constraints */</comment>
	<expr_stmt><expr><call><name>getDumpableObjects</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dobjs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numObjs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dobjs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_FK_CONSTRAINT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>cinfo</name> <init>= <expr><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>dobjs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>ftable</name></decl>;</decl_stmt>

			<comment type="block">/* Not interesting unless both tables are to be dumped */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cinfo</name><operator>-&gt;</operator><name>contable</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<name><name>cinfo</name><operator>-&gt;</operator><name>contable</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>ftable</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>cinfo</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ftable</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<name><name>ftable</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Okay, make referencing table's TABLE_DATA object depend on the
			 * referenced table's TABLE_DATA object.
			 */</comment>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cinfo</name><operator>-&gt;</operator><name>contable</name><operator>-&gt;</operator><name>dataObj</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
								<argument><expr><name><name>ftable</name><operator>-&gt;</operator><name>dataObj</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dobjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * guessConstraintInheritance:
 *	In pre-8.4 databases, we can't tell for certain which constraints
 *	are inherited.  We assume a CHECK constraint is inherited if its name
 *	matches the name of any constraint in the parent.  Originally this code
 *	tried to compare the expression texts, but that can fail for various
 *	reasons --- for example, if the parent and child tables are in different
 *	schemas, reverse-listing of function calls may produce different text
 *	(schema-qualified or not) depending on search path.
 *
 *	In 8.4 and up we can rely on the conislocal field to decide which
 *	constraints must be dumped; much safer.
 *
 *	This function assumes all conislocal flags were initialized to true.
 *	It clears the flag on anything that seems to be inherited.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>guessConstraintInheritance</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numParents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>parents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>

		<comment type="block">/* Some kinds never have parents */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>||</operator>
			<name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
			<name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Don't bother computing anything for non-target tables, either */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>numParents</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numParents</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parents</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>parents</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>numParents</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* nothing to see here, move along */</comment>

		<comment type="block">/* scan for inherited CHECK constraints */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>constr</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>checkexprs</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numParents</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>parent</name> <operator>=</operator> <name><name>parents</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>l</name> <operator>&lt;</operator> <name><name>parent</name><operator>-&gt;</operator><name>ncheck</name></name></expr>;</condition> <incr><expr><name>l</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>pconstr</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>checkexprs</name><index>[<expr><name>l</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pconstr</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>conislocal</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpPreassignedOidArchiveEntry</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>BinaryUpgradeInfo</name> <modifier>*</modifier></type><name>binfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type>	<name>setoidquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogId</name></type>	<name>maxoidid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>setoidquery</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>setoidquery</name></expr></argument>,
						 <argument><expr><literal type="string">"-- Placeholder for binary_upgrade_set_preassigned_oids()\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>maxoidid</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>maxoidid</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"binary_upgrade"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>maxoidid</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
				 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>tag</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <name>tag</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>setoidquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>setoidquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpPreassignedOidDefinition</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>BinaryUpgradeInfo</name> <modifier>*</modifier></type><name>binfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type>	<name>setoidquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleOidListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>setoidquery</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>setoidquery</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT binary_upgrade_set_preassigned_oids(ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>preassigned_oids</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>setoidquery</name></expr></argument>, <argument><expr><literal type="string">"%u%s"</literal></expr></argument>,
						  <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>setoidquery</name></expr></argument>, <argument><expr><literal type="string">"]::pg_catalog.oid[]);\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AmendArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>setoidquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>setoidquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpDatabase:
 *	dump the database definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpDatabase</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>dbQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>creaQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>labelq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>,
				<decl><type ref="prev"/><name>i_oid</name></decl>,
				<decl><type ref="prev"/><name>i_datname</name></decl>,
				<decl><type ref="prev"/><name>i_datdba</name></decl>,
				<decl><type ref="prev"/><name>i_encoding</name></decl>,
				<decl><type ref="prev"/><name>i_collate</name></decl>,
				<decl><type ref="prev"/><name>i_ctype</name></decl>,
				<decl><type ref="prev"/><name>i_frozenxid</name></decl>,
				<decl><type ref="prev"/><name>i_minmxid</name></decl>,
				<decl><type ref="prev"/><name>i_datacl</name></decl>,
				<decl><type ref="prev"/><name>i_acldefault</name></decl>,
				<decl><type ref="prev"/><name>i_datistemplate</name></decl>,
				<decl><type ref="prev"/><name>i_datconnlimit</name></decl>,
				<decl><type ref="prev"/><name>i_tablespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogId</name></type>	<name>dbCatId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpId</name></type>		<name>dbDumpId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableAcl</name></type> <name>dbdacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>datname</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>dba</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>encoding</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>collate</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ctype</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>datistemplate</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>datconnlimit</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tablespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>frozenxid</name></decl>,
				<decl><type ref="prev"/><name>minmxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qdatname</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"saving database definition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch the database-level properties for this database.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, datname, "</literal>
						  <literal type="string">"datdba, "</literal>
						  <literal type="string">"pg_encoding_to_char(encoding) AS encoding, "</literal>
						  <literal type="string">"datcollate, datctype, datfrozenxid, datminmxid, "</literal>
						  <literal type="string">"datacl, acldefault('d', datdba) AS acldefault, "</literal>
						  <literal type="string">"datistemplate, datconnlimit, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace, "</literal>
						  <literal type="string">"shobj_description(oid, 'pg_database') AS description "</literal>

						  <literal type="string">"FROM pg_database "</literal>
						  <literal type="string">"WHERE datname = current_database()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, datname, "</literal>
						  <literal type="string">"datdba, "</literal>
						  <literal type="string">"pg_encoding_to_char(encoding) AS encoding, "</literal>
						  <literal type="string">"datcollate, datctype, datfrozenxid, 0 AS datminmxid, "</literal>
						  <literal type="string">"datacl, acldefault('d', datdba) AS acldefault, "</literal>
						  <literal type="string">"datistemplate, datconnlimit, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace, "</literal>
						  <literal type="string">"shobj_description(oid, 'pg_database') AS description "</literal>

						  <literal type="string">"FROM pg_database "</literal>
						  <literal type="string">"WHERE datname = current_database()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, datname, "</literal>
						  <literal type="string">"datdba, "</literal>
						  <literal type="string">"pg_encoding_to_char(encoding) AS encoding, "</literal>
						  <literal type="string">"datcollate, datctype, datfrozenxid, 0 AS datminmxid, "</literal>
						  <literal type="string">"datacl, NULL AS acldefault, "</literal>
						  <literal type="string">"datistemplate, datconnlimit, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace, "</literal>
						  <literal type="string">"shobj_description(oid, 'pg_database') AS description "</literal>

						  <literal type="string">"FROM pg_database "</literal>
						  <literal type="string">"WHERE datname = current_database()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, datname, "</literal>
						  <literal type="string">"datdba, "</literal>
						  <literal type="string">"pg_encoding_to_char(encoding) AS encoding, "</literal>
						  <literal type="string">"NULL AS datcollate, NULL AS datctype, datfrozenxid, 0 AS datminmxid, "</literal>
						  <literal type="string">"datacl, NULL AS acldefault, "</literal>
						  <literal type="string">"datistemplate, datconnlimit, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace, "</literal>
						  <literal type="string">"shobj_description(oid, 'pg_database') AS description "</literal>

						  <literal type="string">"FROM pg_database "</literal>
						  <literal type="string">"WHERE datname = current_database()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>dbQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datdba</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datdba"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_encoding</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datcollate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ctype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datctype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_frozenxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datfrozenxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_minmxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datminmxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datistemplate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datistemplate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datconnlimit</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datconnlimit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tablespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dbCatId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dbCatId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_datname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dba</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_datdba</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collate</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>frozenxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_frozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minmxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_minmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dbdacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_datacl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dbdacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datistemplate</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_datistemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datconnlimit</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_datconnlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tablespace</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qdatname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>datname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare the CREATE DATABASE command.  We must specify encoding, locale,
	 * and tablespace since those can't be altered later.  Other DB properties
	 * are left to the DATABASE PROPERTIES entry, so that they can be applied
	 * after reconnecting to the target DB.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"CREATE DATABASE %s WITH TEMPLATE = template0"</literal></expr></argument>,
					  <argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">" ENCODING = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>collate</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">" LC_COLLATE = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><name>collate</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">" LC_CTYPE = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Note: looking at dopt-&gt;outputNoTablespaces here is completely the wrong
	 * thing; the decision whether to specify a tablespace should be left till
	 * pg_restore, so that pg_restore --no-tablespaces applies.  Ideally we'd
	 * label the DATABASE entry with the tablespace and let the normal
	 * tablespace selection logic work ... but CREATE DATABASE doesn't pay
	 * attention to default_tablespace, so that won't work.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>, <argument><expr><literal type="string">"pg_default"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>outputNoTablespaces</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">" TABLESPACE = %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>, <argument><expr><literal type="string">"DROP DATABASE %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dbDumpId</name> <operator>=</operator> <call><name>createDumpId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
				 <argument><expr><name>dbCatId</name></expr></argument>,		<comment type="block">/* catalog ID */</comment>
				 <argument><expr><name>dbDumpId</name></expr></argument>,		<comment type="block">/* dump ID */</comment>
				 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>datname</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name>dba</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"DATABASE"</literal></expr></argument>,
							  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>creaQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute correct tag for archive entry */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>, <argument><expr><literal type="string">"DATABASE %s"</literal></expr></argument>, <argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>comment</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>comment</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>comment</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>no_comments</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
			* Generates warning when loaded into a differently-named
			* database.
			*/</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">"COMMENT ON DATABASE %s IS "</literal></expr></argument>, <argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><name>comment</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
						<argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>labelq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									<argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name>dba</name></expr></argument>,
									<argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"COMMENT"</literal></expr></argument>,
									<argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_NONE</name></expr></argument>,
									<argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>dbQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									<argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><name>dbDumpId</name></expr></argument>,
									<argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Dump DB security label, if enabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>no_security_labels</name></name> <operator>&amp;&amp;</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>shres</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>seclabelQry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>seclabelQry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>buildShSecLabelQuery</name><argument_list>(<argument><expr><literal type="string">"pg_database"</literal></expr></argument>, <argument><expr><name><name>dbCatId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>seclabelQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>shres</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>seclabelQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>seclabelQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitShSecLabels</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>shres</name></expr></argument>, <argument><expr><name>seclabelQry</name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>, <argument><expr><name>datname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>seclabelQry</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>labelq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name>dba</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"SECURITY LABEL"</literal></expr></argument>,
									  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_NONE</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>seclabelQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><name>dbDumpId</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>seclabelQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>shres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Dump ACL if any.  Note that we do not support initial privileges
	 * (pg_init_privs) on databases.
	 */</comment>
	<expr_stmt><expr><name><name>dbdacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dbdacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>dbDumpId</name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>,
			<argument><expr><name>qdatname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
			<argument><expr><name>dba</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbdacl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now construct a DATABASE PROPERTIES archive entry to restore any
	 * non-default database-level properties.  (The reason this must be
	 * separate is that we cannot put any additional commands into the TOC
	 * entry that has CREATE DATABASE.  pg_restore would execute such a group
	 * in an implicit transaction block, and the backend won't allow CREATE
	 * DATABASE in that context.)
	 */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>datconnlimit</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>datconnlimit</name></expr></argument>, <argument><expr><literal type="string">"-1"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"ALTER DATABASE %s CONNECTION LIMIT = %s;\n"</literal></expr></argument>,
						  <argument><expr><name>qdatname</name></expr></argument>, <argument><expr><name>datconnlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>datistemplate</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"ALTER DATABASE %s IS_TEMPLATE = true;\n"</literal></expr></argument>,
						  <argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>, <argument><expr><literal type="string">"SET allow_system_table_mods = true;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The backend won't accept DROP DATABASE on a template database.  We
		 * can deal with that by removing the template marking before the DROP
		 * gets issued.  We'd prefer to use ALTER DATABASE IF EXISTS here, but
		 * since no such command is currently supported, fake it with a direct
		 * UPDATE on pg_database.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_database "</literal>
							 <literal type="string">"SET datistemplate = false WHERE datname = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>, <argument><expr><name>datname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>, <argument><expr><literal type="string">"RESET allow_system_table_mods;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add database-specific SET options */</comment>
	<expr_stmt><expr><call><name>dumpDatabaseConfig</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>creaQry</name></expr></argument>, <argument><expr><name>datname</name></expr></argument>, <argument><expr><name><name>dbCatId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We stick this binary-upgrade query into the DATABASE PROPERTIES archive
	 * entry, too, for lack of a better place.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set datfrozenxid and datminmxid.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"SET allow_system_table_mods = true;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_database\n"</literal>
						  <literal type="string">"SET datfrozenxid = '%u', datminmxid = '%u'\n"</literal>
						  <literal type="string">"WHERE datname = "</literal></expr></argument>,
						  <argument><expr><name>frozenxid</name></expr></argument>, <argument><expr><name>minmxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><name>datname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"RESET allow_system_table_mods;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>creaQry</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>datname</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name>dba</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"DATABASE PROPERTIES"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>creaQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><name>dbDumpId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * pg_largeobject comes from the old system intact, so set its
	 * relfrozenxids and relminmxids.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>lo_res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>loFrozenQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>loOutQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_relfrozenxid</name></decl>,
					<decl><type ref="prev"/><name>i_relminmxid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * pg_largeobject
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>loFrozenQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT relfrozenxid, relminmxid\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_class\n"</literal>
							  <literal type="string">"WHERE oid = %u;\n"</literal></expr></argument>,
							  <argument><expr><name>LargeObjectRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>loFrozenQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT relfrozenxid, 0 AS relminmxid\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_class\n"</literal>
							  <literal type="string">"WHERE oid = %u;\n"</literal></expr></argument>,
							  <argument><expr><name>LargeObjectRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>lo_res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>loFrozenQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_relfrozenxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="string">"relfrozenxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_relminmxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="string">"relminmxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>loOutQry</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set pg_largeobject relfrozenxid and relminmxid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>loOutQry</name></expr></argument>, <argument><expr><literal type="string">"SET allow_system_table_mods = true;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>loOutQry</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_class\n"</literal>
						  <literal type="string">"SET relfrozenxid = '%u', relminmxid = '%u'\n"</literal>
						  <literal type="string">"WHERE oid = %u;\n"</literal></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_relfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_relminmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>LargeObjectRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>loOutQry</name></expr></argument>, <argument><expr><literal type="string">"RESET allow_system_table_mods;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <literal type="string">"pg_largeobject"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"pg_largeobject"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>loOutQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>loFrozenQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>loOutQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Collect any database-specific or role-and-database-specific SET options
 * for this database, and append them to outbuf.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpDatabaseConfig</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>outbuf</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>buf</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * First collect database-specific options.  Pre-8.4 server versions lack
	 * unnest(), so we do this the hard way by querying once per subscript.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT setconfig[%d] FROM pg_db_role_setting "</literal>
							  <literal type="string">"WHERE setrole = 0 AND setdatabase = '%u'::oid"</literal></expr></argument>,
							  <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT datconfig[%d] FROM pg_database WHERE oid = '%u'::oid"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>makeAlterConfigCommand</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Now look for role-and-database-specific options */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Here we can assume we have unnest() */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT rolname, unnest(setconfig) "</literal>
						  <literal type="string">"FROM pg_db_role_setting s, pg_roles r "</literal>
						  <literal type="string">"WHERE setrole = r.oid AND setdatabase = '%u'::oid"</literal></expr></argument>,
						  <argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>makeAlterConfigCommand</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><literal type="string">"ROLE"</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>,
									   <argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're upgrading from GPDB 5, use the legacy hash ops.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <name>GPDB6_MAJOR_PGVERSION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>makeAlterConfigCommand</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"gp_use_legacy_hashops=on"</literal></expr></argument>,
							   <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpEncoding: put the correct encoding into the archive
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpEncoding</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encname</name> <init>= <expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>qry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"saving encoding = %s"</literal></expr></argument>, <argument><expr><name>encname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">"SET client_encoding = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>encname</name></expr></argument>, <argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
				 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <literal type="string">"ENCODING"</literal></expr></argument>,
							  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"ENCODING"</literal></expr></argument>,
							  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * dumpStdStrings: put the correct escape string behavior into the archive
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpStdStrings</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stdstrings</name> <init>= <expr><ternary><condition><expr><name><name>AH</name><operator>-&gt;</operator><name>std_strings</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>qry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"saving standard_conforming_strings = %s"</literal></expr></argument>,
				<argument><expr><name>stdstrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">"SET standard_conforming_strings = '%s';\n"</literal></expr></argument>,
					  <argument><expr><name>stdstrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
				 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <literal type="string">"STDSTRINGS"</literal></expr></argument>,
							  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"STDSTRINGS"</literal></expr></argument>,
							  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpSearchPath: record the active search_path in the archive
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpSearchPath</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>qry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>path</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>schemanames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nschemanames</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use the result of current_schemas(), not the search_path GUC,
	 * because that might contain wildcards such as "$user", which won't
	 * necessarily have the same value during restore.  Also, this way avoids
	 * listing schemas that may appear in search_path but not actually exist,
	 * which seems like a prudent exclusion.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
									  <argument><expr><literal type="string">"SELECT pg_catalog.current_schemas(false)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemanames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nschemanames</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not parse result of current_schemas()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We use set_config(), not a simple "SET search_path" command, because
	 * the latter has less-clean behavior if the search path is empty.  While
	 * that's likely to get fixed at some point, it seems like a good idea to
	 * be as backwards-compatible as possible in what we put into archives.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nschemanames</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>schemanames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.set_config('search_path', "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">", false);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"saving search_path = %s"</literal></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
				 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <literal type="string">"SEARCHPATH"</literal></expr></argument>,
							  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"SEARCHPATH"</literal></expr></argument>,
							  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also save it in AH-&gt;searchpath, in case we're doing plain text dump */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>searchpath</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemanames</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>schemanames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * getBlobs:
 *	Collect schema-level data about large objects
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getBlobs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>blobQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlobInfo</name>   <modifier>*</modifier></type><name>binfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>bdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lomowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lomacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_acldefault</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"reading large objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch BLOB OIDs, and owner/ACL data if &gt;= 9.0 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>blobQry</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT oid, lomowner, lomacl, "</literal>
						  <literal type="string">"acldefault('L', lomowner) AS acldefault "</literal>
						  <literal type="string">"FROM pg_largeobject_metadata"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>blobQry</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT oid, lomowner, lomacl, "</literal>
						  <literal type="string">"NULL AS acldefault "</literal>
						  <literal type="string">"FROM pg_largeobject_metadata"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>blobQry</name></expr></argument>,
							 <argument><expr><literal type="string">"SELECT DISTINCT loid AS oid, "</literal>
							 <literal type="string">"NULL::name AS rolname, NULL::oid AS lomacl, "</literal>
							 <literal type="string">"NULL::oid AS acldefault "</literal>
							 <literal type="string">" FROM pg_largeobject"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>blobQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lomowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lomowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lomacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lomacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Each large object has its own BLOB archive entry.
	 */</comment>
	<expr_stmt><expr><name>binfo</name> <operator>=</operator> <operator>(</operator><name>BlobInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BlobInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_BLOB</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <name>LargeObjectRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lomacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lomowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Blobs have data */</comment>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_DATA</name></expr>;</expr_stmt>

		<comment type="block">/* Mark whether blob has an ACL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lomacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * In binary-upgrade mode for blobs, we do *not* dump out the blob
		 * data, as it will be copied by pg_upgrade, which simply copies the
		 * pg_largeobject table. We *do* however dump out anything but the
		 * data, as pg_upgrade copies just pg_largeobject, but not
		 * pg_largeobject_metadata, after the dump is restored.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_DATA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we have any large objects, a "BLOBS" archive entry is needed. This
	 * is just a placeholder for sorting; it carries no data now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bdata</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdata</name><operator>-&gt;</operator><name>objType</name></name> <operator>=</operator> <name>DO_BLOB_DATA</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdata</name><operator>-&gt;</operator><name>catId</name></name> <operator>=</operator> <name>nilCatalogId</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><name>bdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdata</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"BLOBS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdata</name><operator>-&gt;</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_DATA</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>blobQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpBlob
 *
 * dump the definition (metadata) of the given large object
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpBlob</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BlobInfo</name> <modifier>*</modifier></type><name>binfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>cquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>dquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cquery</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.lo_create('%s');\n"</literal></expr></argument>,
					  <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dquery</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.lo_unlink('%s');\n"</literal></expr></argument>,
					  <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>binfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"BLOB"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>cquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>dquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump comment if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump security label if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump ACL if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>,
				<argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>binfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>cquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>dquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpBlobs:
 *	dump the data contents of all large objects
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dumpBlobs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>blobQry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>blobFetchQry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>LOBBUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"saving large objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently, we re-fetch all BLOB OIDs using a cursor.  Consider scanning
	 * the already-in-memory dumpable objects instead...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>blobQry</name> <operator>=</operator>
			<literal type="string">"DECLARE bloboid CURSOR FOR "</literal>
			<literal type="string">"SELECT oid FROM pg_largeobject_metadata ORDER BY 1"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>blobQry</name> <operator>=</operator>
			<literal type="string">"DECLARE bloboid CURSOR FOR "</literal>
			<literal type="string">"SELECT DISTINCT loid FROM pg_largeobject ORDER BY 1"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>blobQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Command to fetch from cursor */</comment>
	<expr_stmt><expr><name>blobFetchQry</name> <operator>=</operator> <literal type="string">"FETCH 1000 IN bloboid"</literal></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<comment type="block">/* Do a fetch */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>blobFetchQry</name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process the tuples, if any */</comment>
		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>blobOid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>loFd</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>blobOid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Open the BLOB */</comment>
			<expr_stmt><expr><name>loFd</name> <operator>=</operator> <call><name>lo_open</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>blobOid</name></expr></argument>, <argument><expr><name>INV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>loFd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not open large object %u: %s"</literal></expr></argument>,
					  <argument><expr><name>blobOid</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>StartBlob</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>blobOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Now read it in chunks, sending data to archive */</comment>
			<do>do
			<block>{<block_content>
				<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>lo_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>loFd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>LOBBUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"error reading large object %u: %s"</literal></expr></argument>,
						  <argument><expr><name>blobOid</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>WriteData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><name>cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

			<expr_stmt><expr><call><name>lo_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>loFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EndBlob</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>blobOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getPolicies
 *	  get information about all RLS policies on dumpable tables.
 */</comment>
<function><type><name>void</name></type>
<name>getPolicies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolicyInfo</name> <modifier>*</modifier></type><name>polinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polpermissive</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polroles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polqual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polwithcheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90500</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, check which tables have RLS enabled.  We represent RLS being
	 * enabled on a table by creating a PolicyInfo object with null polname.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore row security on tables not to be dumped */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_POLICY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rowsec</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_POLICY</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Note: use tableoid 0 so that this object won't be mistaken for
			 * something that pg_depend entries apply to.
			 */</comment>
			<expr_stmt><expr><name>polinfo</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PolicyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_POLICY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>poltable</name></name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polpermissive</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polroles</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polqual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polwithcheck</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now, read all RLS policies, and create PolicyInfo objects for all those
	 * that are of interest.
	 */</comment>
	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"reading row-level security policies"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT oid, tableoid, pol.polrelid, pol.polname, pol.polcmd, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"pol.polpermissive, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"'t' as polpermissive, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"CASE WHEN pol.polroles = '{0}' THEN NULL ELSE "</literal>
					  <literal type="string">"   pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, "</literal>
					  <literal type="string">"pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, "</literal>
					  <literal type="string">"pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck "</literal>
					  <literal type="string">"FROM pg_catalog.pg_policy pol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polcmd</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polcmd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polpermissive</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polpermissive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polroles</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polroles"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polqual</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polqual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polwithcheck</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polwithcheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>polinfo</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PolicyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>polrelid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><call><name>findTableByOid</name><argument_list>(<argument><expr><name>polrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Ignore row security on tables not to be dumped.  (This will
			 * result in some harmless wasted slots in polinfo[].)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_POLICY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_POLICY</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_POLICY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator>
				<call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>poltable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polcmd</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polcmd</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polpermissive</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polpermissive</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polroles</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polroles</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polroles</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polroles</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polqual</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polqual</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polqual</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polqual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polwithcheck</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polwithcheck</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polwithcheck</name>
					<operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polwithcheck</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpPolicy
 *	  dump the definition of the given policy
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpPolicy</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PolicyInfo</name> <modifier>*</modifier></type><name>polinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>polinfo</name><operator>-&gt;</operator><name>poltable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>polprefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtabname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If polname is NULL, then this record is just indicating that ROW LEVEL
	 * SECURITY is enabled for the table. Dump as ALTER TABLE &lt;table&gt; ENABLE
	 * ROW LEVEL SECURITY.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s ENABLE ROW LEVEL SECURITY;"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must emit the ROW SECURITY object's dependency on its table
		 * explicitly, because it will not match anything in pg_depend (unlike
		 * the case for other PolicyInfo objects).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
						 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"ROW SECURITY"</literal></expr></argument>,
									  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>,
									  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">" FOR SELECT"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">" FOR INSERT"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">" FOR UPDATE"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">" FOR DELETE"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"unexpected policy command type: %c"</literal></expr></argument>,
					 <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>polprefix</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qtabname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE POLICY %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" ON %s%s%s"</literal></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><ternary><condition><expr><operator>!</operator><name><name>polinfo</name><operator>-&gt;</operator><name>polpermissive</name></name></expr> ?</condition><then> <expr><literal type="string">" AS RESTRICTIVE"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polroles</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" TO %s"</literal></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polroles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polqual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" USING (%s)"</literal></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polqual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polwithcheck</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" WITH CHECK (%s)"</literal></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polwithcheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP POLICY %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">" ON %s;\n"</literal></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>polprefix</name></expr></argument>, <argument><expr><literal type="string">"POLICY %s ON"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>tag</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"POLICY"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>polprefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>qtabname</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>polprefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtabname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getPublications
 *	  get information about publications
 */</comment>
<function><type><name>PublicationInfo</name> <modifier>*</modifier></type>
<name>getPublications</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numPublications</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PublicationInfo</name> <modifier>*</modifier></type><name>pubinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_puballtables</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubinsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubupdate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubdelete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubtruncate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_publications</name></name> <operator>||</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numPublications</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the publications. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT p.tableoid, p.oid, p.pubname, "</literal>
						  <literal type="string">"p.pubowner, "</literal>
						  <literal type="string">"p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, false AS pubviaroot "</literal>
						  <literal type="string">"FROM pg_publication p"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT p.tableoid, p.oid, p.pubname, "</literal>
						  <literal type="string">"p.pubowner, "</literal>
						  <literal type="string">"p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, false AS pubtruncate, false AS pubviaroot "</literal>
						  <literal type="string">"FROM pg_publication p"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pubname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pubowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_puballtables</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"puballtables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pubinsert</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubinsert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pubupdate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubupdate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pubdelete</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubdelete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pubtruncate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubtruncate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pubinfo</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PublicationInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_PUBLICATION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator>
			<call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pubname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pubowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>puballtables</name> <operator>=</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_puballtables</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pubinsert</name> <operator>=</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pubinsert</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pubupdate</name> <operator>=</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pubupdate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pubdelete</name> <operator>=</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pubdelete</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pubtruncate</name> <operator>=</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pubtruncate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numPublications</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>
	<return>return <expr><name>pubinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpPublication
 *	  dump the definition of the given publication
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpPublication</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PublicationInfo</name> <modifier>*</modifier></type><name>pubinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qpubname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qpubname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP PUBLICATION %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qpubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE PUBLICATION %s"</literal></expr></argument>,
					  <argument><expr><name>qpubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>puballtables</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" FOR ALL TABLES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" WITH (publish = '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>pubinsert</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"insert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>pubupdate</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"update"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>pubdelete</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"delete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>pubtruncate</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"truncate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"');\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>pubinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"PUBLICATION"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"PUBLICATION"</literal></expr></argument>, <argument><expr><name>qpubname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"PUBLICATION"</literal></expr></argument>, <argument><expr><name>qpubname</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qpubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getPublicationTables
 *	  get information about publication membership for dumpable tables.
 */</comment>
<function><type><name>void</name></type>
<name>getPublicationTables</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PublicationRelInfo</name> <modifier>*</modifier></type><name>pubrinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prpubid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_publications</name></name> <operator>||</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Collect all publication membership info. */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT tableoid, oid, prpubid, prrelid "</literal>
						 <literal type="string">"FROM pg_catalog.pg_publication_rel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prpubid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prpubid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this allocation may be more than we need */</comment>
	<expr_stmt><expr><name>pubrinfo</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PublicationRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>prpubid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prpubid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>prrelid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PublicationInfo</name> <modifier>*</modifier></type><name>pubinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore any entries for which we aren't interested in either the
		 * publication or the rel.
		 */</comment>
		<expr_stmt><expr><name>pubinfo</name> <operator>=</operator> <call><name>findPublicationByOid</name><argument_list>(<argument><expr><name>prpubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pubinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tbinfo</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>prrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tbinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ignore publication membership of tables whose definitions are not
		 * to be dumped.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* OK, make a DumpableObject for this relationship */</comment>
		<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_PUBLICATION_REL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator>
			<call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>publication</name> <operator>=</operator> <name>pubinfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pubtable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpablePublicationTable</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpPublicationTable
 *	  dump the definition of the given publication table mapping
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpPublicationTable</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PublicationRelInfo</name> <modifier>*</modifier></type><name>pubrinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PublicationInfo</name> <modifier>*</modifier></type><name>pubinfo</name> <init>= <expr><name><name>pubrinfo</name><operator>-&gt;</operator><name>publication</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>pubrinfo</name><operator>-&gt;</operator><name>pubtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ALTER PUBLICATION %s ADD TABLE ONLY"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There is no point in creating a drop query as the drop is done by table
	 * drop.  (If you think to change this, see also _printTocEntry().)
	 * Although this object doesn't really have ownership as such, set the
	 * owner field anyway to ensure that the command is run by the correct
	 * role at restore time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pubrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>pubrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>pubrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>tag</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>pubinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"PUBLICATION TABLE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Is the currently connected user a superuser?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_superuser</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>fout</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><literal type="string">"is_superuser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getSubscriptions
 *	  get information about subscriptions
 */</comment>
<function><type><name>void</name></type>
<name>getSubscriptions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubscriptionInfo</name> <modifier>*</modifier></type><name>subinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_subname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_subowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_subconninfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_subslotname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_subsynccommit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_subpublications</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_subscriptions</name></name> <operator>||</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_superuser</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT count(*) FROM pg_subscription "</literal>
							  <literal type="string">"WHERE subdbid = (SELECT oid FROM pg_database"</literal>
							  <literal type="string">"                 WHERE datname = current_database())"</literal></expr></argument>,
							  <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"subscriptions not dumped because current user is not a superuser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the subscriptions in current database. */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT s.tableoid, s.oid, s.subname, "</literal>
					  <literal type="string">"s.subowner, "</literal>
					  <literal type="string">"s.subconninfo, s.subslotname, s.subsynccommit, "</literal>
					  <literal type="string">"s.subpublications "</literal>
					  <literal type="string">"FROM pg_subscription s "</literal>
					  <literal type="string">"WHERE s.subdbid = (SELECT oid FROM pg_database"</literal>
					  <literal type="string">"                   WHERE datname = current_database())"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_subname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"subname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_subowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"subowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_subconninfo</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"subconninfo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_subslotname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"subslotname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_subsynccommit</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"subsynccommit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_subpublications</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"subpublications"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>subinfo</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SubscriptionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_SUBSCRIPTION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator>
			<call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subconninfo</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subconninfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subslotname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subslotname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subslotname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subslotname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subsynccommit</name> <operator>=</operator>
			<call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subsynccommit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subpublications</name> <operator>=</operator>
			<call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subpublications</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpSubscription
 *	  dump the definition of the given subscription
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpSubscription</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubscriptionInfo</name> <modifier>*</modifier></type><name>subinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>publications</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qsubname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>pubnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>npubnames</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qsubname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP SUBSCRIPTION %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qsubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE SUBSCRIPTION %s CONNECTION "</literal></expr></argument>,
					  <argument><expr><name>qsubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>subconninfo</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build list of quoted publications and append them to query. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>subpublications</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pubnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>npubnames</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"could not parse subpublications array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pubnames</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pubnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pubnames</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npubnames</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>publications</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npubnames</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>publications</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>publications</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>pubnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" PUBLICATION %s WITH (connect = false, slot_name = "</literal></expr></argument>, <argument><expr><name><name>publications</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>subinfo</name><operator>-&gt;</operator><name>subslotname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>subslotname</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"NONE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>subsynccommit</name></name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", synchronous_commit = %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>subsynccommit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>subinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"SUBSCRIPTION"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SUBSCRIPTION"</literal></expr></argument>, <argument><expr><name>qsubname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SUBSCRIPTION"</literal></expr></argument>, <argument><expr><name>qsubname</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>publications</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pubnames</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pubnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qsubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a "create query", append as many ALTER ... DEPENDS ON EXTENSION as
 * the object needs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_depends_on_extension</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
							<parameter><decl><type><name>PQExpBuffer</name></type> <name>create</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>catalog</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>depends_on_ext</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>nm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type>	<name>query</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>ntups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>i_extname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* dodge fmtId() non-reentrancy */</comment>
		<expr_stmt><expr><name>nm</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT e.extname "</literal>
						  <literal type="string">"FROM pg_catalog.pg_depend d, pg_catalog.pg_extension e "</literal>
						  <literal type="string">"WHERE d.refobjid = e.oid AND classid = '%s'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND objid = '%u'::pg_catalog.oid AND deptype = 'x' "</literal>
						  <literal type="string">"AND refclassid = 'pg_catalog.pg_extension'::pg_catalog.regclass"</literal></expr></argument>,
						  <argument><expr><name>catalog</name></expr></argument>,
						  <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_extname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"extname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>create</name></expr></argument>, <argument><expr><literal type="string">"ALTER %s %s DEPENDS ON EXTENSION %s;\n"</literal></expr></argument>,
							  <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>nm</name></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_extname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>nm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>binary_upgrade_set_namespace_oid</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>pg_namespace_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type>	<name>upgrade_query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>upgrade_res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pg_nspname</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT nspname "</literal>
					  <literal type="string">"FROM pg_catalog.pg_namespace "</literal>
					  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid;"</literal></expr></argument>, <argument><expr><name>pg_namespace_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>upgrade_res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>upgrade_query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name>pg_namespace_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_namespace oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In PostgreSQL, the creation of the public schema is not dumped, because
	 * it's assumed to exist in a new cluster. But in GPDB, we need to re-create
	 * it, so that we can set its OID. This change is required because Oid
	 * preassignment during upgrade requires the namespace. If the public
	 * schema is not re-created, Oid preassignments in public will be
	 * mismatched between old and new cluster if the schema had been
	 * dropped and recreated on the old cluster.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pg_nspname</name></expr></argument>, <argument><expr><literal type="string">"public"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						  <argument><expr><literal type="string">"DROP SCHEMA IF EXISTS public;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT binary_upgrade_set_next_pg_namespace_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"$$%s$$::text);\n\n"</literal></expr></argument>,
						<argument><expr><name>pg_namespace_oid</name></expr></argument>, <argument><expr><name>pg_nspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>binary_upgrade_set_type_oids_by_type_oid</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
										 <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
										 <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name></type> <name>force_array_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>upgrade_query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pg_type_array_oid</name> <init>= <expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typarrayoid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pg_type_array_ns_oid</name> <init>= <expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typarrayns</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>pg_type_array_name</name> <init>= <expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typarrayname</name></name></expr></init></decl>;</decl_stmt>


	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_type oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_pg_type_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"'%u'::pg_catalog.oid, $$%s$$::text);\n\n"</literal></expr></argument>,
						<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pg_type_array_oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>force_array_type</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the old version didn't assign an array type, but the new version
		 * does, we must select an unused type OID to assign.  This currently
		 * only happens for domains, when upgrading pre-v11 to v11 and up.
		 *
		 * Note: local state here is kind of ugly, but we must have some,
		 * since we mustn't choose the same unused OID more than once.
		 */</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>next_possible_free_oid</name> <init>= <expr><name>FirstNormalObjectId</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_dup</name></decl>;</decl_stmt>

		<do>do
		<block>{<block_content>
			<expr_stmt><expr><operator>++</operator><name>next_possible_free_oid</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT EXISTS(SELECT 1 "</literal>
							  <literal type="string">"FROM pg_catalog.pg_type "</literal>
							  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid);"</literal></expr></argument>,
							  <argument><expr><name>next_possible_free_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>upgrade_query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_dup</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>is_dup</name></expr>)</condition>;</do>

		<expr_stmt><expr><name>pg_type_array_oid</name> <operator>=</operator> <name>next_possible_free_oid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pg_type_array_ns_oid</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pg_type_array_name</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"_%s"</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pg_type_array_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name>pg_type_array_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
							 <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_type array oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_array_pg_type_oid('%u'::pg_catalog.oid, "</literal>
						  <literal type="string">"'%u'::pg_catalog.oid, $$%s$$::text);\n\n"</literal></expr></argument>,
						  <argument><expr><name>pg_type_array_oid</name></expr></argument>, <argument><expr><name>pg_type_array_ns_oid</name></expr></argument>,
						  <argument><expr><name>pg_type_array_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>binary_upgrade_set_type_oids_by_rel</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
										<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>typinfo</name> <init>= <expr><call><name>findTypeByOid</name><argument_list>(<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>upgrade_buffer</name></expr></argument>,
											 <argument><expr><name>typinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>binary_upgrade_set_pg_class_oids</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
								 <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>pg_class_oid</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>is_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_index</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name> <init>= <expr><call><name>findTableByOid</name><argument_list>(<argument><expr><name>pg_class_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name>pg_class_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						<argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_class oids\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_heap_pg_class_oid('%u'::pg_catalog.oid, "</literal>
						  <literal type="string">"'%u'::pg_catalog.oid, $$%s$$::text);\n"</literal></expr></argument>,
						  <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Only tables have toast tables, not indexes
		 * Starting GPDB7 CO tables no longer have TOAST tables. Hence, ignore
		 * toast OIDs for CO tables to avoid upgrade failures.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>toast_oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name></name><operator>)</operator> <operator>||</operator>
					<operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>toast_oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>columnstore</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_toast_oids_by_rel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Set up any AO auxiliary tables with preallocated OIDs as well. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_rel_ao_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndxInfo</name> <modifier>*</modifier></type><name>idxinfo</name> <init>= <expr><call><name>findIndexByOid</name><argument_list>(<argument><expr><name>pg_class_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name>pg_class_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_index_pg_class_oid('%u'::pg_catalog.oid, "</literal>
							<literal type="string">"'%u'::pg_catalog.oid, $$%s$$::text);\n"</literal></expr></argument>,
						  <argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up bitmap index auxiliary tables */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>idxinfo</name><operator>-&gt;</operator><name>bmidx</name></name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>bmidx</name><operator>-&gt;</operator><name>bmrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_bitmap_index_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><name>idxinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust the names of all pg_bitmapindex objects for the given index
 * to match what they will be in the new cluster, using the OID of
 * the owning index. In many cases these will be the same as the
 * ones in the old cluster, but not always. Some operations can
 * cause the old pg_bitmapindex object names not to match its owner's
 * OID, but the new cluster will be using the correct name, and it's
 * the new cluster's name that we have to use
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>binary_upgrade_set_bitmap_index_oids</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndxInfo</name> <modifier>*</modifier></type><name>idxinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* pg_bm heap table */</comment>
	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>bmidx</name><operator>-&gt;</operator><name>bmrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
					<argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_class oids\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
					<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_heap_pg_class_oid('%u'::pg_catalog.oid, "</literal>
					<literal type="string">"'%u'::pg_catalog.oid, 'pg_bm_%u'::text);\n"</literal></expr></argument>,
					<argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>bmidx</name><operator>-&gt;</operator><name>bmrelid</name></name></expr></argument>, <argument><expr><name>PG_BITMAPINDEX_NAMESPACE</name></expr></argument>, <argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_bm composite type */</comment>
	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>bmidx</name><operator>-&gt;</operator><name>bmreltype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_type oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
	 					<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_pg_type_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"'%u'::pg_catalog.oid, 'pg_bm_%u'::text);\n\n"</literal></expr></argument>,
					  <argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>bmidx</name><operator>-&gt;</operator><name>bmreltype</name></name></expr></argument>, <argument><expr><name>PG_BITMAPINDEX_NAMESPACE</name></expr></argument>, <argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_bm index */</comment>
	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>bmidx</name><operator>-&gt;</operator><name>bmidxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
					<argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_class oids\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_index_pg_class_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"'%u'::pg_catalog.oid, 'pg_bm_%u_index'::text);\n"</literal></expr></argument>,
						<argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>bmidx</name><operator>-&gt;</operator><name>bmidxid</name></name></expr></argument>, <argument><expr><name>PG_BITMAPINDEX_NAMESPACE</name></expr></argument>, <argument><expr><name><name>idxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust the names of all pg_aoseg objects for the given table
 * to match what they will be in the new cluster, using the OID of
 * the owning table. In many cases these will be the same as the
 * ones in the old cluster, but not always. Some operations can
 * cause the old pg_aoseg object names not to match its owner's OID, but
 * the new cluster will be using the correct name, and it's the new
 * cluster's name that we have to use
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>binary_upgrade_set_rel_ao_oids</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aoseg_prefix</name> <init>= <expr><ternary><condition><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>columnstore</name></name></expr> ?</condition><then> <expr><literal type="string">"pg_aocsseg"</literal></expr> </then><else>: <expr><literal type="string">"pg_aoseg"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/* pg_aoseg heap table */</comment>
	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>segrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
					<argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_class oids\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_heap_pg_class_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"'%u'::pg_catalog.oid, '%s_%u'::text);\n"</literal></expr></argument>,
						<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>segrelid</name></name></expr></argument>, <argument><expr><name>PG_AOSEGMENT_NAMESPACE</name></expr></argument>, <argument><expr><name>aoseg_prefix</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_aoseg composite type */</comment>
	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>segreltype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_type oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
	 					<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_pg_type_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"'%u'::pg_catalog.oid, '%s_%u'::text);\n"</literal></expr></argument>,
					  <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>segreltype</name></name></expr></argument>, <argument><expr><name>PG_AOSEGMENT_NAMESPACE</name></expr></argument>, <argument><expr><name>aoseg_prefix</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* blkdir is optional. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>blkdirrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pg_aoblkdir heap table */</comment>
		<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>blkdirrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
			<argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_class oids\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
							<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_heap_pg_class_oid('%u'::pg_catalog.oid, "</literal>
							<literal type="string">"'%u'::pg_catalog.oid, 'pg_aoblkdir_%d'::text);\n"</literal></expr></argument>,
							<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>blkdirrelid</name></name></expr></argument>, <argument><expr><name>PG_AOSEGMENT_NAMESPACE</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* pg_aoblkdir composite type */</comment>
		<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>blkdirreltype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_type oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
							<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_pg_type_oid('%u'::pg_catalog.oid, "</literal>
							<literal type="string">"'%u'::pg_catalog.oid, 'pg_aoblkdir_%d'::text);\n"</literal></expr></argument>,
							<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>blkdirreltype</name></name></expr></argument>, <argument><expr><name>PG_AOSEGMENT_NAMESPACE</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* pg_aoblkdir index */</comment>
		<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>blkdiridxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						<argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_class oids\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
							<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_index_pg_class_oid('%u'::pg_catalog.oid, "</literal>
							<literal type="string">"'%u'::pg_catalog.oid, 'pg_aoblkdir_%u_index'::text);\n"</literal></expr></argument>,
							<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>blkdiridxid</name></name></expr></argument>, <argument><expr><name>PG_AOSEGMENT_NAMESPACE</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* pg_aovisimap heap table */</comment>
	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>visimaprelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
					<argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_class oids\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_heap_pg_class_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"'%u'::pg_catalog.oid, 'pg_aovisimap_%u'::text);\n"</literal></expr></argument>,
						<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>visimaprelid</name></name></expr></argument>, <argument><expr><name>PG_AOSEGMENT_NAMESPACE</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_aovisimap composite type */</comment>
	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>visimapreltype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_type oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
	 					<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_pg_type_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"'%u'::pg_catalog.oid, 'pg_aovisimap_%u'::text);\n\n"</literal></expr></argument>,
					  <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>visimapreltype</name></name></expr></argument>, <argument><expr><name>PG_AOSEGMENT_NAMESPACE</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_aovisimap index */</comment>
	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>visimapidxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
					<argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_class oids\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_index_pg_class_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"'%u'::pg_catalog.oid, 'pg_aovisimap_%u_index'::text);\n"</literal></expr></argument>,
						<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>aotbl</name><operator>-&gt;</operator><name>visimapidxid</name></name></expr></argument>, <argument><expr><name>PG_AOSEGMENT_NAMESPACE</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust the names of pg_toast tables for the given table
 * to match what they will be in the new cluster, using the OID of
 * the owning table. In many cases these will be the same as the
 * ones in the old cluster, but not always. Some operations can
 * cause the old TOAST table name not to match its owner's OID, but
 * the new cluster will be using the correct name, and it's the new
 * cluster's name that we have to use
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>binary_upgrade_set_toast_oids_by_rel</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>

 <comment type="block">/*
	* One complexity is that the table definition might not require
	* the creation of a TOAST table, and the TOAST table might have
	* been created long after table creation, when the table was
	* loaded with wide data.  By setting the TOAST oid we force
	* creation of the TOAST heap and TOAST index by the backend so we
	* can cleanly copy the files during binary upgrade.
	*/</comment>

	<comment type="block">/* pg_toast table */</comment>
	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>toast_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_toast_pg_class_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"'%u'::pg_catalog.oid, 'pg_toast_%u'::text);\n"</literal></expr></argument>,
						<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>toast_oid</name></name></expr></argument>, <argument><expr><name>PG_TOAST_NAMESPACE</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_toast composite type */</comment>
	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>toast_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_type oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_toast_pg_type_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"'%u'::pg_catalog.oid, 'pg_toast_%u'::text);\n\n"</literal></expr></argument>,
					  <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>toast_type</name></name></expr></argument>, <argument><expr><name>PG_TOAST_NAMESPACE</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* every toast table has an index */</comment>
	<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preassigned_oids</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>toast_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_index_pg_class_oid('%u'::pg_catalog.oid, "</literal>
						<literal type="string">"'%u'::pg_catalog.oid, 'pg_toast_%u_index'::text);\n"</literal></expr></argument>,
						<argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>toast_index</name></name></expr></argument>, <argument><expr><name>PG_TOAST_NAMESPACE</name></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If the DumpableObject is a member of an extension, add a suitable
 * ALTER EXTENSION ADD command to the creation commands in upgrade_buffer.
 *
 * For somewhat historical reasons, objname should already be quoted,
 * but not objnamespace (if any).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>binary_upgrade_extension_member</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objname</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objnamespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>extobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dobj</name><operator>-&gt;</operator><name>ext_member</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find the parent extension.  We could avoid this search if we wanted to
	 * add a link field to DumpableObject, but the space costs of that would
	 * be considerable.  We assume that member objects could only have a
	 * direct dependency on their own extension, not any others.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dobj</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>extobj</name> <operator>=</operator> <call><name>findObjectByDumpId</name><argument_list>(<argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>extobj</name> <operator>&amp;&amp;</operator> <name><name>extobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_EXTENSION</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>extobj</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>extobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not find parent extension for %s %s"</literal></expr></argument>,
			  <argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						 <argument><expr><literal type="string">"\n-- For binary upgrade, handle extension membership the hard way\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"ALTER EXTENSION %s ADD %s "</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>extobj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>objnamespace</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>objnamespace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>objnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getNamespaces:
 *	  read all namespaces in the system catalogs and return them in the
 * NamespaceInfo* structure
 *
 *	numNamespaces is set to the number of namespaces read in
 */</comment>
<function><type><name>NamespaceInfo</name> <modifier>*</modifier></type>
<name>getNamespaces</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numNamespaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NamespaceInfo</name> <modifier>*</modifier></type><name>nsinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_nspowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_nspacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_acldefault</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we fetch all namespaces including system ones, so that every object we
	 * read in can be linked to a containing namespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT n.tableoid, n.oid, n.nspname, "</literal>
						  <literal type="string">"n.nspowner, "</literal>
						  <literal type="string">"n.nspacl, "</literal>
						  <literal type="string">"acldefault('n', n.nspowner) AS acldefault "</literal>
						  <literal type="string">"FROM pg_namespace n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT n.tableoid, n.oid, n.nspname, "</literal>
						  <literal type="string">"n.nspowner, "</literal>
						  <literal type="string">"n.nspacl, NULL AS acldefault "</literal>
						  <literal type="string">"FROM pg_namespace n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsinfo</name> <operator>=</operator> <operator>(</operator><name>NamespaceInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NamespaceInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_nspname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_nspowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_nspacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspowner</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_NAMESPACE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_nspacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nspowner</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_nspowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nspowner</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>nspowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><name>nspowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether to dump this namespace */</comment>
		<expr_stmt><expr><call><name>selectDumpableNamespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark whether namespace has an ACL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_nspacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numNamespaces</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<return>return <expr><name>nsinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findNamespace:
 *		given a namespace OID, look up the info read by getNamespaces
 */</comment>
<function><type><specifier>static</specifier> <name>NamespaceInfo</name> <modifier>*</modifier></type>
<name>findNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nsoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NamespaceInfo</name> <modifier>*</modifier></type><name>nsinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nsinfo</name> <operator>=</operator> <call><name>findNamespaceByOid</name><argument_list>(<argument><expr><name>nsoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nsinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"schema with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>nsoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>nsinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getExtensions:
 *	  read all extensions in the system catalogs and return them in the
 * ExtensionInfo* structure
 *
 *	numExtensions is set to the number of extensions read in
 */</comment>
<function><type><name>ExtensionInfo</name> <modifier>*</modifier></type>
<name>getExtensions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numExtensions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>extinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_extname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_extrelocatable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_extversion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_extconfig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_extcondition</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT x.tableoid, x.oid, "</literal>
						 <literal type="string">"x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition "</literal>
						 <literal type="string">"FROM pg_extension x "</literal>
						 <literal type="string">"JOIN pg_namespace n ON n.oid = x.extnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>extinfo</name> <operator>=</operator> <operator>(</operator><name>ExtensionInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExtensionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_extname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"extname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_nspname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_extrelocatable</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"extrelocatable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_extversion</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"extversion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_extconfig</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"extconfig"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_extcondition</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"extcondition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_EXTENSION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_extname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>namespace</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relocatable</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_extrelocatable</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>extversion</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_extversion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>extconfig</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_extconfig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>extcondition</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_extcondition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>dopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numExtensions</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<return>return <expr><name>extinfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BinaryUpgradeInfo</name> <modifier>*</modifier></type>
<name>getBinaryUpgradeObjects</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BinaryUpgradeInfo</name>	<modifier>*</modifier></type><name>binfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>binfo</name> <operator>=</operator> <operator>(</operator><name>BinaryUpgradeInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BinaryUpgradeInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_BINARY_UPGRADE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"__binary_upgrade"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>binfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTypes:
 *	  read all types in the system catalogs and return them in the
 * TypeInfo* structure
 *
 *	numTypes is set to the number of types read in
 *
 * NB: this must run after getFuncs() because we assume we can do
 * findFuncByOid().
 */</comment>
<function><type><name>TypeInfo</name> <modifier>*</modifier></type>
<name>getTypes</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>tyinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShellTypeInfo</name> <modifier>*</modifier></type><name>stinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_acldefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typelem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typrelkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typisdefined</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_isarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typstorage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typarrayoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typarrayname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typarrayns</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * we include even the built-in types because those may be used as array
	 * elements by user-defined types
	 *
	 * we filter out the built-in types when we dump out the types
	 *
	 * same approach for undefined (shell) types and array types
	 *
	 * Note: as of 8.3 we can reliably detect whether a type is an
	 * auto-generated array type by checking the element type's typarray.
	 * (Before that the test is capable of generating false positives.) We
	 * still check for name beginning with '_', though, so as to avoid the
	 * cost of the subselect probe for all standard types.  This would have to
	 * be revisited if the backend ever allows renaming of array types.
	 *
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT t.tableoid, t.oid, t.typname, "</literal>
						  <literal type="string">"t.typnamespace, t.typacl, "</literal>
						  <literal type="string">"acldefault('T', t.typowner) AS acldefault, "</literal>
						  <literal type="string">"t.typowner, "</literal>
						  <literal type="string">"t.typelem, t.typrelid, "</literal>
						  <literal type="string">"CASE WHEN t.typrelid = 0 THEN ' '::\"char\" "</literal>
						  <literal type="string">"ELSE (SELECT relkind FROM pg_class WHERE oid = t.typrelid) END AS typrelkind, "</literal>
						  <literal type="string">"t.typtype, t.typisdefined, "</literal>
						  <literal type="string">"t.typname[0] = '_' AND t.typelem != 0 AND "</literal>
						  <literal type="string">"(SELECT typarray FROM pg_type te WHERE oid = t.typelem) = t.oid AS isarray, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT t.tableoid, t.oid, t.typname, "</literal>
						  <literal type="string">"t.typnamespace, NULL AS typacl, "</literal>
						  <literal type="string">"NULL AS acldefault, "</literal>
						  <literal type="string">"t.typowner, "</literal>
						  <literal type="string">"t.typelem, t.typrelid, "</literal>
						  <literal type="string">"CASE WHEN t.typrelid = 0 THEN ' '::\"char\" "</literal>
						  <literal type="string">"ELSE (SELECT relkind FROM pg_class WHERE oid = t.typrelid) END AS typrelkind, "</literal>
						  <literal type="string">"t.typtype, t.typisdefined, "</literal>
						  <literal type="string">"t.typname[0] = '_' AND t.typelem != 0 AND "</literal>
						  <literal type="string">"(SELECT typarray FROM pg_type te WHERE oid = t.typelem) = t.oid AS isarray, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							<argument><expr><literal type="string">"coalesce(t.typarray, 0) AS typarrayoid, "</literal>
							<literal type="string">"coalesce(a.typname, '') AS typarrayname, "</literal>
							<literal type="string">"coalesce(a.typnamespace, 0) AS typarrayns, "</literal>
							<literal type="string">"coalesce(array_to_string(e.typoptions, ', '), '') AS typstorage "</literal>
							<literal type="string">"FROM pg_type t "</literal>
							<literal type="string">"LEFT JOIN pg_catalog.pg_type a ON (t.typarray=a.oid) "</literal>
							<literal type="string">"LEFT JOIN pg_type_encoding e ON t.oid = e.typid "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							<argument><expr><literal type="string">"coalesce(array_to_string(e.typoptions, ', '), '') AS typstorage "</literal>
							<literal type="string">"FROM pg_type t "</literal>
							<literal type="string">"LEFT JOIN pg_type_encoding e ON t.oid = e.typid "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tyinfo</name> <operator>=</operator> <operator>(</operator><name>TypeInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TypeInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typelem</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typelem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typrelkind</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typrelkind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typtype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typisdefined</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typisdefined"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_isarray</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"isarray"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typstorage</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typstorage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typarrayoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typarrayoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typarrayname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typarrayname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typarrayns</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typarrayns"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TYPE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ftypname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* may get filled later */</comment>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typelem</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typelem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typrelkind</name> <operator>=</operator> <operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typrelkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typtype</name> <operator>=</operator> <operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shellType</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typisdefined</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isDefined</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isDefined</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_isarray</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isArray</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isArray</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typstorage</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typstorage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typarrayoid</name> <operator>=</operator>  <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typarrayoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typarrayname</name> <operator>=</operator>  <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typarrayname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typarrayns</name> <operator>=</operator>  <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typarrayns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark whether type has an ACL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it's a domain, fetch info about its constraints, if any
		 */</comment>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nDomChecks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>domChecks</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typtype</name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getDomainConstraints</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it's a base type, make a DumpableObject representing a shell
		 * definition of the type.  We will need to dump that ahead of the I/O
		 * functions for the type.  Similarly, range types need a shell
		 * definition in case they have a canonicalize function.
		 *
		 * Note: the shell type doesn't have a catId.  You might think it
		 * should copy the base type's catId, but then it might capture the
		 * pg_depend entries for the type, which we don't want.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typtype</name> <operator>==</operator> <name>TYPTYPE_BASE</name> <operator>||</operator>
			 <name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typtype</name> <operator>==</operator> <name>TYPTYPE_RANGE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>stinfo</name> <operator>=</operator> <operator>(</operator><name>ShellTypeInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShellTypeInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_SHELL_TYPE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name> <operator>=</operator> <name>nilCatalogId</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>baseType</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shellType</name> <operator>=</operator> <name>stinfo</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Initially mark the shell type as not to be dumped.  We'll only
			 * dump it if the I/O or canonicalize functions need to be dumped;
			 * this is taken care of while sorting dependencies.
			 */</comment>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>numTypes</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tyinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getOperators:
 *	  read all operators in the system catalogs and return them in the
 * OprInfo* structure
 *
 *	numOprs is set to the number of operators read in
 */</comment>
<function><type><name>OprInfo</name> <modifier>*</modifier></type>
<name>getOperators</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numOprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OprInfo</name>    <modifier>*</modifier></type><name>oprinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprcode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * find all operators, including builtin operators; we filter out
	 * system-defined operators at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, oprname, "</literal>
					  <literal type="string">"oprnamespace, "</literal>
					  <literal type="string">"oprowner, "</literal>
					  <literal type="string">"oprkind, "</literal>
					  <literal type="string">"oprcode::oid AS oprcode "</literal>
					  <literal type="string">"FROM pg_operator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numOprs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oprinfo</name> <operator>=</operator> <operator>(</operator><name>OprInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OprInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprkind</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprkind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprcode</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprcode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_OPERATOR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oprname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oprnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oprowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oprkind</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oprkind</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oprcode</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oprcode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>oprinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getCollations:
 *	  read all collations in the system catalogs and return them in the
 * CollInfo* structure
 *
 *	numCollations is set to the number of collations read in
 */</comment>
<function><type><name>CollInfo</name> <modifier>*</modifier></type>
<name>getCollations</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numCollations</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>collinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collowner</name></decl>;</decl_stmt>

	<comment type="block">/* Collations didn't exist pre-9.1 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numCollations</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * find all collations, including builtin collations; we filter out
	 * system-defined collations at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, collname, "</literal>
					  <literal type="string">"collnamespace, "</literal>
					  <literal type="string">"collowner "</literal>
					  <literal type="string">"FROM pg_collation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numCollations</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>collinfo</name> <operator>=</operator> <operator>(</operator><name>CollInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CollInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_COLLATION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_collname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_collnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_collowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>collinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getConversions:
 *	  read all conversions in the system catalogs and return them in the
 * ConvInfo* structure
 *
 *	numConversions is set to the number of conversions read in
 */</comment>
<function><type><name>ConvInfo</name> <modifier>*</modifier></type>
<name>getConversions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numConversions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConvInfo</name>   <modifier>*</modifier></type><name>convinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_conname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_connamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_conowner</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * find all conversions, including builtin conversions; we filter out
	 * system-defined conversions at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, conname, "</literal>
					  <literal type="string">"connamespace, "</literal>
					  <literal type="string">"conowner "</literal>
					  <literal type="string">"FROM pg_conversion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numConversions</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>convinfo</name> <operator>=</operator> <operator>(</operator><name>ConvInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConvInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_connamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"connamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_CONVERSION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_connamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>convinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getAccessMethods:
 *	  read all user-defined access methods in the system catalogs and return
 *	  them in the AccessMethodInfo* structure
 *
 *	numAccessMethods is set to the number of access methods read in
 */</comment>
<function><type><name>AccessMethodInfo</name> <modifier>*</modifier></type>
<name>getAccessMethods</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numAccessMethods</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AccessMethodInfo</name> <modifier>*</modifier></type><name>aminfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amhandler</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amtype</name></decl>;</decl_stmt>

	<comment type="block">/* Before 9.6, there are no user-defined access methods */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numAccessMethods</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select all access methods from pg_am table */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, amname, amtype, "</literal>
					  <literal type="string">"amhandler::pg_catalog.regproc AS amhandler "</literal>
					  <literal type="string">"FROM pg_am"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numAccessMethods</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aminfo</name> <operator>=</operator> <operator>(</operator><name>AccessMethodInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AccessMethodInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amhandler</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amhandler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amtype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_ACCESS_METHOD</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>amhandler</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amhandler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>amtype</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableAccessMethod</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>aminfo</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * getOpclasses:
 *	  read all opclasses in the system catalogs and return them in the
 * OpclassInfo* structure
 *
 *	numOpclasses is set to the number of opclasses read in
 */</comment>
<function><type><name>OpclassInfo</name> <modifier>*</modifier></type>
<name>getOpclasses</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numOpclasses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpclassInfo</name> <modifier>*</modifier></type><name>opcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcowner</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * find all opclasses, including builtin opclasses; we filter out
	 * system-defined opclasses at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, opcname, "</literal>
					  <literal type="string">"opcnamespace, "</literal>
					  <literal type="string">"opcowner "</literal>
					  <literal type="string">"FROM pg_opclass"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numOpclasses</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>opcinfo</name> <operator>=</operator> <operator>(</operator><name>OpclassInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OpclassInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_OPCLASS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_opcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_opcnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_opcowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>opcinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getOpfamilies:
 *	  read all opfamilies in the system catalogs and return them in the
 * OpfamilyInfo* structure
 *
 *	numOpfamilies is set to the number of opfamilies read in
 */</comment>
<function><type><name>OpfamilyInfo</name> <modifier>*</modifier></type>
<name>getOpfamilies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numOpfamilies</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpfamilyInfo</name> <modifier>*</modifier></type><name>opfinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opfname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opfnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opfowner</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * find all opfamilies, including builtin opfamilies; we filter out
	 * system-defined opfamilies at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, opfname, "</literal>
					  <literal type="string">"opfnamespace, "</literal>
					  <literal type="string">"opfowner "</literal>
					  <literal type="string">"FROM pg_opfamily"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numOpfamilies</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>opfinfo</name> <operator>=</operator> <operator>(</operator><name>OpfamilyInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OpfamilyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opfname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opfname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opfnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opfnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opfowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opfowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_OPFAMILY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_opfname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_opfnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_opfowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>opfinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getAggregates:
 *	  read all the user-defined aggregates in the system catalogs and
 * return them in the AggInfo* structure
 *
 * numAggs is set to the number of aggregates read in
 */</comment>
<function><type><name>AggInfo</name> <modifier>*</modifier></type>
<name>getAggregates</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numAggs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggInfo</name>    <modifier>*</modifier></type><name>agginfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pronargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_proargtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_proowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_acldefault</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find all interesting aggregates.  See comment in getFuncs() for the
	 * rationale behind the filtering logic.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>agg_check</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>agg_check</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr> ?</condition><then> <expr><literal type="string">"p.prokind = 'a'"</literal></expr>
					 </then><else>: <expr><literal type="string">"p.proisagg"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT p.tableoid, p.oid, "</literal>
						  <literal type="string">"p.proname AS aggname, "</literal>
						  <literal type="string">"p.pronamespace AS aggnamespace, "</literal>
						  <literal type="string">"p.pronargs, p.proargtypes, "</literal>
						  <literal type="string">"p.proowner, "</literal>
						  <literal type="string">"p.proacl AS aggacl, "</literal>
						  <literal type="string">"acldefault('f', p.proowner) AS acldefault "</literal>
						  <literal type="string">"FROM pg_proc p "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip ON "</literal>
						  <literal type="string">"(p.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_proc'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0) "</literal>
						  <literal type="string">"WHERE %s AND ("</literal>
						  <literal type="string">"p.pronamespace != "</literal>
						  <literal type="string">"(SELECT oid FROM pg_namespace "</literal>
						  <literal type="string">"WHERE nspname = 'pg_catalog') OR "</literal>
						  <literal type="string">"p.proacl IS DISTINCT FROM pip.initprivs"</literal></expr></argument>,
						  <argument><expr><name>agg_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">" OR EXISTS(SELECT 1 FROM pg_depend WHERE "</literal>
								 <literal type="string">"classid = 'pg_proc'::regclass AND "</literal>
								 <literal type="string">"objid = p.oid AND "</literal>
								 <literal type="string">"refclassid = 'pg_extension'::regclass AND "</literal>
								 <literal type="string">"deptype = 'e')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, proname AS aggname, "</literal>
						  <literal type="string">"pronamespace AS aggnamespace, "</literal>
						  <literal type="string">"pronargs, proargtypes, "</literal>
						  <literal type="string">"proowner, "</literal>
						  <literal type="string">"proacl AS aggacl, "</literal>
						  <literal type="string">"acldefault('f', proowner) AS acldefault "</literal>
						  <literal type="string">"FROM pg_proc p "</literal>
						  <literal type="string">"WHERE proisagg AND ("</literal>
						  <literal type="string">"pronamespace != "</literal>
						  <literal type="string">"(SELECT oid FROM pg_namespace "</literal>
						  <literal type="string">"WHERE nspname = 'pg_catalog')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">" OR EXISTS(SELECT 1 FROM pg_depend WHERE "</literal>
								 <literal type="string">"classid = 'pg_proc'::regclass AND "</literal>
								 <literal type="string">"objid = p.oid AND "</literal>
								 <literal type="string">"refclassid = 'pg_extension'::regclass AND "</literal>
								 <literal type="string">"deptype = 'e')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, proname AS aggname, "</literal>
						  <literal type="string">"pronamespace AS aggnamespace, "</literal>
						  <literal type="string">"pronargs, proargtypes, "</literal>
						  <literal type="string">"proowner, "</literal>
						  <literal type="string">"proacl AS aggacl, "</literal>
						  <literal type="string">"NULL AS acldefault "</literal>
						  <literal type="string">"FROM pg_proc p "</literal>
						  <literal type="string">"WHERE proisagg AND ("</literal>
						  <literal type="string">"pronamespace != "</literal>
						  <literal type="string">"(SELECT oid FROM pg_namespace "</literal>
						  <literal type="string">"WHERE nspname = 'pg_catalog')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">" OR EXISTS(SELECT 1 FROM pg_depend WHERE "</literal>
								 <literal type="string">"classid = 'pg_proc'::regclass AND "</literal>
								 <literal type="string">"objid = p.oid AND "</literal>
								 <literal type="string">"refclassid = 'pg_extension'::regclass AND "</literal>
								 <literal type="string">"deptype = 'e')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numAggs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>agginfo</name> <operator>=</operator> <operator>(</operator><name>AggInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AggInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pronargs</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pronargs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_proargtypes</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proargtypes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_proowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_AGG</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_aggname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_aggnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_aggacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>rolname</name></name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>lang</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt> <comment type="block">/* not currently interesting */</comment>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>prorettype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* not saved */</comment>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pronargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>nargs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>argtypes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>argtypes</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>parseOidArray</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proargtypes</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>argtypes</name></name></expr></argument>,
						  <argument><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name></name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark whether aggregate has an ACL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_aggacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>agginfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getExtProtocols:
 *	  read all the user-defined protocols in the system catalogs and
 * return them in the ExtProtInfo* structure
 *
 * numExtProtocols is set to the number of protocols read in
 */</comment>
<comment type="block">/*	Declared in pg_dump.h */</comment>
<function><type><name>ExtProtInfo</name> <modifier>*</modifier></type>
<name>getExtProtocols</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numExtProtocols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtProtInfo</name> <modifier>*</modifier></type><name>ptcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ptcname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ptcowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ptcacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_acldefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ptctrusted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>i_ptcreadid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ptcwriteid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ptcvalidid</name></decl>;</decl_stmt>

	<comment type="block">/* find all user-defined external protocol */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, "</literal>
								 <literal type="string">"oid, "</literal>
								 <literal type="string">"ptcname, "</literal>
								 <literal type="string">"ptcreadfn as ptcreadoid, "</literal>
								 <literal type="string">"ptcwritefn as ptcwriteoid, "</literal>
								 <literal type="string">"ptcvalidatorfn as ptcvaloid, "</literal>
								 <literal type="string">"ptcowner, "</literal>
								 <literal type="string">"ptctrusted, ptcacl, "</literal>
								 <literal type="string">"acldefault('E', ptcowner) AS acldefault "</literal>
								 <literal type="string">"FROM pg_extprotocol "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, "</literal>
								 <literal type="string">"oid, "</literal>
								 <literal type="string">"ptcname, "</literal>
								 <literal type="string">"ptcreadfn as ptcreadoid, "</literal>
								 <literal type="string">"ptcwritefn as ptcwriteoid, "</literal>
								 <literal type="string">"ptcvalidatorfn as ptcvaloid, "</literal>
								 <literal type="string">"ptcowner, "</literal>
								 <literal type="string">"ptctrusted, ptcacl, "</literal>
								 <literal type="string">"NULL AS acldefault "</literal>
								 <literal type="string">"FROM pg_extprotocol "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numExtProtocols</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptcinfo</name> <operator>=</operator> <operator>(</operator><name>ExtProtInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExtProtInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ptcname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ptcname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ptcowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ptcowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ptcacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ptcacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ptctrusted</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ptctrusted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ptcreadid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ptcreadoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ptcwriteid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ptcwriteoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ptcvalidid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ptcvaloid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_EXTPROTOCOL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ptcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,  <argument><expr><name>i_ptcowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ptcreadid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptcreadid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptcreadid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ptcreadid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ptcwriteid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptcwriteid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptcwriteid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ptcwriteid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ptcvalidid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptcvalidid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptcvalidid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ptcvalidid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptctrusted</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ptctrusted</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ptcacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark whether function has an ACL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ptcacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ptcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ptcinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getFuncs:
 *	  read all the user-defined functions in the system catalogs and
 * return them in the FuncInfo* structure
 *
 * numFuncs is set to the number of functions read in
 */</comment>
<function><type><name>FuncInfo</name> <modifier>*</modifier></type>
<name>getFuncs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numFuncs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>finfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_proname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pronamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_proowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prolang</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pronargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_proargtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prorettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_proacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_acldefault</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find all interesting functions.  This is a bit complicated:
	 *
	 * 1. Always exclude aggregates; those are handled elsewhere.
	 *
	 * 2. Always exclude functions that are internally dependent on something
	 * else, since presumably those will be created as a result of creating
	 * the something else.  This currently acts only to suppress constructor
	 * functions for range types (so we only need it in 9.2 and up).  Note
	 * this is OK only because the constructors don't have any dependencies
	 * the range type doesn't have; otherwise we might not get creation
	 * ordering correct.
	 *
	 * 3. Otherwise, we normally exclude functions in pg_catalog.  However, if
	 * they're members of extensions and we are in binary-upgrade mode then
	 * include them, since we want to dump extension members individually in
	 * that mode.  Also, if they are used by casts or transforms then we need
	 * to gather the information about them, though they won't be dumped if
	 * they are built-in.  Also, in 9.6 and up, include functions in
	 * pg_catalog if they have an ACL different from what's shown in
	 * pg_init_privs (so we have to join to pg_init_privs; annoying).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>not_agg_check</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>not_agg_check</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr> ?</condition><then> <expr><literal type="string">"p.prokind &lt;&gt; 'a'"</literal></expr>
						 </then><else>: <expr><literal type="string">"NOT p.proisagg"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT p.tableoid, p.oid, p.proname, p.prolang, "</literal>
						  <literal type="string">"p.pronargs, p.proargtypes, p.prorettype, "</literal>
						  <literal type="string">"p.proacl, "</literal>
						  <literal type="string">"acldefault('f', p.proowner) AS acldefault, "</literal>
						  <literal type="string">"p.pronamespace, "</literal>
						  <literal type="string">"p.proowner "</literal>
						  <literal type="string">"FROM pg_proc p "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip ON "</literal>
						  <literal type="string">"(p.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_proc'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0) "</literal>
						  <literal type="string">"WHERE %s"</literal>
						  <literal type="string">"\n  AND NOT EXISTS (SELECT 1 FROM pg_depend "</literal>
						  <literal type="string">"WHERE classid = 'pg_proc'::regclass AND "</literal>
						  <literal type="string">"objid = p.oid AND deptype = 'i')"</literal>
						  <literal type="string">"\n  AND ("</literal>
						  <literal type="string">"\n  pronamespace != "</literal>
						  <literal type="string">"(SELECT oid FROM pg_namespace "</literal>
						  <literal type="string">"WHERE nspname = 'pg_catalog')"</literal>
						  <literal type="string">"\n  OR EXISTS (SELECT 1 FROM pg_cast"</literal>
						  <literal type="string">"\n  WHERE pg_cast.oid &gt; %u "</literal>
						  <literal type="string">"\n  AND p.oid = pg_cast.castfunc)"</literal>
						  <literal type="string">"\n  OR EXISTS (SELECT 1 FROM pg_transform"</literal>
						  <literal type="string">"\n  WHERE pg_transform.oid &gt; %u AND "</literal>
						  <literal type="string">"\n  (p.oid = pg_transform.trffromsql"</literal>
						  <literal type="string">"\n  OR p.oid = pg_transform.trftosql))"</literal></expr></argument>,
						  <argument><expr><name>not_agg_check</name></expr></argument>,
						  <argument><expr><name>g_last_builtin_oid</name></expr></argument>,
						  <argument><expr><name>g_last_builtin_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"\n  OR EXISTS(SELECT 1 FROM pg_depend WHERE "</literal>
								 <literal type="string">"classid = 'pg_proc'::regclass AND "</literal>
								 <literal type="string">"objid = p.oid AND "</literal>
								 <literal type="string">"refclassid = 'pg_extension'::regclass AND "</literal>
								 <literal type="string">"deptype = 'e')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"\n  OR p.proacl IS DISTINCT FROM pip.initprivs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acldefault_call</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>acldefault_call</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr> ?</condition><then>
						   <expr><literal type="string">"acldefault('f', proowner)"</literal></expr> </then><else>: <expr><literal type="string">"NULL"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT tableoid, oid, proname, prolang, "</literal>
						  <literal type="string">"pronargs, proargtypes, prorettype, proacl, "</literal>
						  <literal type="string">"%s AS acldefault, "</literal>
						  <literal type="string">"pronamespace, "</literal>
						  <literal type="string">"proowner "</literal>
						  <literal type="string">"FROM pg_proc p "</literal>
						  <literal type="string">"WHERE NOT proisagg"</literal></expr></argument>,
						  <argument><expr><name>acldefault_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"\n  AND NOT EXISTS (SELECT 1 FROM pg_depend "</literal>
								 <literal type="string">"WHERE classid = 'pg_proc'::regclass AND "</literal>
								 <literal type="string">"objid = p.oid AND deptype = 'i')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"\n  AND ("</literal>
						  <literal type="string">"\n  pronamespace != "</literal>
						  <literal type="string">"(SELECT oid FROM pg_namespace "</literal>
						  <literal type="string">"WHERE nspname = 'pg_catalog')"</literal>
						  <literal type="string">"\n  OR EXISTS (SELECT 1 FROM pg_cast"</literal>
						  <literal type="string">"\n  WHERE pg_cast.oid &gt; '%u'::oid"</literal>
						  <literal type="string">"\n  AND p.oid = pg_cast.castfunc)"</literal></expr></argument>,
						  <argument><expr><name>g_last_builtin_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"\n  OR EXISTS (SELECT 1 FROM pg_transform"</literal>
							  <literal type="string">"\n  WHERE pg_transform.oid &gt; '%u'::oid"</literal>
							  <literal type="string">"\n  AND (p.oid = pg_transform.trffromsql"</literal>
							  <literal type="string">"\n  OR p.oid = pg_transform.trftosql))"</literal></expr></argument>,
							  <argument><expr><name>g_last_builtin_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/*
 * GPDB: Much of the extension machinery was backported into GPDB 5 from higher
 * major versions, so include the clause.
 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"\n  OR EXISTS(SELECT 1 FROM pg_depend WHERE "</literal>
								 <literal type="string">"classid = 'pg_proc'::regclass AND "</literal>
								 <literal type="string">"objid = p.oid AND "</literal>
								 <literal type="string">"refclassid = 'pg_extension'::regclass AND "</literal>
								 <literal type="string">"deptype = 'e')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numFuncs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>finfo</name> <operator>=</operator> <operator>(</operator><name>FuncInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FuncInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_proname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pronamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pronamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_proowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prolang</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prolang"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pronargs</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pronargs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_proargtypes</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proargtypes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prorettype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prorettype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_proacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_FUNC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pronamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lang</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prolang</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prorettype</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prorettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nargs</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pronargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nargs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argtypes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argtypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>parseOidArray</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proargtypes</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argtypes</name></expr></argument>, <argument><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableFunction</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark whether function has an ACL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>finfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTables
 *	  read all the tables (no indexes)
 * in the system catalogs return them in the TableInfo* structure
 *
 * numTables is set to the number of tables read in
 */</comment>
<function><type><name>TableInfo</name> <modifier>*</modifier></type>
<name>getTables</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tblinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>lockTableDumped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_reltableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_reloid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_reltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relchecks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relhastriggers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relhasindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relhasrules</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relrowsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relforcerowsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relhasoids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relfrozenxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relminmxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_toastoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_toastfrozenxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_toastminmxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relpersistence</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relispopulated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relreplident</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_owning_tab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_owning_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_reltablespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_reloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_checkoption</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_toastreloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_reloftype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_is_identity_sequence</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_acldefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_partkeydef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ispartition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_partbound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relstorage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_parrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_parlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_toast_type_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_toast_index_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_distclause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_partclause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_parttemplate</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find all the tables and table-like objects.
	 *
	 * We include system catalogs, so that we can work if a user table is
	 * defined to inherit from a system catalog (pretty weird, but...)
	 *
	 * We ignore relations that are not ordinary tables, sequences, views,
	 * materialized views, composite types, or foreign tables.
	 *
	 * Composite-type table entries won't be dumped as such, but we have to
	 * make a DumpableObject for them so that we can track dependencies of the
	 * composite type (pg_depend entries for columns of the composite type
	 * link to the pg_class entry not the pg_type entry).
	 *
	 * Note: in this phase we should collect only a minimal amount of
	 * information about each table, basically just enough to decide if it is
	 * interesting. We must fetch all tables in this phase because otherwise
	 * we cannot correctly identify inherited columns, owned sequences, etc.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, c.relname, "</literal>
					  <literal type="string">"c.relnamespace, c.relkind, c.reltype, "</literal>
					  <literal type="string">"c.relowner, "</literal>
					  <literal type="string">"c.relchecks, "</literal>
					  <literal type="string">"c.relhasindex, c.relhasrules, c.relpages, "</literal>
					  <literal type="string">"d.refobjid AS owning_tab, "</literal>
					  <literal type="string">"d.refobjsubid AS owning_col, "</literal>
					  <literal type="string">"tsp.spcname AS reltablespace, "</literal>
						<literal type="string">"c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, "</literal>
						<literal type="string">"tc.oid AS toid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"'' AS relstorage, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"c.relstorage, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"false AS relhasoids, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"c.relhasoids, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"c.relhastriggers, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"(c.reltriggers &lt;&gt; 0) AS relhastriggers, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"c.relpersistence, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"'p' AS relpersistence, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"c.relispopulated, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"'t' as relispopulated, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"c.relreplident, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"'d' AS relreplident, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"c.relrowsecurity, c.relforcerowsecurity, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"false AS relrowsecurity, "</literal>
						  <literal type="string">"false AS relforcerowsecurity, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"c.relminmxid, tc.relminmxid AS tminmxid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"0 AS relminmxid, 0 AS tminmxid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, "</literal>
						  <literal type="string">"CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text "</literal>
						  <literal type="string">"WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"c.reloptions, NULL AS checkoption, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"tc.reloptions AS toast_reloptions, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"NULL AS toast_reloptions, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"CASE WHEN c.reloftype &lt;&gt; 0 THEN c.reloftype::pg_catalog.regtype ELSE NULL END AS reloftype, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"NULL AS reloftype, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"am.amname, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"NULL AS amname, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"c.relkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call>
						  <literal type="string">"AND EXISTS (SELECT 1 FROM pg_depend "</literal>
						  <literal type="string">"WHERE classid = 'pg_class'::regclass AND "</literal>
						  <literal type="string">"objid = c.oid AND objsubid = 0 AND "</literal>
						  <literal type="string">"refclassid = 'pg_class'::regclass AND "</literal>
						  <literal type="string">"deptype = 'i') AS is_identity_sequence, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"false AS is_identity_sequence, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"0 as parrelid, "</literal>
						  <literal type="string">"0 as parlevel, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"p.parrelid as parrelid, "</literal>
						  <literal type="string">"pl.parlevel as parlevel, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"c.relacl, "</literal>
							 <literal type="string">"acldefault(CASE WHEN c.relkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call>
							 <literal type="string">" THEN 's'::\"char\" ELSE 'r'::\"char\" END, c.relowner) AS acldefault, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"c.relacl, NULL AS acldefault, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							<argument><expr><literal type="string">"tc.reltype AS toast_type_oid, "</literal>
							<literal type="string">"i.indexrelid as toast_index_oid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* GPDB5: We expect either an empty policy entry, or exactly
	 * 1 policy entry in gp_distribution_policy for a given table.
	 * If there is more than 1 entry in the policy table for an
	 * oid the scalar subquery will fail as intended.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <name>GPDB6_MAJOR_PGVERSION</name></expr>)</condition><block type="pseudo"><block_content>
	 		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							<argument><expr><literal type="string">"pg_catalog.pg_get_table_distributedby(c.oid) as distclause, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							<argument><expr><literal type="string">"(SELECT attrnums FROM pg_catalog.gp_distribution_policy p "</literal>
					  	<literal type="string">"WHERE p.localoid = c.oid) as distclause, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"pg_get_partkeydef(c.oid) AS partkeydef, "</literal>
						  <literal type="string">"c.relispartition AS ispartition, "</literal>
						  <literal type="string">"pg_get_expr(c.relpartbound, c.oid) AS partbound, "</literal>
							<literal type="string">"NULL as partclause, "</literal>
							<literal type="string">"NULL as parttemplate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"NULL AS partkeydef, "</literal>
						  <literal type="string">"0 AS ispartition,"</literal>
						  <literal type="string">"NULL AS partbound, "</literal>
							<literal type="string">"CASE WHEN pl.parlevel = 0 THEN "</literal>
							<literal type="string">"(SELECT pg_get_partition_def(c.oid, true, true)) END AS partclause, "</literal>
							<literal type="string">"CASE WHEN pl.parlevel = 0 THEN "</literal>
							<literal type="string">"(SELECT pg_get_partition_template_def(c.oid, true, true)) END as parttemplate "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Left join to pg_depend to pick up dependency info linking sequences to
	 * their owning column, if any (note this dependency is AUTO as of 8.2).
	 * Also join to pg_tablespace to collect the spcname.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						 <argument><expr><literal type="string">"\nFROM pg_class c\n"</literal>
						 <literal type="string">"LEFT JOIN pg_depend d ON "</literal>
						 <literal type="string">"(c.relkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">" AND "</literal>
						 <literal type="string">"d.classid = 'pg_class'::regclass AND d.objid = c.oid AND "</literal>
						 <literal type="string">"d.objsubid = 0 AND "</literal>
						 <literal type="string">"d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))\n"</literal>
						 <literal type="string">"LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In 9.6 and up, left join to pg_am to pick up the amname.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"LEFT JOIN pg_am am ON (c.relam = am.oid)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 *
	 * We purposefully ignore toast OIDs for partitioned tables; the reason is
	 * that versions 10 and 11 have them, but later versions do not, so
	 * emitting them causes the upgrade to fail.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					<argument><expr><literal type="string">"LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid"</literal>
					<literal type="string">" AND tc.relkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>)</argument_list></call>
					<literal type="string">" AND c.relkind &lt;&gt; "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <name>GPDB7_MAJOR_PGVERSION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"LEFT JOIN pg_partition_rule pr ON c.oid = pr.parchildrelid\n"</literal>
						  <literal type="string">"LEFT JOIN pg_partition p ON pr.paroid = p.oid\n"</literal>
						  <literal type="string">"LEFT JOIN pg_partition pl ON (c.oid = pl.parrelid AND pl.parlevel = 0)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						<argument><expr><literal type="string">"LEFT JOIN pg_catalog.pg_index i ON (c.reltoastrelid = i.indrelid AND i.indisvalid)\n"</literal>
					  <literal type="string">"LEFT JOIN pg_catalog.pg_class ti ON (i.indexrelid = ti.oid)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * Restrict to interesting relkinds (in particular, not indexes).  Not all
	 * relkinds are possible in older servers, but it's not worth the trouble
	 * to emit a version-dependent list.
	 *
	 * Composite-type table entries won't be dumped as such, but we have to
	 * make a DumpableObject for them so that we can track dependencies of the
	 * composite type (pg_depend entries for columns of the composite type
	 * link to the pg_class entry not the pg_type entry).
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"WHERE c.relkind IN ("</literal>
						  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
						  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
						  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
						  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
						  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
						  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
						  <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"AND c.relnamespace &lt;&gt; 7012\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* BM_BITMAPINDEX_NAMESPACE */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"AND c.relnamespace &lt;&gt; 3012\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* BM_BITMAPINDEX_NAMESPACE in GPDB 5 and below */</comment>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						<argument><expr><literal type="string">"ORDER BY c.oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numTables</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Extract data from result and lock dumpable tables.  We do the locking
	 * before anything else, to minimize the window wherein a table could
	 * disappear under us.
	 *
	 * Note that we have to save info about all tables here, even when dumping
	 * only one, because we don't yet know which tables might be inheritance
	 * ancestors of the target table.
	 */</comment>
	<expr_stmt><expr><name>tblinfo</name> <operator>=</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TableInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_reltableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_reloid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relkind</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relkind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_reltype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"reltype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relchecks</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relchecks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relhasindex</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relhasindex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relhasrules</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relhasrules"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relpages</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relpages"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_owning_tab</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"owning_tab"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_owning_col</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"owning_col"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_reltablespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"reltablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relhasoids</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relhasoids"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relhastriggers</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relhastriggers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relpersistence</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relpersistence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relispopulated</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relispopulated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relreplident</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relreplident"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relrowsec</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relrowsecurity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relforcerowsec</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relforcerowsecurity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relfrozenxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relfrozenxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_toastfrozenxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tfrozenxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_toastoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"toid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relminmxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relminmxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_toastminmxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tminmxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_reloptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"reloptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_checkoption</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"checkoption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_toastreloptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"toast_reloptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_reloftype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"reloftype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_is_identity_sequence</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"is_identity_sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_partkeydef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"partkeydef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ispartition</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ispartition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_partbound</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"partbound"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relstorage</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relstorage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_parrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"parrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_parlevel</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"parlevel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_toast_type_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"toast_type_oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_toast_index_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"toast_index_oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_distclause</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"distclause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_partclause</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"partclause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_parttemplate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"parttemplate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>lockWaitTimeout</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Arrange to fail instead of waiting forever for a table lock.
		 *
		 * NB: this coding assumes that the only queries issued within the
		 * following loop are LOCK TABLEs; else the timeout may be undesirably
		 * applied to other things too.
		 */</comment>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SET statement_timeout = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralConn</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>lockWaitTimeout</name></name></expr></argument>, <argument><expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reltableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relkind</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reltype</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ncheck</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relchecks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hasindex</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relhasindex</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hasrules</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relhasrules</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relpages</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relpages</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_owning_tab</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owning_tab</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owning_col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owning_tab</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_owning_tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owning_col</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_owning_col</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reltablespace</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reltablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hasoids</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relhasoids</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hastriggers</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relhastriggers</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relpersistence</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relpersistence</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relispopulated</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relispopulated</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relreplident</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relreplident</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rowsec</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relrowsec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forcerowsec</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relforcerowsec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>frozenxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>toast_frozenxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_toastfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>toast_oid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_toastoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>minmxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relminmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>toast_minmxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_toastminmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reloptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reloptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_checkoption</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>checkoption</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>checkoption</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_checkoption</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>toast_reloptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_toastreloptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_parrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reloftype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reloftype</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reloftype</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reloftype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>amname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>amname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_identity_sequence</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_is_identity_sequence</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>partkeydef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_partkeydef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ispartition</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ispartition</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>partbound</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_partbound</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relstorage</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relstorage</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>distclause</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_distclause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_parlevel</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_parlevel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parparent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parparent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>partclause</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_partclause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parttemplate</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_parttemplate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parparent</name> <operator>&amp;&amp;</operator> <name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parrelid</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relstorage</name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Length of tmpStr is bigger than the sum of NAMEDATALEN
			 * and the length of EXT_PARTITION_NAME_POSTFIX
			 */</comment>
			<decl_stmt><decl><type><name>char</name></type> <name><name>tmpStr</name><index>[<expr><literal type="number">500</literal></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpStr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmpStr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>EXT_PARTITION_NAME_POSTFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>tmpStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* AO table metadata will be set in getAOTableInfo() */</comment>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>aotbl</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>toast_index</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_toast_index_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>toast_type</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_toast_type_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* other fields were zeroed above */</comment>

		<comment type="block">/*
		 * GPDB5/6: To gather binary upgrade information for GP partition children,
		 * they need to exist in the tblinfo array for findTableByOid.
		 * This requires the getTable query to also collect all
		 * partition children so they can be referenced, but we do not want
		 * to dump the partition children as their DDL will be handled by the parent.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator> <name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parrelid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>selectDumpableTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Now, consider the table "interesting" if we need to dump its
		 * definition or its data.  Later on, we'll skip a lot of data
		 * collection for uninteresting tables.
		 *
		 * Note: the "interesting" flag will also be set by flagInhTables for
		 * parents of interesting tables, so that we collect necessary
		 * inheritance info even when the parents are not themselves being
		 * dumped.  This is the main reason why we need an "interesting" flag
		 * that's separate from the components-to-dump bitmask.
		 */</comment>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>interesting</name> <operator>=</operator> <operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator>
								  <operator>(</operator><name>DUMP_COMPONENT_DEFINITION</name> <operator>|</operator>
								   <name>DUMP_COMPONENT_DATA</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dummy_view</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might get set during sort */</comment>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>postponed_def</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might get set during sort */</comment>

		<comment type="block">/* Tables have data */</comment>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_DATA</name></expr>;</expr_stmt>

		<comment type="block">/* Mark whether table has an ACL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hascolumnACLs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* may get set later */</comment>

		<comment type="block">/*
		 * Read-lock target tables to make sure they aren't DROPPED or altered
		 * in schema before we get around to dumping them.
		 *
		 * Note that we don't explicitly lock parents of the target tables; we
		 * assume our lock on the child is enough to prevent schema
		 * alterations to parent tables.
		 *
		 * NOTE: it'd be kinda nice to lock other relations too, not only
		 * plain or partitioned tables, but the backend doesn't presently
		 * allow that.
		 *
		 * We only need to lock the table for certain components; see
		 * pg_dump.h
		 *
		 * GPDB: Build a single LOCK TABLE statement to lock all interesting tables.
		 * This is more performant than issuing a separate LOCK TABLE statement for each table,
		 * with considerable savings in FE/BE overhead. It does come at the cost of some increased
		 * memory usage in both FE and BE, which we will be able to tolerate.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENTS_REQUIRING_LOCK</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			 <name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockTableDumped</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						<argument><expr><literal type="string">"LOCK TABLE %s "</literal></expr></argument>,
						<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						<argument><expr><literal type="string">",%s "</literal></expr></argument>,
						<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>lockTableDumped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Are there any tables to lock? */</comment>
	<if_stmt><if>if <condition>(<expr><name>lockTableDumped</name></expr>)</condition>
	<block>{<block_content>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
			<argument><expr><literal type="string">"IN ACCESS SHARE MODE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>lockWaitTimeout</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SET statement_timeout = 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tblinfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>getAOTableInfo</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>	<modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOTableInfo</name> <modifier>*</modifier></type><name>aotblinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_columnstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_segrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_segreltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_blkdirrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_blkdirreltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_blkdiridxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_visimaprelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_visimapreltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_visimapidxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT "</literal>
						<literal type="string">"ao.relid,"</literal>
						<literal type="string">"ao.columnstore,"</literal>
						<literal type="string">"ao.segrelid, t1.reltype as segreltype, "</literal>
						<literal type="string">"ao.blkdirrelid, t3.reltype as blkdirreltype, "</literal>
						<literal type="string">"ao.blkdiridxid, "</literal>
						<literal type="string">"ao.visimaprelid, t2.reltype as visimapreltype, "</literal>
						<literal type="string">"ao.visimapidxid "</literal>
						<literal type="string">"\nFROM pg_catalog.pg_appendonly ao\n"</literal>
						<literal type="string">"LEFT JOIN pg_class c ON (c.oid=ao.relid)\n"</literal>
						<literal type="string">"LEFT JOIN pg_class t1 ON (t1.oid=ao.segrelid)\n"</literal>
						<literal type="string">"LEFT JOIN pg_class t2 ON (t2.oid=ao.visimaprelid)\n"</literal>
						<literal type="string">"LEFT JOIN pg_class t3 ON (t3.oid=ao.blkdirrelid and ao.blkdirrelid &lt;&gt; 0)\n"</literal>
						<literal type="string">"ORDER BY 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_columnstore</name> <operator>=</operator>  <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"columnstore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_segrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"segrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_segreltype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"segreltype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_blkdirrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"blkdirrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_blkdirreltype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"blkdirreltype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_blkdiridxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"blkdiridxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_visimaprelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"visimaprelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_visimapreltype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"visimapreltype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_visimapidxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"visimapidxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><call><name>findTableByOid</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>tbinfo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>aotblinfo</name> <operator>=</operator> <operator>(</operator><name>AOTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AOTableInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aotblinfo</name><operator>-&gt;</operator><name>columnstore</name></name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_columnstore</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aotblinfo</name><operator>-&gt;</operator><name>segrelid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_segrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aotblinfo</name><operator>-&gt;</operator><name>segreltype</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_segreltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aotblinfo</name><operator>-&gt;</operator><name>blkdirrelid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_blkdirrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aotblinfo</name><operator>-&gt;</operator><name>blkdirreltype</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_blkdirreltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aotblinfo</name><operator>-&gt;</operator><name>blkdiridxid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_blkdiridxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aotblinfo</name><operator>-&gt;</operator><name>visimaprelid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_visimaprelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aotblinfo</name><operator>-&gt;</operator><name>visimapreltype</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_visimapreltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aotblinfo</name><operator>-&gt;</operator><name>visimapidxid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_visimapidxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>aotbl</name></name> <operator>=</operator> <name>aotblinfo</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>getBMIndxInfo</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMIndxInfo</name> <modifier>*</modifier></type><name>bmindxinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>i_indexrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>i_bmrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>i_bmreltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>i_bmidxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>bitmap_index_namespace</name></decl>;</decl_stmt>

	<comment type="block">/* On GPDB5 pg_bitmapindex OID is 3012 */</comment>
	<expr_stmt><expr><name>bitmap_index_namespace</name> <operator>=</operator> <ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <name>GPDB6_MAJOR_PGVERSION</name></expr> ?</condition><then> <expr><name>PG_BITMAPINDEX_NAMESPACE</name></expr> </then><else>: <expr><literal type="number">3012</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT "</literal>
						<literal type="string">"bm.indexrelid, bm.bmrelid, bm.bmreltype, bmidx.bmidxid\n"</literal>
						<literal type="string">"FROM (SELECT substring(relname FROM \'\\d+\')::oid as indexrelid, "</literal>
						<literal type="string">"			oid as bmrelid, reltype as bmreltype\n "</literal>
						<literal type="string">"			FROM pg_class\n"</literal>
						<literal type="string">"			WHERE relnamespace='%u' AND relkind='r') as bm\n"</literal>
						<literal type="string">"JOIN (SELECT substring(relname FROM \'\\d+\')::oid as indexrelid, "</literal>
						<literal type="string">"			oid as bmidxid\n"</literal>
						<literal type="string">"			FROM pg_class\n"</literal>
						<literal type="string">"			WHERE relnamespace='%u' AND relkind='i') as bmidx "</literal>
						<literal type="string">"ON (bmidx.indexrelid=bm.indexrelid)\n"</literal>
						<literal type="string">"ORDER BY 1"</literal></expr></argument>,
						<argument><expr><name>bitmap_index_namespace</name></expr></argument>, <argument><expr><name>bitmap_index_namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_indexrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indexrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_bmrelid</name> <operator>=</operator>  <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"bmrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_bmreltype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"bmreltype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_bmidxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"bmidxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndxInfo</name> <modifier>*</modifier></type><name>indxinfo</name> <init>= <expr><call><name>findIndexByOid</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_indexrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>indxinfo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bmindxinfo</name> <operator>=</operator> <operator>(</operator><name>BMIndxInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMIndxInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bmindxinfo</name><operator>-&gt;</operator><name>bmrelid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_bmrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bmindxinfo</name><operator>-&gt;</operator><name>bmreltype</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_bmreltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bmindxinfo</name><operator>-&gt;</operator><name>bmidxid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_bmidxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>bmidx</name></name> <operator>=</operator> <name>bmindxinfo</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getOwnedSeqs
 *	  identify owned sequences and mark them as dumpable if owning table is
 *
 * We used to do this in getTables(), but it's better to do it after the
 * index used by findTableByOid() has been set up.
 */</comment>
<function><type><name>void</name></type>
<name>getOwnedSeqs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Force sequences that are "owned" by table columns to be dumped whenever
	 * their owning table is being dumped.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>seqinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>owning_tab</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* not an owned sequence */</comment>

		<expr_stmt><expr><name>owning_tab</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>owning_tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"failed sanity check, parent table with OID %u of sequence with OID %u not found"</literal></expr></argument>,
				  <argument><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>, <argument><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Only dump identity sequences if we're going to dump the table that
		 * it belongs to.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>owning_tab</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>==</operator> <name>DUMP_COMPONENT_NONE</name> <operator>&amp;&amp;</operator>
			<name><name>seqinfo</name><operator>-&gt;</operator><name>is_identity_sequence</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise we need to dump the components that are being dumped for
		 * the table and any components which the sequence is explicitly
		 * marked with.
		 *
		 * We can't simply use the set of components which are being dumped
		 * for the table as the table might be in an extension (and only the
		 * non-extension components, eg: ACLs if changed, security labels, and
		 * policies, are being dumped) while the sequence is not (and
		 * therefore the definition and other components should also be
		 * dumped).
		 *
		 * If the sequence is part of the extension then it should be properly
		 * marked by checkExtensionMembership() and this will be a no-op as
		 * the table will be equivalently marked.
		 */</comment>
		<expr_stmt><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>seqinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>|</operator> <name><name>owning_tab</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>seqinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>!=</operator> <name>DUMP_COMPONENT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>interesting</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * getInherits
 *	  read all the inheritance information
 * from the system catalogs return them in the InhInfo* structure
 *
 * numInherits is set to the number of pairs read in
 */</comment>
<function><type><name>InhInfo</name> <modifier>*</modifier></type>
<name>getInherits</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numInherits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InhInfo</name>    <modifier>*</modifier></type><name>inhinfo</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>i_inhrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_inhparent</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find all the inheritance information, excluding implicit inheritance
	 * via partitioning.  We handle that case using getPartitions(), because
	 * we want more information about partitions than just the parent-child
	 * relationship.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT inhrelid, inhparent FROM pg_inherits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numInherits</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>inhinfo</name> <operator>=</operator> <operator>(</operator><name>InhInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>InhInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_inhrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"inhrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_inhparent</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"inhparent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>inhinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>inhrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_inhrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inhinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>inhparent</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_inhparent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>inhinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getIndexes
 *	  get information about every index on a dumpable table
 *
 * Note: index data is not returned directly to the caller, but it
 * does get entered into the DumpableObject tables.
 */</comment>
<function><type><name>void</name></type>
<name>getIndexes</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tbloids</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curtblindx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndxInfo</name>   <modifier>*</modifier></type><name>indxinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>,
				<decl><type ref="prev"/><name>i_oid</name></decl>,
				<decl><type ref="prev"/><name>i_indrelid</name></decl>,
				<decl><type ref="prev"/><name>i_indexname</name></decl>,
				<decl><type ref="prev"/><name>i_parentidx</name></decl>,
				<decl><type ref="prev"/><name>i_indexdef</name></decl>,
				<decl><type ref="prev"/><name>i_indnkeyatts</name></decl>,
				<decl><type ref="prev"/><name>i_indnatts</name></decl>,
				<decl><type ref="prev"/><name>i_indkey</name></decl>,
				<decl><type ref="prev"/><name>i_indisclustered</name></decl>,
				<decl><type ref="prev"/><name>i_indisreplident</name></decl>,
				<decl><type ref="prev"/><name>i_contype</name></decl>,
				<decl><type ref="prev"/><name>i_conname</name></decl>,
				<decl><type ref="prev"/><name>i_condeferrable</name></decl>,
				<decl><type ref="prev"/><name>i_condeferred</name></decl>,
				<decl><type ref="prev"/><name>i_contableoid</name></decl>,
				<decl><type ref="prev"/><name>i_conoid</name></decl>,
				<decl><type ref="prev"/><name>i_condef</name></decl>,
				<decl><type ref="prev"/><name>i_tablespace</name></decl>,
				<decl><type ref="prev"/><name>i_indreloptions</name></decl>,
				<decl><type ref="prev"/><name>i_indstatcols</name></decl>,
				<decl><type ref="prev"/><name>i_indstatvals</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We want to perform just one query against pg_index.  However, we
	 * mustn't try to select every row of the catalog and then sort it out on
	 * the client side, because some of the server-side functions we need
	 * would be unsafe to apply to tables we don't have lock on.  Hence, we
	 * build an array of the OIDs of tables we care about (and now have lock
	 * on!), and use a WHERE clause to constrain which rows are selected.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>hasindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We can ignore indexes of uninteresting tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>interesting</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* OK, we need info for this table */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbloids</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* do we have more than the '{'? */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT t.tableoid, t.oid, i.indrelid, "</literal>
					  <literal type="string">"t.relname AS indexname, "</literal>
					  <literal type="string">"pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, "</literal>
					  <literal type="string">"i.indkey, i.indisclustered, "</literal>
					  <literal type="string">"c.contype, c.conname, "</literal>
					  <literal type="string">"c.condeferrable, c.condeferred, "</literal>
					  <literal type="string">"c.tableoid AS contableoid, "</literal>
					  <literal type="string">"c.oid AS conoid, "</literal>
					  <literal type="string">"pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, "</literal>
					  <literal type="string">"(SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, "</literal>
					  <literal type="string">"t.reloptions AS indreloptions, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"i.indisreplident, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"false AS indisreplident, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"inh.inhparent AS parentidx, "</literal>
						  <literal type="string">"i.indnkeyatts AS indnkeyatts, "</literal>
						  <literal type="string">"i.indnatts AS indnatts, "</literal>
						  <literal type="string">"(SELECT pg_catalog.array_agg(attnum ORDER BY attnum) "</literal>
						  <literal type="string">"  FROM pg_catalog.pg_attribute "</literal>
						  <literal type="string">"  WHERE attrelid = i.indexrelid AND "</literal>
						  <literal type="string">"    attstattarget &gt;= 0) AS indstatcols, "</literal>
						  <literal type="string">"(SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum) "</literal>
						  <literal type="string">"  FROM pg_catalog.pg_attribute "</literal>
						  <literal type="string">"  WHERE attrelid = i.indexrelid AND "</literal>
						  <literal type="string">"    attstattarget &gt;= 0) AS indstatvals "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"0 AS parentidx, "</literal>
						  <literal type="string">"i.indnatts AS indnkeyatts, "</literal>
						  <literal type="string">"i.indnatts AS indnatts, "</literal>
						  <literal type="string">"'' AS indstatcols, "</literal>
						  <literal type="string">"'' AS indstatvals "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							<argument><expr><literal type="string">"FROM unnest('%s'::pg_catalog.oid[]) AS src(tbloid)\n"</literal>
							<literal type="string">"JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) "</literal>
							<literal type="string">"JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) "</literal></expr></argument>,
							<argument><expr><name><name>tbloids</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * The point of the messy-looking outer join is to find a constraint that
	 * is related by an internal dependency link to the index. If we find one,
	 * create a CONSTRAINT entry linked to the INDEX entry.  We assume an
	 * index won't have more than one internal dependency.
	 *
	 * As of 9.0 we don't need to look at pg_depend but can check for a match
	 * to pg_constraint.conindid.  The check on conrelid is redundant but
	 * useful because that column is indexed while conindid is not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_constraint c "</literal>
						  <literal type="string">"ON (i.indrelid = c.conrelid AND "</literal>
						  <literal type="string">"i.indexrelid = c.conindid AND "</literal>
						  <literal type="string">"c.contype IN ('p','u','x')) "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_inherits inh "</literal>
						  <literal type="string">"ON (inh.inhrelid = indexrelid) "</literal>
						  <literal type="string">"WHERE (i.indisvalid OR t2.relkind = 'p') "</literal>
						  <literal type="string">"AND i.indisready "</literal>
						  <literal type="string">"ORDER BY i.indrelid, indexname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * the test on indisready is necessary in 9.2, and harmless in
		 * earlier/later versions
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"LEFT JOIN pg_catalog.pg_constraint c "</literal>
						  <literal type="string">"ON (i.indrelid = c.conrelid AND "</literal>
						  <literal type="string">"i.indexrelid = c.conindid AND "</literal>
						  <literal type="string">"c.contype IN ('p','u','x')) "</literal>
						  <literal type="string">"WHERE i.indisvalid AND i.indisready "</literal>
						  <literal type="string">"ORDER BY i.indrelid, indexname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"LEFT JOIN pg_catalog.pg_depend d "</literal>
						  <literal type="string">"ON (d.classid = t.tableoid "</literal>
						  <literal type="string">"AND d.objid = t.oid "</literal>
						  <literal type="string">"AND d.deptype = 'i') "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_constraint c "</literal>
						  <literal type="string">"ON (d.refclassid = c.tableoid "</literal>
						  <literal type="string">"AND d.refobjid = c.oid) "</literal>
						  <literal type="string">"WHERE i.indisvalid "</literal>
						  <literal type="string">"ORDER BY i.indrelid, indexname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indexname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indexname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_parentidx</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"parentidx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indexdef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indexdef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indnkeyatts</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indnkeyatts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indnatts</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indnatts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indkey</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indkey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indisclustered</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indisclustered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indisreplident</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indisreplident"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_contype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"contype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_condeferrable</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"condeferrable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_condeferred</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"condeferred"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_contableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"contableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_condef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"condef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tablespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indreloptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indreloptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indstatcols</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indstatcols"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indstatvals</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indstatvals"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indxinfo</name> <operator>=</operator> <operator>(</operator><name>IndxInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndxInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Outer loop iterates once per table, not once per row.  Incrementing of
	 * j is handled by the inner loop.
	 */</comment>
	<expr_stmt><expr><name>curtblindx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indrelid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numinds</name></decl>;</decl_stmt>

		<comment type="block">/* Count rows for this table */</comment>
		<for>for <control>(<init><expr><name>numinds</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>numinds</name> <operator>&lt;</operator> <name>ntups</name> <operator>-</operator> <name>j</name></expr>;</condition> <incr><expr><name>numinds</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <name>numinds</name></expr></argument>, <argument><expr><name>i_indrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>indrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

		<comment type="block">/*
		 * Locate the associated TableInfo; we rely on tblinfo[] being in OID
		 * order.
		 */</comment>
		<while>while <condition>(<expr><operator>++</operator><name>curtblindx</name> <operator>&lt;</operator> <name>numTables</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tbinfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>curtblindx</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>==</operator> <name>indrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>curtblindx</name> <operator>&gt;=</operator> <name>numTables</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized table OID %u"</literal></expr></argument>, <argument><expr><name>indrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* cross-check that we only got requested tables */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>hasindex</name></name> <operator>||</operator>
			<operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>interesting</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unexpected index data for table \"%s\""</literal></expr></argument>,
				  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Save data for this table */</comment>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <name>indxinfo</name> <operator>+</operator> <name>j</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>numIndexes</name></name> <operator>=</operator> <name>numinds</name></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>numinds</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>contype</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_INDEX</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indexname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indextable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indexdef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indexdef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indnkeyattrs</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indnkeyatts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indnattrs</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indnatts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tablespace</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indreloptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indreloptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indstatcols</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indstatcols</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indstatvals</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indstatvals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indkeys</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indnattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>parseOidArray</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indkey</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indkeys</name></expr></argument>, <argument><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indnattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indisclustered</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indisclustered</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indisreplident</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indisreplident</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>parentidx</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_parentidx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>partattaches</name> <operator>=</operator> <operator>(</operator><name>SimplePtrList</name><operator>)</operator> <block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>;</expr_stmt>
			<expr_stmt><expr><name>contype</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_contype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>contype</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>||</operator> <name>contype</name> <operator>==</operator> <literal type="char">'u'</literal> <operator>||</operator> <name>contype</name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If we found a constraint matching the index, create an
				 * entry for it.
				 */</comment>
				<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constrinfo</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>constrinfo</name> <operator>=</operator> <operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConstraintInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_CONSTRAINT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_contableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>constrinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>contable</name></name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>condomain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>contype</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>contype</name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>condef</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_condef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>condef</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>confrelid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>conindex</name></name> <operator>=</operator> <name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_condeferrable</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_condeferred</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><operator>-&gt;</operator><name>separate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indexconstraint</name> <operator>=</operator> <name><name>constrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Plain secondary index */</comment>
				<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indexconstraint</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<comment type="block">/* Bitmap index metadata is collected in getBMIndxInfo */</comment>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>bmidx</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getExtendedStatistics
 *	  get information about extended-statistics objects.
 *
 * Note: extended statistics data is not returned directly to the caller, but
 * it does get entered into the DumpableObject tables.
 */</comment>
<function><type><name>void</name></type>
<name>getExtendedStatistics</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StatsExtInfo</name> <modifier>*</modifier></type><name>statsextinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_stxname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_stxnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_stxowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Extended statistics were new in v10 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, stxname, "</literal>
					  <literal type="string">"stxnamespace, stxowner "</literal>
					  <literal type="string">"FROM pg_catalog.pg_statistic_ext"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_stxname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"stxname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_stxnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"stxnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_stxowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"stxowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>statsextinfo</name> <operator>=</operator> <operator>(</operator><name>StatsExtInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StatsExtInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_STATSEXT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_stxname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_stxnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_stxowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getConstraints
 *
 * Get info about constraints on dumpable tables.
 *
 * Currently handles foreign keys only.
 * Unique and primary key constraints are handled with indexes,
 * while check constraints are processed in getTableAttrs().
 */</comment>
<function><type><name>void</name></type>
<name>getConstraints</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tbloids</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curtblindx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constrinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_contableoid</name></decl>,
				<decl><type ref="prev"/><name>i_conoid</name></decl>,
				<decl><type ref="prev"/><name>i_conrelid</name></decl>,
				<decl><type ref="prev"/><name>i_conname</name></decl>,
				<decl><type ref="prev"/><name>i_confrelid</name></decl>,
				<decl><type ref="prev"/><name>i_conindid</name></decl>,
				<decl><type ref="prev"/><name>i_condef</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We want to perform just one query against pg_constraint.  However, we
	 * mustn't try to select every row of the catalog and then sort it out on
	 * the client side, because some of the server-side functions we need
	 * would be unsafe to apply to tables we don't have lock on.  Hence, we
	 * build an array of the OIDs of tables we care about (and now have lock
	 * on!), and use a WHERE clause to constrain which rows are selected.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For partitioned tables, foreign keys have no triggers so they must
		 * be included anyway in case some foreign keys are defined.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>hastriggers</name></name> <operator>&amp;&amp;</operator>
			 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator> <operator>||</operator>
			<operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* OK, we need info for this table */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbloids</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* do we have more than the '{'? */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, "</literal>
						 <literal type="string">"conrelid, conname, confrelid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"conindid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"0 AS conindid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"pg_catalog.pg_get_constraintdef(c.oid) AS condef\n"</literal>
					  <literal type="string">"FROM unnest('%s'::pg_catalog.oid[]) AS src(tbloid)\n"</literal>
					  <literal type="string">"JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)\n"</literal>
					  <literal type="string">"WHERE contype = 'f' "</literal></expr></argument>,
					  <argument><expr><name><name>tbloids</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"AND conparentid = 0 "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						 <argument><expr><literal type="string">"ORDER BY conrelid, conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_contableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_confrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"confrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conindid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conindid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_condef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"condef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>constrinfo</name> <operator>=</operator> <operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstraintInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>curtblindx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>conrelid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>reftable</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Locate the associated TableInfo; we rely on tblinfo[] being in OID
		 * order.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tbinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name>conrelid</name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><operator>++</operator><name>curtblindx</name> <operator>&lt;</operator> <name>numTables</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tbinfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>curtblindx</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>==</operator> <name>conrelid</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name>curtblindx</name> <operator>&gt;=</operator> <name>numTables</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized table OID %u"</literal></expr></argument>, <argument><expr><name>conrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_FK_CONSTRAINT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_contableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>contable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condomain</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>contype</name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_condef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>confrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_confrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>conindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condeferrable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condeferred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>conislocal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restoring an FK that points to a partitioned table requires that
		 * all partition indexes have been attached beforehand. Ensure that
		 * happens by making the constraint depend on each index partition
		 * attach object.
		 */</comment>
		<expr_stmt><expr><name>reftable</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>confrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>reftable</name> <operator>&amp;&amp;</operator> <name><name>reftable</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conindid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>indexOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>reftable</name><operator>-&gt;</operator><name>numIndexes</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>IndxInfo</name>   <modifier>*</modifier></type><name>refidx</name></decl>;</decl_stmt>

					<comment type="block">/* not our index? */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>reftable</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name>indexOid</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>refidx</name> <operator>=</operator> <operator>&amp;</operator><name><name>reftable</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>addConstrChildIdxDeps</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>, <argument><expr><name>refidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * addConstrChildIdxDeps
 *
 * Recursive subroutine for getConstraints
 *
 * Given an object representing a foreign key constraint and an index on the
 * partitioned table it references, mark the constraint object as dependent
 * on each partition, recursing to children until all leaves are found.
 * This ensures that the FK is not restored until the index is fully marked
 * valid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addConstrChildIdxDeps</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndxInfo</name> <modifier>*</modifier></type><name>refidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SimplePtrListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_FK_CONSTRAINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>refidx</name><operator>-&gt;</operator><name>partattaches</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>childobj</name> <init>= <expr><operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>)</operator> <name><name>cell</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexAttachInfo</name> <modifier>*</modifier></type><name>attach</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>childobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>attach</name> <operator>=</operator> <operator>(</operator><name>IndexAttachInfo</name> <operator>*</operator><operator>)</operator> <name>childobj</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attach</name><operator>-&gt;</operator><name>partitionIdx</name><operator>-&gt;</operator><name>partattaches</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addConstrChildIdxDeps</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>attach</name><operator>-&gt;</operator><name>partitionIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * getDomainConstraints
 *
 * Get info about constraints on a domain.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getDomainConstraints</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constrinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>,
				<decl><type ref="prev"/><name>i_oid</name></decl>,
				<decl><type ref="prev"/><name>i_conname</name></decl>,
				<decl><type ref="prev"/><name>i_consrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_GETDOMAINCONSTRAINTS</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up query for constraint-specific details */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"PREPARE getDomainConstraints(pg_catalog.oid) AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, conname, "</literal>
								 <literal type="string">"pg_catalog.pg_get_constraintdef(oid) AS consrc, "</literal>
								 <literal type="string">"convalidated "</literal>
								 <literal type="string">"FROM pg_catalog.pg_constraint "</literal>
								 <literal type="string">"WHERE contypid = $1 "</literal>
								 <literal type="string">"ORDER BY conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, conname, "</literal>
								 <literal type="string">"pg_catalog.pg_get_constraintdef(oid) AS consrc, "</literal>
								 <literal type="string">"true as convalidated "</literal>
								 <literal type="string">"FROM pg_catalog.pg_constraint "</literal>
								 <literal type="string">"WHERE contypid = $1 "</literal>
								 <literal type="string">"ORDER BY conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_GETDOMAINCONSTRAINTS</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"EXECUTE getDomainConstraints('%u')"</literal></expr></argument>,
					  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_consrc</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"consrc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>constrinfo</name> <operator>=</operator> <operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstraintInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>nDomChecks</name></name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>domChecks</name></name> <operator>=</operator> <name>constrinfo</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>validated</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_CONSTRAINT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>contable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>condomain</name> <operator>=</operator> <name>tyinfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>contype</name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>condef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_consrc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>confrelid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>condeferrable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>condeferred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conislocal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <operator>!</operator><name>validated</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make the domain depend on the constraint, ensuring it won't be
		 * output till any constraint dependencies are OK.  If the constraint
		 * has not been validated, it's going to be dumped after the domain
		 * anyway, so this doesn't matter.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>validated</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
								<argument><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getRules
 *	  get basic information about every rule in the system
 *
 * numRules is set to the number of rules read in
 */</comment>
<function><type><name>RuleInfo</name> <modifier>*</modifier></type>
<name>getRules</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numRules</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RuleInfo</name>   <modifier>*</modifier></type><name>ruleinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rulename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ruletable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ev_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_is_instead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ev_enabled</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
							<literal type="string">"tableoid, oid, rulename, "</literal>
							<literal type="string">"ev_class AS ruletable, ev_type, is_instead, "</literal>
							<literal type="string">"ev_enabled "</literal>
							<literal type="string">"FROM pg_rewrite "</literal>
							<literal type="string">"ORDER BY oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numRules</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ruleinfo</name> <operator>=</operator> <operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RuleInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rulename</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rulename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ruletable</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ruletable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ev_type</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ev_type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_is_instead</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"is_instead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ev_enabled</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ev_enabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ruletableoid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_RULE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rulename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ruletableoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ruletable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ruletable</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>ruletableoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ruletable</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"failed sanity check, parent table with OID %u of pg_rewrite entry with OID %u not found"</literal></expr></argument>,
				  <argument><expr><name>ruletableoid</name></expr></argument>, <argument><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_type</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ev_type</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_instead</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_is_instead</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_enabled</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ev_enabled</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ruletable</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the table is a view or materialized view, force its ON
			 * SELECT rule to be sorted before the view itself --- this
			 * ensures that any dependencies for the rule affect the table's
			 * positioning. Other rules are forced to appear after their
			 * table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
				 <name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_type</name> <operator>==</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_instead</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
									<argument><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We'll merge the rule into CREATE VIEW, if possible */</comment>
				<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>,
									<argument><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ruleinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTriggers
 *	  get information about every trigger on a dumpable table
 *
 * Note: trigger data is not returned directly to the caller, but it
 * does get entered into the DumpableObject tables.
 */</comment>
<function><type><name>void</name></type>
<name>getTriggers</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tbloids</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curtblindx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerInfo</name> <modifier>*</modifier></type><name>tginfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>,
				<decl><type ref="prev"/><name>i_oid</name></decl>,
				<decl><type ref="prev"/><name>i_tgrelid</name></decl>,
				<decl><type ref="prev"/><name>i_tgname</name></decl>,
				<decl><type ref="prev"/><name>i_tgfname</name></decl>,
				<decl><type ref="prev"/><name>i_tgtype</name></decl>,
				<decl><type ref="prev"/><name>i_tgnargs</name></decl>,
				<decl><type ref="prev"/><name>i_tgargs</name></decl>,
				<decl><type ref="prev"/><name>i_tgisconstraint</name></decl>,
				<decl><type ref="prev"/><name>i_tgconstrname</name></decl>,
				<decl><type ref="prev"/><name>i_tgconstrrelid</name></decl>,
				<decl><type ref="prev"/><name>i_tgconstrrelname</name></decl>,
				<decl><type ref="prev"/><name>i_tgenabled</name></decl>,
				<decl><type ref="prev"/><name>i_tgdeferrable</name></decl>,
				<decl><type ref="prev"/><name>i_tginitdeferred</name></decl>,
				<decl><type ref="prev"/><name>i_tgdef</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We want to perform just one query against pg_trigger.  However, we
	 * mustn't try to select every row of the catalog and then sort it out on
	 * the client side, because some of the server-side functions we need
	 * would be unsafe to apply to tables we don't have lock on.  Hence, we
	 * build an array of the OIDs of tables we care about (and now have lock
	 * on!), and use a WHERE clause to constrain which rows are selected.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>hastriggers</name></name> <operator>||</operator>
			<operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* OK, we need info for this table */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbloids</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* do we have more than the '{'? */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* See above about pretty=true in pg_get_triggerdef */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT t.tgrelid, t.tgname, "</literal>
						  <literal type="string">"t.tgfoid::pg_catalog.regproc AS tgfname, "</literal>
						  <literal type="string">"pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, "</literal>
						  <literal type="string">"t.tgenabled, t.tableoid, t.oid "</literal>
						  <literal type="string">"FROM unnest('%s'::pg_catalog.oid[]) AS src(tbloid)\n"</literal>
						  <literal type="string">"JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) "</literal>
						  <literal type="string">"WHERE NOT t.tgisinternal "</literal>
						  <literal type="string">"ORDER BY t.tgrelid, t.tgname"</literal></expr></argument>,
						  <argument><expr><name><name>tbloids</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We ignore triggers that are tied to a foreign-key constraint
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT t.tgrelid, tgname, "</literal>
						  <literal type="string">"tgfoid::pg_catalog.regproc AS tgfname, "</literal>
						  <literal type="string">"tgtype, tgnargs, tgargs, tgenabled, "</literal>
						  <literal type="string">"false as tgisinternal, "</literal>
						  <literal type="string">"tgisconstraint, tgconstrname, tgdeferrable, "</literal>
						  <literal type="string">"tgconstrrelid, tginitdeferred, t.tableoid, t.oid, "</literal>
						  <literal type="string">"tgconstrrelid::pg_catalog.regclass AS tgconstrrelname "</literal>
						  <literal type="string">"FROM unnest('%s'::pg_catalog.oid[]) AS src(tbloid)\n"</literal>
						  <literal type="string">"JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) "</literal>
						  <literal type="string">"WHERE tgconstraint = 0 "</literal>
						  <literal type="string">"ORDER BY t.tgrelid, t.tgname"</literal></expr></argument>,
							<argument><expr><name><name>tbloids</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgfname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgfname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgtype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgnargs</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgnargs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgargs</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgargs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgisconstraint</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgisconstraint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgconstrname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgconstrname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgconstrrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgconstrrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgconstrrelname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgconstrrelname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgenabled</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgenabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgdeferrable</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgdeferrable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tginitdeferred</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tginitdeferred"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tgdef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgdef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tginfo</name> <operator>=</operator> <operator>(</operator><name>TriggerInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TriggerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Outer loop iterates once per table, not once per row.  Incrementing of
	 * j is handled by the inner loop.
	 */</comment>
	<expr_stmt><expr><name>curtblindx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>tgrelid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numtrigs</name></decl>;</decl_stmt>

		<comment type="block">/* Count rows for this table */</comment>
		<for>for <control>(<init><expr><name>numtrigs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>numtrigs</name> <operator>&lt;</operator> <name>ntups</name> <operator>-</operator> <name>j</name></expr>;</condition> <incr><expr><name>numtrigs</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <name>numtrigs</name></expr></argument>, <argument><expr><name>i_tgrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>tgrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

		<comment type="block">/*
		 * Locate the associated TableInfo; we rely on tblinfo[] being in OID
		 * order.
		 */</comment>
		<while>while <condition>(<expr><operator>++</operator><name>curtblindx</name> <operator>&lt;</operator> <name>numTables</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tbinfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>curtblindx</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>==</operator> <name>tgrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>curtblindx</name> <operator>&gt;=</operator> <name>numTables</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized table OID %u"</literal></expr></argument>, <argument><expr><name>tgrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Save data for this table */</comment>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>triggers</name></name> <operator>=</operator> <name>tginfo</name> <operator>+</operator> <name>j</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>numTriggers</name></name> <operator>=</operator> <name>numtrigs</name></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>numtrigs</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TRIGGER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgtable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgenabled</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgenabled</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>i_tgdef</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgdef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgdef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* remaining fields are not valid if we have tgdef */</comment>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgfname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgtype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgnargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgargs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgisconstraint</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgdeferrable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tginitdeferred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgdef</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgfname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgfname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgtype</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgnargs</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgnargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgargs</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgisconstraint</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgisconstraint</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgdeferrable</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgdeferrable</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tginitdeferred</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tginitdeferred</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgisconstraint</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgconstrname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgconstrrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgconstrrelname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"query produced null referenced table name for foreign key trigger \"%s\" on table \"%s\" (OID of table: %u)"</literal></expr></argument>,
								  <argument><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgconstrrelname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getEventTriggers
 *	  get information about event triggers
 */</comment>
<function><type><name>EventTriggerInfo</name> <modifier>*</modifier></type>
<name>getEventTriggers</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numEventTriggers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EventTriggerInfo</name> <modifier>*</modifier></type><name>evtinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>,
				<decl><type ref="prev"/><name>i_oid</name></decl>,
				<decl><type ref="prev"/><name>i_evtname</name></decl>,
				<decl><type ref="prev"/><name>i_evtevent</name></decl>,
				<decl><type ref="prev"/><name>i_evtowner</name></decl>,
				<decl><type ref="prev"/><name>i_evttags</name></decl>,
				<decl><type ref="prev"/><name>i_evtfname</name></decl>,
				<decl><type ref="prev"/><name>i_evtenabled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>

	<comment type="block">/* Before 9.3, there are no event triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numEventTriggers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT e.tableoid, e.oid, evtname, evtenabled, "</literal>
					  <literal type="string">"evtevent, evtowner, "</literal>
					  <literal type="string">"array_to_string(array("</literal>
					  <literal type="string">"select quote_literal(x) "</literal>
					  <literal type="string">" from unnest(evttags) as t(x)), ', ') as evttags, "</literal>
					  <literal type="string">"e.evtfoid::regproc as evtfname "</literal>
					  <literal type="string">"FROM pg_event_trigger e "</literal>
					  <literal type="string">"ORDER BY e.oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numEventTriggers</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>evtinfo</name> <operator>=</operator> <operator>(</operator><name>EventTriggerInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EventTriggerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evtname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evtname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evtevent</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evtevent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evtowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evtowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evttags</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evttags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evtfname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evtfname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evtenabled</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evtenabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_EVENT_TRIGGER</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evtname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evtevent</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtevent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evtowner</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evttags</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evttags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evtfname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtfname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evtenabled</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtenabled</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>evtinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getProcLangs
 *	  get basic information about every procedural language in the system
 *
 * numProcLangs is set to the number of langs read in
 *
 * NB: this must run after getFuncs() because we assume we can do
 * findFuncByOid().
 */</comment>
<function><type><name>ProcLangInfo</name> <modifier>*</modifier></type>
<name>getProcLangs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numProcLangs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcLangInfo</name> <modifier>*</modifier></type><name>planginfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanpltrusted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanplcallfoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_laninline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanvalidator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_acldefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanowner</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The laninline column was added in upstream 90000 but was backported to
	 * Greenplum 5, so the check needs to go further back than 90000.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* acldefault() exists */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
						  <literal type="string">"lanname, lanpltrusted, lanplcallfoid, "</literal>
						  <literal type="string">"laninline, lanvalidator, "</literal>
						  <literal type="string">"lanacl, "</literal>
						  <literal type="string">"acldefault('l', lanowner) AS acldefault, "</literal>
						  <literal type="string">"lanowner "</literal>
						  <literal type="string">"FROM pg_language "</literal>
						  <literal type="string">"WHERE lanispl "</literal>
						  <literal type="string">"ORDER BY oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pg_language has a laninline column */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
						  <literal type="string">"lanname, lanpltrusted, lanplcallfoid, "</literal>
						  <literal type="string">"laninline, lanvalidator, "</literal>
						  <literal type="string">"lanacl, NULL AS acldefault, "</literal>
						  <literal type="string">"lanowner "</literal>
						  <literal type="string">"FROM pg_language "</literal>
						  <literal type="string">"WHERE lanispl "</literal>
						  <literal type="string">"ORDER BY oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <comment type="block">/* GPDB5 */</comment>
	<block>{<block_content>
		<comment type="block">/* pg_language has a laninline column */</comment>
		<comment type="block">/* pg_language has a lanowner column */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
						  <literal type="string">"lanname, lanpltrusted, lanplcallfoid, "</literal>
						  <literal type="string">"laninline, lanvalidator, lanacl, "</literal>
						  <literal type="string">"0 AS laninline, lanvalidator, lanacl, "</literal>
						  <literal type="string">"NULL AS acldefault, "</literal>
						  <literal type="string">"lanowner "</literal>
						  <literal type="string">"FROM pg_language "</literal>
						  <literal type="string">"WHERE lanispl "</literal>
						  <literal type="string">"ORDER BY oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numProcLangs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>planginfo</name> <operator>=</operator> <operator>(</operator><name>ProcLangInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ProcLangInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanpltrusted</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanpltrusted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanplcallfoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanplcallfoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_laninline</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"laninline"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanvalidator</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanvalidator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_PROCLANG</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lanpltrusted</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanpltrusted</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lanplcallfoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanplcallfoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>laninline</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_laninline</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lanvalidator</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanvalidator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lanowner</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableProcLang</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark whether language has an ACL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>planginfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getCasts
 *	  get basic information about every cast in the system
 *
 * numCasts is set to the number of casts read in
 */</comment>
<function><type><name>CastInfo</name> <modifier>*</modifier></type>
<name>getCasts</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numCasts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CastInfo</name>   <modifier>*</modifier></type><name>castinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_castsource</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_casttarget</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_castfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_castcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_castmethod</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
							 <literal type="string">"castsource, casttarget, castfunc, castcontext, "</literal>
							 <literal type="string">"castmethod "</literal>
							 <literal type="string">"FROM pg_cast ORDER BY 3,4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
							 <literal type="string">"castsource, casttarget, castfunc, castcontext, "</literal>
							 <literal type="string">"CASE WHEN castfunc = 0 THEN 'b' ELSE 'f' END AS castmethod "</literal>
							 <literal type="string">"FROM pg_cast ORDER BY 3,4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numCasts</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>castinfo</name> <operator>=</operator> <operator>(</operator><name>CastInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CastInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_castsource</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"castsource"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_casttarget</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"casttarget"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_castfunc</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"castfunc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_castcontext</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"castcontext"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_castmethod</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"castmethod"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>namebuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>sTypeInfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>tTypeInfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_CAST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>castsource</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_castsource</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>casttarget</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_casttarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>castfunc</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_castfunc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>castcontext</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_castcontext</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>castmethod</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_castmethod</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try to name cast as concatenation of typnames.  This is only used
		 * for purposes of sorting.  If we fail to find either type, the name
		 * will be an empty string.
		 */</comment>
		<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sTypeInfo</name> <operator>=</operator> <call><name>findTypeByOid</name><argument_list>(<argument><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>castsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tTypeInfo</name> <operator>=</operator> <call><name>findTypeByOid</name><argument_list>(<argument><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>casttarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sTypeInfo</name> <operator>&amp;&amp;</operator> <name>tTypeInfo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>,
							  <argument><expr><name><name>sTypeInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tTypeInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>namebuf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableCast</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>castinfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_language_name</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>langid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lanname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT lanname FROM pg_language WHERE oid = %u"</literal></expr></argument>, <argument><expr><name>langid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lanname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>lanname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTransforms
 *	  get basic information about every transform in the system
 *
 * numTransforms is set to the number of transforms read in
 */</comment>
<function><type><name>TransformInfo</name> <modifier>*</modifier></type>
<name>getTransforms</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTransforms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransformInfo</name> <modifier>*</modifier></type><name>transforminfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_trftype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_trflang</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_trffromsql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_trftosql</name></decl>;</decl_stmt>

	<comment type="block">/* Transforms didn't exist pre-9.5 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90500</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numTransforms</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
					  <literal type="string">"trftype, trflang, trffromsql::oid, trftosql::oid "</literal>
					  <literal type="string">"FROM pg_transform "</literal>
					  <literal type="string">"ORDER BY 3,4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numTransforms</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>transforminfo</name> <operator>=</operator> <operator>(</operator><name>TransformInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransformInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_trftype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"trftype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_trflang</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"trflang"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_trffromsql</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"trffromsql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_trftosql</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"trftosql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>namebuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>typeInfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lanname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TRANSFORM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trftype</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_trftype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trflang</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_trflang</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trffromsql</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_trffromsql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trftosql</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_trftosql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try to name transform as concatenation of type and language name.
		 * This is only used for purposes of sorting.  If we fail to find
		 * either, the name will be an empty string.
		 */</comment>
		<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typeInfo</name> <operator>=</operator> <call><name>findTypeByOid</name><argument_list>(<argument><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trftype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lanname</name> <operator>=</operator> <call><name>get_language_name</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trflang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typeInfo</name> <operator>&amp;&amp;</operator> <name>lanname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>,
							  <argument><expr><name><name>typeInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>namebuf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>transforminfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTableAttrs -
 *	  for each interesting table, read info about its attributes
 *	  (names, types, default values, CHECK constraints, etc)
 *
 *	modifies tblinfo
 */</comment>
<function><type><name>void</name></type>
<name>getTableAttrs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tbloids</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>checkoids</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curtblindx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_atttypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_atttypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attstattarget</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attstorage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typstorage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attidentity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attgenerated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attisdropped</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attislocal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attnotnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attoptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attfdwoptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attmissingval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_atthasdef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attencoding</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We want to perform just one query against pg_attribute, and then just
	 * one against pg_attrdef (for DEFAULTs) and one against pg_constraint
	 * (for CHECK constraints).  However, we mustn't try to select every row
	 * of those catalogs and then sort it out on the client side, because some
	 * of the server-side functions we need would be unsafe to apply to tables
	 * we don't have lock on.  Hence, we build an array of the OIDs of tables
	 * we care about (and now have lock on!), and use a WHERE clause to
	 * constrain which rows are selected.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>checkoids</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Don't bother to collect info for sequences */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Don't bother with uninteresting tables, either */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>interesting</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* OK, we need info for this table */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbloids</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* do we have more than the '{'? */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Also make a list of the ones with check constraints */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>checkoids</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* do we have more than the '{'? */</comment>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>checkoids</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>checkoids</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>checkoids</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* find all the user attributes and their types */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT\n"</literal>
						 <literal type="string">"a.attrelid,\n"</literal>
						 <literal type="string">"a.attnum,\n"</literal>
						 <literal type="string">"a.attname,\n"</literal>
						 <literal type="string">"a.atttypmod,\n"</literal>
						 <literal type="string">"a.attstattarget,\n"</literal>
						 <literal type="string">"a.attstorage,\n"</literal>
						 <literal type="string">"t.typstorage,\n"</literal>
						 <literal type="string">"a.attnotnull,\n"</literal>
						 <literal type="string">"a.atthasdef,\n"</literal>
						 <literal type="string">"a.attisdropped,\n"</literal>
						 <literal type="string">"a.attlen,\n"</literal>
						 <literal type="string">"a.attalign,\n"</literal>
						 <literal type="string">"a.attislocal,\n"</literal>
						 <literal type="string">"pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,\n"</literal>
						 <literal type="string">"pg_catalog.array_to_string(e.attoptions, ',') AS attencoding,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"array_to_string(a.attoptions, ', ') AS attoptions,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"'' AS attoptions,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Since we only want to dump COLLATE clauses for attributes whose
		 * collation is different from their type's default, we use a CASE
		 * here to suppress uninteresting attcollations cheaply.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"CASE WHEN a.attcollation &lt;&gt; t.typcollation "</literal>
							 <literal type="string">"THEN a.attcollation ELSE 0 END AS attcollation,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"0 AS attcollation,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"pg_catalog.array_to_string(ARRAY("</literal>
							 <literal type="string">"SELECT pg_catalog.quote_ident(option_name) || "</literal>
							 <literal type="string">"' ' || pg_catalog.quote_literal(option_value) "</literal>
							 <literal type="string">"FROM pg_catalog.pg_options_to_table(attfdwoptions) "</literal>
							 <literal type="string">"ORDER BY option_name"</literal>
							 <literal type="string">"), E',\n    ') AS attfdwoptions,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"'' AS attfdwoptions,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"a.attidentity,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"'' AS attidentity,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"CASE WHEN a.atthasmissing AND NOT a.attisdropped "</literal>
							 <literal type="string">"THEN a.attmissingval ELSE null END AS attmissingval,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"NULL AS attmissingval,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"a.attgenerated\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"'' AS attgenerated\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* need left join to pg_type to not fail on dropped columns ... */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
					  <argument><expr><literal type="string">"FROM unnest('%s'::pg_catalog.oid[]) AS src(tbloid)\n"</literal>
					  <literal type="string">"JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) "</literal>
					  <literal type="string">"LEFT JOIN pg_catalog.pg_type t "</literal>
					  <literal type="string">"ON (a.atttypid = t.oid)\n"</literal>
						<literal type="string">"LEFT OUTER JOIN pg_catalog.pg_attribute_encoding e "</literal>
						<literal type="string">"ON e.attrelid = a.attrelid AND e.attnum = a.attnum \n"</literal>
					  <literal type="string">"WHERE a.attnum &gt; 0::pg_catalog.int2\n"</literal>
					  <literal type="string">"ORDER BY a.attrelid, a.attnum"</literal></expr></argument>,
					  <argument><expr><name><name>tbloids</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_attrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attnum</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_atttypname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"atttypname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_atttypmod</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"atttypmod"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attstattarget</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attstattarget"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attstorage</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attstorage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typstorage</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typstorage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attidentity</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attidentity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attgenerated</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attgenerated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attisdropped</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attisdropped"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attlen</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attlen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attalign</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attalign"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attislocal</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attislocal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attnotnull</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attnotnull"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attcollation</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attcollation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attfdwoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attfdwoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attmissingval</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attmissingval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_atthasdef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"atthasdef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attencoding</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attencoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Within the next loop, we'll accumulate OIDs of tables with defaults */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Outer loop iterates once per table, not once per row.  Incrementing of
	 * r is handled by the inner loop.
	 */</comment>
	<expr_stmt><expr><name>curtblindx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>r</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>attrelid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numatts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hasdefaults</name></decl>;</decl_stmt>

		<comment type="block">/* Count rows for this table */</comment>
		<for>for <control>(<init><expr><name>numatts</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>numatts</name> <operator>&lt;</operator> <name>ntups</name> <operator>-</operator> <name>r</name></expr>;</condition> <incr><expr><name>numatts</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name> <operator>+</operator> <name>numatts</name></expr></argument>, <argument><expr><name>i_attrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>attrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

		<comment type="block">/*
		 * Locate the associated TableInfo; we rely on tblinfo[] being in OID
		 * order.
		 */</comment>
		<while>while <condition>(<expr><operator>++</operator><name>curtblindx</name> <operator>&lt;</operator> <name>numTables</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tbinfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>curtblindx</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>==</operator> <name>attrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>curtblindx</name> <operator>&gt;=</operator> <name>numTables</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized table OID %u"</literal></expr></argument>, <argument><expr><name>attrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* cross-check that we only got requested tables */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>||</operator>
			<operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>interesting</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unexpected column data for table \"%s\""</literal></expr></argument>,
				  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Save data for this table */</comment>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name> <operator>=</operator> <name>numatts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>typstorage</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attoptions</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attfdwoptions</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attmissingval</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>notnull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>inhNotNull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name></name> <operator>=</operator> <operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrDefInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attencoding</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numatts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasdefaults</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numatts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>r</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"invalid column numbering in table \"%s\""</literal></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_atttypname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypmod</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_atttypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstattarget</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attstattarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstorage</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attstorage</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>typstorage</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_typstorage</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attidentity</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attidentity</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attgenerated</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attgenerated</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>needs_override</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>needs_override</name></name> <operator>||</operator> <operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>attidentity</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_ALWAYS</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attisdropped</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attlen</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attalign</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attalign</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attislocal</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attislocal</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>notnull</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attnotnull</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attoptions</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attcollation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attfdwoptions</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attfdwoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attmissingval</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_attmissingval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* fix below */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>i_atthasdef</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hasdefaults</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* these flags will be set in flagInhAttrs() */</comment>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>inhNotNull</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* column storage attributes */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attencoding"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attencoding</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attencoding"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attencoding</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>hasdefaults</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Collect OIDs of interesting tables that have defaults */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbloids</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* do we have more than the '{'? */</comment>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now get info about column defaults.  This is skipped for a data-only
	 * dump, as it is only needed for table schemas.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>&amp;&amp;</operator> <name><name>tbloids</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrDefInfo</name> <modifier>*</modifier></type><name>attrdefs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numDefaults</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"finding table default expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.tableoid, a.oid, adrelid, adnum, "</literal>
						  <literal type="string">"pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc\n"</literal>
						  <literal type="string">"FROM unnest('%s'::pg_catalog.oid[]) AS src(tbloid)\n"</literal>
						  <literal type="string">"JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)\n"</literal>
						  <literal type="string">"ORDER BY a.adrelid, a.adnum"</literal></expr></argument>,
						  <argument><expr><name><name>tbloids</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>numDefaults</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attrdefs</name> <operator>=</operator> <operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numDefaults</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrDefInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>curtblindx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numDefaults</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>adtableoid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>adoid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>adrelid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>adnum</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>adsrc</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Locate the associated TableInfo; we rely on tblinfo[] being in
			 * OID order.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>tbinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name>adrelid</name></expr>)</condition>
			<block>{<block_content>
				<while>while <condition>(<expr><operator>++</operator><name>curtblindx</name> <operator>&lt;</operator> <name>numTables</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>tbinfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>curtblindx</name></expr>]</index></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>==</operator> <name>adrelid</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></while>
				<if_stmt><if>if <condition>(<expr><name>curtblindx</name> <operator>&gt;=</operator> <name>numTables</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized table OID %u"</literal></expr></argument>, <argument><expr><name>adrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>adnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>adnum</name> <operator>&gt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"invalid adnum value %d for table \"%s\""</literal></expr></argument>,
					  <argument><expr><name>adnum</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * dropped columns shouldn't have defaults, but just in case,
			 * ignore 'em
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_ATTRDEF</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <name>adtableoid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <name>adoid</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>adtable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>adnum</name> <operator>=</operator> <name>adnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>adef_expr</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>adsrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Figure out whether the default/generation expression should be
			 * dumped as part of the main CREATE TABLE (or similar) command or
			 * as a separate ALTER TABLE (or similar) command. The preference
			 * is to put it into the CREATE command, but in some cases that's
			 * not possible.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attgenerated</name><index>[<expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Column generation expressions cannot be dumped separately,
				 * because there is no syntax for it.  The !shouldPrintColumn
				 * case below will be tempted to set them to separate if they
				 * are attached to an inherited column without a local
				 * definition, but that would be wrong and unnecessary,
				 * because generation expressions are always inherited, so
				 * there is no need to set them again in child tables, and
				 * there is no syntax for it either.  By setting separate to
				 * false here we prevent the "default" from being processed as
				 * its own dumpable object, and flagInhAttrs() will remove it
				 * from the table when it detects that it belongs to an
				 * inherited column.
				 */</comment>
				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Defaults on a VIEW must always be dumped as separate ALTER
				 * TABLE commands.
				 */</comment>
				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>shouldPrintColumn</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* column will be suppressed, print default separately */</comment>
				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Mark the default as needing to appear before the table, so
				 * that any dependencies it has must be emitted before the
				 * CREATE TABLE.  If this is not possible, we'll change to
				 * "separate" mode while sorting dependencies.
				 */</comment>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
									<argument><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get info about table CHECK constraints.  This is skipped for a
	 * data-only dump, as it is only needed for table schemas.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>&amp;&amp;</operator> <name><name>checkoids</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constrs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numConstrs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_conrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_conname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_consrc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_conislocal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_convalidated</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"finding table check constraints"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, conrelid, conname, "</literal>
							 <literal type="string">"pg_catalog.pg_get_constraintdef(c.oid) AS consrc, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * convalidated is new in 9.2 (actually, it is there in 9.1, but
			 * it wasn't ever false for check constraints until 9.2).
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
								 <argument><expr><literal type="string">"conislocal, convalidated "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* conislocal is new in 8.4 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
								 <argument><expr><literal type="string">"conislocal, true AS convalidated "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
								 <argument><expr><literal type="string">"true AS conislocal, true AS convalidated "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
						  <argument><expr><literal type="string">"FROM unnest('%s'::pg_catalog.oid[]) AS src(tbloid)\n"</literal>
						  <literal type="string">"JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)\n"</literal>
						  <literal type="string">"WHERE contype = 'c' "</literal>
						  <literal type="string">"ORDER BY c.conrelid, c.conname"</literal></expr></argument>,
						  <argument><expr><name><name>checkoids</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>numConstrs</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constrs</name> <operator>=</operator> <operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numConstrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstraintInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_conrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_conname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_consrc</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"consrc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_conislocal</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conislocal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_convalidated</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"convalidated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* As above, this loop iterates once per table, not once per row */</comment>
		<expr_stmt><expr><name>curtblindx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numConstrs</name></expr>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>conrelid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numcons</name></decl>;</decl_stmt>

			<comment type="block">/* Count rows for this table */</comment>
			<for>for <control>(<init><expr><name>numcons</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>numcons</name> <operator>&lt;</operator> <name>numConstrs</name> <operator>-</operator> <name>j</name></expr>;</condition> <incr><expr><name>numcons</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <name>numcons</name></expr></argument>, <argument><expr><name>i_conrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>conrelid</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

			<comment type="block">/*
			 * Locate the associated TableInfo; we rely on tblinfo[] being in
			 * OID order.
			 */</comment>
			<while>while <condition>(<expr><operator>++</operator><name>curtblindx</name> <operator>&lt;</operator> <name>numTables</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tbinfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>curtblindx</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>==</operator> <name>conrelid</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name>curtblindx</name> <operator>&gt;=</operator> <name>numTables</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized table OID %u"</literal></expr></argument>, <argument><expr><name>conrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>numcons</name> <operator>!=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"expected %d check constraint on table \"%s\" but found %d"</literal></expr></argument>,
									  <argument><expr><literal type="string">"expected %d check constraints on table \"%s\" but found %d"</literal></expr></argument>,
									  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>numcons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"(The system catalogs might be corrupted.)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>checkexprs</name></name> <operator>=</operator> <name>constrs</name> <operator>+</operator> <name>j</name></expr>;</expr_stmt>

			<for>for <control>(<init><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>numcons</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>validated</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_convalidated</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_CONSTRAINT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>contable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condomain</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>contype</name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_consrc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>confrelid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>conindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condeferrable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condeferred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>conislocal</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conislocal</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * An unvalidated constraint needs to be dumped separately, so
				 * that potentially-violating existing data is loaded before
				 * the constraint.
				 */</comment>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <operator>!</operator><name>validated</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Mark the constraint as needing to appear before the table
				 * --- this is so that any other dependencies of the
				 * constraint will be emitted before we try to create the
				 * table.  If the constraint is to be dumped separately, it
				 * will be dumped after data is loaded anyway, so don't do it.
				 * (There's an automatic dependency in the opposite direction
				 * anyway, so don't need to add one manually here.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If the constraint is inherited, this will be detected later
				 * (in pre-8.4 databases).  We also detect later if the
				 * constraint must be split out from the table definition.
				 */</comment>
			</block_content>}</block></for>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tbloids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>checkoids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether a column should be printed as part of table's CREATE TABLE.
 * Column number is zero-based.
 *
 * Normally this is always true, but it's false for dropped columns, as well
 * as those that were inherited without any local definition.  (If we print
 * such a column it will mistakenly get pg_attribute.attislocal set to true.)
 * For partitions, it's always true, because we want the partitions to be
 * created independently and ATTACH PARTITION used afterwards.
 *
 * In binary_upgrade mode, we must print all columns and fix the attislocal/
 * attisdropped state later, so as to keep control of the physical column
 * order.
 *
 * This function exists because there are scattered nonobvious places that
 * must be kept in sync with this decision.
 */</comment>
<function><type><name>bool</name></type>
<name>shouldPrintColumn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>colno</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>attislocal</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>||</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * getTSParsers:
 *	  read all text search parsers in the system catalogs and return them
 *	  in the TSParserInfo* structure
 *
 *	numTSParsers is set to the number of parsers read in
 */</comment>
<function><type><name>TSParserInfo</name> <modifier>*</modifier></type>
<name>getTSParsers</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTSParsers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSParserInfo</name> <modifier>*</modifier></type><name>prsinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prsname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prsnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prsstart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prstoken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prsend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prsheadline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prslextype</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * find all text search objects, including builtin ones; we filter out
	 * system-defined objects at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, prsname, prsnamespace, "</literal>
						 <literal type="string">"prsstart::oid, prstoken::oid, "</literal>
						 <literal type="string">"prsend::oid, prsheadline::oid, prslextype::oid "</literal>
						 <literal type="string">"FROM pg_ts_parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numTSParsers</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>prsinfo</name> <operator>=</operator> <operator>(</operator><name>TSParserInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSParserInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prsname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prsname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prsnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prsnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prsstart</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prsstart"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prstoken</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prstoken"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prsend</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prsend"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prsheadline</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prsheadline"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prslextype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prslextype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TSPARSER</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prsname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prsnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prsstart</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prsstart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prstoken</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prstoken</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prsend</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prsend</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prsheadline</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prsheadline</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prslextype</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prslextype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>prsinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTSDictionaries:
 *	  read all text search dictionaries in the system catalogs and return them
 *	  in the TSDictInfo* structure
 *
 *	numTSDicts is set to the number of dictionaries read in
 */</comment>
<function><type><name>TSDictInfo</name> <modifier>*</modifier></type>
<name>getTSDictionaries</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTSDicts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSDictInfo</name> <modifier>*</modifier></type><name>dictinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_dictname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_dictnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_dictowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_dicttemplate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_dictinitoption</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, dictname, "</literal>
					  <literal type="string">"dictnamespace, dictowner, "</literal>
					  <literal type="string">"dicttemplate, dictinitoption "</literal>
					  <literal type="string">"FROM pg_ts_dict"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numTSDicts</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>dictinfo</name> <operator>=</operator> <operator>(</operator><name>TSDictInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSDictInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dictname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dictname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dictnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dictnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dictowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dictowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dictinitoption</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dictinitoption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dicttemplate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dicttemplate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TSDICT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dictname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dictnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dictowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dicttemplate</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dicttemplate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dictinitoption</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dictinitoption</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dictinitoption</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dictinitoption</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dictinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTSTemplates:
 *	  read all text search templates in the system catalogs and return them
 *	  in the TSTemplateInfo* structure
 *
 *	numTSTemplates is set to the number of templates read in
 */</comment>
<function><type><name>TSTemplateInfo</name> <modifier>*</modifier></type>
<name>getTSTemplates</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTSTemplates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSTemplateInfo</name> <modifier>*</modifier></type><name>tmplinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tmplname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tmplnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tmplinit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tmpllexize</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, tmplname, "</literal>
						 <literal type="string">"tmplnamespace, tmplinit::oid, tmpllexize::oid "</literal>
						 <literal type="string">"FROM pg_ts_template"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numTSTemplates</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmplinfo</name> <operator>=</operator> <operator>(</operator><name>TSTemplateInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSTemplateInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tmplname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tmplname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tmplnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tmplnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tmplinit</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tmplinit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tmpllexize</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tmpllexize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TSTEMPLATE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tmplname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tmplnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tmplinit</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tmplinit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tmpllexize</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tmpllexize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tmplinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTSConfigurations:
 *	  read all text search configurations in the system catalogs and return
 *	  them in the TSConfigInfo* structure
 *
 *	numTSConfigs is set to the number of configurations read in
 */</comment>
<function><type><name>TSConfigInfo</name> <modifier>*</modifier></type>
<name>getTSConfigurations</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTSConfigs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConfigInfo</name> <modifier>*</modifier></type><name>cfginfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_cfgname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_cfgnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_cfgowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_cfgparser</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, cfgname, "</literal>
					  <literal type="string">"cfgnamespace, cfgowner, cfgparser "</literal>
					  <literal type="string">"FROM pg_ts_config"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numTSConfigs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>cfginfo</name> <operator>=</operator> <operator>(</operator><name>TSConfigInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSConfigInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_cfgname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"cfgname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_cfgnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"cfgnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_cfgowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"cfgowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_cfgparser</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"cfgparser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TSCONFIG</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_cfgname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_cfgnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_cfgowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cfgparser</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_cfgparser</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cfginfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getForeignDataWrappers:
 *	  read all foreign-data wrappers in the system catalogs and return
 *	  them in the FdwInfo* structure
 *
 *	numForeignDataWrappers is set to the number of fdws read in
 */</comment>
<function><type><name>FdwInfo</name> <modifier>*</modifier></type>
<name>getForeignDataWrappers</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numForeignDataWrappers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FdwInfo</name>    <modifier>*</modifier></type><name>fdwinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_fdwname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_fdwowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_fdwhandler</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_fdwvalidator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_fdwacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_acldefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_fdwoptions</name></decl>;</decl_stmt>

	<comment type="block">/* Before 8.4, there are no foreign-data wrappers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numForeignDataWrappers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, fdwname, "</literal>
						  <literal type="string">"fdwowner, "</literal>
						  <literal type="string">"fdwhandler::pg_catalog.regproc, "</literal>
						  <literal type="string">"fdwvalidator::pg_catalog.regproc, "</literal>
						  <literal type="string">"fdwacl, "</literal>
						  <literal type="string">"acldefault('F', fdwowner) AS acldefault, "</literal>
						  <literal type="string">"array_to_string(ARRAY("</literal>
						  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
						  <literal type="string">"quote_literal(option_value) "</literal>
						  <literal type="string">"FROM pg_options_to_table(fdwoptions) "</literal>
						  <literal type="string">"ORDER BY option_name"</literal>
						  <literal type="string">"), E',\n    ') AS fdwoptions "</literal>
						  <literal type="string">"FROM pg_foreign_data_wrapper"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, fdwname, "</literal>
						  <literal type="string">"fdwowner, "</literal>
						  <literal type="string">"fdwhandler::pg_catalog.regproc, "</literal>
						  <literal type="string">"fdwvalidator::pg_catalog.regproc, fdwacl, "</literal>
						  <literal type="string">"NULL AS acldefault, "</literal>
						  <literal type="string">"array_to_string(ARRAY("</literal>
						  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
						  <literal type="string">"quote_literal(option_value) "</literal>
						  <literal type="string">"FROM pg_options_to_table(fdwoptions) "</literal>
						  <literal type="string">"ORDER BY option_name"</literal>
						  <literal type="string">"), E',\n    ') AS fdwoptions "</literal>
						  <literal type="string">"FROM pg_foreign_data_wrapper"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, fdwname, "</literal>
						  <literal type="string">"fdwowner, "</literal>
						  <literal type="string">"'-' AS fdwhandler, "</literal>
						  <literal type="string">"fdwvalidator::pg_catalog.regproc, fdwacl, "</literal>
						  <literal type="string">"NULL AS acldefault, "</literal>
						  <literal type="string">"array_to_string(ARRAY("</literal>
						  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
						  <literal type="string">"quote_literal(option_value) "</literal>
						  <literal type="string">"FROM pg_options_to_table(fdwoptions) "</literal>
						  <literal type="string">"ORDER BY option_name"</literal>
						  <literal type="string">"), E',\n    ') AS fdwoptions "</literal>
						  <literal type="string">"FROM pg_foreign_data_wrapper"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numForeignDataWrappers</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>fdwinfo</name> <operator>=</operator> <operator>(</operator><name>FdwInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FdwInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_fdwname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"fdwname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_fdwowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"fdwowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_fdwhandler</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"fdwhandler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_fdwvalidator</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"fdwvalidator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_fdwacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"fdwacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_fdwoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"fdwoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_FDW</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fdwhandler</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwhandler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fdwvalidator</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwvalidator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fdwoptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Leave out the built-in gp_exttable_fdw */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>&lt;</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstNormalObjectId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Mark whether FDW has an ACL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>fdwinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getForeignServers:
 *	  read all foreign servers in the system catalogs and return
 *	  them in the ForeignServerInfo * structure
 *
 *	numForeignServers is set to the number of servers read in
 */</comment>
<function><type><name>ForeignServerInfo</name> <modifier>*</modifier></type>
<name>getForeignServers</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numForeignServers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServerInfo</name> <modifier>*</modifier></type><name>srvinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvfdw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvversion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_acldefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvoptions</name></decl>;</decl_stmt>

	<comment type="block">/* Before 8.4, there are no foreign servers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numForeignServers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, srvname, "</literal>
						  <literal type="string">"srvowner, "</literal>
						  <literal type="string">"srvfdw, srvtype, srvversion, srvacl, "</literal>
						  <literal type="string">"acldefault('S', srvowner) AS acldefault, "</literal>
						  <literal type="string">"array_to_string(ARRAY("</literal>
						  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
						  <literal type="string">"quote_literal(option_value) "</literal>
						  <literal type="string">"FROM pg_options_to_table(srvoptions) "</literal>
						  <literal type="string">"ORDER BY option_name"</literal>
						  <literal type="string">"), E',\n    ') AS srvoptions "</literal>
						  <literal type="string">"FROM pg_foreign_server"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, srvname, "</literal>
						  <literal type="string">"srvowner, "</literal>
						  <literal type="string">"srvfdw, srvtype, srvversion, srvacl, "</literal>
						  <literal type="string">"NULL AS acldefault, "</literal>
						  <literal type="string">"array_to_string(ARRAY("</literal>
						  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
						  <literal type="string">"quote_literal(option_value) "</literal>
						  <literal type="string">"FROM pg_options_to_table(srvoptions) "</literal>
						  <literal type="string">"ORDER BY option_name"</literal>
						  <literal type="string">"), E',\n    ') AS srvoptions "</literal>
						  <literal type="string">"FROM pg_foreign_server"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numForeignServers</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>srvinfo</name> <operator>=</operator> <operator>(</operator><name>ForeignServerInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ForeignServerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvfdw</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvfdw"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvtype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvversion</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvversion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_FOREIGN_SERVER</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>srvfdw</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvfdw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>srvtype</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>srvversion</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvversion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>srvoptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Leave out the built-in gp_exttable_server */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>&lt;</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstNormalObjectId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Servers have user mappings */</comment>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_USERMAP</name></expr>;</expr_stmt>

		<comment type="block">/* Mark whether server has an ACL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>srvinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getDefaultACLs:
 *	  read all default ACL information in the system catalogs and return
 *	  them in the DefaultACLInfo structure
 *
 *	numDefaultACLs is set to the number of ACLs read in
 */</comment>
<function><type><name>DefaultACLInfo</name> <modifier>*</modifier></type>
<name>getDefaultACLs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numDefaultACLs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefaultACLInfo</name> <modifier>*</modifier></type><name>daclinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_defaclrole</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_defaclnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_defaclobjtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_defaclacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_acldefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numDefaultACLs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT oid, tableoid, "</literal>
					  <literal type="string">"defaclrole, "</literal>
					  <literal type="string">"defaclnamespace, "</literal>
					  <literal type="string">"defaclobjtype, "</literal>
					  <literal type="string">"defaclacl, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Global entries (with defaclnamespace=0) replace the hard-wired
		 * default ACL for their object type.  We should dump them as deltas
		 * from the default ACL, since that will be used as a starting point
		 * for interpreting the ALTER DEFAULT PRIVILEGES commands.  On the
		 * other hand, non-global entries can only add privileges not revoke
		 * them.  We must dump those as-is (i.e., as deltas from an empty
		 * ACL).
		 *
		 * We can use defaclobjtype as the object type for acldefault(),
		 * except for the case of 'S' (DEFACLOBJ_SEQUENCE) which must be
		 * converted to 's'.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"CASE WHEN defaclnamespace = 0 THEN "</literal>
							 <literal type="string">"acldefault(CASE WHEN defaclobjtype = 'S' "</literal>
							 <literal type="string">"THEN 's'::\"char\" ELSE defaclobjtype END, "</literal>
							 <literal type="string">"defaclrole) ELSE '{}' END AS acldefault "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"NULL AS acldefault "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						 <argument><expr><literal type="string">"FROM pg_default_acl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numDefaultACLs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>daclinfo</name> <operator>=</operator> <operator>(</operator><name>DefaultACLInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DefaultACLInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_defaclrole</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"defaclrole"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_defaclnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"defaclnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_defaclobjtype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"defaclobjtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_defaclacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"defaclacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_acldefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acldefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_defaclnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_DEFAULT_ACL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* cheesy ... is it worth coming up with a better object name? */</comment>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_defaclobjtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nspid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <call><name>findNamespace</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_defaclacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_acldefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>defaclrole</name> <operator>=</operator> <call><name>getRoleName</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_defaclrole</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>defaclobjtype</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_defaclobjtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Default ACLs are ACLs, of course */</comment>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableDefaultACL</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>dopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>daclinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getRoleName -- look up the name of a role, given its OID
 *
 * In current usage, we don't expect failures, so error out for a bad OID.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getRoleName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>roleoid_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleoid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><name>roleoid_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do binary search to find the appropriate item.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nrolenames</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RoleNameItem</name> <modifier>*</modifier></type><name>low</name> <init>= <expr><operator>&amp;</operator><name><name>rolenames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RoleNameItem</name> <modifier>*</modifier></type><name>high</name> <init>= <expr><operator>&amp;</operator><name><name>rolenames</name><index>[<expr><name>nrolenames</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RoleNameItem</name> <modifier>*</modifier></type><name>middle</name> <init>= <expr><name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>roleoid</name> <operator>&lt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>roleoid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>roleoid</name> <operator>&gt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>roleoid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name><name>middle</name><operator>-&gt;</operator><name>rolename</name></name></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* found a match */</comment>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"role with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>roleoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * collectRoleNames --
 *
 * Construct a table of all known roles.
 * The table is sorted by OID for speed in lookup.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>collectRoleNames</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <literal type="string">"SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nrolenames</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rolenames</name> <operator>=</operator> <operator>(</operator><name>RoleNameItem</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>nrolenames</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RoleNameItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrolenames</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rolenames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>roleoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rolenames</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolename</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getAdditionalACLs
 *
 * We have now created all the DumpableObjects, and collected the ACL data
 * that appears in the directly-associated catalog entries.  However, there's
 * more ACL-related info to collect.  If any of a table's columns have ACLs,
 * we must set the TableInfo's DUMP_COMPONENT_ACL components flag, as well as
 * its hascolumnACLs flag (we won't store the ACLs themselves here, though).
 * Also, in versions having the pg_init_privs catalog, read that and load the
 * information into the relevant DumpableObjects.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getAdditionalACLs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Check for per-column ACLs */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"SELECT DISTINCT attrelid FROM pg_attribute "</literal>
							 <literal type="string">"WHERE attacl IS NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tblinfo</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tblinfo</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* OK to ignore tables we haven't got a DumpableObject for */</comment>
			<if_stmt><if>if <condition>(<expr><name>tblinfo</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>hascolumnACLs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fetch initial-privileges data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT objoid, classoid, objsubid, privtype, initprivs "</literal>
						  <literal type="string">"FROM pg_init_privs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>objoid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>classoid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>objsubid</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name>privtype</name> <init>= <expr><operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>initprivs</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CatalogId</name></type>	<name>objId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <name>classoid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <name>objoid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dobj</name> <operator>=</operator> <call><name>findObjectByCatalogId</name><argument_list>(<argument><expr><name>objId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* OK to ignore entries we haven't got a DumpableObject for */</comment>
			<if_stmt><if>if <condition>(<expr><name>dobj</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Cope with sub-object initprivs */</comment>
				<if_stmt><if>if <condition>(<expr><name>objsubid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* For a column initpriv, set the table's ACL flags */</comment>
						<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>(</operator><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name><operator>)</operator><operator>-&gt;</operator><name>hascolumnACLs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"unsupported pg_init_privs entry: %u %u %d"</literal></expr></argument>,
									   <argument><expr><name>classoid</name></expr></argument>, <argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Else it had better be of a type we think has ACLs */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_NAMESPACE</name> <operator>||</operator>
					<name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TYPE</name> <operator>||</operator>
					<name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_FUNC</name> <operator>||</operator>
					<name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_AGG</name> <operator>||</operator>
					<name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE</name> <operator>||</operator>
					<name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_PROCLANG</name> <operator>||</operator>
					<name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_FDW</name> <operator>||</operator>
					<name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_FOREIGN_SERVER</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DumpableObjectWithAcl</name> <modifier>*</modifier></type><name>daobj</name> <init>= <expr><operator>(</operator><name>DumpableObjectWithAcl</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>daobj</name><operator>-&gt;</operator><name>dacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <name>privtype</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>daobj</name><operator>-&gt;</operator><name>dacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>initprivs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"unsupported pg_init_privs entry: %u %u %d"</literal></expr></argument>,
								   <argument><expr><name>classoid</name></expr></argument>, <argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpComment --
 *
 * This routine is used to dump any comments associated with the
 * object handed to this routine. The routine takes the object type
 * and object name (ready to print, except for schema decoration), plus
 * the namespace and owner of the object (for labeling the ArchiveEntry),
 * plus catalog ID and subid which are the lookup key for pg_description,
 * plus the dump ID for the object (for setting a dependency).
 * If a matching pg_description entry is found, it is dumped.
 *
 * Note: in some cases, such as comments for triggers and rules, the "type"
 * string really looks like, e.g., "TRIGGER name ON".  This is a bit of a hack
 * but it doesn't seem worth complicating the API for all callers to make
 * it cleaner.
 *
 * Note: although this routine takes a dumpId for dependency purposes,
 * that purpose is just to mark the dependency in the emitted dump file
 * for possible future use by pg_restore.  We do NOT use it for determining
 * ordering of the comment in the dump file, because this routine is called
 * after dependency sorting occurs.  This routine should be called just after
 * calling ArchiveEntry() for the specified object.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpComment</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
			<parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>comments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncomments</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing, if --no-comments is supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_comments</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Comments are schema not data ... except blob comments are data */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We do dump blob comments in binary-upgrade mode */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>schemaOnly</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Search for comments associated with catalogId, using table */</comment>
	<expr_stmt><expr><name>ncomments</name> <operator>=</operator> <call><name>findComments</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>comments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Is there one matching the subid? */</comment>
	<while>while <condition>(<expr><name>ncomments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>comments</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>==</operator> <name>subid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>comments</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ncomments</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* If a comment exists, build COMMENT ON statement */</comment>
	<if_stmt><if>if <condition>(<expr><name>ncomments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"COMMENT ON %s "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>namespace</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>namespace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s IS "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>comments</name><operator>-&gt;</operator><name>descr</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We mark comments as SECTION_NONE because they really belong in the
		 * same section as their parent, whether that is pre-data or
		 * post-data.
		 */</comment>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name>namespace</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name>owner</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"COMMENT"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_NONE</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><name>dumpId</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTableComment --
 *
 * As above, but dump comments for both the specified table (or view)
 * and its columns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTableComment</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reltypename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>comments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncomments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing, if --no-comments is supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_comments</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Comments are SCHEMA not data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Search for comments associated with relation, using table */</comment>
	<expr_stmt><expr><name>ncomments</name> <operator>=</operator> <call><name>findComments</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
							 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name></expr></argument>,
							 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>comments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If comments exist, build COMMENT ON statements */</comment>
	<if_stmt><if>if <condition>(<expr><name>ncomments</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>ncomments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><name><name>comments</name><operator>-&gt;</operator><name>descr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>objsubid</name> <init>= <expr><name><name>comments</name><operator>-&gt;</operator><name>objsubid</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>objsubid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>reltypename</name></expr></argument>, <argument><expr><literal type="string">"EXTERNAL TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>reltypename</name> <operator>=</operator> <literal type="string">"TABLE"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"%s %s."</literal></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"COMMENT ON %s %s IS "</literal></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"COMMENT"</literal></expr></argument>,
									  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_NONE</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>,
									  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>objsubid</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>objsubid</name> <operator>&lt;=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"COLUMN %s."</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>objsubid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"COMMENT ON COLUMN %s."</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s IS "</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>objsubid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"COMMENT"</literal></expr></argument>,
									  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_NONE</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>,
									  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>comments</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ncomments</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * findComments --
 *
 * Find the comment(s), if any, associated with the given object.  All the
 * objsubid values associated with the given classoid/objoid are found with
 * one search.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>findComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>,
			 <parameter><decl><type><name>CommentItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>middle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>low</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>high</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmatch</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do binary search to find some item matching the object.
	 */</comment>
	<expr_stmt><expr><name>low</name> <operator>=</operator> <operator>&amp;</operator><name><name>comments</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>high</name> <operator>=</operator> <operator>&amp;</operator><name><name>comments</name><index>[<expr><name>ncomments</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>middle</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>&lt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>&gt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>objoid</name> <operator>&lt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>objoid</name> <operator>&gt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>				<comment type="block">/* found a match */</comment>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>low</name> <operator>&gt;</operator> <name>high</name></expr>)</condition>				<comment type="block">/* no matches */</comment>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now determine how many items match the object.  The search loop
	 * invariant still holds: only items between low and high inclusive could
	 * match.
	 */</comment>
	<expr_stmt><expr><name>nmatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>middle</name> <operator>&gt;</operator> <name>low</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>!=</operator> <name><name>middle</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>classoid</name> <operator>||</operator>
			<name>objoid</name> <operator>!=</operator> <name><name>middle</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>objoid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>middle</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmatch</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>middle</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>middle</name> <operator>+=</operator> <name>nmatch</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>middle</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>!=</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name> <operator>||</operator>
			<name>objoid</name> <operator>!=</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>middle</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmatch</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>nmatch</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * collectComments --
 *
 * Construct a table of all comments available for database objects;
 * also set the has-comment component flag for each relevant object.
 *
 * We used to do per-object queries for the comments, but it's much faster
 * to pull them all over at once, and on most databases the memory cost
 * isn't high.
 *
 * The table is sorted by classoid/objid/objsubid for speed in lookup.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>collectComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_description</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_classoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_objoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_objsubid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT description, classoid, objoid, objsubid "</literal>
						 <literal type="string">"FROM pg_catalog.pg_description "</literal>
						 <literal type="string">"ORDER BY classoid, objoid, objsubid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct lookup table containing OIDs in numeric form */</comment>

	<expr_stmt><expr><name>i_description</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"description"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_classoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"classoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objsubid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objsubid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>comments</name> <operator>=</operator> <operator>(</operator><name>CommentItem</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CommentItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ncomments</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>dobj</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>objId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>subid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_classoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objsubid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We needn't remember comments that don't match any dumpable object */</comment>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>dobj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>!=</operator> <name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>||</operator>
			<name><name>dobj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name><name>objId</name><operator>.</operator><name>oid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dobj</name> <operator>=</operator> <call><name>findObjectByCatalogId</name><argument_list>(<argument><expr><name>objId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Comments on columns of composite types are linked to the type's
		 * pg_class entry, but we need to set the DUMP_COMPONENT_COMMENT flag
		 * in the type's own DumpableObject.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>subid</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>cTypeInfo</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>cTypeInfo</name> <operator>=</operator> <call><name>findTypeByOid</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name><operator>)</operator><operator>-&gt;</operator><name>reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cTypeInfo</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cTypeInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>comments</name><index>[<expr><name>ncomments</name></expr>]</index></name><operator>.</operator><name>descr</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_description</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>comments</name><index>[<expr><name>ncomments</name></expr>]</index></name><operator>.</operator><name>classoid</name> <operator>=</operator> <name><name>objId</name><operator>.</operator><name>tableoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>comments</name><index>[<expr><name>ncomments</name></expr>]</index></name><operator>.</operator><name>objoid</name> <operator>=</operator> <name><name>objId</name><operator>.</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>comments</name><index>[<expr><name>ncomments</name></expr>]</index></name><operator>.</operator><name>objsubid</name> <operator>=</operator> <name>subid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ncomments</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpDumpableObject
 *
 * This routine and its subsidiaries are responsible for creating
 * ArchiveEntries (TOC objects) for each object to be dumped.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpDumpableObject</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Clear any dump-request bits for components that don't exist for this
	 * object.  (This makes it safe to initially use DUMP_COMPONENT_ALL as the
	 * request for every kind of object.)
	 */</comment>
	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>&amp;=</operator> <name><name>dobj</name><operator>-&gt;</operator><name>components</name></name></expr>;</expr_stmt>

	<comment type="block">/* Now, short-circuit if there's nothing to be done here. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DO_NAMESPACE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>NamespaceInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_EXTENSION</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpExtension</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ExtensionInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TYPE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TypeInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_SHELL_TYPE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpShellType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ShellTypeInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_FUNC</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpFunc</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>FuncInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_AGG</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpAgg</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>AggInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_EXTPROTOCOL</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpExtProtocol</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>ExtProtInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_OPERATOR</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpOpr</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>OprInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_ACCESS_METHOD</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpAccessMethod</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>AccessMethodInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_OPCLASS</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpOpclass</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>OpclassInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_OPFAMILY</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpOpfamily</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>OpfamilyInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_COLLATION</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpCollation</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>CollInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_CONVERSION</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpConversion</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ConvInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTable</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TABLE_ATTACH</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTableAttach</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TableAttachInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_ATTRDEF</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpAttrDef</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpIndex</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>IndxInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_INDEX_ATTACH</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpIndexAttach</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>IndexAttachInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_STATSEXT</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpStatisticsExt</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>StatsExtInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_REFRESH_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><call><name>refreshMatViewData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_RULE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpRule</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTrigger</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TriggerInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_EVENT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpEventTrigger</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>EventTriggerInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_CONSTRAINT</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpConstraint</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_FK_CONSTRAINT</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpConstraint</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_PROCLANG</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpProcLang</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ProcLangInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_CAST</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpCast</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>CastInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TRANSFORM</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTransform</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TransformInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_SEQUENCE_SET</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpSequenceData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TABLE_DATA</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTableData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_DUMMY_TYPE</name></expr>:</case>
			<comment type="block">/* table rowtypes and array types are never dumped separately */</comment>
			<break>break;</break>
		<case>case <expr><name>DO_TSPARSER</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTSParser</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TSParserInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TSDICT</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTSDictionary</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TSDictInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TSTEMPLATE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTSTemplate</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TSTemplateInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TSCONFIG</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTSConfig</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>TSConfigInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_FDW</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpForeignDataWrapper</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>FdwInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_FOREIGN_SERVER</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpForeignServer</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ForeignServerInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_DEFAULT_ACL</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpDefaultACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>DefaultACLInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_BLOB</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpBlob</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>BlobInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_BLOB_DATA</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DATA</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>,
								  <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>dobj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
											   <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"BLOBS"</literal></expr></argument>,
											   <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_DATA</name></expr></argument>,
											   <argument><expr><operator>.</operator><name>dumpFn</name> <operator>=</operator> <name>dumpBlobs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Set the TocEntry's dataLength in case we are doing a
				 * parallel dump and want to order dump jobs by table size.
				 * (We need some size estimate for every TocEntry with a
				 * DataDumper function.)  We don't currently have any cheap
				 * way to estimate the size of blobs, but it doesn't matter;
				 * let's just set the size to a large value so parallel dumps
				 * will launch this job first.  If there's lots of blobs, we
				 * win, and if there aren't, we don't lose much.  (If you want
				 * to improve on this, really what you should be thinking
				 * about is allowing blob dumping to be parallelized, not just
				 * getting a smarter estimate for the single TOC entry.)
				 */</comment>
				<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>=</operator> <name>MaxBlockNumber</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_POLICY</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpPolicy</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>PolicyInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_PUBLICATION</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpPublication</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>PublicationInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_PUBLICATION_REL</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpPublicationTable</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>PublicationRelInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_SUBSCRIPTION</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpSubscription</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>SubscriptionInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_PRE_DATA_BOUNDARY</name></expr>:</case>
		<case>case <expr><name>DO_POST_DATA_BOUNDARY</name></expr>:</case>
			<comment type="block">/* never dumped, nothing to do */</comment>
			<break>break;</break>

		<case>case <expr><name>DO_BINARY_UPGRADE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpPreassignedOidArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>BinaryUpgradeInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * dumpNamespace
 *	  writes out to fout the queries to recreate a user-defined namespace
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpNamespace</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamespaceInfo</name> <modifier>*</modifier></type><name>nspinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qnspname</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qnspname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP SCHEMA %s;\n"</literal></expr></argument>, <argument><expr><name>qnspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_namespace_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE SCHEMA %s;\n"</literal></expr></argument>, <argument><expr><name>qnspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>, <argument><expr><name>qnspname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>nspinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"SCHEMA"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Schema Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>, <argument><expr><name>qnspname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>, <argument><expr><name>qnspname</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>,
				<argument><expr><name>qnspname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nspinfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qnspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpExtension
 *	  writes out to fout the queries to recreate an extension
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpExtension</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExtensionInfo</name> <modifier>*</modifier></type><name>extinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qextname</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qextname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP EXTENSION %s;\n"</literal></expr></argument>, <argument><expr><name>qextname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In a regular dump, we simply create the extension, intentionally
		 * not specifying a version, so that the destination installation's
		 * default version is used.
		 *
		 * Use of IF NOT EXISTS here is unlike our behavior for other object
		 * types; but there are various scenarios in which it's convenient to
		 * manually create the desired extension before restoring, so we
		 * prefer to allow it to exist already.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE EXTENSION IF NOT EXISTS %s WITH SCHEMA %s;\n"</literal></expr></argument>,
						  <argument><expr><name>qextname</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * In binary-upgrade mode, it's critical to reproduce the state of the
		 * database exactly, so our procedure is to create an empty extension,
		 * restore all the contained objects normally, and add them to the
		 * extension one by one.  This function performs just the first of
		 * those steps.  binary_upgrade_extension_member() takes care of
		 * adding member objects as they're created.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"-- For binary upgrade, create an empty extension and insert objects into it\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We unconditionally create the extension, so we must drop it if it
		 * exists.  This could happen if the user deleted 'plpgsql' and then
		 * readded it, causing its oid to be greater than g_last_builtin_oid.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"DROP EXTENSION IF EXISTS %s;\n"</literal></expr></argument>, <argument><expr><name>qextname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_create_empty_extension("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s, "</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>extinfo</name><operator>-&gt;</operator><name>relocatable</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>extversion</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that we're pushing extconfig (an OID array) back into
		 * pg_extension exactly as-is.  This is OK because pg_class OIDs are
		 * preserved in binary upgrade.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>extconfig</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>extconfig</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>extcondition</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>extcondition</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>extobj</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>extobj</name> <operator>=</operator> <call><name>findObjectByDumpId</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>extobj</name> <operator>&amp;&amp;</operator> <name><name>extobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_EXTENSION</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>n</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extobj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"]::pg_catalog.text[]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"EXTENSION"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Extension Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"EXTENSION"</literal></expr></argument>, <argument><expr><name>qextname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"EXTENSION"</literal></expr></argument>, <argument><expr><name>qextname</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					 <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qextname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpType
 *	  writes out to fout the queries to recreate a user-defined type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Dump out in proper style */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_BASE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpBaseType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpDomain</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpCompositeType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_ENUM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpEnumType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpRangeType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>isDefined</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpUndefinedType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"typtype of data type \"%s\" appears to be invalid"</literal></expr></argument>,
					   <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typstorage</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>typstorage</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpTypeStorageOptions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * dumpEnumType
 *	  writes out to fout the queries to recreate a user-defined enum type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpEnumType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>enum_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_enumlabel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPENUMTYPE</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up query for enum-specific details */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"PREPARE dumpEnumType(pg_catalog.oid) AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT oid, enumlabel "</literal>
								 <literal type="string">"FROM pg_catalog.pg_enum "</literal>
								 <literal type="string">"WHERE enumtypid = $1 "</literal>
								 <literal type="string">"ORDER BY enumsortorder"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT oid, enumlabel "</literal>
								 <literal type="string">"FROM pg_catalog.pg_enum "</literal>
								 <literal type="string">"WHERE enumtypid = $1 "</literal>
								 <literal type="string">"ORDER BY oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPENUMTYPE</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"EXECUTE dumpEnumType('%u')"</literal></expr></argument>,
					  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * CASCADE shouldn't be required here as for normal types since the I/O
	 * functions are generic and do not get dropped.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TYPE %s;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TYPE %s AS ENUM ("</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i_enumlabel</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"enumlabel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Labels with server-assigned oids */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_enumlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_enumlabel</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"enumlabel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Labels with dump-assigned (preserved) oids */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>enum_oid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_enumlabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_enum oids\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_pg_enum_oid('%u'::pg_catalog.oid, '%u'::pg_catalog.oid, $$%s$$::text);\n"</literal></expr></argument>,
							  <argument><expr><name>enum_oid</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TYPE %s ADD VALUE "</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TYPE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Type Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpRangeType
 *	  writes out to fout the queries to recreate a user-defined range type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpRangeType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collationOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>procname</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPRANGETYPE</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up query for range-specific details */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"PREPARE dumpRangeType(pg_catalog.oid) AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"pg_catalog.format_type(rngsubtype, NULL) AS rngsubtype, "</literal>
							 <literal type="string">"opc.opcname AS opcname, "</literal>
							 <literal type="string">"(SELECT nspname FROM pg_catalog.pg_namespace nsp "</literal>
							 <literal type="string">"  WHERE nsp.oid = opc.opcnamespace) AS opcnsp, "</literal>
							 <literal type="string">"opc.opcdefault, "</literal>
							 <literal type="string">"CASE WHEN rngcollation = st.typcollation THEN 0 "</literal>
							 <literal type="string">"     ELSE rngcollation END AS collation, "</literal>
							 <literal type="string">"rngcanonical, rngsubdiff "</literal>
							 <literal type="string">"FROM pg_catalog.pg_range r, pg_catalog.pg_type st, "</literal>
							 <literal type="string">"     pg_catalog.pg_opclass opc "</literal>
							 <literal type="string">"WHERE st.oid = rngsubtype AND opc.oid = rngsubopc AND "</literal>
							 <literal type="string">"rngtypid = $1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPRANGETYPE</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"EXECUTE dumpRangeType('%u')"</literal></expr></argument>,
					  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * CASCADE shouldn't be required here as for normal types since the I/O
	 * functions are generic and do not get dropped.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TYPE %s;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name>tyinfo</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TYPE %s AS RANGE ("</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    subtype = %s"</literal></expr></argument>,
					  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rngsubtype"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* print subtype_opclass only if not default for subtype */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcdefault"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <literal type="char">'t'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcnsp"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    subtype_opclass = %s."</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>collationOid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collation"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collationOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>coll</name> <init>= <expr><call><name>findCollationByOid</name><argument_list>(<argument><expr><name>collationOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>coll</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    collation = %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>procname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rngcanonical"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    canonical = %s"</literal></expr></argument>, <argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>procname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rngsubdiff"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    subtype_diff = %s"</literal></expr></argument>, <argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TYPE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Type Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpUndefinedType
 *	  writes out to fout the queries to recreate a !typisdefined type
 *
 * This is a shell type, but we use different terminology to distinguish
 * this case from where we have to emit a shell type definition to break
 * circular dependencies.  An undefined type shouldn't ever have anything
 * depending on it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpUndefinedType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TYPE %s;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
												 <argument><expr><name>q</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TYPE %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TYPE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Type Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpBaseType
 *	  writes out to fout the queries to recreate a user-defined base type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpBaseType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typinput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typoutput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typreceive</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typsend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typmodin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typmodout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typanalyze</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typreceiveoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typsendoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typmodinoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typmodoutoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typanalyzeoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typcategory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typispreferred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typdelim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typstorage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typcollatable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typdefault_is_literal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPBASETYPE</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up query for type-specific details */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							<argument><expr><literal type="string">"PREPARE dumpBaseType(pg_catalog.oid) AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT typlen, "</literal>
							<literal type="string">"typinput, typoutput, typreceive, typsend, "</literal>
							<literal type="string">"typreceive::pg_catalog.oid AS typreceiveoid, "</literal>
							<literal type="string">"typsend::pg_catalog.oid AS typsendoid, "</literal>
							<literal type="string">"typanalyze, "</literal>
							<literal type="string">"typanalyze::pg_catalog.oid AS typanalyzeoid, "</literal>
							<literal type="string">"typdelim, typbyval, typalign, typstorage, "</literal>
							<literal type="string">"typmodin, typmodout, "</literal>
							<literal type="string">"typmodin::pg_catalog.oid AS typmodinoid, "</literal>
							<literal type="string">"typmodout::pg_catalog.oid AS typmodoutoid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"typcategory, typispreferred, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"'U' AS typcategory, false AS typispreferred, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"(typcollation &lt;&gt; 0) AS typcollatable, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"false AS typcollatable, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Before 8.4, pg_get_expr does not allow 0 for its second arg */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"pg_catalog.pg_get_expr(typdefaultbin, 0) AS typdefaultbin, typdefault "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"pg_catalog.pg_get_expr(typdefaultbin, 'pg_catalog.pg_type'::pg_catalog.regclass) AS typdefaultbin, typdefault "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"FROM pg_catalog.pg_type "</literal>
							<literal type="string">"WHERE oid = $1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPBASETYPE</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"EXECUTE dumpBaseType('%u')"</literal></expr></argument>,
					  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typlen"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typinput</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typinput"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typoutput</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typoutput"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typreceive</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typreceive"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typsend</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typsend"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typmodin</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typmodin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typmodout</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typmodout"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typanalyze</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typanalyze"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typreceiveoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typreceiveoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typsendoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typsendoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typmodinoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typmodinoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typmodoutoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typmodoutoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typanalyzeoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typanalyzeoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typcategory</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typcategory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typispreferred</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typispreferred"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typdelim</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdelim"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typbyval"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typalign"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typstorage</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typstorage"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typcollatable</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typcollatable"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefaultbin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefaultbin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefault"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefault"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typdefault_is_literal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* it needs quotes */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The reason we include CASCADE is that the circular dependency between
	 * the type and its I/O functions makes it impossible to drop the type any
	 * other way.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TYPE %s CASCADE;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We might already have a shell type, but setting pg_type_oid is
	 * harmless, and in any case we'd better set the array type OID.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name>tyinfo</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
					  <argument><expr><literal type="string">"CREATE TYPE %s (\n"</literal>
					  <literal type="string">"    INTERNALLENGTH = %s"</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>,
					  <argument><expr><ternary><condition><expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>typlen</name></expr></argument>, <argument><expr><literal type="string">"-1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"variable"</literal></expr> </then><else>: <expr><name>typlen</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* regproc result is sufficiently quoted already */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    INPUT = %s"</literal></expr></argument>, <argument><expr><name>typinput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    OUTPUT = %s"</literal></expr></argument>, <argument><expr><name>typoutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typreceiveoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    RECEIVE = %s"</literal></expr></argument>, <argument><expr><name>typreceive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typsendoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    SEND = %s"</literal></expr></argument>, <argument><expr><name>typsend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typmodinoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    TYPMOD_IN = %s"</literal></expr></argument>, <argument><expr><name>typmodin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typmodoutoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    TYPMOD_OUT = %s"</literal></expr></argument>, <argument><expr><name>typmodout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typanalyzeoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ANALYZE = %s"</literal></expr></argument>, <argument><expr><name>typanalyze</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typcollatable</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    COLLATABLE = true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typdefault</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    DEFAULT = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typdefault_is_literal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typdefault</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>elemType</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>elemType</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>, <argument><expr><name>zeroAsOpaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ELEMENT = %s"</literal></expr></argument>, <argument><expr><name>elemType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>elemType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typcategory</name></expr></argument>, <argument><expr><literal type="string">"U"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    CATEGORY = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typcategory</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typispreferred</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    PREFERRED = true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typdelim</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>typdelim</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    DELIMITER = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typdelim</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typalign</name></expr></argument>, <argument><expr><literal type="string">"c"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ALIGNMENT = char"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typalign</name></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ALIGNMENT = int2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typalign</name></expr></argument>, <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ALIGNMENT = int4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typalign</name></expr></argument>, <argument><expr><literal type="string">"d"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ALIGNMENT = double"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typstorage</name></expr></argument>, <argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    STORAGE = plain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typstorage</name></expr></argument>, <argument><expr><literal type="string">"e"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    STORAGE = external"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typstorage</name></expr></argument>, <argument><expr><literal type="string">"x"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    STORAGE = extended"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typstorage</name></expr></argument>, <argument><expr><literal type="string">"m"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    STORAGE = main"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typbyval</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    PASSEDBYVALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TYPE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Type Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTypeStorageOptions
 *     writes out to fout the ALTER TYPE queries to set default storage options for type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTypeStorageOptions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TYPE %s."</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s SET DEFAULT ENCODING (%s);\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typstorage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
				 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>,
				 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
				 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TYPE STORAGE OPTIONS"</literal></expr></argument>,
							  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpDomain
 *	  writes out to fout the queries to recreate a user-defined domain
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpDomain</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typnotnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typdefn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typdefault_is_literal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPDOMAIN</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up query for domain-specific details */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"PREPARE dumpDomain(pg_catalog.oid) AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* typcollation is new in 9.1 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT t.typnotnull, "</literal>
								 <literal type="string">"pg_catalog.format_type(t.typbasetype, t.typtypmod) AS typdefn, "</literal>
								 <literal type="string">"pg_catalog.pg_get_expr(t.typdefaultbin, 'pg_catalog.pg_type'::pg_catalog.regclass) AS typdefaultbin, "</literal>
								 <literal type="string">"t.typdefault, "</literal>
								 <literal type="string">"CASE WHEN t.typcollation &lt;&gt; u.typcollation "</literal>
								 <literal type="string">"THEN t.typcollation ELSE 0 END AS typcollation "</literal>
								 <literal type="string">"FROM pg_catalog.pg_type t "</literal>
								 <literal type="string">"LEFT JOIN pg_catalog.pg_type u ON (t.typbasetype = u.oid) "</literal>
								 <literal type="string">"WHERE t.oid = $1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT typnotnull, "</literal>
								 <literal type="string">"pg_catalog.format_type(typbasetype, typtypmod) AS typdefn, "</literal>
								 <literal type="string">"pg_catalog.pg_get_expr(typdefaultbin, 'pg_catalog.pg_type'::pg_catalog.regclass) AS typdefaultbin, "</literal>
								 <literal type="string">"typdefault, 0 AS typcollation "</literal>
								 <literal type="string">"FROM pg_catalog.pg_type "</literal>
								 <literal type="string">"WHERE oid = $1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPDOMAIN</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"EXECUTE dumpDomain('%u')"</literal></expr></argument>,
					  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typnotnull</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typnotnull"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typdefn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefn"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefaultbin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefaultbin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefault"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefault"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typdefault_is_literal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* it needs quotes */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>typcollation</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typcollation"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name>tyinfo</name></expr></argument>,
												 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* force array type */</comment>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
					  <argument><expr><literal type="string">"CREATE DOMAIN %s AS %s"</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>,
					  <argument><expr><name>typdefn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Print collation only if different from base type's collation */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typcollation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>coll</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>findCollationByOid</name><argument_list>(<argument><expr><name>typcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>coll</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>typnotnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typdefault</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typdefault_is_literal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typdefault</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add any CHECK constraints for the domain
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>nDomChecks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>domcheck</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>domChecks</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>domcheck</name><operator>-&gt;</operator><name>separate</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n\tCONSTRAINT %s %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>domcheck</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>domcheck</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP DOMAIN %s;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"DOMAIN"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"DOMAIN"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Domain Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"DOMAIN"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"DOMAIN"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump any per-constraint comments */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>nDomChecks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>domcheck</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>domChecks</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>conprefix</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>conprefix</name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT %s ON DOMAIN"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>domcheck</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>conprefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
						<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
						<argument><expr><name><name>domcheck</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>conprefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpCompositeType
 *	  writes out to fout the queries to recreate a user-defined stand-alone
 *	  composite type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpCompositeType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>dropped</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_atttypdefn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attisdropped</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>actual_atts</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPCOMPOSITETYPE</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up query for type-specific details */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"PREPARE dumpCompositeType(pg_catalog.oid) AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * attcollation is new in 9.1.  Since we only want to dump COLLATE
			 * clauses for attributes whose collation is different from their
			 * type's default, we use a CASE here to suppress uninteresting
			 * attcollations cheaply.  atttypid will be 0 for dropped columns;
			 * collation does not matter for those.
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attname, "</literal>
								 <literal type="string">"pg_catalog.format_type(a.atttypid, a.atttypmod) AS atttypdefn, "</literal>
								 <literal type="string">"a.attlen, a.attalign, a.attisdropped, "</literal>
								 <literal type="string">"CASE WHEN a.attcollation &lt;&gt; at.typcollation "</literal>
								 <literal type="string">"THEN a.attcollation ELSE 0 END AS attcollation "</literal>
								 <literal type="string">"FROM pg_catalog.pg_type ct "</literal>
								 <literal type="string">"JOIN pg_catalog.pg_attribute a ON a.attrelid = ct.typrelid "</literal>
								 <literal type="string">"LEFT JOIN pg_catalog.pg_type at ON at.oid = a.atttypid "</literal>
								 <literal type="string">"WHERE ct.oid = $1 "</literal>
								 <literal type="string">"ORDER BY a.attnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Since ALTER TYPE could not drop columns until 9.1, attisdropped
			 * should always be false.
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attname, "</literal>
								 <literal type="string">"pg_catalog.format_type(a.atttypid, a.atttypmod) AS atttypdefn, "</literal>
								 <literal type="string">"a.attlen, a.attalign, a.attisdropped, "</literal>
								 <literal type="string">"0 AS attcollation "</literal>
								 <literal type="string">"FROM pg_catalog.pg_type ct, pg_catalog.pg_attribute a "</literal>
								 <literal type="string">"WHERE ct.oid = $1 "</literal>
								 <literal type="string">"AND a.attrelid = ct.typrelid "</literal>
								 <literal type="string">"ORDER BY a.attnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPCOMPOSITETYPE</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"EXECUTE dumpCompositeType('%u')"</literal></expr></argument>,
					  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_attname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_atttypdefn</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"atttypdefn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attlen</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attlen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attalign</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attalign"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attisdropped</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attisdropped"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attcollation</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attcollation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name>tyinfo</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TYPE %s AS ("</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>actual_atts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>atttypdefn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>attisdropped</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>atttypdefn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_atttypdefn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attlen</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attalign</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attisdropped</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attisdropped</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attcollation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>attisdropped</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Format properly if not first attr */</comment>
		<if_stmt><if>if <condition>(<expr><name>actual_atts</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attisdropped</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>atttypdefn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add collation if not default for the column type */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>coll</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>findCollationByOid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>coll</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
									  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * This is a dropped attribute and we're in binary_upgrade mode.
			 * Insert a placeholder for it in the CREATE TYPE command, and set
			 * length and alignment with direct UPDATE to the catalogs
			 * afterwards. See similar code in dumpTableSchema().
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s INTEGER /* dummy */"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* stash separately for insertion after the CREATE TYPE */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>,
								 <argument><expr><literal type="string">"\n-- For binary upgrade, recreate dropped column.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"SET allow_system_table_mods = true;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_attribute\n"</literal>
							  <literal type="string">"SET attlen = %s, "</literal>
							  <literal type="string">"attalign = '%s', attbyval = false\n"</literal>
							  <literal type="string">"WHERE attname = "</literal></expr></argument>, <argument><expr><name>attlen</name></expr></argument>, <argument><expr><name>attalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"\n  AND attrelid = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"ALTER TYPE %s "</literal></expr></argument>,
							  <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"DROP ATTRIBUTE %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"RESET allow_system_table_mods;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>dropped</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TYPE %s;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TYPE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/* Dump Type Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Dump any per-column comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpCompositeTypeColComments</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpCompositeTypeColComments
 *	  writes out to fout the queries to recreate comments on the columns of
 *	  a user-defined stand-alone composite type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpCompositeTypeColComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>comments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncomments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pgClassOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attnum</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing, if --no-comments is supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>no_comments</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT c.tableoid, a.attname, a.attnum "</literal>
					  <literal type="string">"FROM pg_catalog.pg_class c, pg_catalog.pg_attribute a "</literal>
					  <literal type="string">"WHERE c.oid = '%u' AND c.oid = a.attrelid "</literal>
					  <literal type="string">"  AND NOT a.attisdropped "</literal>
					  <literal type="string">"ORDER BY a.attnum "</literal></expr></argument>,
					  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch column attnames */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pgClassOid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Search for comments associated with type's pg_class OID */</comment>
	<expr_stmt><expr><name>ncomments</name> <operator>=</operator> <call><name>findComments</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
							 <argument><expr><name>pgClassOid</name></expr></argument>,
							 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>comments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If no comments exist, we're done */</comment>
	<if_stmt><if>if <condition>(<expr><name>ncomments</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Build COMMENT ON statements */</comment>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_attnum</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>ncomments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>comments</name><operator>-&gt;</operator><name>objsubid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>attname</name></expr>)</condition>			<comment type="block">/* just in case we don't find it */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><name><name>comments</name><operator>-&gt;</operator><name>descr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"COLUMN %s."</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"COMMENT ON COLUMN %s."</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s IS "</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"COMMENT"</literal></expr></argument>,
									  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_NONE</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>,
									  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>comments</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ncomments</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpShellType
 *	  writes out to fout the queries to create a shell type
 *
 * We dump a shell definition in advance of the I/O functions for the type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpShellType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ShellTypeInfo</name> <modifier>*</modifier></type><name>stinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note the lack of a DROP command for the shell type; any required DROP
	 * is driven off the base type entry, instead.  This interacts with
	 * _printTocEntry()'s use of the presence of a DROP command to decide
	 * whether an entry needs an ALTER OWNER command.  We don't want to alter
	 * the shell type's owner immediately on creation; that should happen only
	 * after it's filled in, otherwise the backend complains.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name><name>stinfo</name><operator>-&gt;</operator><name>baseType</name></name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TYPE %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>stinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>stinfo</name><operator>-&gt;</operator><name>baseType</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"SHELL TYPE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpProcLang
 *		  writes out to fout the queries to recreate a user-defined
 *		  procedural language
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpProcLang</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProcLangInfo</name> <modifier>*</modifier></type><name>plang</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>defqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qlanname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>funcInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>inlineInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>validatorInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Try to find the support function(s).  It is not an error if we don't
	 * find them --- if the functions are in the pg_catalog schema, as is
	 * standard in 8.1 and up, then we won't have loaded them. (In this case
	 * we will emit a parameterless CREATE LANGUAGE command, which will
	 * require PL template knowledge in the backend to reload.)
	 */</comment>

	<expr_stmt><expr><name>funcInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanplcallfoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>funcInfo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>funcInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>funcInfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* treat not-dumped same as not-found */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>laninline</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>inlineInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>laninline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>inlineInfo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>inlineInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inlineInfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanvalidator</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>validatorInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanvalidator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>validatorInfo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>validatorInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>validatorInfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the functions are dumpable then emit a traditional CREATE LANGUAGE
	 * with parameters.  Otherwise, we'll write a parameterless command, which
	 * will rely on data from pg_pltemplate.
	 */</comment>
	<expr_stmt><expr><name>useParams</name> <operator>=</operator> <operator>(</operator><name>funcInfo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name>inlineInfo</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>laninline</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name>validatorInfo</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanvalidator</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>defqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qlanname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP PROCEDURAL LANGUAGE %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qlanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>useParams</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"CREATE %sPROCEDURAL LANGUAGE %s"</literal></expr></argument>,
						  <argument><expr><ternary><condition><expr><name><name>plang</name><operator>-&gt;</operator><name>lanpltrusted</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUSTED "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name>qlanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">" HANDLER %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>funcInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>laninline</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">" INLINE %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>inlineInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanvalidator</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">" VALIDATOR %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>validatorInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If not dumping parameters, then use CREATE OR REPLACE so that the
		 * command will not fail if the language is preinstalled in the target
		 * database.  We restrict the use of REPLACE to this case so as to
		 * eliminate the risk of replacing a language with incompatible
		 * parameter settings: this command will only succeed at all if there
		 * is a pg_pltemplate entry, and if there is one, the existing entry
		 * must match it too.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE PROCEDURAL LANGUAGE %s"</literal></expr></argument>,
						  <argument><expr><name>qlanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>plang</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"LANGUAGE"</literal></expr></argument>, <argument><expr><name>qlanname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>plang</name><operator>-&gt;</operator><name>lanowner</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"PROCEDURAL LANGUAGE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>defqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  )</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Proc Lang Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"LANGUAGE"</literal></expr></argument>, <argument><expr><name>qlanname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanowner</name></name></expr></argument>,
					<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"LANGUAGE"</literal></expr></argument>, <argument><expr><name>qlanname</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanowner</name></name></expr></argument>,
					 <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plang</name><operator>-&gt;</operator><name>lanpltrusted</name></name> <operator>&amp;&amp;</operator> <name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>, <argument><expr><literal type="string">"LANGUAGE"</literal></expr></argument>,
				<argument><expr><name>qlanname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanowner</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>plang</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qlanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * format_function_arguments: generate function name and argument list
 *
 * This is used when we can rely on pg_get_function_arguments to format
 * the argument list.  Note, however, that pg_get_function_arguments
 * does not special-case zero-argument aggregates.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_function_arguments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcargs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>fn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_agg</name> <operator>&amp;&amp;</operator> <name><name>finfo</name><operator>-&gt;</operator><name>nargs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"(*)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>funcargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name><name>fn</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	is_returns_table_function: returns true if function id declared as
 *	RETURNS TABLE, i.e. at least one argument is PROARGMODE_TABLE
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_returns_table_function</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nallargs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argmodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>argmodes</name></expr>)</condition><block type="pseudo"><block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nallargs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>argmodes</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * format_table_function_columns: generate column list for
 * table functions.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_table_function_columns</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nallargs</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>allargtypes</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argmodes</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>fn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_column</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nallargs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * argmodes are checked in format_function_arguments, it isn't necessary
		 * to check argmodes here again
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>argmodes</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>typid</name> <operator>=</operator> <ternary><condition><expr><name>allargtypes</name></expr> ?</condition><then> <expr><call><name>atooid</name><argument_list>(<argument><expr><name><name>allargtypes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>finfo</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>j</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>typname</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>zeroAsOpaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* column's name is always NOT NULL (checked in gram.y) */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"%s%s %s"</literal></expr></argument>,
							  <argument><expr><ternary><condition><expr><name>first_column</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>argnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first_column</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>fn</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * format_function_signature: generate function name and argument list
 *
 * Generates a minimal list of input argument types; this is sufficient to
 * reference the function, but not to define it.
 *
 * If honor_quotes is false then the function name is never quoted.
 * This is appropriate for use in TOC tags, but not in SQL commands.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_function_signature</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>honor_quotes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>fn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>honor_quotes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>finfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>typname</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name>zeroAsOpaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>fn</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * dumpFunc:
 *	  dump out one function
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpFunc</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>asPart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcsig</name></decl>;</decl_stmt>		<comment type="block">/* identity signature */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcfullsig</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* full signature */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcsig_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qual_funcsig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proretset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>probin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funciargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>protrftypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prokind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>provolatile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proisstrict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosecdef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proleakproof</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proconfig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>procost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prorows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosupport</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proparallel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lanname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>callbackfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prodataaccess</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proexeclocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rettypename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nallargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>allargtypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argmodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>configitems</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nconfigitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>asPart</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPFUNC</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up query for function-specific details */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"PREPARE dumpFunc(pg_catalog.oid) AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							<argument><expr><literal type="string">"SELECT\n"</literal>
							<literal type="string">"proretset,\n"</literal>
							<literal type="string">"prosrc,\n"</literal>
							<literal type="string">"probin,\n"</literal>
							<literal type="string">"provolatile,\n"</literal>
							<literal type="string">"proisstrict,\n"</literal>
							<literal type="string">"prosecdef,\n"</literal>
							<literal type="string">"(SELECT lanname FROM pg_catalog.pg_language WHERE oid = prolang) AS lanname,\n "</literal>
							<literal type="string">"proconfig,\n"</literal>
							<literal type="string">"procost,\n"</literal>
							<literal type="string">"prorows,\n"</literal>
							<literal type="string">"prodataaccess,\n"</literal>
							<literal type="string">"pg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\n"</literal>
							<literal type="string">"pg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\n"</literal>
							<literal type="string">"pg_catalog.pg_get_function_result(p.oid) AS funcresult,\n"</literal>
							<literal type="string">"(SELECT procallback FROM pg_catalog.pg_proc_callback WHERE profnoid::pg_catalog.oid = p.oid) as callbackfunc,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"proleakproof,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"false AS proleakproof,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* GPDB6 added proexeclocation */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <name>GPDB6_MAJOR_PGVERSION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"proexeclocation,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"'a' as proexeclocation,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"array_to_string(protrftypes, ' ') AS protrftypes,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"proparallel,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"'u' AS proparallel,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"prokind,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"CASE WHEN proiswindow THEN 'w' ELSE 'f' END AS prokind,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"CASE WHEN proiswin THEN 'w' ELSE 'f' END AS prokind,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"prosupport\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								<argument><expr><literal type="string">"'-' AS prosupport\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"FROM pg_catalog.pg_proc p, pg_catalog.pg_language l\n"</literal>
							 <literal type="string">"WHERE p.oid = $1 "</literal>
							 <literal type="string">"AND l.oid = p.prolang"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPFUNC</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"EXECUTE dumpFunc('%u')"</literal></expr></argument>,
					  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proretset</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proretset"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prosrc</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prosrc"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>probin</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"probin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcargs</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"funcargs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funciargs</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"funciargs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcresult</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"funcresult"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"protrftypes"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>protrftypes</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"protrftypes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>protrftypes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>prokind</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prokind"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>provolatile</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"provolatile"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proisstrict</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proisstrict"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prosecdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prosecdef"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proleakproof</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proleakproof"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proconfig</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proconfig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>procost</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"procost"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prorows</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prorows"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prosupport</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prosupport"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proparallel</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proparallel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lanname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>callbackfunc</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"callbackfunc"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prodataaccess</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prodataaccess"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proexeclocation</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proexeclocation"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See backend/commands/define.c for details of how the 'AS' clause is
	 * used. In GPDB Paris and up, an unused probin is NULL (here ""); previous8bc709b37411ba7ad0fd0f1f79c354714424af3d
	 * versions would set it to "-".  There are no known cases in which prosrc
	 * is unused, so the tests below for "-" are probably useless.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>probin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>probin</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><literal type="string">"AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><name>probin</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * where we have bin, use dollar quoting if allowed and src
			 * contains quote or backslash; else use regular quoting.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>disable_dollar_quoting</name></name> <operator>||</operator>
				<operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringLiteralDQ</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><literal type="string">"AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* with no bin, dollar quote src unconditionally if allowed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>disable_dollar_quoting</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringLiteralDQ</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>nallargs</name> <operator>=</operator> <name><name>finfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>	<comment type="block">/* unless we learn different from allargs */</comment>
	<expr_stmt><expr><name>funcfullsig</name> <operator>=</operator> <call><name>format_function_arguments</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>funcargs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcsig</name> <operator>=</operator> <call><name>format_function_arguments</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>funciargs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>funcsig_tag</name> <operator>=</operator> <call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>proconfig</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>proconfig</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name>proconfig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>configitems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nconfigitems</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"could not parse proconfig array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>configitems</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>configitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>configitems</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nconfigitems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcsig_tag</name> <operator>=</operator> <call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prokind</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROKIND_PROCEDURE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>keyword</name> <operator>=</operator> <literal type="string">"PROCEDURE"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>configitems</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nconfigitems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>


	<comment type="block">/* 8.4 or later; we rely on server-side code for most of the work */</comment>
	<expr_stmt><expr><name>funcfullsig</name> <operator>=</operator> <call><name>format_function_arguments</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>funcargs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcsig</name> <operator>=</operator> <call><name>format_function_arguments</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>funciargs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><name>funcsig_tag</name> <operator>=</operator> <call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qual_funcsig</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>,
							<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>funcsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prokind</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROKIND_PROCEDURE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>keyword</name> <operator>=</operator> <literal type="string">"PROCEDURE"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>keyword</name> <operator>=</operator> <literal type="string">"FUNCTION"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* works for window functions too */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP %s %s;\n"</literal></expr></argument>,
					  <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>qual_funcsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE %s %s.%s"</literal></expr></argument>,
					  <argument><expr><name>keyword</name></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>funcfullsig</name></expr> ?</condition><then> <expr><name>funcfullsig</name></expr> </then><else>:
					  <expr><name>funcsig</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prokind</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROKIND_PROCEDURE</name></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* no result type to output */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>funcresult</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" RETURNS %s"</literal></expr></argument>, <argument><expr><name>funcresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>is_returns_table_function</name><argument_list>(<argument><expr><name>nallargs</name></expr></argument>, <argument><expr><name>argmodes</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rettypename</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>,
										   <argument><expr><name>zeroAsOpaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" RETURNS %s%s"</literal></expr></argument>,
						  <argument><expr><ternary><condition><expr><operator>(</operator><name><name>proretset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"SETOF "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name>rettypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>rettypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* RETURNS TABLE functions */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>func_cols</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>func_cols</name> <operator>=</operator> <call><name>format_table_function_columns</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>nallargs</name></expr></argument>, <argument><expr><name>allargtypes</name></expr></argument>,
												  <argument><expr><name>argmodes</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"RETURNS TABLE %s"</literal></expr></argument>, <argument><expr><name>func_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>func_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    LANGUAGE %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>protrftypes</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>protrftypes</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>typeids</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>FUNC_MAX_ARGS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" TRANSFORM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>parseOidArray</name><argument_list>(<argument><expr><name>protrftypes</name></expr></argument>, <argument><expr><name>typeids</name></expr></argument>, <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"FOR TYPE %s"</literal></expr></argument>,
							  <argument><expr><call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zeroAsNone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prokind</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROKIND_WINDOW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" WINDOW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>provolatile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>provolatile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" IMMUTABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>provolatile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROVOLATILE_STABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" STABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>provolatile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized provolatile value for function \"%s\""</literal></expr></argument>,
				  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proisstrict</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" STRICT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prosecdef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" SECURITY DEFINER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proleakproof</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" LEAKPROOF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * COST and ROWS are emitted only if present and not default, so as not to
	 * break backwards-compatibility of the dump without need.  Keep this code
	 * in sync with the defaults in functioncmds.c.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>procost</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>lanname</name></expr></argument>, <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>lanname</name></expr></argument>, <argument><expr><literal type="string">"c"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* default cost is 1 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>procost</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" COST %s"</literal></expr></argument>, <argument><expr><name>procost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* default cost is 100 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>procost</name></expr></argument>, <argument><expr><literal type="string">"100"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" COST %s"</literal></expr></argument>, <argument><expr><name>procost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>proretset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>prorows</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>prorows</name></expr></argument>, <argument><expr><literal type="string">"1000"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ROWS %s"</literal></expr></argument>, <argument><expr><name>prorows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>prosupport</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We rely on regprocout to provide quoting and qualification */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" SUPPORT %s"</literal></expr></argument>, <argument><expr><name>prosupport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROPARALLEL_UNSAFE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROPARALLEL_SAFE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" PARALLEL SAFE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROPARALLEL_RESTRICTED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" PARALLEL RESTRICTED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROPARALLEL_UNSAFE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized proparallel value for function \"%s\""</literal></expr></argument>,
				  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prodataaccess</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PRODATAACCESS_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" NO SQL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>prodataaccess</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PRODATAACCESS_CONTAINS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" CONTAINS SQL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>prodataaccess</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PRODATAACCESS_READS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" READS SQL DATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>prodataaccess</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PRODATAACCESS_MODIFIES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" MODIFIES SQL DATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proexeclocation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROEXECLOCATION_ANY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* the default, omit */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>proexeclocation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" EXECUTE ON COORDINATOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>proexeclocation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROEXECLOCATION_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" EXECUTE ON COORDINATOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>proexeclocation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROEXECLOCATION_ALL_SEGMENTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" EXECUTE ON ALL SEGMENTS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>proexeclocation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROEXECLOCATION_INITPLAN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" EXECUTE ON INITPLAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"unrecognized proexeclocation value: %c"</literal></expr></argument>,
					   <argument><expr><name><name>proexeclocation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nconfigitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* we feel free to scribble on configitems[] here */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>configitem</name> <init>= <expr><name><name>configitems</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>configitem</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>pos</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    SET %s TO "</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>configitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Variables that are marked GUC_LIST_QUOTE were already fully quoted
		 * by flatten_set_variable_args() before they were put into the
		 * proconfig array.  However, because the quoting rules used there
		 * aren't exactly like SQL's, we have to break the list value apart
		 * and then quote the elements as string literals.  (The elements may
		 * be double-quoted as-is, but we can't just feed them to the SQL
		 * parser; it would do the wrong thing with elements that are
		 * zero-length or longer than NAMEDATALEN.)
		 *
		 * Variables that are not so marked should just be emitted as simple
		 * string literals.  If the variable is not known to
		 * variable_is_guc_list_quote(), we'll do that; this makes it unsafe
		 * to use GUC_LIST_QUOTE for extension variables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>variable_is_guc_list_quote</name><argument_list>(<argument><expr><name>configitem</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>nameptr</name></decl>;</decl_stmt>

			<comment type="block">/* Parse string into list of identifiers */</comment>
			<comment type="block">/* this shouldn't fail really */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>SplitGUCList</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelist</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>nameptr</name> <operator>=</operator> <name>namelist</name></expr>;</init> <condition><expr><operator>*</operator><name>nameptr</name></expr>;</condition> <incr><expr><name>nameptr</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>nameptr</name> <operator>!=</operator> <name>namelist</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>*</operator><name>nameptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    %s"</literal></expr></argument>, <argument><expr><name><name>asPart</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Append callback function */</comment>
	<if_stmt><if>if <condition>(<expr><name>callbackfunc</name> <operator>&amp;&amp;</operator> <name><name>callbackfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    WITH (describe = %s)"</literal></expr></argument>, <argument><expr><name>callbackfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>append_depends_on_extension</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
								<argument><expr><literal type="string">"pg_catalog.pg_proc"</literal></expr></argument>, <argument><expr><name>keyword</name></expr></argument>,
								<argument><expr><name>qual_funcsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>funcsig</name></expr></argument>,
										<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>funcsig_tag</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>finfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <name>keyword</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Function Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>funcsig</name></expr></argument>,
					<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>funcsig</name></expr></argument>,
					 <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>,
				<argument><expr><name>funcsig</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>finfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>funcsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>funcfullsig</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>funcfullsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>funcsig_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qual_funcsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>allargtypes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>allargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>argmodes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>argnames</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>configitems</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>configitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<comment type="block">/*
 * Dump a user-defined cast
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpCast</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CastInfo</name> <modifier>*</modifier></type><name>cast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>defqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>labelq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>castargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>funcInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sourceType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>targetType</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Cannot dump if we don't have the cast function's info */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>cast</name><operator>-&gt;</operator><name>castfunc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>funcInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>cast</name><operator>-&gt;</operator><name>castfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>funcInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not find function definition for function with OID %u"</literal></expr></argument>,
				  <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>castfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>defqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>labelq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>castargs</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sourceType</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>castsource</name></name></expr></argument>, <argument><expr><name>zeroAsNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetType</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>casttarget</name></name></expr></argument>, <argument><expr><name>zeroAsNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP CAST (%s AS %s);\n"</literal></expr></argument>,
					  <argument><expr><name>sourceType</name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"CREATE CAST (%s AS %s) "</literal></expr></argument>,
					  <argument><expr><name>sourceType</name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>castmethod</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>COERCION_METHOD_BINARY</name></expr>:</case>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"WITHOUT FUNCTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COERCION_METHOD_INOUT</name></expr>:</case>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"WITH INOUT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COERCION_METHOD_FUNCTION</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>funcInfo</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fsig</name> <init>= <expr><call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>funcInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Always qualify the function name (format_function_signature
				 * won't qualify it).
				 */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"WITH FUNCTION %s.%s"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>funcInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"bogus value in pg_cast.castfunc or pg_cast.castmethod field"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"bogus value in pg_cast.castmethod field"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>castcontext</name></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">" AS ASSIGNMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>castcontext</name></name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">" AS IMPLICIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>, <argument><expr><literal type="string">"CAST (%s AS %s)"</literal></expr></argument>,
					  <argument><expr><name>sourceType</name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>castargs</name></expr></argument>, <argument><expr><literal type="string">"(%s AS %s)"</literal></expr></argument>,
					  <argument><expr><name>sourceType</name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cast</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"CAST"</literal></expr></argument>, <argument><expr><name><name>castargs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>labelq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"CAST"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>defqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Cast Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"CAST"</literal></expr></argument>, <argument><expr><name><name>castargs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sourceType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>castargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Dump a transform
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTransform</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TransformInfo</name> <modifier>*</modifier></type><name>transform</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>defqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>labelq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>transformargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>fromsqlFuncInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>tosqlFuncInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lanname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>transformType</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Cannot dump if we don't have the transform functions' info */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fromsqlFuncInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fromsqlFuncInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not find function definition for function with OID %u"</literal></expr></argument>,
				  <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trftosql</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tosqlFuncInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trftosql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tosqlFuncInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not find function definition for function with OID %u"</literal></expr></argument>,
				  <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trftosql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>defqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>labelq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>transformargs</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lanname</name> <operator>=</operator> <call><name>get_language_name</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trflang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>transformType</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trftype</name></name></expr></argument>, <argument><expr><name>zeroAsNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP TRANSFORM FOR %s LANGUAGE %s;\n"</literal></expr></argument>,
					  <argument><expr><name>transformType</name></expr></argument>, <argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"CREATE TRANSFORM FOR %s LANGUAGE %s ("</literal></expr></argument>,
					  <argument><expr><name>transformType</name></expr></argument>, <argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>transform</name><operator>-&gt;</operator><name>trftosql</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"bogus transform definition, at least one of trffromsql and trftosql should be nonzero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fromsqlFuncInfo</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fsig</name> <init>= <expr><call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>fromsqlFuncInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Always qualify the function name (format_function_signature
			 * won't qualify it).
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"FROM SQL WITH FUNCTION %s.%s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>fromsqlFuncInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"bogus value in pg_transform.trffromsql field"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>transform</name><operator>-&gt;</operator><name>trftosql</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>tosqlFuncInfo</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fsig</name> <init>= <expr><call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tosqlFuncInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Always qualify the function name (format_function_signature
			 * won't qualify it).
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"TO SQL WITH FUNCTION %s.%s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tosqlFuncInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"bogus value in pg_transform.trftosql field"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>, <argument><expr><literal type="string">"TRANSFORM FOR %s LANGUAGE %s"</literal></expr></argument>,
					  <argument><expr><name>transformType</name></expr></argument>, <argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>transformargs</name></expr></argument>, <argument><expr><literal type="string">"FOR %s LANGUAGE %s"</literal></expr></argument>,
					  <argument><expr><name>transformType</name></expr></argument>, <argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>transform</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TRANSFORM"</literal></expr></argument>, <argument><expr><name><name>transformargs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>labelq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TRANSFORM"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>defqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dependencies</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>nDeps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Transform Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TRANSFORM"</literal></expr></argument>, <argument><expr><name><name>transformargs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>transformType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>transformargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * dumpOpr
 *	  write out a single operator definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpOpr</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OprInfo</name> <modifier>*</modifier></type><name>oprinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>oprid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>details</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprright</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprcom</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprnegate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprrest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprjoin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprcanmerge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprcanhash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprright</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprcom</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprnegate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprrest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprjoin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprcanmerge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprcanhash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprregproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprref</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * some operators are invalid because they were the result of user
	 * defining operators before commutators exist
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>oprcode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprid</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>details</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPOPR</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up query for operator-specific details */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"PREPARE dumpOpr(pg_catalog.oid) AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT oprkind, "</literal>
							<literal type="string">"oprcode::pg_catalog.regprocedure, "</literal>
							<literal type="string">"oprleft::pg_catalog.regtype, "</literal>
							<literal type="string">"oprright::pg_catalog.regtype, "</literal>
							<literal type="string">"oprcom, "</literal>
							<literal type="string">"oprnegate, "</literal>
							<literal type="string">"oprrest::pg_catalog.regprocedure, "</literal>
							<literal type="string">"oprjoin::pg_catalog.regprocedure, "</literal>
							<literal type="string">"oprcanmerge, oprcanhash "</literal>
							<literal type="string">"FROM pg_catalog.pg_operator "</literal>
							<literal type="string">"WHERE oid = $1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPOPR</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"EXECUTE dumpOpr('%u')"</literal></expr></argument>,
					  <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_oprkind</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprkind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprcode</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprcode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprleft</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprleft"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprright</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprright"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprcom</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprcom"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprnegate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprnegate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprrest</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprrest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprjoin</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprjoin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprcanmerge</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprcanmerge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprcanhash</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprcanhash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oprkind</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprcode</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprleft</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprright</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprcom</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprcom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprnegate</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprnegate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprrest</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprrest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprjoin</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprjoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprcanmerge</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprcanmerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprcanhash</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprcanhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oprregproc</name> <operator>=</operator> <call><name>convertRegProcReference</name><argument_list>(<argument><expr><name>oprcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprregproc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">"    FUNCTION = %s"</literal></expr></argument>, <argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>, <argument><expr><literal type="string">"%s ("</literal></expr></argument>,
					  <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * right unary means there's a left arg and left unary means there's a
	 * right arg
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oprkind</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>oprkind</name></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    LEFTARG = %s"</literal></expr></argument>, <argument><expr><name>oprleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>, <argument><expr><name>oprleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>, <argument><expr><literal type="string">"NONE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oprkind</name></expr></argument>, <argument><expr><literal type="string">"l"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>oprkind</name></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    RIGHTARG = %s"</literal></expr></argument>, <argument><expr><name>oprright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>, <argument><expr><literal type="string">", %s)"</literal></expr></argument>, <argument><expr><name>oprright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>, <argument><expr><literal type="string">", NONE)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>oprref</name> <operator>=</operator> <call><name>getFormattedOperatorName</name><argument_list>(<argument><expr><name>oprcom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprref</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    COMMUTATOR = %s"</literal></expr></argument>, <argument><expr><name>oprref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oprref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oprref</name> <operator>=</operator> <call><name>getFormattedOperatorName</name><argument_list>(<argument><expr><name>oprnegate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprref</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    NEGATOR = %s"</literal></expr></argument>, <argument><expr><name>oprref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oprref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oprcanmerge</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MERGES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oprcanhash</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    HASHES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oprregproc</name> <operator>=</operator> <call><name>convertRegProcReference</name><argument_list>(<argument><expr><name>oprrest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprregproc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    RESTRICT = %s"</literal></expr></argument>, <argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oprregproc</name> <operator>=</operator> <call><name>convertRegProcReference</name><argument_list>(<argument><expr><name>oprjoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprregproc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    JOIN = %s"</literal></expr></argument>, <argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP OPERATOR %s.%s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name><name>oprid</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE OPERATOR %s.%s (\n%s\n);\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>details</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"OPERATOR"</literal></expr></argument>, <argument><expr><name><name>oprid</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
										<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>oprinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"OPERATOR"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Operator Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR"</literal></expr></argument>, <argument><expr><name><name>oprid</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a function reference obtained from pg_operator
 *
 * Returns allocated string of what to print, or NULL if function references
 * is InvalidOid. Returned string is expected to be free'd by the caller.
 *
 * The input is a REGPROCEDURE display; we have to strip the argument-types
 * part.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>convertRegProcReference</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>paren</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inquote</name></decl>;</decl_stmt>

	<comment type="block">/* In all cases "-" means a null reference */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* find non-double-quoted left paren */</comment>
	<expr_stmt><expr><name>inquote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>paren</name> <operator>=</operator> <name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>paren</name></expr>;</condition> <incr><expr><name>paren</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>paren</name> <operator>==</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>inquote</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>paren</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>paren</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inquote</name> <operator>=</operator> <operator>!</operator><name>inquote</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getFormattedOperatorName - retrieve the operator name for the
 * given operator OID (presented in string form).
 *
 * Returns an allocated string, or NULL if the given OID is invalid.
 * Caller is responsible for free'ing result string.
 *
 * What we produce has the format "OPERATOR(schema.oprname)".  This is only
 * useful in commands where the operator's argument types can be inferred from
 * context.  We always schema-qualify the name, though.  The predecessor to
 * this code tried to skip the schema qualification if possible, but that led
 * to wrong results in corner cases, such as if an operator and its negator
 * are in different schemas.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getFormattedOperatorName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oproid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OprInfo</name>    <modifier>*</modifier></type><name>oprInfo</name></decl>;</decl_stmt>

	<comment type="block">/* In all cases "0" means a null reference */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oproid</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oprInfo</name> <operator>=</operator> <call><name>findOprByOid</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><name>oproid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"could not find operator with OID %s"</literal></expr></argument>,
					   <argument><expr><name>oproid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"OPERATOR(%s.%s)"</literal></expr></argument>,
					<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>oprInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name><name>oprInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a function OID obtained from pg_ts_parser or pg_ts_template
 *
 * It is sufficient to use REGPROC rather than REGPROCEDURE, since the
 * argument lists of these functions are predetermined.  Note that the
 * caller should ensure we are in the proper schema, because the results
 * are search path dependent!
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>convertTSFunction</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>query</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"SELECT '%u'::pg_catalog.regproc"</literal></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpAccessMethod
 *	  write out a single access method definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpAccessMethod</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AccessMethodInfo</name> <modifier>*</modifier></type><name>aminfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qamname</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qamname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE ACCESS METHOD %s "</literal></expr></argument>, <argument><expr><name>qamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>aminfo</name><operator>-&gt;</operator><name>amtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AMTYPE_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"TYPE INDEX "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AMTYPE_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"TYPE TABLE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"invalid type \"%c\" of access method \"%s\""</literal></expr></argument>,
						   <argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>amtype</name></name></expr></argument>, <argument><expr><name>qamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"HANDLER %s;\n"</literal></expr></argument>, <argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>amhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP ACCESS METHOD %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"ACCESS METHOD"</literal></expr></argument>, <argument><expr><name>qamname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"ACCESS METHOD"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Access Method Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"ACCESS METHOD"</literal></expr></argument>, <argument><expr><name>qamname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpOpclass
 *	  write out a single operator class definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpOpclass</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OpclassInfo</name> <modifier>*</modifier></type><name>opcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>nameusing</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcintype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opckeytype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcfamilyname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopstrategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopreqcheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_sortfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_sortfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amprocnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amproclefttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amprocrighttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcintype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opckeytype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcfamilyname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopstrategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopreqcheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sortfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sortfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amprocnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amproclefttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amprocrighttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needComma</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nameusing</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get additional fields from the pg_opclass row */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT opcintype::pg_catalog.regtype, "</literal>
						<literal type="string">"opckeytype::pg_catalog.regtype, "</literal>
						<literal type="string">"opcdefault, opcfamily, "</literal>
						<literal type="string">"opfname AS opcfamilyname, "</literal>
						<literal type="string">"nspname AS opcfamilynsp, "</literal>
						<literal type="string">"(SELECT amname FROM pg_catalog.pg_am WHERE oid = opcmethod) AS amname "</literal>
						<literal type="string">"FROM pg_catalog.pg_opclass c "</literal>
						<literal type="string">"LEFT JOIN pg_catalog.pg_opfamily f ON f.oid = opcfamily "</literal>
						<literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = opfnamespace "</literal>
						<literal type="string">"WHERE c.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						<argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_opcintype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcintype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opckeytype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opckeytype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcdefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcdefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcfamily</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcfamily"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcfamilyname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcfamilyname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcfamilynsp</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcfamilynsp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* opcintype may still be needed after we PQclear res */</comment>
	<expr_stmt><expr><name>opcintype</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opcintype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opckeytype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opckeytype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opcdefault</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opcdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* opcfamily will still be needed after we PQclear res */</comment>
	<expr_stmt><expr><name>opcfamily</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opcfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opcfamilyname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opcfamilyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opcfamilynsp</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opcfamilynsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* amname will still be needed after we PQclear res */</comment>
	<expr_stmt><expr><name>amname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP OPERATOR CLASS %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>opcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">" USING %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build the fixed portion of the CREATE command */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE OPERATOR CLASS %s\n    "</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>opcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opcdefault</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"FOR TYPE %s USING %s"</literal></expr></argument>,
					  <argument><expr><name>opcintype</name></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>opcfamilyname</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" FAMILY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>opcfamilynsp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>opcfamilyname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" AS\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opckeytype</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"STORAGE %s"</literal></expr></argument>,
						  <argument><expr><name>opckeytype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now fetch and print the OPERATOR entries (pg_amop rows).
	 *
	 * Print only those opfamily members that are tied to the opclass by
	 * pg_depend entries.
	 *
	 * XXX RECHECK is gone as of 8.4, but we'll still print it if dumping an
	 * older server's opclass in which it is used.  This is to avoid
	 * hard-to-detect breakage if a newer pg_dump is used to dump from an
	 * older server and then reload into that old version.  This can go away
	 * once 8.3 is so old as to not be of interest to anyone.
	 */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, false AS amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"opfname AS sortfamily, "</literal>
						  <literal type="string">"nspname AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao JOIN pg_catalog.pg_depend ON "</literal>
						  <literal type="string">"(classid = 'pg_catalog.pg_amop'::pg_catalog.regclass AND objid = ao.oid) "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_opfamily f ON f.oid = amopsortfamily "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = opfnamespace "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opclass'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND amopfamily = '%s'::pg_catalog.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
						  <argument><expr><name>opcfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, false AS amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"NULL AS sortfamily, "</literal>
						  <literal type="string">"NULL AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao, pg_catalog.pg_depend "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opclass'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND classid = 'pg_catalog.pg_amop'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND objid = ao.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"NULL AS sortfamily, "</literal>
						  <literal type="string">"NULL AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao, pg_catalog.pg_depend "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opclass'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND classid = 'pg_catalog.pg_amop'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND objid = ao.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_amopstrategy</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amopstrategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amopreqcheck</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amopreqcheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amopopr</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amopopr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_sortfamily</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"sortfamily"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_sortfamilynsp</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"sortfamilynsp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>amopstrategy</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amopreqcheck</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopreqcheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amopopr</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortfamily</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_sortfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortfamilynsp</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_sortfamilynsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ,\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR %s %s"</literal></expr></argument>,
						  <argument><expr><name>amopstrategy</name></expr></argument>, <argument><expr><name>amopopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>sortfamily</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" FOR ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>sortfamilynsp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>sortfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>amopreqcheck</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" RECHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now fetch and print the FUNCTION entries (pg_amproc rows).
	 *
	 * Print only those opfamily members that are tied to the opclass by
	 * pg_depend entries.
	 *
	 * We print the amproclefttype/amprocrighttype even though in most cases
	 * the backend could deduce the right values, because of the corner case
	 * of a btree sort support function for a cross-type comparison.  That's
	 * only allowed in 9.2 and later, but for simplicity print them in all
	 * versions that have the columns.
	 */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amprocnum, "</literal>
						<literal type="string">"amproc::pg_catalog.regprocedure, "</literal>
						<literal type="string">"amproclefttype::pg_catalog.regtype, "</literal>
						<literal type="string">"amprocrighttype::pg_catalog.regtype "</literal>
						<literal type="string">"FROM pg_catalog.pg_amproc ap, pg_catalog.pg_depend "</literal>
						<literal type="string">"WHERE refclassid = 'pg_catalog.pg_opclass'::pg_catalog.regclass "</literal>
						<literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						<literal type="string">"AND classid = 'pg_catalog.pg_amproc'::pg_catalog.regclass "</literal>
						<literal type="string">"AND objid = ap.oid "</literal>
						<literal type="string">"ORDER BY amprocnum"</literal></expr></argument>,
						<argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_amprocnum</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amprocnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amproc</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amproc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amproclefttype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amproclefttype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amprocrighttype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amprocrighttype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>amprocnum</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amprocnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amproc</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amproclefttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amproclefttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amprocrighttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amprocrighttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ,\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"FUNCTION %s"</literal></expr></argument>, <argument><expr><name>amprocnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>amproclefttype</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>amprocrighttype</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" (%s, %s)"</literal></expr></argument>, <argument><expr><name>amproclefttype</name></expr></argument>, <argument><expr><name>amprocrighttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>amproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If needComma is still false it means we haven't added anything after
	 * the AS keyword.  To avoid printing broken SQL, append a dummy STORAGE
	 * clause with the same datatype.  This isn't sanctioned by the
	 * documentation, but actually DefineOpClass will treat it as a no-op.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"STORAGE %s"</literal></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>, <argument><expr><literal type="string">" USING %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"OPERATOR CLASS"</literal></expr></argument>, <argument><expr><name><name>nameusing</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
										<argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>opcinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"OPERATOR CLASS"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Operator Class Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR CLASS"</literal></expr></argument>, <argument><expr><name><name>nameusing</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					<argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>opcintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>opcfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpOpfamily
 *	  write out a single operator family definition
 *
 * Note: this also dumps any "loose" operator members that aren't bound to a
 * specific opclass within the opfamily.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpOpfamily</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OpfamilyInfo</name> <modifier>*</modifier></type><name>opfinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>nameusing</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res_ops</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res_procs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopstrategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopreqcheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_sortfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_sortfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amprocnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amproclefttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amprocrighttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopstrategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopreqcheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sortfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sortfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amprocnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amproclefttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amprocrighttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needComma</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nameusing</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch only those opfamily members that are tied directly to the
	 * opfamily by pg_depend entries.
	 *
	 * XXX RECHECK is gone as of 8.4, but we'll still print it if dumping an
	 * older server's opclass in which it is used.  This is to avoid
	 * hard-to-detect breakage if a newer pg_dump is used to dump from an
	 * older server and then reload into that old version.  This can go away
	 * once 8.3 is so old as to not be of interest to anyone.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, false AS amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"opfname AS sortfamily, "</literal>
						  <literal type="string">"nspname AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao JOIN pg_catalog.pg_depend ON "</literal>
						  <literal type="string">"(classid = 'pg_catalog.pg_amop'::pg_catalog.regclass AND objid = ao.oid) "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_opfamily f ON f.oid = amopsortfamily "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = opfnamespace "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opfamily'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND amopfamily = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
						  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, false AS amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"NULL AS sortfamily, "</literal>
						  <literal type="string">"NULL AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao, pg_catalog.pg_depend "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opfamily'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND classid = 'pg_catalog.pg_amop'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND objid = ao.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"NULL AS sortfamily, "</literal>
						  <literal type="string">"NULL AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao, pg_catalog.pg_depend "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opfamily'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND classid = 'pg_catalog.pg_amop'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND objid = ao.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res_ops</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amprocnum, "</literal>
					  <literal type="string">"amproc::pg_catalog.regprocedure, "</literal>
					  <literal type="string">"amproclefttype::pg_catalog.regtype, "</literal>
					  <literal type="string">"amprocrighttype::pg_catalog.regtype "</literal>
					  <literal type="string">"FROM pg_catalog.pg_amproc ap, pg_catalog.pg_depend "</literal>
					  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opfamily'::pg_catalog.regclass "</literal>
					  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
					  <literal type="string">"AND classid = 'pg_catalog.pg_amproc'::pg_catalog.regclass "</literal>
					  <literal type="string">"AND objid = ap.oid "</literal>
					  <literal type="string">"ORDER BY amprocnum"</literal></expr></argument>,
					  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res_procs</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get additional fields from the pg_opfamily row */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
					  <literal type="string">"(SELECT amname FROM pg_catalog.pg_am WHERE oid = opfmethod) AS amname "</literal>
					  <literal type="string">"FROM pg_catalog.pg_opfamily "</literal>
					  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
					  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_amname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* amname will still be needed after we PQclear res */</comment>
	<expr_stmt><expr><name>amname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP OPERATOR FAMILY %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>opfinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">" USING %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build the fixed portion of the CREATE command */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE OPERATOR FAMILY %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>opfinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" USING %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do we need an ALTER to add loose members? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER OPERATOR FAMILY %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>opfinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" USING %s ADD\n    "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now fetch and print the OPERATOR entries (pg_amop rows).
		 */</comment>
		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_amopstrategy</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><literal type="string">"amopstrategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_amopreqcheck</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><literal type="string">"amopreqcheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_amopopr</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><literal type="string">"amopopr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_sortfamily</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><literal type="string">"sortfamily"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_sortfamilynsp</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><literal type="string">"sortfamilynsp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>amopstrategy</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>amopreqcheck</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopreqcheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>amopopr</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sortfamily</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_sortfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sortfamilynsp</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_sortfamilynsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ,\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR %s %s"</literal></expr></argument>,
							  <argument><expr><name>amopstrategy</name></expr></argument>, <argument><expr><name>amopopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>sortfamily</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" FOR ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>sortfamilynsp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>sortfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>amopreqcheck</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" RECHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Now fetch and print the FUNCTION entries (pg_amproc rows).
		 */</comment>
		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_amprocnum</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><literal type="string">"amprocnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_amproc</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><literal type="string">"amproc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_amproclefttype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><literal type="string">"amproclefttype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_amprocrighttype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><literal type="string">"amprocrighttype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>amprocnum</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amprocnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>amproc</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>amproclefttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amproclefttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>amprocrighttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amprocrighttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ,\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"FUNCTION %s (%s, %s) %s"</literal></expr></argument>,
							  <argument><expr><name>amprocnum</name></expr></argument>, <argument><expr><name>amproclefttype</name></expr></argument>, <argument><expr><name>amprocrighttype</name></expr></argument>,
							  <argument><expr><name>amproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>, <argument><expr><literal type="string">" USING %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"OPERATOR FAMILY"</literal></expr></argument>, <argument><expr><name><name>nameusing</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
										<argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>opfinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"OPERATOR FAMILY"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Operator Family Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR FAMILY"</literal></expr></argument>, <argument><expr><name><name>nameusing</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					<argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpCollation
 *	  write out a single collation definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpCollation</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CollInfo</name> <modifier>*</modifier></type><name>collinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qcollname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collprovider</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collisdeterministic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collcollate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collctype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collprovider</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collcollate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collctype</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qcollname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get collation-specific details */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"collprovider, "</literal>
						  <literal type="string">"collversion, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"'c' AS collprovider, "</literal>
						  <literal type="string">"NULL AS collversion, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"collisdeterministic, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"true AS collisdeterministic, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"collcollate, "</literal>
					  <literal type="string">"collctype "</literal>
					  <literal type="string">"FROM pg_catalog.pg_collation c "</literal>
					  <literal type="string">"WHERE c.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
					  <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_collprovider</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collprovider"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collisdeterministic</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collisdeterministic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collcollate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collcollate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collctype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collctype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>collprovider</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collprovider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collcollate</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collctype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP COLLATION %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>collinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE COLLATION %s ("</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>collinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"provider = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>collprovider</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"libc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>collprovider</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"icu"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>collprovider</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* to allow dumping pg_catalog; not accepted on input */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized collation provider: %s\n"</literal></expr></argument>,
			  <argument><expr><name>collprovider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collisdeterministic</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", deterministic = false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>, <argument><expr><name>collctype</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", locale = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", lc_collate = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", lc_ctype = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>collctype</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * For binary upgrade, carry over the collation version.  For normal
	 * dump/restore, omit the version, so that it is computed upon restore.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_collversion</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>i_collversion</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collversion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collversion</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", version = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
								  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collversion</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"COLLATION"</literal></expr></argument>, <argument><expr><name>qcollname</name></expr></argument>,
										<argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>collinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"COLLATION"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Collation Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"COLLATION"</literal></expr></argument>, <argument><expr><name>qcollname</name></expr></argument>,
					<argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qcollname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpConversion
 *	  write out a single conversion definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpConversion</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConvInfo</name> <modifier>*</modifier></type><name>convinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qconvname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_conforencoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_contoencoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_conproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_condefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conforencoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>contoencoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>condefault</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qconvname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get conversion-specific details */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
					  <literal type="string">"pg_catalog.pg_encoding_to_char(conforencoding) AS conforencoding, "</literal>
					  <literal type="string">"pg_catalog.pg_encoding_to_char(contoencoding) AS contoencoding, "</literal>
					  <literal type="string">"conproc, condefault "</literal>
					  <literal type="string">"FROM pg_catalog.pg_conversion c "</literal>
					  <literal type="string">"WHERE c.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
					  <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_conforencoding</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conforencoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_contoencoding</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"contoencoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conproc</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conproc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_condefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"condefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conforencoding</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_conforencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>contoencoding</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_contoencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conproc</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_conproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>condefault</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_condefault</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP CONVERSION %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>convinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE %sCONVERSION %s FOR "</literal></expr></argument>,
					  <argument><expr><ternary><condition><expr><operator>(</operator><name>condefault</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"DEFAULT "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>convinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>conforencoding</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" TO "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>contoencoding</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* regproc output is already sufficiently quoted */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" FROM %s;\n"</literal></expr></argument>, <argument><expr><name>conproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"CONVERSION"</literal></expr></argument>, <argument><expr><name>qconvname</name></expr></argument>,
										<argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>convinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"CONVERSION"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Conversion Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"CONVERSION"</literal></expr></argument>, <argument><expr><name>qconvname</name></expr></argument>,
					<argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qconvname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * format_aggregate_signature: generate aggregate name and argument list
 *
 * The argument type names are qualified if needed.  The aggregate name
 * is never qualified.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_aggregate_signature</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AggInfo</name> <modifier>*</modifier></type><name>agginfo</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>honor_quotes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>honor_quotes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>nargs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(*)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>typname</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>argtypes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name>zeroAsOpaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
							  <argument><expr><ternary><condition><expr><operator>(</operator><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							  <argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpAgg
 *	  write out a single aggregate definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpAgg</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggInfo</name> <modifier>*</modifier></type><name>agginfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>details</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>aggsig</name></decl>;</decl_stmt>			<comment type="block">/* identity signature */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>aggfullsig</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* full signature */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>aggsig_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_agginitval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggminitval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggtransfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggfinalfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggcombinefn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggserialfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggdeserialfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggmtransfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggminvtransfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggmfinalfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>aggfinalextra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>aggmfinalextra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>aggfinalmodify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>aggmfinalmodify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggsortop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>aggsortconvop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>aggkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggtranstype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggtransspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggmtranstype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggmtransspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>agginitval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggminitval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proparallel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>defaultfinalmodify</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>details</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPAGG</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up query for aggregate-specific details */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"PREPARE dumpAgg(pg_catalog.oid) AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"SELECT "</literal>
							 <literal type="string">"aggtransfn,\n"</literal>
							 <literal type="string">"aggfinalfn,\n"</literal>
							 <literal type="string">"aggtranstype::pg_catalog.regtype,\n"</literal>
							 <literal type="string">"agginitval,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"aggsortop,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"0 AS aggsortop,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"pg_catalog.pg_get_function_arguments(p.oid) AS funcargs,\n"</literal>
								 <literal type="string">"pg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"aggkind,\n"</literal>
								 <literal type="string">"aggmtransfn,\n"</literal>
								 <literal type="string">"aggminvtransfn,\n"</literal>
								 <literal type="string">"aggmfinalfn,\n"</literal>
								 <literal type="string">"aggmtranstype::pg_catalog.regtype,\n"</literal>
								 <literal type="string">"aggfinalextra,\n"</literal>
								 <literal type="string">"aggmfinalextra,\n"</literal>
								 <literal type="string">"aggtransspace,\n"</literal>
								 <literal type="string">"aggmtransspace,\n"</literal>
								 <literal type="string">"aggminitval,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"'n' AS aggkind,\n"</literal>
								 <literal type="string">"'-' AS aggmtransfn,\n"</literal>
								 <literal type="string">"'-' AS aggminvtransfn,\n"</literal>
								 <literal type="string">"'-' AS aggmfinalfn,\n"</literal>
								 <literal type="string">"0 AS aggmtranstype,\n"</literal>
								 <literal type="string">"false AS aggfinalextra,\n"</literal>
								 <literal type="string">"false AS aggmfinalextra,\n"</literal>
								 <literal type="string">"0 AS aggtransspace,\n"</literal>
								 <literal type="string">"0 AS aggmtransspace,\n"</literal>
								 <literal type="string">"NULL AS aggminitval,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"aggcombinefn,\n"</literal>
								 <literal type="string">"aggserialfn,\n"</literal>
								 <literal type="string">"aggdeserialfn,\n"</literal>
								 <literal type="string">"proparallel,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"'-' AS aggcombinefn,\n"</literal>
								 <literal type="string">"'-' AS aggserialfn,\n"</literal>
								 <literal type="string">"'-' AS aggdeserialfn,\n"</literal>
								 <literal type="string">"'u' AS proparallel,\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"aggfinalmodify,\n"</literal>
								 <literal type="string">"aggmfinalmodify\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"'0' AS aggfinalmodify,\n"</literal>
								 <literal type="string">"'0' AS aggmfinalmodify\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"FROM pg_catalog.pg_aggregate a, pg_catalog.pg_proc p "</literal>
							 <literal type="string">"WHERE a.aggfnoid = p.oid "</literal>
							 <literal type="string">"AND p.oid = $1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_DUMPAGG</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"EXECUTE dumpAgg('%u')"</literal></expr></argument>,
					  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_agginitval</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"agginitval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggminitval</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggminitval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aggtransfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggtransfn"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggfinalfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggfinalfn"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggcombinefn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggcombinefn"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggserialfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggserialfn"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggdeserialfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggdeserialfn"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmtransfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmtransfn"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggminvtransfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggminvtransfn"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmfinalfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmfinalfn"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggfinalextra</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggfinalextra"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmfinalextra</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmfinalextra"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggfinalmodify</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggfinalmodify"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmfinalmodify</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmfinalmodify"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggsortop</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggsortop"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggkind</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggkind"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggtranstype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggtranstype"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggtransspace</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggtransspace"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmtranstype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmtranstype"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmtransspace</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmtransspace"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>agginitval</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_agginitval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggminitval</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggminitval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proparallel</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proparallel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* 8.4 or later; we rely on server-side code for most of the work */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcargs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funciargs</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcargs</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"funcargs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funciargs</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"funciargs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggfullsig</name> <operator>=</operator> <call><name>format_function_arguments</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name></name></expr></argument>, <argument><expr><name>funcargs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggsig</name> <operator>=</operator> <call><name>format_function_arguments</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name></name></expr></argument>, <argument><expr><name>funciargs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* pre-8.4, do it ourselves */</comment>
		<expr_stmt><expr><name>aggsig</name> <operator>=</operator> <call><name>format_aggregate_signature</name><argument_list>(<argument><expr><name>agginfo</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>aggsig_tag</name> <operator>=</operator> <call><name>format_aggregate_signature</name><argument_list>(<argument><expr><name>agginfo</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* identify default modify flag for aggkind (must match DefineAggregate) */</comment>
	<expr_stmt><expr><name>defaultfinalmodify</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>aggkind</name> <operator>==</operator> <name>AGGKIND_NORMAL</name><operator>)</operator></expr> ?</condition><then> <expr><name>AGGMODIFY_READ_ONLY</name></expr> </then><else>: <expr><name>AGGMODIFY_READ_WRITE</name></expr></else></ternary></expr>;</expr_stmt>
	<comment type="block">/* replace omitted flags for old versions */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggfinalmodify</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>aggfinalmodify</name> <operator>=</operator> <name>defaultfinalmodify</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggmfinalmodify</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>aggmfinalmodify</name> <operator>=</operator> <name>defaultfinalmodify</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* regproc and regtype output is already sufficiently quoted */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">"    SFUNC = %s,\n    STYPE = %s"</literal></expr></argument>,
					  <argument><expr><name>aggtransfn</name></expr></argument>, <argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggtransspace</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    SSPACE = %s"</literal></expr></argument>,
						  <argument><expr><name>aggtransspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_agginitval</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    INITCOND = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><name>agginitval</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggfinalfn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    FINALFUNC = %s"</literal></expr></argument>,
						  <argument><expr><name>aggfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggfinalextra</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    FINALFUNC_EXTRA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggfinalmodify</name> <operator>!=</operator> <name>defaultfinalmodify</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>aggfinalmodify</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>AGGMODIFY_READ_ONLY</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    FINALFUNC_MODIFY = READ_ONLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AGGMODIFY_SHAREABLE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    FINALFUNC_MODIFY = SHAREABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AGGMODIFY_READ_WRITE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    FINALFUNC_MODIFY = READ_WRITE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized aggfinalmodify value for aggregate \"%s\""</literal></expr></argument>,
						  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggcombinefn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    COMBINEFUNC = %s"</literal></expr></argument>, <argument><expr><name>aggcombinefn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggserialfn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    SERIALFUNC = %s"</literal></expr></argument>, <argument><expr><name>aggserialfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggdeserialfn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    DESERIALFUNC = %s"</literal></expr></argument>, <argument><expr><name>aggdeserialfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggmtransfn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MSFUNC = %s,\n    MINVFUNC = %s,\n    MSTYPE = %s"</literal></expr></argument>,
						  <argument><expr><name>aggmtransfn</name></expr></argument>,
						  <argument><expr><name>aggminvtransfn</name></expr></argument>,
						  <argument><expr><name>aggmtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggmtransspace</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MSSPACE = %s"</literal></expr></argument>,
						  <argument><expr><name>aggmtransspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggminitval</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MINITCOND = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><name>aggminitval</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggmfinalfn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MFINALFUNC = %s"</literal></expr></argument>,
						  <argument><expr><name>aggmfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggmfinalextra</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MFINALFUNC_EXTRA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggmfinalmodify</name> <operator>!=</operator> <name>defaultfinalmodify</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>aggmfinalmodify</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>AGGMODIFY_READ_ONLY</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MFINALFUNC_MODIFY = READ_ONLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AGGMODIFY_SHAREABLE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MFINALFUNC_MODIFY = SHAREABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AGGMODIFY_READ_WRITE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MFINALFUNC_MODIFY = READ_WRITE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized aggmfinalmodify value for aggregate \"%s\""</literal></expr></argument>,
						  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>aggsortconvop</name> <operator>=</operator> <call><name>getFormattedOperatorName</name><argument_list>(<argument><expr><name>aggsortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggsortconvop</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    SORTOP = %s"</literal></expr></argument>,
						  <argument><expr><name>aggsortconvop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggsortconvop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>aggkind</name> <operator>==</operator> <name>AGGKIND_HYPOTHETICAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    HYPOTHETICAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROPARALLEL_UNSAFE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROPARALLEL_SAFE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    PARALLEL = safe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROPARALLEL_RESTRICTED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    PARALLEL = restricted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROPARALLEL_UNSAFE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized proparallel value for function \"%s\""</literal></expr></argument>,
				  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP AGGREGATE %s.%s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>aggsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE AGGREGATE %s.%s (\n%s\n);\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>aggfullsig</name></expr> ?</condition><then> <expr><name>aggfullsig</name></expr> </then><else>: <expr><name>aggsig</name></expr></else></ternary></expr></argument>, <argument><expr><name><name>details</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"AGGREGATE"</literal></expr></argument>, <argument><expr><name>aggsig</name></expr></argument>,
										<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>,
					 <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>aggsig_tag</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"AGGREGATE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Aggregate Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"AGGREGATE"</literal></expr></argument>, <argument><expr><name>aggsig</name></expr></argument>,
					<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"AGGREGATE"</literal></expr></argument>, <argument><expr><name>aggsig</name></expr></argument>,
					 <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Since there is no GRANT ON AGGREGATE syntax, we have to make the ACL
	 * command look like a function's GRANT; in particular this affects the
	 * syntax for zero-argument aggregates and ordered-set aggregates.
	 */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aggsig</name> <operator>=</operator> <call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>,
				<argument><expr><literal type="string">"FUNCTION"</literal></expr></argument>, <argument><expr><name>aggsig</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggfullsig</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggfullsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggsig_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getFunctionName - retrieves a function name from an oid
 *
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getFunctionName</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT proname FROM pg_proc WHERE oid = %u;"</literal></expr></argument>,<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Expecting a single result only */</comment>
	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"query yielded %d rows instead of one: %s"</literal></expr></argument>,
					   <argument><expr><name>ntups</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* already quoted */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpExtProtocol
 *	  write out a single external protocol definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpExtProtocol</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ExtProtInfo</name> <modifier>*</modifier></type><name>ptcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FCOUNT</name></cpp:macro>	<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READFN_IDX</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITEFN_IDX</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALIDFN_IDX</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

	<typedef>typedef <type><struct>struct
	<block>{
		<decl_stmt><decl><type><name>Oid</name></type> <name>oid</name></decl>;</decl_stmt> 				<comment type="block">/* func's oid */</comment>
		<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>name</name></decl>;</decl_stmt> 			<comment type="block">/* func name */</comment>
		<decl_stmt><decl><type><name>FuncInfo</name><modifier>*</modifier></type> <name>pfuncinfo</name></decl>;</decl_stmt> 	<comment type="block">/* FuncInfo ptr */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>dumpable</name></decl>;</decl_stmt> 			<comment type="block">/* should we dump this function */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>internal</name></decl>;</decl_stmt>			<comment type="block">/* is it an internal function */</comment>
	}</block></struct></type> <name>ProtoFunc</name>;</typedef>

	<decl_stmt><decl><type><name>ProtoFunc</name></type>	<name><name>protoFuncs</name><index>[<expr><name>FCOUNT</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type>	<name>nsq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prev_ns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>namecopy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_internal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* init and fill the protoFuncs array */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>protoFuncs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>protoFuncs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>READFN_IDX</name></expr>]</index></name><operator>.</operator><name>oid</name> <operator>=</operator> <name><name>ptcinfo</name><operator>-&gt;</operator><name>ptcreadid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>WRITEFN_IDX</name></expr>]</index></name><operator>.</operator><name>oid</name> <operator>=</operator> <name><name>ptcinfo</name><operator>-&gt;</operator><name>ptcwriteid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>VALIDFN_IDX</name></expr>]</index></name><operator>.</operator><name>oid</name> <operator>=</operator> <name><name>ptcinfo</name><operator>-&gt;</operator><name>ptcvalidid</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FCOUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dumpable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>internal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/*
			 * We have at least one internal function, signal that we need the
			 * public schema in the search_path
			 */</comment>
			<expr_stmt><expr><name>has_internal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pfuncinfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pfuncinfo</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dumpable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pfuncinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>internal</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>internal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* if all funcs are internal then we do not need to dump this protocol */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>protoFuncs</name><index>[<expr><name>READFN_IDX</name></expr>]</index></name><operator>.</operator><name>internal</name> <operator>&amp;&amp;</operator> <name><name>protoFuncs</name><index>[<expr><name>WRITEFN_IDX</name></expr>]</index></name><operator>.</operator><name>internal</name>
			<operator>&amp;&amp;</operator> <name><name>protoFuncs</name><index>[<expr><name>VALIDFN_IDX</name></expr>]</index></name><operator>.</operator><name>internal</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* obtain the function name for internal functions (if any) */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FCOUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>internal</name> <operator>&amp;&amp;</operator> <name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>getFunctionName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dumpable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>nsq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since the function parameters to the external protocol cannot be fully
	 * qualified with namespace, we must ensure that we have the search_path
	 * set with the namespaces of the referenced functions. We only need the
	 * dump file to have the search_path so inject a SET search_path = .. ;
	 * into the output stream instead of calling selectSourceSchema().
	 *
	 * GPDB_96_MERGE_FIXME: update the above comment because selectSourceSchema
	 * has been removed in upstream 9f6e5296a  Security: CVE-2018-1058
	 */</comment>
	<expr_stmt><expr><name>prev_ns</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FCOUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pfuncinfo</name> <operator>||</operator> <name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>internal</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>prev_ns</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>prev_ns</name></expr></argument>, <argument><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pfuncinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>nsq</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>prev_ns</name></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pfuncinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_ns</name> <operator>=</operator> <name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pfuncinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are adding public to the search_path, then we don't need to do
		 * so again for any internal functions
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>prev_ns</name></expr></argument>, <argument><expr><literal type="string">"public"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>has_internal</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>prev_ns</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"-- Set the search_path required to look up the functions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET search_path = %s%s;\n\n"</literal></expr></argument>,
						  <argument><expr><name><name>nsq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>has_internal</name></expr> ?</condition><then> <expr><literal type="string">", public"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>nsq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE %s PROTOCOL %s ("</literal></expr></argument>,
			<argument><expr><ternary><condition><expr><name><name>ptcinfo</name><operator>-&gt;</operator><name>ptctrusted</name></name> <operator>==</operator> <name>true</name></expr> ?</condition><then> <expr><literal type="string">"TRUSTED"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>ptcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>protoFuncs</name><index>[<expr><name>READFN_IDX</name></expr>]</index></name><operator>.</operator><name>dumpable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" readfunc = '%s'%s"</literal></expr></argument>,
						  <argument><expr><name><name>protoFuncs</name><index>[<expr><name>READFN_IDX</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name><name>protoFuncs</name><index>[<expr><name>WRITEFN_IDX</name></expr>]</index></name><operator>.</operator><name>dumpable</name></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>protoFuncs</name><index>[<expr><name>WRITEFN_IDX</name></expr>]</index></name><operator>.</operator><name>dumpable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" writefunc = '%s'%s"</literal></expr></argument>,
						  <argument><expr><name><name>protoFuncs</name><index>[<expr><name>WRITEFN_IDX</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
					      <argument><expr><operator>(</operator><ternary><condition><expr><name><name>protoFuncs</name><index>[<expr><name>VALIDFN_IDX</name></expr>]</index></name><operator>.</operator><name>dumpable</name></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>protoFuncs</name><index>[<expr><name>VALIDFN_IDX</name></expr>]</index></name><operator>.</operator><name>dumpable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" validatorfunc = '%s'"</literal></expr></argument>,
						  <argument><expr><name><name>protoFuncs</name><index>[<expr><name>VALIDFN_IDX</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP PROTOCOL %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>ptcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>ptcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>ptcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
				 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>ptcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>ptcinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"PROTOCOL"</literal></expr></argument>,
							  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <name><name>ptcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dependencies</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <name><name>ptcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>nDeps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle the ACL */</comment>
	<expr_stmt><expr><name>namecopy</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>ptcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>ptcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>ptcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
			<argument><expr><literal type="string">"PROTOCOL"</literal></expr></argument>,
			<argument><expr><name>namecopy</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
			<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ptcinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ptcinfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>namecopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FCOUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>protoFuncs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTSParser
 *	  write out a single text search parser
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTSParser</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TSParserInfo</name> <modifier>*</modifier></type><name>prsinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qprsname</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qprsname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TEXT SEARCH PARSER %s (\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>prsinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    START = %s,\n"</literal></expr></argument>,
					  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prsstart</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    GETTOKEN = %s,\n"</literal></expr></argument>,
					  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prstoken</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    END = %s,\n"</literal></expr></argument>,
					  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prsend</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prsheadline</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    HEADLINE = %s,\n"</literal></expr></argument>,
						  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prsheadline</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    LEXTYPES = %s );\n"</literal></expr></argument>,
					  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prslextype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TEXT SEARCH PARSER %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>prsinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TEXT SEARCH PARSER"</literal></expr></argument>, <argument><expr><name>qprsname</name></expr></argument>,
										<argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TEXT SEARCH PARSER"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Parser Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH PARSER"</literal></expr></argument>, <argument><expr><name>qprsname</name></expr></argument>,
					<argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qprsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTSDictionary
 *	  write out a single text search dictionary
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTSDictionary</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TSDictInfo</name> <modifier>*</modifier></type><name>dictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qdictname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmplname</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qdictname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch name and namespace of the dictionary's template */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT nspname, tmplname "</literal>
					  <literal type="string">"FROM pg_ts_template p, pg_namespace n "</literal>
					  <literal type="string">"WHERE p.oid = '%u' AND n.oid = tmplnamespace"</literal></expr></argument>,
					  <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dicttemplate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmplname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TEXT SEARCH DICTIONARY %s (\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>dictinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    TEMPLATE = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>tmplname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the dictinitoption can be dumped straight into the command */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dictinitoption</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    %s"</literal></expr></argument>, <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dictinitoption</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" );\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TEXT SEARCH DICTIONARY %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>dictinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TEXT SEARCH DICTIONARY"</literal></expr></argument>, <argument><expr><name>qdictname</name></expr></argument>,
										<argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>dictinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TEXT SEARCH DICTIONARY"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Dictionary Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH DICTIONARY"</literal></expr></argument>, <argument><expr><name>qdictname</name></expr></argument>,
					<argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qdictname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTSTemplate
 *	  write out a single text search template
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTSTemplate</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TSTemplateInfo</name> <modifier>*</modifier></type><name>tmplinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtmplname</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qtmplname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TEXT SEARCH TEMPLATE %s (\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tmplinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>tmplinit</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    INIT = %s,\n"</literal></expr></argument>,
						  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>tmplinit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    LEXIZE = %s );\n"</literal></expr></argument>,
					  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>tmpllexize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TEXT SEARCH TEMPLATE %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tmplinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TEXT SEARCH TEMPLATE"</literal></expr></argument>, <argument><expr><name>qtmplname</name></expr></argument>,
										<argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TEXT SEARCH TEMPLATE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Template Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH TEMPLATE"</literal></expr></argument>, <argument><expr><name>qtmplname</name></expr></argument>,
					<argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtmplname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTSConfig
 *	  write out a single text search configuration
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTSConfig</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TSConfigInfo</name> <modifier>*</modifier></type><name>cfginfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qcfgname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prsname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tokenname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_dictname</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qcfgname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch name and namespace of the config's parser */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT nspname, prsname "</literal>
					  <literal type="string">"FROM pg_ts_parser p, pg_namespace n "</literal>
					  <literal type="string">"WHERE p.oid = '%u' AND n.oid = prsnamespace"</literal></expr></argument>,
					  <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>cfgparser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prsname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TEXT SEARCH CONFIGURATION %s (\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>cfginfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    PARSER = %s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s );\n"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT\n"</literal>
					  <literal type="string">"  ( SELECT alias FROM pg_catalog.ts_token_type('%u'::pg_catalog.oid) AS t\n"</literal>
					  <literal type="string">"    WHERE t.tokid = m.maptokentype ) AS tokenname,\n"</literal>
					  <literal type="string">"  m.mapdict::pg_catalog.regdictionary AS dictname\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_ts_config_map AS m\n"</literal>
					  <literal type="string">"WHERE m.mapcfg = '%u'\n"</literal>
					  <literal type="string">"ORDER BY m.mapcfg, m.maptokentype, m.mapseqno"</literal></expr></argument>,
					  <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>cfgparser</name></name></expr></argument>, <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tokenname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tokenname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dictname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dictname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tokenname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tokenname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dictname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dictname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>tokenname</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>i_tokenname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* starting a new token type, so start a new command */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TEXT SEARCH CONFIGURATION %s\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>cfginfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* tokenname needs quoting, dictname does NOT */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    ADD MAPPING FOR %s WITH %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>tokenname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", %s"</literal></expr></argument>, <argument><expr><name>dictname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TEXT SEARCH CONFIGURATION %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>cfginfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TEXT SEARCH CONFIGURATION"</literal></expr></argument>, <argument><expr><name>qcfgname</name></expr></argument>,
										<argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>cfginfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TEXT SEARCH CONFIGURATION"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Configuration Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH CONFIGURATION"</literal></expr></argument>, <argument><expr><name>qcfgname</name></expr></argument>,
					<argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qcfgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpForeignDataWrapper
 *	  write out a single foreign-data wrapper definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpForeignDataWrapper</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FdwInfo</name> <modifier>*</modifier></type><name>fdwinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qfdwname</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qfdwname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE FOREIGN DATA WRAPPER %s"</literal></expr></argument>,
					  <argument><expr><name>qfdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwhandler</name></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" HANDLER %s"</literal></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwvalidator</name></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" VALIDATOR %s"</literal></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwvalidator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwoptions</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" OPTIONS (\n    %s\n)"</literal></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwoptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP FOREIGN DATA WRAPPER %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qfdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>, <argument><expr><name>qfdwname</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>fdwinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Foreign Data Wrapper Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>, <argument><expr><name>qfdwname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Handle the ACL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>,
				<argument><expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>, <argument><expr><name>qfdwname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fdwinfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qfdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpForeignServer
 *	  write out a foreign server definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpForeignServer</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignServerInfo</name> <modifier>*</modifier></type><name>srvinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qsrvname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fdwname</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qsrvname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* look up the foreign-data wrapper */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT fdwname "</literal>
					  <literal type="string">"FROM pg_foreign_data_wrapper w "</literal>
					  <literal type="string">"WHERE w.oid = '%u'"</literal></expr></argument>,
					  <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvfdw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fdwname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE SERVER %s"</literal></expr></argument>, <argument><expr><name>qsrvname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvtype</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvtype</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" TYPE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvtype</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvversion</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" VERSION "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvversion</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" FOREIGN DATA WRAPPER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvoptions</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvoptions</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" OPTIONS (\n    %s\n)"</literal></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvoptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP SERVER %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qsrvname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"SERVER"</literal></expr></argument>, <argument><expr><name>qsrvname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>srvinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"SERVER"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Foreign Server Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SERVER"</literal></expr></argument>, <argument><expr><name>qsrvname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Handle the ACL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>,
				<argument><expr><literal type="string">"FOREIGN SERVER"</literal></expr></argument>, <argument><expr><name>qsrvname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>srvinfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump user mappings */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_USERMAP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpUserMappings</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						 <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
						 <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qsrvname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpUserMappings
 *
 * This routine is used to dump any user mappings associated with the
 * server handed to this routine. Should be called after ArchiveEntry()
 * for the server.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpUserMappings</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>servername</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
				 <parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_usename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_umoptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We read from the publicly accessible view pg_user_mappings, so as not
	 * to fail if run by a non-superuser.  Note that the view will show
	 * umoptions as null if the user hasn't got privileges for the associated
	 * server; this means that pg_dump will dump such a mapping, but with no
	 * OPTIONS clause.  A possible alternative is to skip such mappings
	 * altogether, but it's not clear that that's an improvement.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT usename, "</literal>
					  <literal type="string">"array_to_string(ARRAY("</literal>
					  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
					  <literal type="string">"quote_literal(option_value) "</literal>
					  <literal type="string">"FROM pg_options_to_table(umoptions) "</literal>
					  <literal type="string">"ORDER BY option_name"</literal>
					  <literal type="string">"), E',\n    ') AS umoptions "</literal>
					  <literal type="string">"FROM pg_user_mappings "</literal>
					  <literal type="string">"WHERE srvid = '%u' "</literal>
					  <literal type="string">"ORDER BY usename"</literal></expr></argument>,
					  <argument><expr><name><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_usename</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"usename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_umoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"umoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>usename</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>umoptions</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>usename</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_usename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>umoptions</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_umoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE USER MAPPING FOR %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>usename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" SERVER %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>umoptions</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>umoptions</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" OPTIONS (\n    %s\n)"</literal></expr></argument>, <argument><expr><name>umoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP USER MAPPING FOR %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>usename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">" SERVER %s;\n"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"USER MAPPING %s SERVER %s"</literal></expr></argument>,
						  <argument><expr><name>usename</name></expr></argument>, <argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name>namespace</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name>owner</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"USER MAPPING"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write out default privileges information
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpDefaultACL</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DefaultACLInfo</name> <modifier>*</modifier></type><name>daclinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump, or if we're skipping ACLs */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>aclsSkip</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>daclinfo</name><operator>-&gt;</operator><name>defaclobjtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DEFACLOBJ_RELATION</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"TABLES"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DEFACLOBJ_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"SEQUENCES"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DEFACLOBJ_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"FUNCTIONS"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DEFACLOBJ_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"TYPES"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DEFACLOBJ_NAMESPACE</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"SCHEMAS"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* shouldn't get here */</comment>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized object type in default privileges: %d"</literal></expr></argument>,
				  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>daclinfo</name><operator>-&gt;</operator><name>defaclobjtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT PRIVILEGES FOR %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build the actual command(s) for this tuple */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>buildDefaultACLCommands</name><argument_list>(<argument><expr><name>type</name></expr></argument>,
								 <argument><expr><ternary><condition><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then>
								 <expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
								 <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dacl</name><operator>.</operator><name>acl</name></name></expr></argument>,
								 <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dacl</name><operator>.</operator><name>acldefault</name></name></expr></argument>,
								 <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>defaclrole</name></name></expr></argument>,
								 <argument><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name></expr></argument>,
								 <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not parse default ACL list (%s)"</literal></expr></argument>,
			  <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dacl</name><operator>.</operator><name>acl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <ternary><condition><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr> ?</condition><then>
								  <expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>daclinfo</name><operator>-&gt;</operator><name>defaclrole</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"DEFAULT ACL"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------
 * Write out grant/revoke information
 *
 * 'objDumpId' is the dump ID of the underlying object.
 * 'altDumpId' can be a second dumpId that the ACL entry must also depend on,
 *		or InvalidDumpId if there is no need for a second dependency.
 * 'type' must be one of
 *		TABLE, SEQUENCE, FUNCTION, LANGUAGE, SCHEMA, DATABASE, TABLESPACE,
 *		FOREIGN DATA WRAPPER, SERVER, or LARGE OBJECT.
 * 'name' is the formatted name of the object.  Must be quoted etc. already.
 * 'subname' is the formatted name of the sub-object, if any.  Must be quoted.
 *		(Currently we assume that subname is only provided for table columns.)
 * 'nspname' is the namespace the object is in (NULL if none).
 * 'owner' is the owner, NULL if there is no owner (for languages).
 * 'dacl' is the DumpableAcl struct fpr the object.
 *
 * Returns the dump ID assigned to the ACL TocEntry, or InvalidDumpId if
 * no ACL entry was created.
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>DumpId</name></type>
<name>dumpACL</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>objDumpId</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>altDumpId</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>DumpableAcl</name> <modifier>*</modifier></type><name>dacl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpId</name></type>		<name>aclDumpId</name> <init>= <expr><name>InvalidDumpId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acls</name> <init>= <expr><name><name>dacl</name><operator>-&gt;</operator><name>acl</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acldefault</name> <init>= <expr><name><name>dacl</name><operator>-&gt;</operator><name>acldefault</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>privtype</name> <init>= <expr><name><name>dacl</name><operator>-&gt;</operator><name>privtype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initprivs</name> <init>= <expr><name><name>dacl</name><operator>-&gt;</operator><name>initprivs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>baseacls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>sql</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing if ACL dump is not enabled */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>aclsSkip</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidDumpId</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* --data-only skips ACLs *except* BLOB ACLs */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidDumpId</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In binary upgrade mode, we don't run an extension's script but instead
	 * dump out the objects independently and then recreate them.  To preserve
	 * any initial privileges which were set on extension objects, we need to
	 * compute the set of GRANT and REVOKE commands necessary to get from the
	 * default privileges of an object to its initial privileges as recorded
	 * in pg_init_privs.
	 *
	 * At restore time, we apply these commands after having called
	 * binary_upgrade_set_record_init_privs(true).  That tells the backend to
	 * copy the results into pg_init_privs.  This is how we preserve the
	 * contents of that catalog across binary upgrades.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator> <name>privtype</name> <operator>==</operator> <literal type="char">'e'</literal> <operator>&amp;&amp;</operator>
		<name>initprivs</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>initprivs</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>buildACLCommands</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
							  <argument><expr><name>initprivs</name></expr></argument>, <argument><expr><name>acldefault</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>,
							  <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not parse initial ACL list (%s) or default (%s) for object \"%s\" (%s)"</literal></expr></argument>,
				  <argument><expr><name>initprivs</name></expr></argument>, <argument><expr><name>acldefault</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now figure the GRANT and REVOKE commands needed to get to the object's
	 * actual current ACL, starting from the initprivs if given, else from the
	 * object-type-specific default.  Also, while buildACLCommands will assume
	 * that a NULL/empty acls string means it needn't do anything, what that
	 * actually represents is the object-type-specific default; so we need to
	 * substitute the acldefault string to get the right results in that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>initprivs</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>initprivs</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>baseacls</name> <operator>=</operator> <name>initprivs</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>acls</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>acls</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>acls</name> <operator>=</operator> <name>acldefault</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>baseacls</name> <operator>=</operator> <name>acldefault</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>buildACLCommands</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
						  <argument><expr><name>acls</name></expr></argument>, <argument><expr><name>baseacls</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>,
						  <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"could not parse ACL list (%s) or default (%s) for object \"%s\" (%s)"</literal></expr></argument>,
			  <argument><expr><name>acls</name></expr></argument>, <argument><expr><name>baseacls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sql</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DumpId</name></type>		<name><name>aclDeps</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nDeps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"COLUMN %s.%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>aclDeps</name><index>[<expr><name>nDeps</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>objDumpId</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>altDumpId</name> <operator>!=</operator> <name>InvalidDumpId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>aclDeps</name><index>[<expr><name>nDeps</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>altDumpId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclDumpId</name> <operator>=</operator> <call><name>createDumpId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><name>aclDumpId</name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name>nspname</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name>owner</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"ACL"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_NONE</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <name>aclDeps</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <name>nDeps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>aclDumpId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpSecLabel
 *
 * This routine is used to dump any security labels associated with the
 * object handed to this routine. The routine takes the object type
 * and object name (ready to print, except for schema decoration), plus
 * the namespace and owner of the object (for labeling the ArchiveEntry),
 * plus catalog ID and subid which are the lookup key for pg_seclabel,
 * plus the dump ID for the object (for setting a dependency).
 * If a matching pg_seclabel entry is found, it is dumped.
 *
 * Note: although this routine takes a dumpId for dependency purposes,
 * that purpose is just to mark the dependency in the emitted dump file
 * for possible future use by pg_restore.  We do NOT use it for determining
 * ordering of the label in the dump file, because this routine is called
 * after dependency sorting occurs.  This routine should be called just after
 * calling ArchiveEntry() for the specified object.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpSecLabel</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
			 <parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecLabelItem</name> <modifier>*</modifier></type><name>labels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nlabels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing, if --no-security-labels is supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_security_labels</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Security labels are schema not data ... except blob labels are data */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We do dump blob security labels in binary-upgrade mode */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>schemaOnly</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Search for security labels associated with catalogId, using table */</comment>
	<expr_stmt><expr><name>nlabels</name> <operator>=</operator> <call><name>findSecLabels</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>labels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlabels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Ignore label entries for which the subid doesn't match.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objsubid</name> <operator>!=</operator> <name>subid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SECURITY LABEL FOR %s ON %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>provider</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>namespace</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>namespace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s IS "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name>namespace</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name>owner</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"SECURITY LABEL"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_NONE</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><name>dumpId</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTableSecLabel
 *
 * As above, but dump security label for both the specified table (or view)
 * and its columns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTableSecLabel</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reltypename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecLabelItem</name> <modifier>*</modifier></type><name>labels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nlabels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>target</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing, if --no-security-labels is supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_security_labels</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* SecLabel are SCHEMA not data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Search for comments associated with relation, using table */</comment>
	<expr_stmt><expr><name>nlabels</name> <operator>=</operator> <call><name>findSecLabels</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
							<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name></expr></argument>,
							<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>labels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If security labels exist, build SECURITY LABEL statements */</comment>
	<if_stmt><if>if <condition>(<expr><name>nlabels</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlabels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>provider</name> <init>= <expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>provider</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>objsubid</name> <init>= <expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objsubid</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>objsubid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>getAttrName</name><argument_list>(<argument><expr><name>objsubid</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* first fmtXXX result must be consumed before calling again */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"COLUMN %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SECURITY LABEL FOR %s ON %s IS "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"SECURITY LABEL"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_NONE</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>,
								  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * findSecLabels
 *
 * Find the security label(s), if any, associated with the given object.
 * All the objsubid values associated with the given classoid/objoid are
 * found with one search.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>findSecLabels</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>, <parameter><decl><type><name>SecLabelItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SecLabelItem</name> <modifier>*</modifier></type><name>middle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecLabelItem</name> <modifier>*</modifier></type><name>low</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecLabelItem</name> <modifier>*</modifier></type><name>high</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmatch</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nseclabels</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>		<comment type="block">/* no labels, so no match is possible */</comment>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do binary search to find some item matching the object.
	 */</comment>
	<expr_stmt><expr><name>low</name> <operator>=</operator> <operator>&amp;</operator><name><name>seclabels</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>high</name> <operator>=</operator> <operator>&amp;</operator><name><name>seclabels</name><index>[<expr><name>nseclabels</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>middle</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>&lt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>&gt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>objoid</name> <operator>&lt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>objoid</name> <operator>&gt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>				<comment type="block">/* found a match */</comment>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>low</name> <operator>&gt;</operator> <name>high</name></expr>)</condition>				<comment type="block">/* no matches */</comment>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now determine how many items match the object.  The search loop
	 * invariant still holds: only items between low and high inclusive could
	 * match.
	 */</comment>
	<expr_stmt><expr><name>nmatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>middle</name> <operator>&gt;</operator> <name>low</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>!=</operator> <name><name>middle</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>classoid</name> <operator>||</operator>
			<name>objoid</name> <operator>!=</operator> <name><name>middle</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>objoid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>middle</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmatch</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>middle</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>middle</name> <operator>+=</operator> <name>nmatch</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>middle</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>!=</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name> <operator>||</operator>
			<name>objoid</name> <operator>!=</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>middle</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmatch</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>nmatch</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * collectSecLabels
 *
 * Construct a table of all security labels available for database objects;
 * also set the has-seclabel component flag for each relevant object.
 *
 * The table is sorted by classoid/objid/objsubid for speed in lookup.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>collectSecLabels</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_provider</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_classoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_objoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_objsubid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT label, provider, classoid, objoid, objsubid "</literal>
						 <literal type="string">"FROM pg_catalog.pg_seclabel "</literal>
						 <literal type="string">"ORDER BY classoid, objoid, objsubid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct lookup table containing OIDs in numeric form */</comment>
	<expr_stmt><expr><name>i_label</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_provider</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"provider"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_classoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"classoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objsubid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objsubid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seclabels</name> <operator>=</operator> <operator>(</operator><name>SecLabelItem</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SecLabelItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nseclabels</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>dobj</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>objId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>subid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_classoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objsubid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We needn't remember labels that don't match any dumpable object */</comment>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>dobj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>!=</operator> <name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>||</operator>
			<name><name>dobj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name><name>objId</name><operator>.</operator><name>oid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dobj</name> <operator>=</operator> <call><name>findObjectByCatalogId</name><argument_list>(<argument><expr><name>objId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Labels on columns of composite types are linked to the type's
		 * pg_class entry, but we need to set the DUMP_COMPONENT_SECLABEL flag
		 * in the type's own DumpableObject.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>subid</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>cTypeInfo</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>cTypeInfo</name> <operator>=</operator> <call><name>findTypeByOid</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name><operator>)</operator><operator>-&gt;</operator><name>reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cTypeInfo</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cTypeInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>components</name></name> <operator>|=</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>seclabels</name><index>[<expr><name>nseclabels</name></expr>]</index></name><operator>.</operator><name>label</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seclabels</name><index>[<expr><name>nseclabels</name></expr>]</index></name><operator>.</operator><name>provider</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_provider</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seclabels</name><index>[<expr><name>nseclabels</name></expr>]</index></name><operator>.</operator><name>classoid</name> <operator>=</operator> <name><name>objId</name><operator>.</operator><name>tableoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seclabels</name><index>[<expr><name>nseclabels</name></expr>]</index></name><operator>.</operator><name>objoid</name> <operator>=</operator> <name><name>objId</name><operator>.</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seclabels</name><index>[<expr><name>nseclabels</name></expr>]</index></name><operator>.</operator><name>objsubid</name> <operator>=</operator> <name>subid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nseclabels</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTable
 *	  write out to fout the declarations (not data) of a user-defined table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTable</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpId</name></type>		<name>tableAclDumpId</name> <init>= <expr><name>InvalidDumpId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>namecopy</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dumpSequence</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dumpTableSchema</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Handle the ACL here */</comment>
	<expr_stmt><expr><name>namecopy</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name> <init>=
		<expr><ternary><condition><expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"SEQUENCE"</literal></expr> </then><else>: <expr><literal type="string">"TABLE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>tableAclDumpId</name> <operator>=</operator>
			<call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>InvalidDumpId</name></expr></argument>,
					<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>namecopy</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Handle column ACLs, if any.  Note: we pull these with a separate query
	 * rather than trying to fetch them during getTableAttrs, so that we won't
	 * miss ACLs on system columns.  Doing it this way also allows us to dump
	 * ACLs for catalogs that we didn't mark "interesting" back in getTables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>hascolumnACLs</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_GETCOLUMNACLS</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Set up query for column ACLs */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"PREPARE getColumnACLs(pg_catalog.oid) AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * In principle we should call acldefault('c', relowner) to
				 * get the default ACL for a column.  However, we don't
				 * currently store the numeric OID of the relowner in
				 * TableInfo.  We could convert the owner name using regrole,
				 * but that creates a risk of failure due to concurrent role
				 * renames.  Given that the default ACL for columns is empty
				 * and is likely to stay that way, it's not worth extra cycles
				 * and risk to avoid hard-wiring that knowledge here.
				 */</comment>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
									 <argument><expr><literal type="string">"SELECT at.attname, "</literal>
									 <literal type="string">"at.attacl, "</literal>
									 <literal type="string">"'{}' AS acldefault, "</literal>
									 <literal type="string">"pip.privtype, pip.initprivs "</literal>
									 <literal type="string">"FROM pg_catalog.pg_attribute at "</literal>
									 <literal type="string">"LEFT JOIN pg_catalog.pg_init_privs pip ON "</literal>
									 <literal type="string">"(at.attrelid = pip.objoid "</literal>
									 <literal type="string">"AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass "</literal>
									 <literal type="string">"AND at.attnum = pip.objsubid) "</literal>
									 <literal type="string">"WHERE at.attrelid = $1 AND "</literal>
									 <literal type="string">"NOT at.attisdropped "</literal>
									 <literal type="string">"AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) "</literal>
									 <literal type="string">"ORDER BY at.attnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
									 <argument><expr><literal type="string">"SELECT attname, attacl, '{}' AS acldefault, "</literal>
									 <literal type="string">"NULL AS privtype, NULL AS initprivs "</literal>
									 <literal type="string">"FROM pg_catalog.pg_attribute "</literal>
									 <literal type="string">"WHERE attrelid = $1 AND NOT attisdropped "</literal>
									 <literal type="string">"AND attacl IS NOT NULL "</literal>
									 <literal type="string">"ORDER BY attnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>is_prepared</name><index>[<expr><name>PREPQUERY_GETCOLUMNACLS</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"EXECUTE getColumnACLs('%u')"</literal></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attacl</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>acldefault</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name>privtype</name> <init>= <expr><operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>initprivs</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DumpableAcl</name></type> <name>coldacl</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attnamecopy</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>coldacl</name><operator>.</operator><name>acl</name></name> <operator>=</operator> <name>attacl</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coldacl</name><operator>.</operator><name>acldefault</name></name> <operator>=</operator> <name>acldefault</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coldacl</name><operator>.</operator><name>privtype</name></name> <operator>=</operator> <name>privtype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coldacl</name><operator>.</operator><name>initprivs</name></name> <operator>=</operator> <name>initprivs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attnamecopy</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Column's GRANT type is always TABLE.  Each column ACL depends
			 * on the table-level ACL, since we can restore column ACLs in
			 * parallel but the table-level ACL has to be done first.
			 */</comment>
			<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>tableAclDumpId</name></expr></argument>,
					<argument><expr><literal type="string">"TABLE"</literal></expr></argument>, <argument><expr><name>namecopy</name></expr></argument>, <argument><expr><name>attnamecopy</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>coldacl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>attnamecopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>namecopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpExternal</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
		<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>urilocations</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>execlocations</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>location</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fmttype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fmtopts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rejlim</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rejlimtype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>extencoding</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>writable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmpstring</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> 	   <modifier>*</modifier></type><name>tabfmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>customfmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isweb</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>iswritable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>logerrors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>on_clause</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualrelname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>qualrelname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * DROP must be fully qualified in case same name appears in
		 * pg_catalog
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP EXTERNAL TABLE %s."</literal></expr></argument>,
						  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now get required information from pg_exttable */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <name>GPDB6_MAJOR_PGVERSION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					<argument><expr><literal type="string">"SELECT x.urilocation, x.execlocation, x.fmttype, x.fmtopts, x.command, "</literal>
						   <literal type="string">"x.rejectlimit, x.rejectlimittype, "</literal>
						   <literal type="string">"CASE WHEN x.logerrors='f' THEN null ELSE x.logerrors::text END AS logerrors, "</literal>
						   <literal type="string">"pg_catalog.pg_encoding_to_char(x.encoding), "</literal>
						   <literal type="string">"x.writable, "</literal>
						   <literal type="string">"array_to_string(ARRAY( "</literal>
						   <literal type="string">"SELECT pg_catalog.quote_ident(option_name) || ' ' || "</literal>
						   <literal type="string">"pg_catalog.quote_literal(option_value) "</literal>
						   <literal type="string">"FROM pg_options_to_table(x.options) "</literal>
						   <literal type="string">"ORDER BY option_name"</literal>
						   <literal type="string">"), E',\n    ') AS options "</literal>
					<literal type="string">"FROM pg_catalog.pg_exttable x, pg_catalog.pg_class c "</literal>
					<literal type="string">"WHERE x.reloid = c.oid AND c.oid = '%u'::oid "</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					<argument><expr><literal type="string">"SELECT x.urilocation, x.execlocation, x.fmttype, x.fmtopts, x.command, "</literal>
						   <literal type="string">"x.rejectlimit, x.rejectlimittype, "</literal>
						   <literal type="string">"x.fmterrtbl AS logerrors, "</literal>
						   <literal type="string">"pg_catalog.pg_encoding_to_char(x.encoding), "</literal>
						   <literal type="string">"x.writable, "</literal>
						   <literal type="string">"array_to_string(ARRAY( "</literal>
						   <literal type="string">"SELECT pg_catalog.quote_ident(option_name) || ' ' || "</literal>
						   <literal type="string">"pg_catalog.quote_literal(option_value) "</literal>
						   <literal type="string">"FROM pg_options_to_table(x.options) "</literal>
						   <literal type="string">"ORDER BY option_name"</literal>
						   <literal type="string">"), E',\n    ') AS options "</literal>
					<literal type="string">"FROM pg_catalog.pg_exttable x, pg_catalog.pg_class c "</literal>
					<literal type="string">"WHERE x.reloid = c.oid AND c.oid = '%u'::oid "</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"query to obtain definition of external table \"%s\" returned no data"</literal></expr></argument>,
							   <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"query to obtain definition of external table \"%s\" returned more than one definition"</literal></expr></argument>,
							   <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></if></if_stmt>


		<expr_stmt><expr><name>urilocations</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>execlocations</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmtopts</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rejlim</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rejlimtype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>logerrors</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>extencoding</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>writable</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>on_clause</name> <operator>=</operator> <name>execlocations</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>command</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>urilocations</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"http"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"http"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>isweb</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>writable</name> <operator>&amp;&amp;</operator> <name><name>writable</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>iswritable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE %sEXTERNAL %sTABLE %s ("</literal></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>iswritable</name></expr> ?</condition><then> <expr><literal type="string">"WRITABLE "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>isweb</name></expr> ?</condition><then> <expr><literal type="string">"WEB "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>actual_atts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Is the attribute not dropped? */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>shouldPrintColumn</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Format properly if not first attr */</comment>
				<if_stmt><if>if <condition>(<expr><name>actual_atts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Attribute name */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Attribute type */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * ALTER TABLE DROP COLUMN clears
					 * pg_attribute.atttypid, so we will not have gotten a
					 * valid type name; insert INTEGER as a stopgap. We'll
					 * clean things up later.
					*/</comment>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" INTEGER /* dummy */"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>actual_atts</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>command</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* add EXECUTE clause */</comment>
			<expr_stmt><expr><name>tmpstring</name> <operator>=</operator> <call><name>escape_backslashes</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" EXECUTE E'%s' "</literal></expr></argument>, <argument><expr><name>tmpstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmpstring</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* add LOCATION clause, remove '{"' and '"}' */</comment>
			<expr_stmt><expr><name><name>urilocations</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>urilocations</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>urilocations</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* the URI of custom protocol will contains \"\" and need to be removed */</comment>

			<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>nextToken</name><argument_list>(<argument><expr><operator>&amp;</operator><name>urilocations</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>location</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\"'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>location</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>location</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" LOCATION (\n    '%s'"</literal></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>location</name> <operator>=</operator> <call><name>nextToken</name><argument_list>(<argument><expr><operator>&amp;</operator><name>urilocations</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>;</condition><incr/>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>location</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\"'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>location</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>location</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    '%s'"</literal></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n) "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Add ON clause (unless WRITABLE table, which doesn't allow ON).
		 * ON clauses were up until 5.0 supported only on EXECUTE, in 5.0
		 * and thereafter they are allowed on all external tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iswritable</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* remove curly braces */</comment>
			<expr_stmt><expr><name><name>on_clause</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>on_clause</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"HOST:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"HOST:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ON HOST '%s' "</literal></expr></argument>, <argument><expr><name>on_clause</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"HOST:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"PER_HOST"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"PER_HOST"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ON HOST "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"MASTER_ONLY"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"MASTER_ONLY"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ON COORDINATOR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ON COORDINATOR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ON SEGMENT %s "</literal></expr></argument>, <argument><expr><name>on_clause</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ON %s "</literal></expr></argument>, <argument><expr><name>on_clause</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"ALL_SEGMENTS"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"ALL_SEGMENTS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ON ALL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"illegal ON clause catalog information \"%s\" for command '%s' on table \"%s\""</literal></expr></argument>,
							   <argument><expr><name>on_clause</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* add FORMAT clause */</comment>
		<expr_stmt><expr><name>tmpstring</name> <operator>=</operator> <call><name>escape_fmtopts_string</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>fmtopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>fmttype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<expr_stmt><expr><name>tabfmt</name> <operator>=</operator> <literal type="string">"text"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
				<comment type="block">/*
				 * b denotes that a custom format is used.
				 * the fmtopts string should be formatted as:
				 * a1 = 'val1',...,an = 'valn'
				 *
				 */</comment>
				<expr_stmt><expr><name>tabfmt</name> <operator>=</operator> <literal type="string">"custom"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>customfmt</name> <operator>=</operator> <call><name>custom_fmtopts_string</name><argument_list>(<argument><expr><name>tmpstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'a'</literal></expr>:</case>
				<expr_stmt><expr><name>tabfmt</name> <operator>=</operator> <literal type="string">"avro"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>customfmt</name> <operator>=</operator> <call><name>custom_fmtopts_string</name><argument_list>(<argument><expr><name>tmpstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<expr_stmt><expr><name>tabfmt</name> <operator>=</operator> <literal type="string">"parquet"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>customfmt</name> <operator>=</operator> <call><name>custom_fmtopts_string</name><argument_list>(<argument><expr><name>tmpstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>tabfmt</name> <operator>=</operator> <literal type="string">"csv"</literal></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"FORMAT '%s' (%s)\n"</literal></expr></argument>,
						  <argument><expr><name>tabfmt</name></expr></argument>,
						  <argument><expr><ternary><condition><expr><name>customfmt</name></expr> ?</condition><then> <expr><name>customfmt</name></expr> </then><else>: <expr><name>tmpstring</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>tmpstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>customfmt</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>customfmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>customfmt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;&amp;</operator> <name><name>options</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"OPTIONS (\n %s\n )\n"</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* add ENCODING clause */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ENCODING '%s'"</literal></expr></argument>, <argument><expr><name>extencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* add Single Row Error Handling clause (if any) */</comment>
		<if_stmt><if>if <condition>(<expr><name>rejlim</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>rejlim</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
				* Error tables were removed and replaced with file error
				* logging.
				*/</comment>
			<if_stmt><if>if <condition>(<expr><name>logerrors</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>logerrors</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"LOG ERRORS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>logerrors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>logerrors</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"PERSISTENTLY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* reject limit */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SEGMENT REJECT LIMIT %s"</literal></expr></argument>, <argument><expr><name>rejlim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* reject limit type */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rejlimtype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ROWS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" PERCENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* DISTRIBUTED BY clause (if WRITABLE table) */</comment>
		<if_stmt><if>if <condition>(<expr><name>iswritable</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addDistributedBy</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>actual_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create the AS clause for a view or materialized view. The semicolon is
 * stripped because a materialized view must add a WITH NO DATA clause.
 *
 * This returns a new buffer which must be freed by the caller.
 */</comment>
<function><type><specifier>static</specifier> <name>PQExpBuffer</name></type>
<name>createViewAsClause</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch the view definition */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.pg_get_viewdef('%u'::pg_catalog.oid) AS viewdef"</literal></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"query to obtain definition of view \"%s\" returned no data"</literal></expr></argument>,
				  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"query to obtain definition of view \"%s\" returned more than one definition"</literal></expr></argument>,
				  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>PQgetlength</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"definition of view \"%s\" appears to be empty (length zero)"</literal></expr></argument>,
			  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Strip off the trailing semicolon so that other things may follow. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a dummy AS clause for a view.  This is used when the real view
 * definition has to be postponed because of circular dependencies.
 * We must duplicate the view's external properties -- column names and types
 * (including collation) -- so that it works for subsequent references.
 *
 * This returns a new buffer which must be freed by the caller.
 */</comment>
<function><type><specifier>static</specifier> <name>PQExpBuffer</name></type>
<name>createDummyViewAsClause</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"NULL::%s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Must add collation if not default for the type, because CREATE OR
		 * REPLACE VIEW won't change it
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>coll</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>findCollationByOid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>coll</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
								  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">" AS %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTableSchema
 *	  write the declaration (not data) of one user-defined table or view
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTableSchema</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qrelname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualrelname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>parents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>actual_atts</name></decl>;</decl_stmt>	<comment type="block">/* number of attrs in this CREATE statement */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reltypename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>storage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasExternalPartitions</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ftoptions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srvname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


	<comment type="block">/* We had better have loaded per-column details about this table */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>interesting</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qrelname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualrelname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>hasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"WITH OIDS is not supported anymore (table \"%s\")"</literal></expr></argument>,
					   <argument><expr><name>qrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_rel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, 	<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Is it a table or a view? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note: keep this code in sync with the is_view case in dumpRule()
		 */</comment>

		<expr_stmt><expr><name>reltypename</name> <operator>=</operator> <literal type="string">"VIEW"</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP VIEW %s;\n"</literal></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
											 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE VIEW %s"</literal></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dummy_view</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createDummyViewAsClause</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" WITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendReloptionsArrayAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createViewAsClause</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" AS\n%s"</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>checkoption</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dummy_view</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n  WITH %s CHECK OPTION"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>checkoption</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>i_srvname</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>i_ftoptions</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>reltypename</name> <operator>=</operator> <literal type="string">"FOREIGN TABLE"</literal></expr>;</expr_stmt>

					<comment type="block">/* retrieve name of foreign server and generic options */</comment>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
									  <argument><expr><literal type="string">"SELECT fs.srvname, "</literal>
									  <literal type="string">"pg_catalog.array_to_string(ARRAY("</literal>
									  <literal type="string">"SELECT pg_catalog.quote_ident(option_name) || "</literal>
									  <literal type="string">"' ' || pg_catalog.quote_literal(option_value) "</literal>
									  <literal type="string">"FROM pg_catalog.pg_options_to_table(ftoptions) "</literal>
									  <literal type="string">"ORDER BY option_name"</literal>
									  <literal type="string">"), E',\n    ') AS ftoptions "</literal>
									  <literal type="string">"FROM pg_catalog.pg_foreign_table ft "</literal>
									  <literal type="string">"JOIN pg_catalog.pg_foreign_server fs "</literal>
									  <literal type="string">"ON (fs.oid = ft.ftserver) "</literal>
									  <literal type="string">"WHERE ft.ftrelid = '%u'"</literal></expr></argument>,
									  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>i_srvname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>i_ftoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ftoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>srvname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_srvname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ftoptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_ftoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
				<expr_stmt><expr><name>reltypename</name> <operator>=</operator> <literal type="string">"MATERIALIZED VIEW"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>reltypename</name> <operator>=</operator> <literal type="string">"TABLE"</literal></expr>;</expr_stmt>

				<comment type="block">/* Is it an external table (server GPDB 6.x and below.) */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relstorage</name></name> <operator>==</operator> <name>RELSTORAGE_EXTERNAL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>reltypename</name> <operator>=</operator> <literal type="string">"EXTERNAL TABLE"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>reltypename</name></expr></argument>, <argument><expr><literal type="string">"EXTERNAL TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dumpExternal</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>reltypename</name></expr></argument>, <argument><expr><literal type="string">"VIEW"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* handled above already */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>numParents</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numParents</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parents</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>parents</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP %s %s;\n"</literal></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
											 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If this is a partition hierarchy parent, dump the Oid
			 * preassignments for each partition member individually.
			 *
			 * GPDB_12_MERGE_FIXME: Disabled when dumping GPDB 7. But do
			 * we need it when dumping older versions, either? The presumed
			 * *target* is the current latest version anyway.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>parparent</name></name> <operator>&amp;&amp;</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PQExpBuffer</name></type> 	<name>partquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PGresult</name>	   <modifier>*</modifier></type><name>partres</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>partquery</name></expr></argument>, <argument><expr><literal type="string">"SELECT DISTINCT(child.oid) "</literal>
											 <literal type="string">"FROM pg_catalog.pg_partition part, "</literal>
											 <literal type="string">"     pg_catalog.pg_partition_rule rule, "</literal>
											 <literal type="string">"     pg_catalog.pg_class child "</literal>
											 <literal type="string">"WHERE part.parrelid = '%u'::pg_catalog.oid "</literal>
											 <literal type="string">"  AND rule.paroid = part.oid "</literal>
											 <literal type="string">"  AND child.oid = rule.parchildrelid"</literal></expr></argument>,
											 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>partres</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>partquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* It really should..  */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>partres</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>partres</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type> <name>part_oid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>partres</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><call><name>findTableByOid</name><argument_list>(<argument><expr><name>part_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relstorage</name></name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>hasExternalPartitions</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>part_oid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_rel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>partres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>partquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE %s%s %s"</literal></expr></argument>,
						  <argument><expr><ternary><condition><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr> ?</condition><then>
						  <expr><literal type="string">"UNLOGGED "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name>reltypename</name></expr></argument>,
						  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Attach to type, if reloftype; except in case of a binary upgrade,
		 * we dump the table normally and attach it to the type afterward.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" OF %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Dump the attributes */</comment>
			<expr_stmt><expr><name>actual_atts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/*
				 * Normally, dump if it's locally defined in this table, and
				 * not dropped.  But for binary upgrade, we'll dump all the
				 * columns, and then fix up the dropped and nonlocal cases
				 * below.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>shouldPrintColumn</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>print_default</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>print_notnull</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Default value --- suppress if to be printed separately.
					 */</comment>
					<expr_stmt><expr><name>print_default</name> <operator>=</operator> <operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
									 <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>separate</name><operator>)</operator></expr>;</expr_stmt>

					<comment type="block">/*
					 * Not Null constraint --- suppress if inherited, except
					 * if partition, or in binary-upgrade case where that
					 * won't work.
					 */</comment>
					<expr_stmt><expr><name>print_notnull</name> <operator>=</operator> <operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>notnull</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator>
									 <operator>(</operator><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>inhNotNull</name><index>[<expr><name>j</name></expr>]</index></name> <operator>||</operator>
									  <name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

					<comment type="block">/*
					 * Skip column if fully defined by reloftype, except in
					 * binary upgrade
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>print_default</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>print_notnull</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<comment type="block">/* Format properly if not first attr */</comment>
					<if_stmt><if>if <condition>(<expr><name>actual_atts</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>actual_atts</name><operator>++</operator></expr>;</expr_stmt>

					<comment type="block">/* Attribute name */</comment>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * ALTER TABLE DROP COLUMN clears
						 * pg_attribute.atttypid, so we will not have gotten a
						 * valid type name; insert INTEGER as a stopgap. We'll
						 * clean things up later.
						 */</comment>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" INTEGER /* dummy */"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* and skip to the next column */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Attribute type; print it except when creating a typed
					 * table ('OF type_name'), but in binary-upgrade mode,
					 * print it in that case too.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
										  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>print_default</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attgenerated</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" GENERATED ALWAYS AS (%s) STORED"</literal></expr></argument>,
											  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>adef_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT %s"</literal></expr></argument>,
											  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>adef_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>


					<if_stmt><if>if <condition>(<expr><name>print_notnull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Add collation if not default for the type */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>coll</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>findCollationByOid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>coll</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
											  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Add non-inherited CHECK constraints, if any.
			 *
			 * For partitions, we need to include check constraints even if
			 * they're not defined locally, because the ALTER TABLE ATTACH
			 * PARTITION that we'll emit later expects the constraint to be
			 * there.  (No need to fix conislocal: ATTACH PARTITION does that)
			 */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>checkexprs</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>separate</name></name> <operator>||</operator>
					<operator>(</operator><operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>actual_atts</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" (\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>actual_atts</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Add AOCO ENCODING directives, if any.
			 *
			 * We dump these as separate "COLUMN &lt;col&gt; ENCODING ..." clauses,
			 * instead of tacking the ENCODING at the column definition, so
			 * that this works for inherited columns, too. Inherited columns
			 * are not listed in the column list.
			 */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attencoding</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>actual_atts</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" (\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"COLUMN %s ENCODING (%s)"</literal></expr></argument>,
									  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attencoding</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>actual_atts</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>actual_atts</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * No attributes? we must have a parenthesized attribute list,
				 * even though empty, when not using the OF TYPE syntax.
				 */</comment>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" (\n)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Emit the INHERITS clause (not for partitions), except in
			 * binary-upgrade mode.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>numParents</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nINHERITS ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numParents</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parentRel</name> <init>= <expr><name><name>parents</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nPARTITION BY %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>partkeydef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nSERVER %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>srvname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>actual_atts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_reloptions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>addcomma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nWITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>addcomma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendReloptionsArrayAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_reloptions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>addcomma</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendReloptionsArrayAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_reloptions</name></name></expr></argument>, <argument><expr><literal type="string">"toast."</literal></expr></argument>,
										<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>


		<comment type="block">/*
		 * For materialized views, create the AS clause just like a view. At
		 * this point, we always mark the view as not populated.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createViewAsClause</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" AS\n%s\n  WITH NO DATA"</literal></expr></argument>,
							  <argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* START MPP ADDITION */</comment>

		<comment type="block">/*
		 * Dump distributed by clause.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dumpGpPolicy</name></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addDistributedBy</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>actual_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Add the GPDB partitioning constraints to the table definition.
		 * These do not exist on GPDB7, so first check if we are dumping
		 * from &lt;= GPDB6.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <name>GPDB7_MAJOR_PGVERSION</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>*</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>partclause</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>partclause</name></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* partition by clause */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>partclause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* subpartition template */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>parttemplate</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>parttemplate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt> <comment type="block">/* END MPP ADDITION */</comment>

		<comment type="block">/* Dump generic options if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>ftoptions</name> <operator>&amp;&amp;</operator> <name><name>ftoptions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nOPTIONS (\n    %s\n)"</literal></expr></argument>, <argument><expr><name>ftoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dumpGpPolicy</name></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>srvname</name></expr></argument>, <argument><expr><name>GP_EXTTABLE_SERVER_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addDistributedBy</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>actual_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Exchange external partitions. This is an expensive process, so only
		 * run it if we've found evidence of external partitions up above.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hasExternalPartitions</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>ntups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i_relname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i_parname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i_partitionrank</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * The multiple JOINs below trigger an apparent planner bug which
			 * may effectively hang the backend. This bug is present in both
			 * released versions of GPDB and the current development tip at time
			 * of writing. Disable nestloops temporarily as a workaround.
			 *
			 * TODO: when this bug is fixed, version-gate this code so that we
			 * don't run it on well-behaved backends.
			 */</comment>
			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SET enable_nestloop TO off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT DISTINCT cc.relname, ps.partitionrank, pp.parname "</literal>
					<literal type="string">"FROM pg_partition p "</literal>
					<literal type="string">"JOIN pg_class c on (p.parrelid = c.oid) "</literal>
					<literal type="string">"JOIN pg_partitions ps on (c.relname = ps.tablename) "</literal>
					<literal type="string">"JOIN pg_class cc on (ps.partitiontablename = cc.relname) "</literal>
					<literal type="string">"JOIN pg_partition_rule pp on (cc.oid = pp.parchildrelid) "</literal>
					<literal type="string">"WHERE p.parrelid = %u AND (cc.relstorage='%c' OR cc.relkind = '%c');"</literal></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
					<argument><expr><name>RELSTORAGE_EXTERNAL</name></expr></argument>, <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i_relname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i_parname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"parname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i_partitionrank</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"partitionrank"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* FIXME: does this code handle external SUBPARTITIONs correctly? */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type> <name><name>tmpExtTable</name><index>[<expr><literal type="number">500</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpExtTable</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmpExtTable</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>EXT_PARTITION_NAME_POSTFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualTmpExtTable</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
																 <argument><expr><name>tmpExtTable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s "</literal></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				 * If it is an anonymous range partition we must exchange for
				 * the rank rather than the parname.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_parname</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strlen</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_parname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"EXCHANGE PARTITION FOR (RANK(%s)) "</literal></expr></argument>,
									  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_partitionrank</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"EXCHANGE PARTITION %s "</literal></expr></argument>,
									  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_parname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"WITH TABLE %s WITHOUT VALIDATION; "</literal></expr></argument>, <argument><expr><name>qualTmpExtTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"DROP TABLE %s; "</literal></expr></argument>, <argument><expr><name>qualTmpExtTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualTmpExtTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* TODO: version-gate this when the planner bug is fixed; see above. */</comment>
			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SET enable_nestloop TO on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Materialized views can depend on extensions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>append_depends_on_extension</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"pg_catalog.pg_class"</literal></expr></argument>,
										<argument><expr><ternary><condition><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr> ?</condition><then>
										<expr><literal type="string">"MATERIALIZED VIEW"</literal></expr> </then><else>: <expr><literal type="string">"INDEX"</literal></expr></else></ternary></expr></argument>,
										<argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * in binary upgrade mode, update the catalog with any missing values
		 * that might be present.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attmissingval</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- set missing value.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
										 <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_missing_value("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attmissingval</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">");\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * To create binary-compatible heap files, we have to ensure the same
		 * physical column order, including dropped columns, as in the
		 * original.  Therefore, we create dropped columns above and drop them
		 * here, also updating their attlen/attalign values so that the
		 * dropped column can be skipped properly.  (We do not bother with
		 * restoring the original attbyval setting.)  Also, inheritance
		 * relationships are set up by doing ALTER TABLE INHERIT rather than
		 * using an INHERITS clause --- the latter would possibly mess up the
		 * column order.  That also means we have to take care about setting
		 * attislocal correctly, plus fix up any inherited CHECK constraints.
		 * Analogously, we set up typed tables using ALTER TABLE / OF here.
		 *
		 * We process foreign and partitioned tables here, even though they
		 * lack heap storage, because they can participate in inheritance
		 * relationships and we want this stuff to be consistent across the
		 * inheritance tree.  We can exclude indexes, toast tables, sequences
		 * and matviews, even though they have storage, because we don't
		 * support altering or dropping columns in them, nor can they be part
		 * of inheritance trees.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
			 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Greenplum doesn't allow altering system catalogs without
			 * setting the allow_system_table_mods GUC first.
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET allow_system_table_mods = true;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, recreate dropped column.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_attribute\n"</literal>
									  <literal type="string">"SET attlen = %d, "</literal>
									  <literal type="string">"attalign = '%c', attbyval = false\n"</literal>
									  <literal type="string">"WHERE attname = "</literal></expr></argument>,
									  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attlen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attalign</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* GPDB partitioning */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <name>GPDB7_MAJOR_PGVERSION</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Do for all descendants of a partition table.
						 * No hurt if this is not a table with partitions.
						 */</comment>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n  AND attrelid IN (SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UNION SELECT pr.parchildrelid FROM "</literal>
										  <literal type="string">"pg_catalog.pg_partition_rule pr, "</literal>
										  <literal type="string">"pg_catalog.pg_partition p WHERE "</literal>
										  <literal type="string">"pr.parchildrelid != 0 AND "</literal>
										  <literal type="string">"pr.paroid = p.oid AND p.parrelid = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n  AND attrelid = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * GPDB: Upstream uses ALTER TABLE ONLY below. Because we
					 * need to cascade the DROP down into partitions as well,
					 * we use ALTER TABLE instead.
					 *
					 * At the moment, we believe this does not cause problems
					 * for vanilla inherited tables, because the tables aren't
					 * plugged into the inheritance hierarchy until after this
					 * code is run (see the ALTER TABLE ... INHERIT below), and
					 * therefore ALTER TABLE and ALTER TABLE ONLY are
					 * effectively the same. If that changes, this will need to
					 * be revisited.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s "</literal></expr></argument>,
										  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
										  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER FOREIGN TABLE ONLY %s "</literal></expr></argument>,
										  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"DROP COLUMN %s;\n"</literal></expr></argument>,
									  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>attislocal</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, recreate inherited column.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_attribute\n"</literal>
										 <literal type="string">"SET attislocal = false\n"</literal>
										 <literal type="string">"WHERE attname = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n  AND attrelid = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Add inherited CHECK constraints, if any.
			 *
			 * For partitions, they were already dumped, and conislocal
			 * doesn't need fixing.
			 */</comment>
			<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>checkexprs</name><index>[<expr><name>k</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>separate</name></name> <operator>||</operator> <name><name>constr</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>||</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set up inherited constraint.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ADD CONSTRAINT %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_constraint\n"</literal>
									 <literal type="string">"SET conislocal = false\n"</literal>
									 <literal type="string">"WHERE contype = 'c' AND conname = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n  AND conrelid = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>numParents</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set up inheritance this way.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numParents</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parentRel</name> <init>= <expr><name><name>parents</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s INHERIT %s;\n"</literal></expr></argument>,
									  <argument><expr><name>qualrelname</name></expr></argument>,
									  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set up typed tables this way.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s OF %s;\n"</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"RESET allow_system_table_mods;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In binary_upgrade mode, arrange to restore the old relfrozenxid and
		 * relminmxid of all vacuumable relations.  (While vacuum.c processes
		 * TOAST tables semi-independently, here we see them only as children
		 * of other relations; so this "if" lacks RELKIND_TOASTVALUE, and the
		 * child toast table is handled below.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET allow_system_table_mods = true;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set heap's relfrozenxid and relminmxid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_class\n"</literal>
							  <literal type="string">"SET relfrozenxid = '%u', relminmxid = '%u'\n"</literal>
							  <literal type="string">"WHERE oid = "</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>frozenxid</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>minmxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_oid</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The toast table will have the same OID at restore, so we
				 * can safely target it by OID.
				 */</comment>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set toast's relfrozenxid and relminmxid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_class\n"</literal>
								  <literal type="string">"SET relfrozenxid = '%u', relminmxid = '%u'\n"</literal>
								  <literal type="string">"WHERE oid = '%u';\n"</literal></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_frozenxid</name></name></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_minmxid</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We have probably bumped allow_system_table_mods to true in the
			 * above processing, but even we didn't let's just reset it here
			 * since it doesn't to do any harm to.
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"RESET allow_system_table_mods;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In binary_upgrade mode, restore matviews' populated status by
		 * poking pg_class directly.  This is pretty ugly, but we can't use
		 * REFRESH MATERIALIZED VIEW since it's possible that some underlying
		 * matview is not populated even though this matview is; in any case,
		 * we want to transfer the matview's heap storage, not run REFRESH.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
			<name><name>tbinfo</name><operator>-&gt;</operator><name>relispopulated</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET allow_system_table_mods = true;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, mark materialized view as populated\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_class\n"</literal>
								 <literal type="string">"SET relispopulated = 't'\n"</literal>
								 <literal type="string">"WHERE oid = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"RESET allow_system_table_mods;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Dump additional per-column properties that we can't handle in the
		 * main CREATE TABLE command.
		 */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* None of this applies to dropped columns */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If we didn't dump the column definition explicitly above, and
			 * it is NOT NULL and did not inherit that property from a parent,
			 * we have to mark it separately.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>shouldPrintColumn</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>tbinfo</name><operator>-&gt;</operator><name>notnull</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>inhNotNull</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s SET NOT NULL;\n"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Dump per-column statistics information. We only issue an ALTER
			 * TABLE statement if the attstattarget entry for this column is
			 * non-negative (i.e. it's not the default value)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstattarget</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET STATISTICS %d;\n"</literal></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstattarget</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Dump per-column storage information.  The statement is only
			 * dumped if the storage has been changed from the type's default.
			 * An inherited column can have
			 * its storage type changed independently from the parent
			 * specification.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstorage</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>typstorage</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<switch>switch <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstorage</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="char">'p'</literal></expr>:</case>
						<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="string">"PLAIN"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'e'</literal></expr>:</case>
						<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="string">"EXTERNAL"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'m'</literal></expr>:</case>
						<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="string">"MAIN"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'x'</literal></expr>:</case>
						<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="string">"EXTENDED"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><name>storage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></switch>

				<comment type="block">/*
				 * Only dump the statement if it's a storage type we recognize
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>storage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
									  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
									  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET STORAGE %s;\n"</literal></expr></argument>,
									  <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Dump per-column attributes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attoptions</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET (%s);\n"</literal></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attoptions</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Dump per-column fdw options.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
				<name><name>tbinfo</name><operator>-&gt;</operator><name>attfdwoptions</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER FOREIGN TABLE %s "</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"OPTIONS (\n    %s\n);\n"</literal></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attfdwoptions</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>ftoptions</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ftoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>srvname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>srvname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * dump properties we only have ALTER TABLE syntax for
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
		 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>tbinfo</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>!=</operator> <name>REPLICA_IDENTITY_DEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* nothing to do, will be set when the index is dumped */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_NOTHING</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE ONLY %s REPLICA IDENTITY NOTHING;\n"</literal></expr></argument>,
							  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE ONLY %s REPLICA IDENTITY FULL;\n"</literal></expr></argument>,
							  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>forcerowsec</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE ONLY %s FORCE ROW LEVEL SECURITY;\n"</literal></expr></argument>,
						  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><name>reltypename</name></expr></argument>, <argument><expr><name>qrelname</name></expr></argument>,
										<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tableam</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			<name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tableam</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>amname</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>tablespace</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name><operator>)</operator></expr> ?</condition><then>
								  <expr><name>NULL</name></expr> </then><else>: <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></else></ternary></expr></argument>,
								  <argument><expr><operator>.</operator><name>tableam</name> <operator>=</operator> <name>tableam</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <name>reltypename</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <ternary><condition><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>postponed_def</name></name></expr> ?</condition><then>
								  <expr><name>SECTION_POST_DATA</name></expr> </then><else>: <expr><name>SECTION_PRE_DATA</name></expr></else></ternary></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Dump Table Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpTableComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Table Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpTableSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump comments on inlined table constraints */</comment>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>checkexprs</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>separate</name></name> <operator>||</operator> <operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>conislocal</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dumpTableConstraintComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTableAttach
 *	  write to fout the commands to attach a child partition
 *
 * Child partitions are always made by creating them separately
 * and then using ATTACH PARTITION, rather than using
 * CREATE TABLE ... PARTITION OF.  This is important for preserving
 * any possible discrepancy in column layout, to allow assigning the
 * correct tablespace if different, and so that it's possible to restore
 * a partition without restoring its parent.  (You'll get an error from
 * the ATTACH PARTITION command, but that can be ignored, or skipped
 * using "pg_restore -L" if you prefer.)  The last point motivates
 * treating ATTACH PARTITION as a completely separate ArchiveEntry
 * rather than emitting it within the child partition's ArchiveEntry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTableAttach</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableAttachInfo</name> <modifier>*</modifier></type><name>attachinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>attachinfo</name><operator>-&gt;</operator><name>partitionTbl</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform ALTER TABLE on the parent */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
					  <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>parentTbl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
					  <argument><expr><literal type="string">"ATTACH PARTITION %s %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>partitionTbl</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>partitionTbl</name><operator>-&gt;</operator><name>partbound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There is no point in creating a drop query as the drop is done by table
	 * drop.  (If you think to change this, see also _printTocEntry().)
	 * Although this object doesn't really have ownership as such, set the
	 * owner field anyway to ensure that the command is run by the correct
	 * role at restore time.
	 */</comment>
	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
				 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>attachinfo</name><operator>-&gt;</operator><name>partitionTbl</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
							  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TABLE ATTACH"</literal></expr></argument>,
							  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
							  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpAttrDef --- dump an attribute's default-value declaration
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpAttrDef</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttrDefInfo</name> <modifier>*</modifier></type><name>adinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>adinfo</name><operator>-&gt;</operator><name>adtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>adnum</name> <init>= <expr><name><name>adinfo</name><operator>-&gt;</operator><name>adnum</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualrelname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Skip if not "separate"; it was dumped in the table's definition */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>adinfo</name><operator>-&gt;</operator><name>separate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qualrelname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * GPDB: Upstream uses ALTER TABLE ONLY below. If the table
	 * is the parent of a GPDB partitioning hierarchy, the default
	 * constraint must cascade to all children as well. Because of
	 * this, we use ALTER TABLE instead when acting on a partition
	 * parent.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s%s "</literal></expr></argument>,
					  <argument><expr><ternary><condition><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>parparent</name></name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s SET DEFAULT %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name><name>adinfo</name><operator>-&gt;</operator><name>adef_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s "</literal></expr></argument>,
					  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s DROP DEFAULT;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>adinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>adinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>adinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>tag</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"DEFAULT"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getAttrName: extract the correct name for an attribute
 *
 * The array tblInfo-&gt;attnames[] only provides names of user attributes;
 * if a system attribute number is supplied, we have to fake it.
 * We also do a little bit of bounds checking for safety's sake.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getAttrName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>attrnum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tblInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>attrnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attrnum</name> <operator>&lt;=</operator> <name><name>tblInfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>tblInfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>attrnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><name>attrnum</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SelfItemPointerAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"ctid"</literal></expr>;</return>
		<case>case <expr><name>MinTransactionIdAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"xmin"</literal></expr>;</return>
		<case>case <expr><name>MinCommandIdAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"cmin"</literal></expr>;</return>
		<case>case <expr><name>MaxTransactionIdAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"xmax"</literal></expr>;</return>
		<case>case <expr><name>MaxCommandIdAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"cmax"</literal></expr>;</return>
		<case>case <expr><name>TableOidAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"tableoid"</literal></expr>;</return>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"invalid column number %d for table \"%s\""</literal></expr></argument>,
		  <argument><expr><name>attrnum</name></expr></argument>, <argument><expr><name><name>tblInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * dumpIndex
 *	  write out to fout a user-defined index
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpIndex</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndxInfo</name> <modifier>*</modifier></type><name>indxinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indextable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_constraint</name> <init>= <expr><operator>(</operator><name><name>indxinfo</name><operator>-&gt;</operator><name>indexconstraint</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qindxname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qqindxname</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qindxname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qqindxname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>indxinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there's an associated constraint, don't dump the index per se, but
	 * do dump any comment for it.  (This is safe because dependency ordering
	 * will have ensured the constraint is emitted first.)	Note that the
	 * emitted comment has to be shown as depending on the constraint, not the
	 * index, in such cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_constraint</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indstatcols</name> <init>= <expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indstatcols</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indstatvals</name> <init>= <expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indstatvals</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>indstatcolsarray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>indstatvalsarray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nstatcols</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nstatvals</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Plain secondary index */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indexdef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Append ALTER TABLE commands as needed to set properties that we
		 * only have ALTER TABLE syntax for.  Keep this in sync with the
		 * similar code in dumpConstraint!
		 */</comment>

		<comment type="block">/* If the index is clustered, we need to record that. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE %s CLUSTER"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* index name is not qualified in this syntax */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ON %s;\n"</literal></expr></argument>,
							  <argument><expr><name>qindxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the index has any statistics on some of its columns, generate
		 * the associated ALTER INDEX queries.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>parsePGArray</name><argument_list>(<argument><expr><name>indstatcols</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indstatcolsarray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nstatcols</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>parsePGArray</name><argument_list>(<argument><expr><name>indstatvals</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indstatvalsarray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nstatvals</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>nstatcols</name> <operator>==</operator> <name>nstatvals</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nstatcols</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER INDEX %s "</literal></expr></argument>, <argument><expr><name>qqindxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Note that this is a column number, so no quotes should be
				 * used.
				 */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
								  <argument><expr><name><name>indstatcolsarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET STATISTICS %s;\n"</literal></expr></argument>,
								  <argument><expr><name><name>indstatvalsarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Indexes can depend on extensions */</comment>
		<expr_stmt><expr><call><name>append_depends_on_extension</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
									<argument><expr><literal type="string">"pg_catalog.pg_class"</literal></expr></argument>,
									<argument><expr><literal type="string">"INDEX"</literal></expr></argument>, <argument><expr><name>qqindxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If the index defines identity, we need to record that. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE ONLY %s REPLICA IDENTITY USING"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* index name is not qualified in this syntax */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" INDEX %s;\n"</literal></expr></argument>,
							  <argument><expr><name>qindxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP INDEX %s;\n"</literal></expr></argument>, <argument><expr><name>qqindxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
						 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>tablespace</name> <operator>=</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"INDEX"</literal></expr></argument>,
									  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>indstatcolsarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>indstatcolsarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>indstatvalsarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>indstatvalsarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Dump Index Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"INDEX"</literal></expr></argument>, <argument><expr><name>qindxname</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><name>is_constraint</name></expr> ?</condition><then> <expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indexconstraint</name></name></expr> </then><else>:
					<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qindxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qqindxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpIndexAttach
 *	  write out to fout a partitioned-index attachment clause
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpIndexAttach</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexAttachInfo</name> <modifier>*</modifier></type><name>attachinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attachinfo</name><operator>-&gt;</operator><name>partitionIdx</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER INDEX %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>parentIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ATTACH PARTITION %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>partitionIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * There is no point in creating a drop query as the drop is done by
		 * index drop.  (If you think to change this, see also
		 * _printTocEntry().)  Although this object doesn't really have
		 * ownership as such, set the owner field anyway to ensure that the
		 * command is run by the correct role at restore time.
		 */</comment>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>attachinfo</name><operator>-&gt;</operator><name>parentIdx</name><operator>-&gt;</operator><name>indextable</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"INDEX ATTACH"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpStatisticsExt
 *	  write out to fout an extended statistics object
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpStatisticsExt</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StatsExtInfo</name> <modifier>*</modifier></type><name>statsextinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qstatsextname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>stxdef</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qstatsextname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
					  <literal type="string">"pg_catalog.pg_get_statisticsobjdef('%u'::pg_catalog.oid)"</literal></expr></argument>,
					  <argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>stxdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Result of pg_get_statisticsobjdef is complete except for semicolon */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name>stxdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP STATISTICS %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>statsextinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>,
					 <argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>statsextinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"STATISTICS"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Statistics Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"STATISTICS"</literal></expr></argument>, <argument><expr><name>qstatsextname</name></expr></argument>,
					<argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					<argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qstatsextname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpConstraint
 *	  write out to fout a user-defined constraint
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpConstraint</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConstraintInfo</name> <modifier>*</modifier></type><name>coninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>coninfo</name><operator>-&gt;</operator><name>contable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'p'</literal> <operator>||</operator>
		<name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'u'</literal> <operator>||</operator>
		<name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Index-related constraint */</comment>
		<decl_stmt><decl><type><name>IndxInfo</name>   <modifier>*</modifier></type><name>indxinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indxinfo</name> <operator>=</operator> <operator>(</operator><name>IndxInfo</name> <operator>*</operator><operator>)</operator> <call><name>findObjectByDumpId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>conindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>indxinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"missing index for constraint \"%s\""</literal></expr></argument>,
				  <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    ADD CONSTRAINT %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>condef</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* pg_get_constraintdef should have provided everything */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s ("</literal></expr></argument>,
							  <argument><expr><ternary><condition><expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'p'</literal></expr> ?</condition><then> <expr><literal type="string">"PRIMARY KEY"</literal></expr> </then><else>: <expr><literal type="string">"UNIQUE"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indnkeyattrs</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>indkey</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indkeys</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>indkey</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>getAttrName</name><argument_list>(<argument><expr><name>indkey</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>k</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indnkeyattrs</name></name> <operator>&lt;</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indnattrs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">") INCLUDE ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indnkeyattrs</name></name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indnattrs</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>indkey</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indkeys</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>indkey</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>getAttrName</name><argument_list>(<argument><expr><name>indkey</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
								  <argument><expr><ternary><condition><expr><operator>(</operator><name>k</name> <operator>==</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indnkeyattrs</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indreloptions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" WITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendReloptionsArrayAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indreloptions</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>condeferrable</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" DEFERRABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>condeferred</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" INITIALLY DEFERRED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Append ALTER TABLE commands as needed to set properties that we
		 * only have ALTER TABLE syntax for.  Keep this in sync with the
		 * similar code in dumpIndex!
		 */</comment>

		<comment type="block">/* If the index is clustered, we need to record that. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE %s CLUSTER"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* index name is not qualified in this syntax */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ON %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If the index defines identity, we need to record that. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE ONLY %s REPLICA IDENTITY USING"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* index name is not qualified in this syntax */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" INDEX %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Indexes can depend on extensions */</comment>
		<expr_stmt><expr><call><name>append_depends_on_extension</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
									<argument><expr><literal type="string">"pg_catalog.pg_class"</literal></expr></argument>, <argument><expr><literal type="string">"INDEX"</literal></expr></argument>,
									<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>indxinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP CONSTRAINT %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
						 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>tag</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>tablespace</name> <operator>=</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"CONSTRAINT"</literal></expr></argument>,
									  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>only</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Foreign keys on partitioned tables are always declared as
		 * inheriting to partitions; for all other cases, emit them as
		 * applying ONLY directly to the named table, because that's how they
		 * work for regular inherited tables.
		 */</comment>
		<expr_stmt><expr><name>only</name> <operator>=</operator> <ternary><condition><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/*
		 * XXX Potentially wrap in a 'SET CONSTRAINTS OFF' block so that the
		 * current table data is not processed
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s%s\n"</literal></expr></argument>,
						  <argument><expr><name>only</name></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    ADD CONSTRAINT %s %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s%s "</literal></expr></argument>,
						  <argument><expr><name>only</name></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP CONSTRAINT %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
						 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>tag</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"FK CONSTRAINT"</literal></expr></argument>,
									  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
									  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <name>tbinfo</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* CHECK constraint on a table */</comment>

		<comment type="block">/* Ignore if not to be dumped separately, or if it was inherited */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>separate</name></name> <operator>&amp;&amp;</operator> <name><name>coninfo</name><operator>-&gt;</operator><name>conislocal</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* not ONLY since we want it to propagate to children */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    ADD CONSTRAINT %s %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s "</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP CONSTRAINT %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
							 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>tag</name></expr></argument>,
										  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
										  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
										  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"CHECK CONSTRAINT"</literal></expr></argument>,
										  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
										  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
										  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <name>tbinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* CHECK constraint on a domain */</comment>
		<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>tyinfo</name> <init>= <expr><name><name>coninfo</name><operator>-&gt;</operator><name>condomain</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore if not to be dumped separately */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>separate</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER DOMAIN %s\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    ADD CONSTRAINT %s %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER DOMAIN %s "</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP CONSTRAINT %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
							 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>tag</name></expr></argument>,
										  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
										  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
										  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"CHECK CONSTRAINT"</literal></expr></argument>,
										  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
										  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
										  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized constraint type: %c"</literal></expr></argument>,
			  <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Dump Constraint Comments --- only works for table constraints */</comment>
	<if_stmt><if>if <condition>(<expr><name>tbinfo</name> <operator>&amp;&amp;</operator> <name><name>coninfo</name><operator>-&gt;</operator><name>separate</name></name> <operator>&amp;&amp;</operator>
		<name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpTableConstraintComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>coninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTableConstraintComment --- dump a constraint's comment if any
 *
 * This is split out because we need the function in two different places
 * depending on whether the constraint is dumped as part of CREATE TABLE
 * or as a separate ALTER command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTableConstraintComment</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConstraintInfo</name> <modifier>*</modifier></type><name>coninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>coninfo</name><operator>-&gt;</operator><name>contable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>conprefix</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtabname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qtabname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>conprefix</name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT %s ON"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>conprefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>qtabname</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><name><name>coninfo</name><operator>-&gt;</operator><name>separate</name></name></expr> ?</condition><then> <expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr> </then><else>: <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>conprefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtabname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpSequence
 *	  write the declaration (not data) of one user-defined sequence
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpSequence</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>startv</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>incby</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>maxv</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>minv</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>cache</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>seqtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cycled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_ascending</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>default_minv</name></decl>,
				<decl><type ref="prev"/><name>default_maxv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>bufm</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>bufx</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qseqname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qseqname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT format_type(seqtypid, NULL), "</literal>
						  <literal type="string">"seqstart, seqincrement, "</literal>
						  <literal type="string">"seqmax, seqmin, "</literal>
						  <literal type="string">"seqcache, seqcycle "</literal>
						  <literal type="string">"FROM pg_catalog.pg_sequence "</literal>
						  <literal type="string">"WHERE seqrelid = '%u'::oid"</literal></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Before PostgreSQL 10, sequence metadata is in the sequence itself.
		 *
		 * Note: it might seem that 'bigint' potentially needs to be
		 * schema-qualified, but actually that's a keyword.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT 'bigint' AS sequence_type, "</literal>
						  <literal type="string">"start_value, increment_by, max_value, min_value, "</literal>
						  <literal type="string">"cache_value, is_cycled FROM %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT 'bigint' AS sequence_type, "</literal>
						  <literal type="string">"0 AS start_value, increment_by, max_value, min_value, "</literal>
						  <literal type="string">"cache_value, is_cycled FROM %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"query to get data of sequence \"%s\" returned %d row (expected 1)"</literal></expr></argument>,
							  <argument><expr><literal type="string">"query to get data of sequence \"%s\" returned %d rows (expected 1)"</literal></expr></argument>,
							  <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>seqtype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>startv</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>incby</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxv</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minv</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cycled</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Calculate default limits for a sequence of this type */</comment>
	<expr_stmt><expr><name>is_ascending</name> <operator>=</operator> <operator>(</operator><name><name>incby</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>seqtype</name></expr></argument>, <argument><expr><literal type="string">"smallint"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>default_minv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>PG_INT16_MIN</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_maxv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><name>PG_INT16_MAX</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>seqtype</name></expr></argument>, <argument><expr><literal type="string">"integer"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>default_minv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>PG_INT32_MIN</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_maxv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><name>PG_INT32_MAX</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>seqtype</name></expr></argument>, <argument><expr><literal type="string">"bigint"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>default_minv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>PG_INT64_MIN</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_maxv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><name>PG_INT64_MAX</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"unrecognized sequence type: %s"</literal></expr></argument>, <argument><expr><name>seqtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_minv</name> <operator>=</operator> <name>default_maxv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * 64-bit strtol() isn't very portable, so convert the limits to strings
	 * and compare that way.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufm</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>default_minv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>default_maxv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't print minv/maxv if they match the respective default limit */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>minv</name></expr></argument>, <argument><expr><name>bufm</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>minv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>maxv</name></expr></argument>, <argument><expr><name>bufx</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Identity sequences are not to be dropped separately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>is_identity_sequence</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP SEQUENCE %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
										 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_rel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
												<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>is_identity_sequence</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>owning_tab</name> <init>= <expr><call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"ALTER TABLE %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>owning_tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"ALTER COLUMN %s ADD GENERATED "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>owning_tab</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_col</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>owning_tab</name><operator>-&gt;</operator><name>attidentity</name><index>[<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_col</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_ALWAYS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ALWAYS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>owning_tab</name><operator>-&gt;</operator><name>attidentity</name><index>[<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_col</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_BY_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"BY DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" AS IDENTITY (\n    SEQUENCE NAME %s\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"CREATE SEQUENCE %s\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>seqtype</name></expr></argument>, <argument><expr><literal type="string">"bigint"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    AS %s\n"</literal></expr></argument>, <argument><expr><name>seqtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    START WITH %s\n"</literal></expr></argument>, <argument><expr><name>startv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    INCREMENT BY %s\n"</literal></expr></argument>, <argument><expr><name>incby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>minv</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    MINVALUE %s\n"</literal></expr></argument>, <argument><expr><name>minv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    NO MINVALUE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>maxv</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    MAXVALUE %s\n"</literal></expr></argument>, <argument><expr><name>maxv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    NO MAXVALUE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"    CACHE %s%s"</literal></expr></argument>,
					  <argument><expr><name>cache</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>cycled</name></expr> ?</condition><then> <expr><literal type="string">"\n    CYCLE"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>is_identity_sequence</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\n);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* binary_upgrade:	no need to clear TOAST table oid */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>, <argument><expr><name>qseqname</name></expr></argument>,
										<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"SEQUENCE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the sequence is owned by a table column, emit the ALTER for it as a
	 * separate TOC entry immediately following the sequence's own entry. It's
	 * OK to do this rather than using full sorting logic, because the
	 * dependency that tells us it's owned will have forced the table to be
	 * created first.  We can't just include the ALTER in the TOC entry
	 * because it will fail if we haven't reassigned the sequence owner to
	 * match the table's owner.
	 *
	 * We need not schema-qualify the table reference because both sequence
	 * and table must be in the same schema.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>is_identity_sequence</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>owning_tab</name> <init>= <expr><call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>owning_tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"failed sanity check, parent table with OID %u of sequence with OID %u not found"</literal></expr></argument>,
				  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>owning_tab</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ALTER SEQUENCE %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" OWNED BY %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>owning_tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">".%s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>owning_tab</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_col</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
							 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
										  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
										  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
										  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"SEQUENCE OWNED BY"</literal></expr></argument>,
										  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_PRE_DATA</name></expr></argument>,
										  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
										  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>,
										  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Dump Sequence Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>, <argument><expr><name>qseqname</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>, <argument><expr><name>qseqname</name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qseqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpSequenceData
 *	  write the data of one user-defined sequence
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpSequenceData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>called</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT last_value, is_called FROM %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"query to get data of sequence \"%s\" returned %d row (expected 1)"</literal></expr></argument>,
							  <argument><expr><literal type="string">"query to get data of sequence \"%s\" returned %d rows (expected 1)"</literal></expr></argument>,
							  <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>called</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.setval("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", %s, %s);\n"</literal></expr></argument>,
					  <argument><expr><name>last</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>called</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DATA</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"SEQUENCE SET"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>deps</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>,
								  <argument><expr><operator>.</operator><name>nDeps</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTrigger
 *	  write the declaration of one user-defined table trigger
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTrigger</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TriggerInfo</name> <modifier>*</modifier></type><name>tginfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>trigprefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>trigidentity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtabname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tgargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>lentgargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>findx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>trigprefix</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>trigidentity</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qtabname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>trigidentity</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>trigidentity</name></expr></argument>, <argument><expr><literal type="string">"ON %s"</literal></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP TRIGGER %s;\n"</literal></expr></argument>, <argument><expr><name><name>trigidentity</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgdef</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgdef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgisconstraint</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE CONSTRAINT TRIGGER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgconstrname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE TRIGGER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Trigger type */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_BEFORE</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"BEFORE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FOR_AFTER</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"AFTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FOR_INSTEAD</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"INSTEAD OF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"unexpected tgtype value: %d"</literal></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>findx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_INSERT</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_DELETE</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>findx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" OR DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>findx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" OR UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_TRUNCATE</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>findx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" OR TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" ON %s\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgisconstraint</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgconstrrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* regclass output is already quoted */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    FROM %s\n    "</literal></expr></argument>,
								  <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgconstrrelname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tginfo</name><operator>-&gt;</operator><name>tgdeferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"NOT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"DEFERRABLE INITIALLY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tginitdeferred</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"DEFERRED\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"IMMEDIATE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    FOR EACH ROW\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    FOR EACH STATEMENT\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* regproc output is already sufficiently quoted */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"EXECUTE FUNCTION %s("</literal></expr></argument>,
						  <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgfname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tgargs</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>PQunescapeBytea</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>tginfo</name><operator>-&gt;</operator><name>tgargs</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>lentgargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>tgargs</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>findx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>findx</name> <operator>&lt;</operator> <name><name>tginfo</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>findx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* find the embedded null that terminates this trigger argument */</comment>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>tlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <name>tlen</name> <operator>&gt;=</operator> <name>tgargs</name> <operator>+</operator> <name>lentgargs</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* hm, not found before end of bytea value... */</comment>
				<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"invalid argument string (%s) for trigger \"%s\" on table \"%s\""</literal></expr></argument>,
							 <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgargs</name></name></expr></argument>,
							 <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>findx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>tlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tgargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Triggers can depend on extensions */</comment>
	<expr_stmt><expr><call><name>append_depends_on_extension</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
								<argument><expr><literal type="string">"pg_catalog.pg_trigger"</literal></expr></argument>, <argument><expr><literal type="string">"TRIGGER"</literal></expr></argument>,
								<argument><expr><name><name>trigidentity</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>!=</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name><name>tginfo</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>!=</operator> <literal type="char">'O'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgenabled</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"DISABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE ALWAYS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE REPLICA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" TRIGGER %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>trigprefix</name></expr></argument>, <argument><expr><literal type="string">"TRIGGER %s ON"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>tag</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"TRIGGER"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>trigprefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>qtabname</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>trigprefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>trigidentity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtabname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpEventTrigger
 *	  write the declaration of one user-defined event trigger
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpEventTrigger</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>EventTriggerInfo</name> <modifier>*</modifier></type><name>evtinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qevtname</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qevtname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE EVENT TRIGGER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>qevtname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" ON "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evtevent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evttags</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\n         WHEN TAG IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evttags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\n   EXECUTE FUNCTION "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evtfname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"();\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evtenabled</name></name> <operator>!=</operator> <literal type="char">'O'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\nALTER EVENT TRIGGER %s "</literal></expr></argument>,
						  <argument><expr><name>qevtname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evtenabled</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"DISABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE ALWAYS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE REPLICA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP EVENT TRIGGER %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qevtname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"EVENT TRIGGER"</literal></expr></argument>, <argument><expr><name>qevtname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>evtinfo</name><operator>-&gt;</operator><name>evtowner</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"EVENT TRIGGER"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"EVENT TRIGGER"</literal></expr></argument>, <argument><expr><name>qevtname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evtowner</name></name></expr></argument>,
					<argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qevtname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpRule
 *		Dump a rule
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpRule</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RuleInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>ruletable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_view</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>ruleprefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtabname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing in data-only dump */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it is an ON SELECT rule that is created implicitly by CREATE VIEW,
	 * we do not want to dump it as a separate object.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>separate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's an ON SELECT rule, we want to print it as a view definition,
	 * instead of a rule.
	 */</comment>
	<expr_stmt><expr><name>is_view</name> <operator>=</operator> <operator>(</operator><name><name>rinfo</name><operator>-&gt;</operator><name>ev_type</name></name> <operator>==</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>is_instead</name></name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delcmd</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ruleprefix</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qtabname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_view</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We need OR REPLACE here because we'll be replacing a dummy view.
		 * Otherwise this should look largely like the regular view dump code.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE VIEW %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" WITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendReloptionsArrayAH</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createViewAsClause</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" AS\n%s"</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>checkoption</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"\n  WITH %s CHECK OPTION"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>checkoption</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* In the rule case, just print pg_get_ruledef's result verbatim */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.pg_get_ruledef('%u'::pg_catalog.oid)"</literal></expr></argument>,
						  <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_error</name><argument_list>(<argument><expr><literal type="string">"query to get rule \"%s\" for table \"%s\" failed: wrong number of rows returned"</literal></expr></argument>,
						 <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Add the command to alter the rules replication firing semantics if it
	 * differs from the default.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>ev_enabled</name></name> <operator>!=</operator> <literal type="char">'O'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s "</literal></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>ev_enabled</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"ENABLE ALWAYS RULE %s;\n"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"ENABLE REPLICA RULE %s;\n"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"DISABLE RULE %s;\n"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_view</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can't DROP a view's ON SELECT rule.  Instead, use CREATE OR
		 * REPLACE VIEW to replace the rule with something with minimal
		 * dependencies.
		 */</comment>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delcmd</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE VIEW %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createDummyViewAsClause</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delcmd</name></expr></argument>, <argument><expr><literal type="string">" AS\n%s;\n"</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delcmd</name></expr></argument>, <argument><expr><literal type="string">"DROP RULE %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delcmd</name></expr></argument>, <argument><expr><literal type="string">"ON %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>ruleprefix</name></expr></argument>, <argument><expr><literal type="string">"RULE %s ON"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><call><name>ARCHIVE_OPTS</name><argument_list>(<argument><expr><operator>.</operator><name>tag</name> <operator>=</operator> <name>tag</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>namespace</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>owner</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>description</name> <operator>=</operator> <literal type="string">"RULE"</literal></expr></argument>,
								  <argument><expr><operator>.</operator><name>section</name> <operator>=</operator> <name>SECTION_POST_DATA</name></expr></argument>,
								  <argument><expr><operator>.</operator><name>createStmt</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								  <argument><expr><operator>.</operator><name>dropStmt</name> <operator>=</operator> <name><name>delcmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump rule comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>ruleprefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>qtabname</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>ruleprefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtabname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getExtensionMembership --- obtain extension membership data
 *
 * We need to identify objects that are extension members as soon as they're
 * loaded, so that we can correctly determine whether they need to be dumped.
 * Generally speaking, extension member objects will get marked as *not* to
 * be dumped, as they will be recreated by the single CREATE EXTENSION
 * command.  However, in binary upgrade mode we still need to dump the members
 * individually.
 */</comment>
<function><type><name>void</name></type>
<name>getExtensionMembership</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ExtensionInfo</name></type> <name><name>extinfo</name><index>[]</index></name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>numExtensions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_classid</name></decl>,
				<decl><type ref="prev"/><name>i_objid</name></decl>,
				<decl><type ref="prev"/><name>i_refobjid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>ext</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if no extensions */</comment>
	<if_stmt><if>if <condition>(<expr><name>numExtensions</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* refclassid constraint is redundant but may speed the search */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
						 <literal type="string">"classid, objid, refobjid "</literal>
						 <literal type="string">"FROM pg_depend "</literal>
						 <literal type="string">"WHERE refclassid = 'pg_extension'::regclass "</literal>
						 <literal type="string">"AND deptype = 'e' "</literal>
						 <literal type="string">"ORDER BY 3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_classid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"classid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_refobjid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"refobjid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we ordered the SELECT by referenced ID, we can expect that
	 * multiple entries for the same extension will appear together; this
	 * saves on searches.
	 */</comment>
	<expr_stmt><expr><name>ext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>objId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>extId</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>extId</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_refobjid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ext</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>ext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name>extId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ext</name> <operator>=</operator> <call><name>findExtensionByOid</name><argument_list>(<argument><expr><name>extId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"could not find referenced extension %u"</literal></expr></argument>, <argument><expr><name>extId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>recordExtensionMembership</name><argument_list>(<argument><expr><name>objId</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * processExtensionTables --- deal with extension configuration tables
 *
 * There are two parts to this process:
 *
 * 1. Identify and create dump records for extension configuration tables.
 *
 *	  Extensions can mark tables as "configuration", which means that the user
 *	  is able and expected to modify those tables after the extension has been
 *	  loaded.  For these tables, we dump out only the data- the structure is
 *	  expected to be handled at CREATE EXTENSION time, including any indexes or
 *	  foreign keys, which brings us to-
 *
 * 2. Record FK dependencies between configuration tables.
 *
 *	  Due to the FKs being created at CREATE EXTENSION time and therefore before
 *	  the data is loaded, we have to work out what the best order for reloading
 *	  the data is, to avoid FK violations when the tables are restored.  This is
 *	  not perfect- we can't handle circular dependencies and if any exist they
 *	  will cause an invalid dump to be produced (though at least all of the data
 *	  is included for a user to manually restore).  This is currently documented
 *	  but perhaps we can provide a better solution in the future.
 */</comment>
<function><type><name>void</name></type>
<name>processExtensionTables</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ExtensionInfo</name></type> <name><name>extinfo</name><index>[]</index></name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>numExtensions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_conrelid</name></decl>,
				<decl><type ref="prev"/><name>i_confrelid</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if no extensions */</comment>
	<if_stmt><if>if <condition>(<expr><name>numExtensions</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Identify extension configuration tables and create TableDataInfo
	 * objects for them, ensuring their data will be dumped even though the
	 * tables themselves won't be.
	 *
	 * Note that we create TableDataInfo objects even in schemaOnly mode, ie,
	 * user data in a configuration table is treated like schema data. This
	 * seems appropriate since system data in a config table would get
	 * reloaded by CREATE EXTENSION.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numExtensions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>curext</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>extconfig</name> <init>= <expr><name><name>curext</name><operator>-&gt;</operator><name>extconfig</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>extcondition</name> <init>= <expr><name><name>curext</name><operator>-&gt;</operator><name>extcondition</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>extconfigarray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>extconditionarray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nconfigitems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nconditionitems</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>parsePGArray</name><argument_list>(<argument><expr><name>extconfig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extconfigarray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nconfigitems</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>parsePGArray</name><argument_list>(<argument><expr><name>extcondition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extconditionarray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nconditionitems</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>nconfigitems</name> <operator>==</operator> <name>nconditionitems</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nconfigitems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>configtbl</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>configtbloid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><name><name>extconfigarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>dumpobj</name> <init>=
				<expr><name><name>curext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>configtbl</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>configtbloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>configtbl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Tables of not-to-be-dumped extensions shouldn't be dumped
				 * unless the table or its schema is explicitly included
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>curext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* check table explicitly requested */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>table_include_oids</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_include_oids</name></expr></argument>,
											   <argument><expr><name>configtbloid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>dumpobj</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* check table's schema explicitly requested */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>configtbl</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator>
						<name>DUMP_COMPONENT_DATA</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>dumpobj</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* check table excluded by an exclusion switch */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>table_exclude_oids</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_exclude_oids</name></expr></argument>,
										   <argument><expr><name>configtbloid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>dumpobj</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* check schema excluded by an exclusion switch */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema_exclude_oids</name></expr></argument>,
										   <argument><expr><name><name>configtbl</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>dumpobj</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>dumpobj</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>makeTableDataInfo</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><name>configtbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>configtbl</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>extconditionarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>configtbl</name><operator>-&gt;</operator><name>dataObj</name><operator>-&gt;</operator><name>filtercond</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>extconditionarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>extconfigarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>extconfigarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>extconditionarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>extconditionarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now that all the TableInfoData objects have been created for all the
	 * extensions, check their FK dependencies and register them to try and
	 * dump the data out in an order that they can be restored in.
	 *
	 * Note that this is not a problem for user tables as their FKs are
	 * recreated after the data has been loaded.
	 */</comment>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT conrelid, confrelid "</literal>
					  <literal type="string">"FROM pg_constraint "</literal>
					  <literal type="string">"JOIN pg_depend ON (objid = confrelid) "</literal>
					  <literal type="string">"WHERE contype = 'f' "</literal>
					  <literal type="string">"AND refclassid = 'pg_extension'::regclass "</literal>
					  <literal type="string">"AND classid = 'pg_class'::regclass;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_conrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_confrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"confrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now get the dependencies and register them */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>conrelid</name></decl>,
					<decl><type ref="prev"/><name>confrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>reftable</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>contable</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>conrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>confrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_confrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>contable</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>conrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reftable</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>confrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>reftable</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>reftable</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name>contable</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>contable</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Make referencing TABLE_DATA object depend on the referenced table's
		 * TABLE_DATA object.
		 */</comment>
		<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>contable</name><operator>-&gt;</operator><name>dataObj</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
							<argument><expr><name><name>reftable</name><operator>-&gt;</operator><name>dataObj</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setExtPartDependency -
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setExtPartDependency</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>parrelid</name> <init>= <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>parrelid</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>parrelid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>parrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>parent</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"parent table (OID %u) of partition \"%s\" (OID %u) not found"</literal></expr></argument>,
						   <argument><expr><name>parrelid</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * getDependencies --- obtain available dependency data
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_classid</name></decl>,
				<decl><type ref="prev"/><name>i_objid</name></decl>,
				<decl><type ref="prev"/><name>i_refclassid</name></decl>,
				<decl><type ref="prev"/><name>i_refobjid</name></decl>,
				<decl><type ref="prev"/><name>i_deptype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>refdobj</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_log_info</name><argument_list>(<argument><expr><literal type="string">"reading dependency data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Messy query to collect the dependency data we need.  Note that we
	 * ignore the sub-object column, so that dependencies of or on a column
	 * look the same as dependencies of or on a whole table.
	 *
	 * PIN dependencies aren't interesting, and EXTENSION dependencies were
	 * already processed by getExtensionMembership.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
						 <literal type="string">"classid, objid, refclassid, refobjid, deptype "</literal>
						 <literal type="string">"FROM pg_depend "</literal>
						 <literal type="string">"WHERE deptype != 'p' AND deptype != 'e'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we don't treat pg_amop entries as separate DumpableObjects, we
	 * have to translate their dependencies into dependencies of their parent
	 * opfamily.  Ignore internal dependencies though, as those will point to
	 * their parent opclass, which we needn't consider here (and if we did,
	 * it'd just result in circular dependencies).  Also, "loose" opfamily
	 * entries will have dependencies on their parent opfamily, which we
	 * should drop since they'd likewise become useless self-dependencies.
	 * (But be sure to keep deps on *other* opfamilies; see amopsortfamily.)
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"UNION ALL\n"</literal>
						 <literal type="string">"SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype "</literal>
						 <literal type="string">"FROM pg_depend d, pg_amop o "</literal>
						 <literal type="string">"WHERE deptype NOT IN ('p', 'e', 'i') AND "</literal>
						 <literal type="string">"classid = 'pg_amop'::regclass AND objid = o.oid "</literal>
						 <literal type="string">"AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Likewise for pg_amproc entries */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"UNION ALL\n"</literal>
						 <literal type="string">"SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype "</literal>
						 <literal type="string">"FROM pg_depend d, pg_amproc p "</literal>
						 <literal type="string">"WHERE deptype NOT IN ('p', 'e', 'i') AND "</literal>
						 <literal type="string">"classid = 'pg_amproc'::regclass AND objid = p.oid "</literal>
						 <literal type="string">"AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort the output for efficiency below */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY 1,2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_classid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"classid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_refclassid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"refclassid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_refobjid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"refobjid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_deptype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"deptype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we ordered the SELECT by referencing ID, we can expect that
	 * multiple entries for the same object will appear together; this saves
	 * on searches.
	 */</comment>
	<expr_stmt><expr><name>dobj</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>objId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>refobjId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>deptype</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refobjId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_refclassid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refobjId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_refobjid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>deptype</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_deptype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>dobj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>!=</operator> <name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>||</operator>
			<name><name>dobj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name><name>objId</name><operator>.</operator><name>oid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dobj</name> <operator>=</operator> <call><name>findObjectByCatalogId</name><argument_list>(<argument><expr><name>objId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Failure to find objects mentioned in pg_depend is not unexpected,
		 * since for example we don't collect info about TOAST tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"no referencing object %u %u"</literal></expr></argument>,
						   <argument><expr><name><name>objId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>objId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>refdobj</name> <operator>=</operator> <call><name>findObjectByCatalogId</name><argument_list>(<argument><expr><name>refobjId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>refdobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
			<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"no referenced object %u %u"</literal></expr></argument>,
						   <argument><expr><name><name>refobjId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>refobjId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For 'x' dependencies, mark the object for later; we still add the
		 * normal dependency, for possible ordering purposes.  Currently
		 * pg_dump_sort.c knows to put extensions ahead of all object types
		 * that could possibly depend on them, but this is safer.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>deptype</name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>depends_on_ext</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ordinarily, table rowtypes have implicit dependencies on their
		 * tables.  However, for a composite type the implicit dependency goes
		 * the other way in pg_depend; which is the right thing for DROP but
		 * it doesn't produce the dependency ordering we need. So in that one
		 * case, we reverse the direction of the dependency.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>deptype</name> <operator>==</operator> <literal type="char">'i'</literal> <operator>&amp;&amp;</operator>
			<name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
			<name><name>refdobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>refdobj</name></expr></argument>, <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="block">/* normal case */</comment>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>refdobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * createBoundaryObjects - create dummy DumpableObjects to represent
 * dump section boundaries.
 */</comment>
<function><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier></type>
<name>createBoundaryObjects</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobjs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dobjs</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>objType</name> <operator>=</operator> <name>DO_PRE_DATA_BOUNDARY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>catId</name> <operator>=</operator> <name>nilCatalogId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><name>dobjs</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"PRE-DATA BOUNDARY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>objType</name> <operator>=</operator> <name>DO_POST_DATA_BOUNDARY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>catId</name> <operator>=</operator> <name>nilCatalogId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><name>dobjs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"POST-DATA BOUNDARY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dobjs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * addBoundaryDependencies - add dependencies as needed to enforce the dump
 * section boundaries.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addBoundaryDependencies</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>dobjs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>,
						<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>boundaryObjs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>preDataBound</name> <init>= <expr><name>boundaryObjs</name> <operator>+</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>postDataBound</name> <init>= <expr><name>boundaryObjs</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numObjs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name> <init>= <expr><name><name>dobjs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The classification of object types here must match the SECTION_xxx
		 * values assigned during subsequent ArchiveEntry calls!
		 */</comment>
		<switch>switch <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DO_NAMESPACE</name></expr>:</case>
			<case>case <expr><name>DO_EXTENSION</name></expr>:</case>
			<case>case <expr><name>DO_TYPE</name></expr>:</case>
			<case>case <expr><name>DO_SHELL_TYPE</name></expr>:</case>
			<case>case <expr><name>DO_FUNC</name></expr>:</case>
			<case>case <expr><name>DO_AGG</name></expr>:</case>
			<case>case <expr><name>DO_OPERATOR</name></expr>:</case>
			<case>case <expr><name>DO_ACCESS_METHOD</name></expr>:</case>
			<case>case <expr><name>DO_OPCLASS</name></expr>:</case>
			<case>case <expr><name>DO_OPFAMILY</name></expr>:</case>
			<case>case <expr><name>DO_COLLATION</name></expr>:</case>
			<case>case <expr><name>DO_CONVERSION</name></expr>:</case>
			<case>case <expr><name>DO_TABLE</name></expr>:</case>
			<case>case <expr><name>DO_TABLE_ATTACH</name></expr>:</case>
			<case>case <expr><name>DO_ATTRDEF</name></expr>:</case>
			<case>case <expr><name>DO_PROCLANG</name></expr>:</case>
			<case>case <expr><name>DO_CAST</name></expr>:</case>
			<case>case <expr><name>DO_DUMMY_TYPE</name></expr>:</case>
			<case>case <expr><name>DO_TSPARSER</name></expr>:</case>
			<case>case <expr><name>DO_TSDICT</name></expr>:</case>
			<case>case <expr><name>DO_TSTEMPLATE</name></expr>:</case>
			<case>case <expr><name>DO_TSCONFIG</name></expr>:</case>
			<case>case <expr><name>DO_FDW</name></expr>:</case>
			<case>case <expr><name>DO_FOREIGN_SERVER</name></expr>:</case>
			<case>case <expr><name>DO_TRANSFORM</name></expr>:</case>
			<case>case <expr><name>DO_BLOB</name></expr>:</case>
			<case>case <expr><name>DO_EXTPROTOCOL</name></expr>:</case>
			<case>case <expr><name>DO_BINARY_UPGRADE</name></expr>:</case>
				<comment type="block">/* Pre-data objects: must come before the pre-data boundary */</comment>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>preDataBound</name></expr></argument>, <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DO_TABLE_DATA</name></expr>:</case>
			<case>case <expr><name>DO_SEQUENCE_SET</name></expr>:</case>
			<case>case <expr><name>DO_BLOB_DATA</name></expr>:</case>
				<comment type="block">/* Data objects: must come between the boundaries */</comment>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>preDataBound</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>postDataBound</name></expr></argument>, <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DO_INDEX</name></expr>:</case>
			<case>case <expr><name>DO_INDEX_ATTACH</name></expr>:</case>
			<case>case <expr><name>DO_STATSEXT</name></expr>:</case>
			<case>case <expr><name>DO_REFRESH_MATVIEW</name></expr>:</case>
			<case>case <expr><name>DO_TRIGGER</name></expr>:</case>
			<case>case <expr><name>DO_EVENT_TRIGGER</name></expr>:</case>
			<case>case <expr><name>DO_DEFAULT_ACL</name></expr>:</case>
			<case>case <expr><name>DO_POLICY</name></expr>:</case>
			<case>case <expr><name>DO_PUBLICATION</name></expr>:</case>
			<case>case <expr><name>DO_PUBLICATION_REL</name></expr>:</case>
			<case>case <expr><name>DO_SUBSCRIPTION</name></expr>:</case>
				<comment type="block">/* Post-data objects: must come after the post-data boundary */</comment>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>postDataBound</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DO_RULE</name></expr>:</case>
				<comment type="block">/* Rules are post-data, but only if dumped separately */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name><operator>)</operator><operator>-&gt;</operator><name>separate</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>postDataBound</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>DO_CONSTRAINT</name></expr>:</case>
			<case>case <expr><name>DO_FK_CONSTRAINT</name></expr>:</case>
				<comment type="block">/* Constraints are post-data, but only if dumped separately */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name><operator>)</operator><operator>-&gt;</operator><name>separate</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>postDataBound</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>DO_PRE_DATA_BOUNDARY</name></expr>:</case>
				<comment type="block">/* nothing to do */</comment>
				<break>break;</break>
			<case>case <expr><name>DO_POST_DATA_BOUNDARY</name></expr>:</case>
				<comment type="block">/* must come after the pre-data boundary */</comment>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>preDataBound</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * BuildArchiveDependencies - create dependency data for archive TOC entries
 *
 * The raw dependency data obtained by getDependencies() is not terribly
 * useful in an archive dump, because in many cases there are dependency
 * chains linking through objects that don't appear explicitly in the dump.
 * For example, a view will depend on its _RETURN rule while the _RETURN rule
 * will depend on other objects --- but the rule will not appear as a separate
 * object in the dump.  We need to adjust the view's dependencies to include
 * whatever the rule depends on that is included in the dump.
 *
 * Just to make things more complicated, there are also "special" dependencies
 * such as the dependency of a TABLE DATA item on its TABLE, which we must
 * not rearrange because pg_restore knows that TABLE DATA only depends on
 * its table.  In these cases we must leave the dependencies strictly as-is
 * even if they refer to not-to-be-dumped objects.
 *
 * To handle this, the convention is that "special" dependencies are created
 * during ArchiveEntry calls, and an archive TOC item that has any such
 * entries will not be touched here.  Otherwise, we recursively search the
 * DumpableObject data structures to build the correct dependencies for each
 * archive TOC item.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BuildArchiveDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>fout</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<comment type="block">/* Scan all TOC entries in the archive */</comment>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DumpId</name>	   <modifier>*</modifier></type><name>dependencies</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nDeps</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>allocDeps</name></decl>;</decl_stmt>

		<comment type="block">/* No need to process entries that will not be dumped */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Ignore entries that already have "special" dependencies */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Otherwise, look up the item's original DumpableObject, if any */</comment>
		<expr_stmt><expr><name>dobj</name> <operator>=</operator> <call><name>findObjectByDumpId</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* No work if it has no dependencies */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Set up work array */</comment>
		<expr_stmt><expr><name>allocDeps</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>allocDeps</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nDeps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Recursively find all dumpable dependencies */</comment>
		<expr_stmt><expr><call><name>findDumpableDependencies</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>dobj</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>dependencies</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDeps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allocDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* And save 'em ... */</comment>
		<if_stmt><if>if <condition>(<expr><name>nDeps</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>,
												 <argument><expr><name>nDeps</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <name>dependencies</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>=</operator> <name>nDeps</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Recursive search subroutine for BuildArchiveDependencies */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>findDumpableDependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>,
						 <parameter><decl><type><name>DumpId</name> <modifier>*</modifier><modifier>*</modifier></type><name>dependencies</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nDeps</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>allocDeps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ignore section boundary objects: if we search through them, we'll
	 * report lots of bogus dependencies.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_PRE_DATA_BOUNDARY</name> <operator>||</operator>
		<name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_POST_DATA_BOUNDARY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dobj</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpId</name></type>		<name>depid</name> <init>= <expr><name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TocIDRequired</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>depid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Object will be dumped, so just reference it as a dependency */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nDeps</name> <operator>&gt;=</operator> <operator>*</operator><name>allocDeps</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>allocDeps</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>dependencies</name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>dependencies</name></expr></argument>,
													  <argument><expr><operator>*</operator><name>allocDeps</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>dependencies</name><operator>)</operator><index>[<expr><operator>*</operator><name>nDeps</name></expr>]</index> <operator>=</operator> <name>depid</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>nDeps</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Object will not be dumped, so recursively consider its deps. We
			 * rely on the assumption that sortDumpableObjects already broke
			 * any dependency loops, else we might recurse infinitely.
			 */</comment>
			<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>otherdobj</name> <init>= <expr><call><name>findObjectByDumpId</name><argument_list>(<argument><expr><name>depid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>otherdobj</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>findDumpableDependencies</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>otherdobj</name></expr></argument>,
										 <argument><expr><name>dependencies</name></expr></argument>, <argument><expr><name>nDeps</name></expr></argument>, <argument><expr><name>allocDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * isGPbackend - returns true if the connected backend is a GreenPlum DB backend.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>testGPbackend</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT 1 FROM current_setting('gp_role');"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>isGPbackend</name></name> <operator>=</operator> <operator>(</operator><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	addDistributedBy
 *
 *	find the distribution policy of the passed in relation and append the
 *	DISTRIBUTED BY clause to the passed in dump buffer (q).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addDistributedBy</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>actual_atts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <name>GPDB6_MAJOR_PGVERSION</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>distclause</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>distclause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>addDistributedByOld</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>actual_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is used with GPDB 5 and older, where pg_get_table_distributedby()
 * backend function is not available.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addDistributedByOld</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>actual_atts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>policydef</name> <init>= <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>distclause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>policycol</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>policydef</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There is no entry in the policy table for this table. Report an
		 * error unless this is a zero attribute table (actual_atts == 0).
		 *
		 * In binary_upgrade mode, we run directly against segments, and there
		 * are no gp_distribution_policy rows in segments.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>actual_atts</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if this is a catalog table we allow dumping it, skip the error */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"pg_"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"query to obtain distribution policy of table \"%s\" returned no data"</literal></expr></argument>,
							   <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * There is exactly 1 policy entry for this table (either a concrete
		 * one or NULL).
		 */</comment>
		<expr_stmt><expr><name>policydef</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>distclause</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>policydef</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isfirst</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>separator</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" DISTRIBUTED BY ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* policy indicates one or more columns to distribute on */</comment>
			<expr_stmt><expr><name><name>policydef</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>policydef</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>policydef</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>separator</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>

			<while>while <condition>(<expr><operator>(</operator><name>policycol</name> <operator>=</operator> <call><name>nextToken</name><argument_list>(<argument><expr><operator>&amp;</operator><name>policydef</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isfirst</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>isfirst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><call><name>atoi</name><argument_list>(<argument><expr><name>policycol</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* policy has an empty policy - distribute randomly */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" DISTRIBUTED RANDOMLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getFormattedTypeName - retrieve a nicely-formatted type name for the
 * given type OID.
 *
 * This does not guarantee to schema-qualify the output, so it should not
 * be used to create the target object name for CREATE or ALTER commands.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getFormattedTypeName</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>OidOptions</name></type> <name>opts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>typeInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>zeroAsOpaque</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>g_opaque_type</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>zeroAsAny</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"'any'"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>zeroAsStar</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>zeroAsNone</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"NONE"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* see if we have the result cached in the type's TypeInfo record */</comment>
	<expr_stmt><expr><name>typeInfo</name> <operator>=</operator> <call><name>findTypeByOid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typeInfo</name> <operator>&amp;&amp;</operator> <name><name>typeInfo</name><operator>-&gt;</operator><name>ftypname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>typeInfo</name><operator>-&gt;</operator><name>ftypname</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.format_type('%u'::pg_catalog.oid, NULL)"</literal></expr></argument>,
					  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* result of format_type is already quoted */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cache a copy for later requests */</comment>
	<if_stmt><if>if <condition>(<expr><name>typeInfo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>typeInfo</name><operator>-&gt;</operator><name>ftypname</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a column list clause for the given relation.
 *
 * Special case: if there are no undropped columns in the relation, return
 * "", not an invalid "()" column list.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>fmtCopyColumnList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numatts</name> <init>= <expr><name><name>ti</name><operator>-&gt;</operator><name>numatts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>attnames</name> <init>= <expr><name><name>ti</name><operator>-&gt;</operator><name>attnames</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>attisdropped</name> <init>= <expr><name><name>ti</name><operator>-&gt;</operator><name>attisdropped</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attgenerated</name> <init>= <expr><name><name>ti</name><operator>-&gt;</operator><name>attgenerated</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needComma</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>attisdropped</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attgenerated</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>attnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* no undropped columns */</comment>

	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a reloptions array is nonempty.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>nonemptyReloptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Don't want to print it if it's just "{}" */</comment>
	<return>return <expr><operator>(</operator><name>reloptions</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Format a reloptions array and append it to the given buffer.
 *
 * "prefix" is prepended to the option names; typically it's "" or "toast.".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendReloptionsArrayAH</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>appendReloptionsArray</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>fout</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>,
								<argument><expr><name><name>fout</name><operator>-&gt;</operator><name>std_strings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log_warning</name><argument_list>(<argument><expr><literal type="string">"could not parse reloptions array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* START MPP ADDITION */</comment>
<comment type="block">/*
 * Get next token from string *stringp, where tokens are possibly-empty
 * strings separated by characters from delim.
 *
 * Writes NULs into the string at *stringp to end tokens.
 * delim need not remain constant from call to call.
 * On return, *stringp points past the last NUL written (if there might
														 * be further tokens), or is NULL (if there are definitely no more tokens).
 *
 * If *stringp is NULL, strsep returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>nextToken</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>stringp</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spanp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>c</name></decl>,
				<decl><type ref="prev"/><name>sc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tok</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <operator>*</operator><name>stringp</name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>tok</name> <operator>=</operator> <name>s</name></expr>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>spanp</name> <operator>=</operator> <name>delim</name></expr>;</expr_stmt>
		<do>do
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sc</name> <operator>=</operator> <operator>*</operator><name>spanp</name><operator>++</operator><operator>)</operator> <operator>==</operator> <name>c</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>s</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>stringp</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>tok</name><operator>)</operator></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block> while <condition>(<expr><name>sc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
	</block_content>}</block></for>
	<comment type="block">/* NOTREACHED */</comment>
</block_content>}</block></function>

<comment type="block">/* END MPP ADDITION */</comment>
</unit>
