<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/timezone/localtime.c"><comment type="block">/* Convert timestamp from pg_time_t to struct pg_tm.  */</comment>

<comment type="block">/*
 * This file is in the public domain, so clarified as of
 * 1996-06-05 by Arthur David Olson.
 *
 * IDENTIFICATION
 *	  src/timezone/localtime.c
 */</comment>

<comment type="block">/*
 * Leap second handling from Bradley White.
 * POSIX-style TZ environment variable handling from Guy Harris.
 */</comment>

<comment type="block">/* this file needs to build in both frontend and backend contexts */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datatype/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtz.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tzfile.h"</cpp:file></cpp:include>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WILDABBR</name></cpp:ifndef>
<comment type="block">/*
 * Someone might make incorrect use of a time zone abbreviation:
 *	1.	They might reference tzname[0] before calling tzset (explicitly
 *		or implicitly).
 *	2.	They might reference tzname[1] before calling tzset (explicitly
 *		or implicitly).
 *	3.	They might reference tzname[1] after setting to a time zone
 *		in which Daylight Saving Time is never observed.
 *	4.	They might reference tzname[0] after setting to a time zone
 *		in which Standard Time is never observed.
 *	5.	They might reference tm.TM_ZONE after calling offtime.
 * What's best to do in the above cases is open to debate;
 * for now, we just set things up so that in any of the five cases
 * WILDABBR is used. Another possibility: initialize tzname[0] to the
 * string "tzname[0] used before set", and similarly for the other cases.
 * And another: initialize tzname[0] to "ERA", with an explanation in the
 * manual page of what this "time zone abbreviation" means (doing this so
 * that tzname[0] has the "normal" length of three characters).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WILDABBR</name></cpp:macro>	<cpp:value>"   "</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !defined WILDABBR */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>wildabbr</name><index>[]</index></name> <init>= <expr><name>WILDABBR</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>gmt</name><index>[]</index></name> <init>= <expr><literal type="string">"GMT"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * PG: We cache the result of trying to load the TZDEFRULES zone here.
 * tzdefrules_loaded is 0 if not tried yet, +1 if good, -1 if failed.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>tzdefrules_s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>tzdefrules_loaded</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * The DST rules to use if TZ has no rules and we can't load TZDEFRULES.
 * Default to US rules as of 2017-05-07.
 * POSIX does not specify the default DST rules;
 * for historical reasons, US rules are a common default.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TZDEFRULESTRING</name></cpp:macro> <cpp:value>",M3.2.0,M11.1.0"</cpp:value></cpp:define>

<comment type="block">/* structs ttinfo, lsinfo, state have been moved to pgtz.h */</comment>

<enum>enum <name>r_type</name>
<block>{
	<decl><name>JULIAN_DAY</name></decl>,					<comment type="block">/* Jn = Julian day */</comment>
	<decl><name>DAY_OF_YEAR</name></decl>,				<comment type="block">/* n = day of year */</comment>
	<decl><name>MONTH_NTH_DAY_OF_WEEK</name></decl>		<comment type="block">/* Mm.n.d = month, week, day of week */</comment>
}</block>;</enum>

<struct>struct <name>rule</name>
<block>{
	<decl_stmt><decl><type><name><name>enum</name> <name>r_type</name></name></type> <name>r_type</name></decl>;</decl_stmt>			<comment type="block">/* type of rule */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>r_day</name></decl>;</decl_stmt>			<comment type="block">/* day number of rule */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>r_week</name></decl>;</decl_stmt>			<comment type="block">/* week number of rule */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>r_mon</name></decl>;</decl_stmt>			<comment type="block">/* month number of rule */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>r_time</name></decl>;</decl_stmt>			<comment type="block">/* transition time of rule */</comment>
}</block>;</struct>

<comment type="block">/*
 * Prototypes for static functions.
 */</comment>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>gmtsub</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int32</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>increment_overflow</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>increment_overflow_time</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>timesub</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int32</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>,
							 <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>typesequiv</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Section 4.12.3 of X3.159-1989 requires that
 *	Except for the strftime function, these functions [asctime,
 *	ctime, gmtime, localtime] return values in one of two static
 *	objects: a broken-down time structure and an array of char.
 * Thanks to Paul Eggert for noting this.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>

<comment type="block">/* Initialize *S to a value based on UTOFF, ISDST, and DESIGIDX.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_ttinfo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>utoff</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>desigidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tt_utoff</name></name> <operator>=</operator> <name>utoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tt_isdst</name></name> <operator>=</operator> <name>isdst</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tt_desigidx</name></name> <operator>=</operator> <name>desigidx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tt_ttisstd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tt_ttisut</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32</name></type>
<name>detzcode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>codep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>halfmaxval</name> <init>= <expr><name>one</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>maxval</name> <init>= <expr><name>halfmaxval</name> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>halfmaxval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>minval</name> <init>= <expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>maxval</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>codep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>codep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name><name>codep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do two's-complement negation even on non-two's-complement machines.
		 * If the result would be minval - 1, return minval.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>-=</operator> <operator>!</operator><call><name>TWOS_COMPLEMENT</name><argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>minval</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>detzcode64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>codep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>halfmaxval</name> <init>= <expr><name>one</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>maxval</name> <init>= <expr><name>halfmaxval</name> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>halfmaxval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>minval</name> <init>= <expr><operator>-</operator><call><name>TWOS_COMPLEMENT</name><argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></call> <operator>-</operator><name>maxval</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>codep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>codep</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name><name>codep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do two's-complement negation even on non-two's-complement machines.
		 * If the result would be minval - 1, return minval.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>-=</operator> <operator>!</operator><call><name>TWOS_COMPLEMENT</name><argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>minval</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>differ_by_repeat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_time_t</name></type> <name>t1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pg_time_t</name></type> <name>t0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TYPE_BIT</name><argument_list>(<argument><expr><name>pg_time_t</name></expr></argument>)</argument_list></call> <operator>-</operator><call><name>TYPE_SIGNED</name><argument_list>(<argument><expr><name>pg_time_t</name></expr></argument>)</argument_list></call> <operator>&lt;</operator><name>SECSPERREPEAT_BITS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>t1</name> <operator>-</operator> <name>t0</name> <operator>==</operator> <name>SECSPERREPEAT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Input buffer for data read from a compiled tz file.  */</comment>
<union>union <name>input_buffer</name>
<block>{
	<comment type="block">/* The first part of the buffer, interpreted as a header.  */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>tzhead</name></name></type> <name>tzhead</name></decl>;</decl_stmt>

	<comment type="block">/* The entire buffer.  */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>tzhead</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>state</name></expr></argument>)</argument_list></sizeof>
					<operator>+</operator> <literal type="number">4</literal> <operator>*</operator> <name>TZ_MAX_TIMES</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</union>

<comment type="block">/* Local storage needed for 'tzloadbody'.  */</comment>
<union>union <name>local_storage</name>
<block>{
	<comment type="block">/* The results of analyzing the file's contents after it is opened.  */</comment>
	<struct>struct <name>file_analysis</name>
	<block>{
		<comment type="block">/* The input buffer.  */</comment>
		<decl_stmt><decl><type><name><name>union</name> <name>input_buffer</name></name></type> <name>u</name></decl>;</decl_stmt>

		<comment type="block">/* A temporary state used for parsing a TZ string in the file.  */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name></type> <name>st</name></decl>;</decl_stmt>
	}</block>			<decl><name>u</name></decl>;</struct>

	<comment type="block">/* We don't need the "fullname" member */</comment>
}</block>;</union>

<comment type="block">/* Load tz data from the file named NAME into *SP.  Read extended
 * format if DOEXTEND.  Use *LSP for temporary storage.  Return 0 on
 * success, an errno value on failure.
 * PG: If "canonname" is not NULL, then on success the canonical spelling of
 * given name is stored there (the buffer must be &gt; TZ_STRLEN_MAX bytes!).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tzloadbody</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>canonname</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doextend</name></decl></parameter>,
		   <parameter><decl><type><name><name>union</name> <name>local_storage</name></name> <modifier>*</modifier></type><name>lsp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>stored</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>nread</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>union</name> <name>input_buffer</name></name> <modifier>*</modifier></type><name>up</name> <init>= <expr><operator>&amp;</operator><name><name>lsp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>u</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tzheadsize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>tzhead</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>goback</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>goahead</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>name</name> <operator>=</operator> <name>TZDEFAULT</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>name</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fid</name> <operator>=</operator> <call><name>pg_open_tzfile</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>canonname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ENOENT</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* pg_open_tzfile may not set errno */</comment>

	<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fid</name></expr></argument>, <argument><expr><name><name>up</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>up</name><operator>-&gt;</operator><name>buf</name></name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;</operator> <name>tzheadsize</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>err</name> <init>= <expr><ternary><condition><expr><name>nread</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>errno</name></expr> </then><else>: <expr><name>EINVAL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>err</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>stored</name> <operator>=</operator> <literal type="number">4</literal></expr>;</init> <condition><expr><name>stored</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>stored</name> <operator>*=</operator> <literal type="number">2</literal></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>ttisstdcnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_ttisstdcnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>ttisutcnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_ttisutcnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>prevtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>prevcorr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>leapcnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_leapcnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>timecnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_timecnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>typecnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_typecnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>charcnt</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_charcnt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>up</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>tzheadsize</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Although tzfile(5) currently requires typecnt to be nonzero,
		 * support future formats that may allow zero typecnt in files that
		 * have a TZ string and no transitions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><literal type="number">0</literal> <operator>&lt;=</operator> <name>leapcnt</name> <operator>&amp;&amp;</operator> <name>leapcnt</name> <operator>&lt;</operator> <name>TZ_MAX_LEAPS</name>
			  <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>typecnt</name> <operator>&amp;&amp;</operator> <name>typecnt</name> <operator>&lt;</operator> <name>TZ_MAX_TYPES</name>
			  <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>timecnt</name> <operator>&amp;&amp;</operator> <name>timecnt</name> <operator>&lt;</operator> <name>TZ_MAX_TIMES</name>
			  <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>charcnt</name> <operator>&amp;&amp;</operator> <name>charcnt</name> <operator>&lt;</operator> <name>TZ_MAX_CHARS</name>
			  <operator>&amp;&amp;</operator> <operator>(</operator><name>ttisstdcnt</name> <operator>==</operator> <name>typecnt</name> <operator>||</operator> <name>ttisstdcnt</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
			  <operator>&amp;&amp;</operator> <operator>(</operator><name>ttisutcnt</name> <operator>==</operator> <name>typecnt</name> <operator>||</operator> <name>ttisutcnt</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nread</name>
			<operator>&lt;</operator> <operator>(</operator><name>tzheadsize</name>		<comment type="block">/* struct tzhead */</comment>
			   <operator>+</operator> <name>timecnt</name> <operator>*</operator> <name>stored</name>	<comment type="block">/* ats */</comment>
			   <operator>+</operator> <name>timecnt</name>		<comment type="block">/* types */</comment>
			   <operator>+</operator> <name>typecnt</name> <operator>*</operator> <literal type="number">6</literal>	<comment type="block">/* ttinfos */</comment>
			   <operator>+</operator> <name>charcnt</name>		<comment type="block">/* chars */</comment>
			   <operator>+</operator> <name>leapcnt</name> <operator>*</operator> <operator>(</operator><name>stored</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator> <comment type="block">/* lsinfos */</comment>
			   <operator>+</operator> <name>ttisstdcnt</name>		<comment type="block">/* ttisstds */</comment>
			   <operator>+</operator> <name>ttisutcnt</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* ttisuts */</comment>
			<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name> <operator>=</operator> <name>leapcnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>=</operator> <name>timecnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>=</operator> <name>typecnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name> <operator>=</operator> <name>charcnt</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Read transitions, discarding those out of pg_time_t range. But
		 * pretend the last transition before TIME_T_MIN occurred at
		 * TIME_T_MIN.
		 */</comment>
		<expr_stmt><expr><name>timecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type>		<name>at</name>
			<init>= <expr><ternary><condition><expr><name>stored</name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><call><name>detzcode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>detzcode64</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>at</name> <operator>&lt;=</operator> <name>TIME_T_MAX</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>attime</name>
				<init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><ternary><condition><expr><call><name>TYPE_SIGNED</name><argument_list>(<argument><expr><name>pg_time_t</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>at</name> <operator>&lt;</operator> <name>TIME_T_MIN</name></expr> </then><else>: <expr><name>at</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>
				   ?</condition><then> <expr><name>TIME_T_MIN</name></expr> </then><else>: <expr><name>at</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>timecnt</name> <operator>&amp;&amp;</operator> <name>attime</name> <operator>&lt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>attime</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>timecnt</name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>attime</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>stored</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>timecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>typ</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>&lt;=</operator> <name>typ</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>timecnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>typ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>=</operator> <name>timecnt</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type><name>ttisp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>isdst</name></decl>,
						<decl><type ref="prev"/><name>desigidx</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name> <operator>=</operator> <call><name>detzcode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>isdst</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>isdst</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name> <operator>=</operator> <name>isdst</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>desigidx</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>desigidx</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_desigidx</name></name> <operator>=</operator> <name>desigidx</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* ensure '\0' at end */</comment>

		<comment type="block">/* Read leap seconds, discarding those out of pg_time_t range.  */</comment>
		<expr_stmt><expr><name>leapcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type>		<name>tr</name> <init>= <expr><ternary><condition><expr><name>stored</name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><call><name>detzcode</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>detzcode64</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>corr</name> <init>= <expr><call><name>detzcode</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>stored</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>stored</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<comment type="block">/* Leap seconds cannot occur before the Epoch.  */</comment>
			<if_stmt><if>if <condition>(<expr><name>tr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>tr</name> <operator>&lt;=</operator> <name>TIME_T_MAX</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Leap seconds cannot occur more than once per UTC month, and
				 * UTC months are at least 28 days long (minus 1 second for a
				 * negative leap second).  Each leap second's correction must
				 * differ from the previous one's by 1 second.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>tr</name> <operator>-</operator> <name>prevtr</name> <operator>&lt;</operator> <literal type="number">28</literal> <operator>*</operator> <name>SECSPERDAY</name> <operator>-</operator> <literal type="number">1</literal>
					<operator>||</operator> <operator>(</operator><name>corr</name> <operator>!=</operator> <name>prevcorr</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>corr</name> <operator>!=</operator> <name>prevcorr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>lsis</name><index>[<expr><name>leapcnt</name></expr>]</index></name><operator>.</operator><name>ls_trans</name> <operator>=</operator> <name>prevtr</name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>lsis</name><index>[<expr><name>leapcnt</name></expr>]</index></name><operator>.</operator><name>ls_corr</name> <operator>=</operator> <name>prevcorr</name> <operator>=</operator> <name>corr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>leapcnt</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name> <operator>=</operator> <name>leapcnt</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type><name>ttisp</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ttisstdcnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_ttisstd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>true</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_ttisstd</name></name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type><name>ttisp</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ttisutcnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_ttisut</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>true</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_ttisut</name></name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If this is an old file, we're done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>up</name><operator>-&gt;</operator><name>tzhead</name><operator>.</operator><name>tzh_version</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>nread</name> <operator>-=</operator> <name>p</name> <operator>-</operator> <name><name>up</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>up</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>doextend</name> <operator>&amp;&amp;</operator> <name>nread</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>up</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name><name>up</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>nread</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator>
		<name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>TZ_MAX_TYPES</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>ts</name> <init>= <expr><operator>&amp;</operator><name><name>lsp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>st</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>up</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>nread</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>tzparse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>up</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Attempt to reuse existing abbreviations. Without this,
			 * America/Anchorage would be right on the edge after 2037 when
			 * TZ_MAX_CHARS is 50, as sp-&gt;charcnt equals 40 (for LMT AST AWT
			 * APT AHST AHDT YST AKDT AKST) and ts-&gt;charcnt equals 10 (for
			 * AKST AKDT).  Reusing means sp-&gt;charcnt can stay 40 in this
			 * example.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>gotabbr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>charcnt</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tsabbr</name> <init>= <expr><name><name>ts</name><operator>-&gt;</operator><name>chars</name></name> <operator>+</operator> <name><name>ts</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_desigidx</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>charcnt</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>chars</name></name> <operator>+</operator> <name>j</name></expr></argument>, <argument><expr><name>tsabbr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_desigidx</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>gotabbr</name><operator>++</operator></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt></block_content></block></for>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>j</name> <operator>&lt;</operator> <name>charcnt</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>tsabbrlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>tsabbr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>j</name> <operator>+</operator> <name>tsabbrlen</name> <operator>&lt;</operator> <name>TZ_MAX_CHARS</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>chars</name></name> <operator>+</operator> <name>j</name></expr></argument>, <argument><expr><name>tsabbr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>charcnt</name> <operator>=</operator> <name>j</name> <operator>+</operator> <name>tsabbrlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>ts</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_desigidx</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>gotabbr</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>gotabbr</name> <operator>==</operator> <name><name>ts</name><operator>-&gt;</operator><name>typecnt</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name> <operator>=</operator> <name>charcnt</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Ignore any trailing, no-op transitions generated by zic as
				 * they don't help here and can run afoul of bugs in zic 2016j
				 * or earlier.
				 */</comment>
				<while>while <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name>
					   <operator>&amp;&amp;</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
						   <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>==</operator> <literal type="number">0</literal>
						<operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
				<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>timecnt</name></name>
					   <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>&lt;</operator> <name>TZ_MAX_TIMES</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>]</index></name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name>
											  <operator>+</operator> <name><name>ts</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ts</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>ts</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>typesequiv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>differ_by_repeat</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>goback</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt></block_content></block></for>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>typesequiv</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
						   <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>differ_by_repeat</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
								 <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>goahead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Infer sp-&gt;defaulttype from the data.  Although this default type is
	 * always zero for data from recent tzdb releases, things are trickier for
	 * data from tzdb 2018e or earlier.
	 *
	 * The first set of heuristics work around bugs in 32-bit data generated
	 * by tzdb 2013c or earlier.  The workaround is for zones like
	 * Australia/Macquarie where timestamps before the first transition have a
	 * time type that is not the earliest standard-time type.  See:
	 * https://mm.icann.org/pipermail/tz/2013-May/019368.html
	 */</comment>

	<comment type="block">/*
	 * If type 0 is unused in transitions, it's the type to use for early
	 * times.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Absent the above, if there are transition times and the first
	 * transition is to a daylight time find the standard type less than and
	 * closest to the type of the first transition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>i</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The next heuristics are for data generated by tzdb 2018e or earlier,
	 * for zones like EST5EDT where the first transition is to DST.
	 */</comment>

	<comment type="block">/*
	 * If no result yet, find the first standard type. If there is none, punt
	 * to type zero.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * A simple 'sp-&gt;defaulttype = 0;' would suffice here if we didn't have to
	 * worry about 2018e-or-earlier data.  Even simpler would be to remove the
	 * defaulttype member and just use 0 in its place.
	 */</comment>
	<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>defaulttype</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Load tz data from the file named NAME into *SP.  Read extended
 * format if DOEXTEND.  Return 0 on success, an errno value on failure.
 * PG: If "canonname" is not NULL, then on success the canonical spelling of
 * given name is stored there (the buffer must be &gt; TZ_STRLEN_MAX bytes!).
 */</comment>
<function><type><name>int</name></type>
<name>tzload</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>canonname</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doextend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>union</name> <name>local_storage</name></name> <modifier>*</modifier></type><name>lsp</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>lsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lsp</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>errno</name></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>err</name> <init>= <expr><call><name>tzloadbody</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>canonname</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>doextend</name></expr></argument>, <argument><expr><name>lsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>err</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>typesequiv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name>a</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>a</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>||</operator>
		<name>b</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>b</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>a</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>b</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>ap</name><operator>-&gt;</operator><name>tt_utoff</name></name> <operator>==</operator> <name><name>bp</name><operator>-&gt;</operator><name>tt_utoff</name></name>
				  <operator>&amp;&amp;</operator> <name><name>ap</name><operator>-&gt;</operator><name>tt_isdst</name></name> <operator>==</operator> <name><name>bp</name><operator>-&gt;</operator><name>tt_isdst</name></name>
				  <operator>&amp;&amp;</operator> <name><name>ap</name><operator>-&gt;</operator><name>tt_ttisstd</name></name> <operator>==</operator> <name><name>bp</name><operator>-&gt;</operator><name>tt_ttisstd</name></name>
				  <operator>&amp;&amp;</operator> <name><name>ap</name><operator>-&gt;</operator><name>tt_ttisut</name></name> <operator>==</operator> <name><name>bp</name><operator>-&gt;</operator><name>tt_ttisut</name></name>
				  <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name><name>ap</name><operator>-&gt;</operator><name>tt_desigidx</name></name></expr>]</index></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name><name>bp</name><operator>-&gt;</operator><name>tt_desigidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call>
					  <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>mon_lengths</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>MONSPERYEAR</name></expr>]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="number">31</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="number">31</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>year_lengths</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><name>DAYSPERNYEAR</name></expr>, <expr><name>DAYSPERLYEAR</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Given a pointer into a timezone string, scan until a character that is not
 * a valid character in a time zone abbreviation is found.
 * Return a pointer to that character.
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getzname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>strp</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_digit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator>
		   <name>c</name> <operator>!=</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt></block_content></block></while>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a pointer into an extended timezone string, scan until the ending
 * delimiter of the time zone abbreviation is located.
 * Return a pointer to the delimiter.
 *
 * As with getzname above, the legal character set is actually quite
 * restricted, with other characters producing undefined results.
 * We don't do any checking here; checking is done later in common-case code.
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getqzname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>delim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>strp</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>delim</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt></block_content></block></while>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a pointer into a timezone string, extract a number from that string.
 * Check that the number is within a specified range; if it is not, return
 * NULL.
 * Otherwise, return a pointer to the first character not part of the number.
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getnum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><specifier>const</specifier></type> <name>nump</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>is_digit</name><argument_list>(<argument><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>strp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>num</name> <operator>=</operator> <name>num</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* illegal value */</comment>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>strp</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><call><name>is_digit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
	<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <name>min</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* illegal value */</comment>
	<expr_stmt><expr><operator>*</operator><name>nump</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a pointer into a timezone string, extract a number of seconds,
 * in hh[:mm[:ss]] form, from the string.
 * If any error occurs, return NULL.
 * Otherwise, return a pointer to the first character not part of the number
 * of seconds.
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getsecs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier><specifier>const</specifier></type> <name>secsp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * 'HOURSPERDAY * DAYSPERWEEK - 1' allows quasi-Posix rules like
	 * "M10.4.6/26", which does not conform to Posix, but which specifies the
	 * equivalent of "02:00 on the first Sunday on or after 23 Oct".
	 */</comment>
	<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>HOURSPERDAY</name> <operator>*</operator> <name>DAYSPERWEEK</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>secsp</name> <operator>=</operator> <name>num</name> <operator>*</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>SECSPERHOUR</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MINSPERHOUR</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>secsp</name> <operator>+=</operator> <name>num</name> <operator>*</operator> <name>SECSPERMIN</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
			<comment type="block">/* 'SECSPERMIN' allows for leap seconds.  */</comment>
			<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SECSPERMIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>secsp</name> <operator>+=</operator> <name>num</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a pointer into a timezone string, extract an offset, in
 * [+-]hh[:mm[:ss]] form, from the string.
 * If any error occurs, return NULL.
 * Otherwise, return a pointer to the first character not part of the time.
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getoffset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier><specifier>const</specifier></type> <name>offsetp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>neg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>neg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getsecs</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><name>offsetp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* illegal time */</comment>
	<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>offsetp</name> <operator>=</operator> <operator>-</operator><operator>*</operator><name>offsetp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a pointer into a timezone string, extract a rule in the form
 * date[/time]. See POSIX section 8 for the format of "date" and "time".
 * If a valid rule is not found, return NULL.
 * Otherwise, return a pointer to the first character not part of the rule.
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getrule</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rule</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>rulep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">'J'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Julian day.
		 */</comment>
		<expr_stmt><expr><name><name>rulep</name><operator>-&gt;</operator><name>r_type</name></name> <operator>=</operator> <name>JULIAN_DAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>DAYSPERNYEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">'M'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Month, week, day.
		 */</comment>
		<expr_stmt><expr><name><name>rulep</name><operator>-&gt;</operator><name>r_type</name></name> <operator>=</operator> <name>MONTH_NTH_DAY_OF_WEEK</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_mon</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>MONSPERYEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name><operator>++</operator> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_week</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name><operator>++</operator> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DAYSPERWEEK</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>is_digit</name><argument_list>(<argument><expr><operator>*</operator><name>strp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Day of year.
		 */</comment>
		<expr_stmt><expr><name><name>rulep</name><operator>-&gt;</operator><name>r_type</name></name> <operator>=</operator> <name>DAY_OF_YEAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getnum</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DAYSPERLYEAR</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>			<comment type="block">/* invalid format */</comment>
	<if_stmt><if>if <condition>(<expr><name>strp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strp</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Time specified.
		 */</comment>
		<expr_stmt><expr><operator>++</operator><name>strp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>strp</name> <operator>=</operator> <call><name>getoffset</name><argument_list>(<argument><expr><name>strp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rulep</name><operator>-&gt;</operator><name>r_time</name></name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>SECSPERHOUR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* default = 2:00:00 */</comment>
	<return>return <expr><name>strp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a year, a rule, and the offset from UT at the time that rule takes
 * effect, calculate the year-relative time that rule takes effect.
 */</comment>

<function><type><specifier>static</specifier> <name>int32</name></type>
<name>transtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>year</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rule</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>rulep</name></decl></parameter>,
		  <parameter><decl><type><specifier>const</specifier> <name>int32</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>leapyear</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>d</name></decl>,
				<decl><type ref="prev"/><name>m1</name></decl>,
				<decl><type ref="prev"/><name>yy0</name></decl>,
				<decl><type ref="prev"/><name>yy1</name></decl>,
				<decl><type ref="prev"/><name>yy2</name></decl>,
				<decl><type ref="prev"/><name>dow</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INITIALIZE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leapyear</name> <operator>=</operator> <call><name>isleap</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>rulep</name><operator>-&gt;</operator><name>r_type</name></name></expr>)</condition>
	<block>{<block_content>

		<case>case <expr><name>JULIAN_DAY</name></expr>:</case>

			<comment type="block">/*
			 * Jn - Julian day, 1 == January 1, 60 == March 1 even in leap
			 * years. In non-leap years, or if the day number is 59 or less,
			 * just add SECSPERDAY times the day number-1 to the time of
			 * January 1, midnight, to get the day.
			 */</comment>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>leapyear</name> <operator>&amp;&amp;</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name> <operator>&gt;=</operator> <literal type="number">60</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>value</name> <operator>+=</operator> <name>SECSPERDAY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>DAY_OF_YEAR</name></expr>:</case>

			<comment type="block">/*
			 * n - day of year. Just add SECSPERDAY times the day number to
			 * the time of January 1, midnight, to get the day.
			 */</comment>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>MONTH_NTH_DAY_OF_WEEK</name></expr>:</case>

			<comment type="block">/*
			 * Mm.n.d - nth "dth day" of month m.
			 */</comment>

			<comment type="block">/*
			 * Use Zeller's Congruence to get day-of-week of first day of
			 * month.
			 */</comment>
			<expr_stmt><expr><name>m1</name> <operator>=</operator> <operator>(</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_mon</name></name> <operator>+</operator> <literal type="number">9</literal><operator>)</operator> <operator>%</operator> <literal type="number">12</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>yy0</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>rulep</name><operator>-&gt;</operator><name>r_mon</name></name> <operator>&lt;=</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>year</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name>year</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>yy1</name> <operator>=</operator> <name>yy0</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>yy2</name> <operator>=</operator> <name>yy0</name> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dow</name> <operator>=</operator> <operator>(</operator><operator>(</operator><literal type="number">26</literal> <operator>*</operator> <name>m1</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <literal type="number">10</literal> <operator>+</operator>
				   <literal type="number">1</literal> <operator>+</operator> <name>yy2</name> <operator>+</operator> <name>yy2</name> <operator>/</operator> <literal type="number">4</literal> <operator>+</operator> <name>yy1</name> <operator>/</operator> <literal type="number">4</literal> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <name>yy1</name><operator>)</operator> <operator>%</operator> <literal type="number">7</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>dow</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dow</name> <operator>+=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * "dow" is the day-of-week of the first day of the month. Get the
			 * day-of-month (zero-origin) of the first "dow" day of the month.
			 */</comment>
			<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_day</name></name> <operator>-</operator> <name>dow</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>d</name> <operator>+=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_week</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>d</name> <operator>+</operator> <name>DAYSPERWEEK</name> <operator>&gt;=</operator>
					<name><name>mon_lengths</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <name>leapyear</name></expr>]</index><index>[<expr><name><name>rulep</name><operator>-&gt;</operator><name>r_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>d</name> <operator>+=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * "d" is the day-of-month (zero-origin) of the day we want.
			 */</comment>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <name>d</name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name>value</name> <operator>+=</operator> <name><name>mon_lengths</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator> <name>leapyear</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>SECSPERDAY</name></expr>;</expr_stmt></block_content></block></for>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * "value" is the year-relative time of 00:00:00 UT on the day in
	 * question. To get the year-relative time of the specified local time on
	 * that day, add the transition time and the current offset from UT.
	 */</comment>
	<return>return <expr><name>value</name> <operator>+</operator> <name><name>rulep</name><operator>-&gt;</operator><name>r_time</name></name> <operator>+</operator> <name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a POSIX section 8-style TZ string, fill in the rule tables as
 * appropriate.
 * Returns true on success, false on failure.
 */</comment>
<function><type><name>bool</name></type>
<name>tzparse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lastditch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stdname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dstname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>stdlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>dstlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>charcnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>stdoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dstoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>load_ok</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>stdname</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lastditch</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Unlike IANA, don't assume name is exactly "GMT" */</comment>
		<expr_stmt><expr><name>stdlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* length of standard zone name */</comment>
		<expr_stmt><expr><name>name</name> <operator>+=</operator> <name>stdlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stdoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>stdname</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getqzname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>stdlen</name> <operator>=</operator> <name>name</name> <operator>-</operator> <name>stdname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getzname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stdlen</name> <operator>=</operator> <name>name</name> <operator>-</operator> <name>stdname</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* we allow empty STD abbrev, unlike IANA */</comment>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getoffset</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stdoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>charcnt</name> <operator>=</operator> <name>stdlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><sizeof>sizeof <name><name>sp</name><operator>-&gt;</operator><name>chars</name></name></sizeof> <operator>&lt;</operator> <name>charcnt</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The IANA code always tries tzload(TZDEFRULES) here.  We do not want to
	 * do that; it would be bad news in the lastditch case, where we can't
	 * assume pg_open_tzfile() is sane yet.  Moreover, the only reason to do
	 * it unconditionally is to absorb the TZDEFRULES zone's leap second info,
	 * which we don't want to do anyway.  Without that, we only need to load
	 * TZDEFRULES if the zone name specifies DST but doesn't incorporate a
	 * POSIX-style transition date rule, which is not a common case.
	 */</comment>
	<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>goback</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>goahead</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* simulate failed tzload() */</comment>
	<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* intentionally assume no leap seconds */</comment>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dstname</name> <operator>=</operator> <operator>++</operator><name>name</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getqzname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>dstlen</name> <operator>=</operator> <name>name</name> <operator>-</operator> <name>dstname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>dstname</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getzname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dstlen</name> <operator>=</operator> <name>name</name> <operator>-</operator> <name>dstname</name></expr>;</expr_stmt>	<comment type="block">/* length of DST abbr. */</comment>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dstlen</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>charcnt</name> <operator>+=</operator> <name>dstlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><sizeof>sizeof <name><name>sp</name><operator>-&gt;</operator><name>chars</name></name></sizeof> <operator>&lt;</operator> <name>charcnt</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">';'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getoffset</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dstoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>dstoffset</name> <operator>=</operator> <name>stdoffset</name> <operator>-</operator> <name>SECSPERHOUR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The POSIX zone name does not provide a transition-date rule.
			 * Here we must load the TZDEFRULES zone, if possible, to serve as
			 * source data for the transition dates.  Unlike the IANA code, we
			 * try to cache the data so it's only loaded once.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>tzdefrules_loaded</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Allocate on first use */</comment>
				<if_stmt><if>if <condition>(<expr><name>tzdefrules_s</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tzdefrules_s</name> <operator>=</operator> <operator>(</operator>struct <name>state</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>tzdefrules_s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>tzload</name><argument_list>(<argument><expr><name>TZDEFRULES</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tzdefrules_s</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>tzdefrules_loaded</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>tzdefrules_loaded</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<comment type="block">/* In any case, we ignore leap-second data from the file */</comment>
					<expr_stmt><expr><name><name>tzdefrules_s</name><operator>-&gt;</operator><name>leapcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>load_ok</name> <operator>=</operator> <operator>(</operator><name>tzdefrules_loaded</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>load_ok</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>tzdefrules_s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* If we can't load TZDEFRULES, fall back to hard-wired rule */</comment>
				<expr_stmt><expr><name>name</name> <operator>=</operator> <name>TZDEFRULESTRING</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">','</literal> <operator>||</operator> <operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name></type> <name>start</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name><name>struct</name> <name>rule</name></name></type> <name>end</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>year</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>yearlim</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>timecnt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>janfirst</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>janoffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>yearbeg</name></decl>;</decl_stmt>

			<expr_stmt><expr><operator>++</operator><name>name</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>getrule</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name><operator>++</operator> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>getrule</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>	<comment type="block">/* standard time and DST */</comment>

			<comment type="block">/*
			 * Two transitions per year, from EPOCH_YEAR forward.
			 */</comment>
			<expr_stmt><expr><call><name>init_ttinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>stdoffset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>init_ttinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>dstoffset</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>stdlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>defaulttype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>timecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>janfirst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>yearbeg</name> <operator>=</operator> <name>EPOCH_YEAR</name></expr>;</expr_stmt>

			<do>do
			<block>{<block_content>
				<decl_stmt><decl><type><name>int32</name></type>		<name>yearsecs</name>
				<init>= <expr><name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>yearbeg</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>*</operator> <name>SECSPERDAY</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>yearbeg</name><operator>--</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>increment_overflow_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>janfirst</name></expr></argument>, <argument><expr><operator>-</operator><name>yearsecs</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>janoffset</name> <operator>=</operator> <operator>-</operator><name>yearsecs</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block> while <condition>(<expr><name>EPOCH_YEAR</name> <operator>-</operator> <name>YEARSPERREPEAT</name> <operator>/</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>yearbeg</name></expr>)</condition>;</do>

			<expr_stmt><expr><name>yearlim</name> <operator>=</operator> <name>yearbeg</name> <operator>+</operator> <name>YEARSPERREPEAT</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>year</name> <operator>=</operator> <name>yearbeg</name></expr>;</init> <condition><expr><name>year</name> <operator>&lt;</operator> <name>yearlim</name></expr>;</condition> <incr><expr><name>year</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int32</name></type>
							<name>starttime</name> <init>= <expr><call><name>transtime</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><name>stdoffset</name></expr></argument>)</argument_list></call></expr></init></decl>,
							<decl><type ref="prev"/><name>endtime</name> <init>= <expr><call><name>transtime</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><name>dstoffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>
							<name>yearsecs</name> <init>= <expr><operator>(</operator><name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>year</name></expr></argument>)</argument_list></call></expr>]</index></name>
										<operator>*</operator> <name>SECSPERDAY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>reversed</name> <init>= <expr><name>endtime</name> <operator>&lt;</operator> <name>starttime</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>reversed</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int32</name></type>		<name>swap</name> <init>= <expr><name>starttime</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>starttime</name> <operator>=</operator> <name>endtime</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>endtime</name> <operator>=</operator> <name>swap</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>reversed</name>
					<operator>||</operator> <operator>(</operator><name>starttime</name> <operator>&lt;</operator> <name>endtime</name>
						<operator>&amp;&amp;</operator> <operator>(</operator><name>endtime</name> <operator>-</operator> <name>starttime</name>
							<operator>&lt;</operator> <operator>(</operator><name>yearsecs</name>
							   <operator>+</operator> <operator>(</operator><name>stdoffset</name> <operator>-</operator> <name>dstoffset</name><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>TZ_MAX_TIMES</name> <operator>-</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>timecnt</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name></expr>]</index></name> <operator>=</operator> <name>janfirst</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>increment_overflow_time</name>
						<argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name></expr>]</index></name></expr></argument>,
						 <argument><expr><name>janoffset</name> <operator>+</operator> <name>starttime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>timecnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>!</operator><name>reversed</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name></expr>]</index></name> <operator>=</operator> <name>janfirst</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>increment_overflow_time</name>
						<argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>timecnt</name></expr>]</index></name></expr></argument>,
						 <argument><expr><name>janoffset</name> <operator>+</operator> <name>endtime</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>timecnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>reversed</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>yearlim</name> <operator>=</operator> <name>year</name> <operator>+</operator> <name>YEARSPERREPEAT</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>increment_overflow_time</name>
					<argument_list>(<argument><expr><operator>&amp;</operator><name>janfirst</name></expr></argument>, <argument><expr><name>janoffset</name> <operator>+</operator> <name>yearsecs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>janoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>=</operator> <name>timecnt</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>timecnt</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* Perpetual DST.  */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>YEARSPERREPEAT</name> <operator>&lt;</operator> <name>year</name> <operator>-</operator> <name>yearbeg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>goback</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>goahead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type>		<name>theirstdoffset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>theirdstoffset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>theiroffset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isdst</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Initial values of theirstdoffset and theirdstoffset.
			 */</comment>
			<expr_stmt><expr><name>theirstdoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>theirstdoffset</name> <operator>=</operator>
						<operator>-</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>theirdstoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>theirdstoffset</name> <operator>=</operator>
						<operator>-</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Initially we're assumed to be in standard time.
			 */</comment>
			<expr_stmt><expr><name>isdst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>theiroffset</name> <operator>=</operator> <name>theirstdoffset</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now juggle transition times and types tracking offsets as you
			 * do.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_ttisut</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* No adjustment to transition time */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * If daylight saving time is in effect, and the
					 * transition time was not specified as standard time, add
					 * the daylight saving time offset to the transition time;
					 * otherwise, add the standard time offset to the
					 * transition time.
					 */</comment>
					<comment type="block">/*
					 * Transitions from DST to DDST will effectively disappear
					 * since POSIX provides for only one DST offset.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>isdst</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_ttisstd</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>dstoffset</name> <operator>-</operator>
							<name>theirdstoffset</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>stdoffset</name> <operator>-</operator>
							<name>theirstdoffset</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>theiroffset</name> <operator>=</operator> <operator>-</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>theirdstoffset</name> <operator>=</operator> <name>theiroffset</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>theirstdoffset</name> <operator>=</operator> <name>theiroffset</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Finally, fill in ttis.
			 */</comment>
			<expr_stmt><expr><call><name>init_ttinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>stdoffset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>init_ttinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>dstoffset</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>stdlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>defaulttype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dstlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* only standard time */</comment>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_ttinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>stdoffset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>defaulttype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name> <operator>=</operator> <name>charcnt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>chars</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>stdname</name></expr></argument>, <argument><expr><name>stdlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cp</name> <operator>+=</operator> <name>stdlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dstlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>dstname</name></expr></argument>, <argument><expr><name>dstlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>cp</name> <operator>+</operator> <name>dstlen</name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gmtload</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>sp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>tzload</name><argument_list>(<argument><expr><name>gmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tzparse</name><argument_list>(<argument><expr><name>gmt</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * The easy way to behave "as if no library function calls" localtime
 * is to not call it, so we drop its guts into "localsub", which can be
 * freely called. (And no, the PANS doesn't require the above behavior,
 * but it *is* desirable.)
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type>
<name>localsub</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>pg_time_t</name> <specifier>const</specifier> <modifier>*</modifier></type><name>timep</name></decl></parameter>,
		 <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type><name>ttisp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>pg_time_t</name></type> <name>t</name> <init>= <expr><operator>*</operator><name>timep</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gmtsub</name><argument_list>(<argument><expr><name>timep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>goback</name></name> <operator>&amp;&amp;</operator> <name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>goahead</name></name> <operator>&amp;&amp;</operator> <name>t</name> <operator>&gt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>newt</name> <init>= <expr><name>t</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>seconds</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>years</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>t</name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><operator>--</operator><name>seconds</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>years</name> <operator>=</operator> <operator>(</operator><name>seconds</name> <operator>/</operator> <name>SECSPERREPEAT</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>YEARSPERREPEAT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>years</name> <operator>*</operator> <name>AVGSECSPERYEAR</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newt</name> <operator>+=</operator> <name>seconds</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newt</name> <operator>-=</operator> <name>seconds</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>newt</name> <argument_list type="generic">&lt; <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
			<name>newt</name></expr></argument> &gt;</argument_list></name> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* "cannot happen" */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>localsub</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newt</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type>		<name>newy</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newy</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>tm_year</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newy</name> <operator>-=</operator> <name>years</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newy</name> <operator>+=</operator> <name>years</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>INT_MIN</name> <operator>&lt;=</operator> <name>newy</name> <operator>&amp;&amp;</operator> <name>newy</name> <operator>&lt;=</operator> <name>INT_MAX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>newy</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>defaulttype</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>lo</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>hi</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>mid</name> <init>= <expr><operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>mid</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>lo</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * To get (wrong) behavior that's compatible with System V Release 2.0
	 * you'd replace the statement below with t += ttisp-&gt;tt_utoff;
	 * timesub(&amp;t, 0L, sp, tmp);
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>timesub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>tm_zone</name></name> <operator>=</operator> <call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_desigidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type>
<name>pg_localtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pg_tz</name> <modifier>*</modifier></type><name>tz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>localsub</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tz</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>timep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_localtime_thread_safe is similar to pg_localtime.
 *
 * Except we don't use the global variable 'tm' to make it thread-safe.
 */</comment>
<function><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type>
<name>pg_localtime_thread_safe</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pg_tz</name> <modifier>*</modifier></type><name>tz</name></decl></parameter>,
						 <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>localsub</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tz</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>timep</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gmtsub is to gmtime as localsub is to localtime.
 *
 * Except we have a private "struct state" for GMT, so no sp is passed in.
 */</comment>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type>
<name>gmtsub</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name> <specifier>const</specifier> <modifier>*</modifier></type><name>timep</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>offset</name></decl></parameter>,
	   <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* GMT timezone state data is kept here */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>gmtptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>gmtptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Allocate on first use */</comment>
		<expr_stmt><expr><name>gmtptr</name> <operator>=</operator> <operator>(</operator>struct <name>state</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>gmtptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* errno should be set by malloc */</comment>
		<expr_stmt><expr><call><name>gmtload</name><argument_list>(<argument><expr><name>gmtptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>timesub</name><argument_list>(<argument><expr><name>timep</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>gmtptr</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Could get fancy here and deliver something such as "+xx" or "-xx" if
	 * offset is non-zero, but this is no time for a treasure hunt.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_zone</name></name> <operator>=</operator> <name>wildabbr</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_zone</name></name> <operator>=</operator> <name><name>gmtptr</name><operator>-&gt;</operator><name>chars</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type>
<name>pg_gmtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>gmtsub</name><argument_list>(<argument><expr><name>timep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the number of leap years through the end of the given year
 * where, to make the math easy, the answer for year zero is defined as zero.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>leaps_thru_end_of_nonneg</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>y</name> <operator>/</operator> <literal type="number">4</literal> <operator>-</operator> <name>y</name> <operator>/</operator> <literal type="number">100</literal> <operator>+</operator> <name>y</name> <operator>/</operator> <literal type="number">400</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>leaps_thru_end_of</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><ternary><condition><expr><name>y</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>
			?</condition><then> <expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <call><name>leaps_thru_end_of_nonneg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>y</name></expr></argument>)</argument_list></call></expr>
			</then><else>: <expr><call><name>leaps_thru_end_of_nonneg</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type>
<name>timesub</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>offset</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tmp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lsinfo</name></name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>tdays</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>idays</name></decl>;</decl_stmt>			<comment type="block">/* unsigned would be so 2003 */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>rem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>y</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name>  <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>corr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>corr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>sp</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>sp</name><operator>-&gt;</operator><name>leapcnt</name></name></expr></else></ternary></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>lsis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>timep</name> <operator>&gt;=</operator> <name><name>lp</name><operator>-&gt;</operator><name>ls_trans</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>corr</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>ls_corr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hit</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>timep</name> <operator>==</operator> <name><name>lp</name><operator>-&gt;</operator><name>ls_trans</name></name>
				   <operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>lp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ls_corr</name></expr></else></ternary><operator>)</operator> <operator>&lt;</operator> <name>corr</name><operator>)</operator></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <name>EPOCH_YEAR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tdays</name> <operator>=</operator> <operator>*</operator><name>timep</name> <operator>/</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rem</name> <operator>=</operator> <operator>*</operator><name>timep</name> <operator>%</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>tdays</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>tdays</name> <operator>&gt;=</operator> <name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>newy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>tdelta</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>idelta</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>leapdays</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tdelta</name> <operator>=</operator> <name>tdays</name> <operator>/</operator> <name>DAYSPERLYEAR</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><operator>!</operator><call><name>TYPE_SIGNED</name><argument_list>(<argument><expr><name>pg_time_t</name></expr></argument>)</argument_list></call> <operator>||</operator><name>INT_MIN</name> <operator>&lt;=</operator> <name>tdelta</name><operator>)</operator>
			  <operator>&amp;&amp;</operator> <name>tdelta</name> <operator>&lt;=</operator> <name>INT_MAX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>out_of_range</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>idelta</name> <operator>=</operator> <name>tdelta</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>idelta</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>idelta</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>tdays</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>newy</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>increment_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newy</name></expr></argument>, <argument><expr><name>idelta</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>out_of_range</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>leapdays</name> <operator>=</operator> <call><name>leaps_thru_end_of</name><argument_list>(<argument><expr><name>newy</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator>
			<call><name>leaps_thru_end_of</name><argument_list>(<argument><expr><name>y</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tdays</name> <operator>-=</operator> <operator>(</operator><operator>(</operator><name>pg_time_t</name><operator>)</operator> <name>newy</name> <operator>-</operator> <name>y</name><operator>)</operator> <operator>*</operator> <name>DAYSPERNYEAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tdays</name> <operator>-=</operator> <name>leapdays</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>y</name> <operator>=</operator> <name>newy</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Given the range, we can now fearlessly cast...
	 */</comment>
	<expr_stmt><expr><name>idays</name> <operator>=</operator> <name>tdays</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rem</name> <operator>+=</operator> <name>offset</name> <operator>-</operator> <name>corr</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>rem</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rem</name> <operator>+=</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>idays</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<while>while <condition>(<expr><name>rem</name> <operator>&gt;=</operator> <name>SECSPERDAY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rem</name> <operator>-=</operator> <name>SECSPERDAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>idays</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<while>while <condition>(<expr><name>idays</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>increment_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>out_of_range</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>idays</name> <operator>+=</operator> <name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<while>while <condition>(<expr><name>idays</name> <operator>&gt;=</operator> <name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>idays</name> <operator>-=</operator> <name><name>year_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>increment_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>out_of_range</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>increment_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmp</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>-</operator><name>TM_YEAR_BASE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>out_of_range</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_yday</name></name> <operator>=</operator> <name>idays</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The "extra" mods below avoid overflow problems.
	 */</comment>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>=</operator> <name>EPOCH_WDAY</name> <operator>+</operator>
		<operator>(</operator><operator>(</operator><name>y</name> <operator>-</operator> <name>EPOCH_YEAR</name><operator>)</operator> <operator>%</operator> <name>DAYSPERWEEK</name><operator>)</operator> <operator>*</operator>
		<operator>(</operator><name>DAYSPERNYEAR</name> <operator>%</operator> <name>DAYSPERWEEK</name><operator>)</operator> <operator>+</operator>
		<call><name>leaps_thru_end_of</name><argument_list>(<argument><expr><name>y</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>leaps_thru_end_of</name><argument_list>(<argument><expr><name>EPOCH_YEAR</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator>
		<name>idays</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>%=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>+=</operator> <name>DAYSPERWEEK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>rem</name> <operator>/</operator> <name>SECSPERHOUR</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>rem</name> <operator>%=</operator> <name>SECSPERHOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>rem</name> <operator>/</operator> <name>SECSPERMIN</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * A positive leap second requires a special representation. This uses
	 * "... ??:59:60" et seq.
	 */</comment>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>rem</name> <operator>%</operator> <name>SECSPERMIN</name><operator>)</operator> <operator>+</operator> <name>hit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ip</name> <operator>=</operator> <name><name>mon_lengths</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idays</name> <operator>&gt;=</operator> <name><name>ip</name><index>[<expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><operator>(</operator><name><name>tmp</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>)</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idays</name> <operator>-=</operator> <name><name>ip</name><index>[<expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>idays</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_isdst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tm_gmtoff</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
	<return>return <expr><name>tmp</name></expr>;</return>

<label><name>out_of_range</name>:</label>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EOVERFLOW</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Normalize logic courtesy Paul Eggert.
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>increment_overflow</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type>	<name>i</name> <init>= <expr><operator>*</operator><name>ip</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*----------
	 * If i &gt;= 0 there can only be overflow if i + j &gt; INT_MAX
	 * or if j &gt; INT_MAX - i; given i &gt;= 0, INT_MAX - i cannot overflow.
	 * If i &lt; 0 there can only be overflow if i + j &lt; INT_MIN
	 * or if j &lt; INT_MIN - i; given i &lt; 0, INT_MIN - i cannot overflow.
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>j</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>-</operator> <name>i</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>j</name> <operator>&lt;</operator> <name>INT_MIN</name> <operator>-</operator> <name>i</name><operator>)</operator></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>ip</name> <operator>+=</operator> <name>j</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>increment_overflow_time</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name> <modifier>*</modifier></type><name>tp</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>j</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*----------
	 * This is like
	 * 'if (! (TIME_T_MIN &lt;= *tp + j &amp;&amp; *tp + j &lt;= TIME_T_MAX)) ...',
	 * except that it does the right thing even if *tp + j would overflow.
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><ternary><condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>
		  ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><call><name>TYPE_SIGNED</name><argument_list>(<argument><expr><name>pg_time_t</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>TIME_T_MIN</name> <operator>-</operator> <name>j</name> <operator>&lt;=</operator> <operator>*</operator><name>tp</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>j</name> <operator>&lt;</operator> <operator>*</operator><name>tp</name></expr></else></ternary><operator>)</operator></expr>
		  </then><else>: <expr><operator>*</operator><name>tp</name> <operator>&lt;=</operator> <name>TIME_T_MAX</name> <operator>-</operator> <name>j</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>tp</name> <operator>+=</operator> <name>j</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the next DST transition time in the given zone after the given time
 *
 * *timep and *tz are input arguments, the other parameters are output values.
 *
 * When the function result is 1, *boundary is set to the pg_time_t
 * representation of the next DST transition time after *timep,
 * *before_gmtoff and *before_isdst are set to the GMT offset and isdst
 * state prevailing just before that boundary (in particular, the state
 * prevailing at *timep), and *after_gmtoff and *after_isdst are set to
 * the state prevailing just after that boundary.
 *
 * When the function result is 0, there is no known DST transition
 * after *timep, but *before_gmtoff and *before_isdst indicate the GMT
 * offset and isdst state prevailing at *timep.  (This would occur in
 * DST-less time zones, or if a zone has permanently ceased using DST.)
 *
 * A function result of -1 indicates failure (this case does not actually
 * occur in our current implementation).
 */</comment>
<function><type><name>int</name></type>
<name>pg_next_dst_boundary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>,
					 <parameter><decl><type><name>long</name> <name>int</name> <modifier>*</modifier></type><name>before_gmtoff</name></decl></parameter>,
					 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>before_isdst</name></decl></parameter>,
					 <parameter><decl><type><name>pg_time_t</name> <modifier>*</modifier></type><name>boundary</name></decl></parameter>,
					 <parameter><decl><type><name>long</name> <name>int</name> <modifier>*</modifier></type><name>after_gmtoff</name></decl></parameter>,
					 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>after_isdst</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>pg_tz</name> <modifier>*</modifier></type><name>tz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type><name>ttisp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>pg_time_t</name></type> <name>t</name> <init>= <expr><operator>*</operator><name>timep</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>tz</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* non-DST zone, use lowest-numbered standard type */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt></block_content></block></while>
		<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>before_gmtoff</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>before_isdst</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>goback</name></name> <operator>&amp;&amp;</operator> <name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>goahead</name></name> <operator>&amp;&amp;</operator> <name>t</name> <operator>&gt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* For values outside the transition table, extrapolate */</comment>
		<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>newt</name> <init>= <expr><name>t</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>seconds</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>tcycles</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>icycles</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>t</name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><operator>--</operator><name>seconds</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tcycles</name> <operator>=</operator> <name>seconds</name> <operator>/</operator> <name>YEARSPERREPEAT</name> <operator>/</operator> <name>AVGSECSPERYEAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>tcycles</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>icycles</name> <operator>=</operator> <name>tcycles</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tcycles</name> <operator>-</operator> <name>icycles</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name>icycles</name> <operator>-</operator> <name>tcycles</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>icycles</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>seconds</name> <operator>*=</operator> <name>YEARSPERREPEAT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>seconds</name> <operator>*=</operator> <name>AVGSECSPERYEAR</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newt</name> <operator>+=</operator> <name>seconds</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newt</name> <operator>-=</operator> <name>seconds</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>newt</name> <argument_list type="generic">&lt; <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
			<name>newt</name></expr></argument> &gt;</argument_list></name> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* "cannot happen" */</comment>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_next_dst_boundary</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newt</name></expr></argument>, <argument><expr><name>before_gmtoff</name></expr></argument>,
									  <argument><expr><name>before_isdst</name></expr></argument>,
									  <argument><expr><name>boundary</name></expr></argument>,
									  <argument><expr><name>after_gmtoff</name></expr></argument>,
									  <argument><expr><name>after_isdst</name></expr></argument>,
									  <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>boundary</name> <operator>-=</operator> <name>seconds</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>boundary</name> <operator>+=</operator> <name>seconds</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No known transition &gt; t, so use last known segment's type */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>before_gmtoff</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>before_isdst</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* For "before", use lowest-numbered standard type */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_isdst</name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt></block_content></block></while>
		<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>before_gmtoff</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>before_isdst</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>boundary</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* And for "after", use the first segment's type */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>after_gmtoff</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>after_isdst</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Else search to find the boundary following t */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>lo</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>hi</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>mid</name> <init>= <expr><operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>mid</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>lo</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>before_gmtoff</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>before_isdst</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>boundary</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>after_gmtoff</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>after_isdst</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Identify a timezone abbreviation's meaning in the given zone
 *
 * Determine the GMT offset and DST flag associated with the abbreviation.
 * This is generally used only when the abbreviation has actually changed
 * meaning over time; therefore, we also take a UTC cutoff time, and return
 * the meaning in use at or most recently before that time, or the meaning
 * in first use after that time if the abbrev was never used before that.
 *
 * On success, returns true and sets *gmtoff and *isdst.  If the abbreviation
 * was never used at all in this zone, returns false.
 *
 * Note: abbrev is matched case-sensitively; it should be all-upper-case.
 */</comment>
<function><type><name>bool</name></type>
<name>pg_interpret_timezone_abbrev</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abbrev</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>pg_time_t</name> <modifier>*</modifier></type><name>timep</name></decl></parameter>,
							 <parameter><decl><type><name>long</name> <name>int</name> <modifier>*</modifier></type><name>gmtoff</name></decl></parameter>,
							 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>isdst</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>pg_tz</name> <modifier>*</modifier></type><name>tz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abbrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ttinfo</name></name> <modifier>*</modifier></type><name>ttisp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>abbrind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cutoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>pg_time_t</name></type> <name>t</name> <init>= <expr><operator>*</operator><name>timep</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>tz</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Locate the abbreviation in the zone's abbreviation list.  We assume
	 * there are not duplicates in the list.
	 */</comment>
	<expr_stmt><expr><name>abbrs</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>chars</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>abbrind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>abbrind</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>abbrev</name></expr></argument>, <argument><expr><name>abbrs</name> <operator>+</operator> <name>abbrind</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<while>while <condition>(<expr><name><name>abbrs</name><index>[<expr><name>abbrind</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>abbrind</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name>abbrind</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>abbrind</name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>charcnt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* not there! */</comment>

	<comment type="block">/*
	 * Unlike pg_next_dst_boundary, we needn't sweat about extrapolation
	 * (goback/goahead zones).  Finding the newest or oldest meaning of the
	 * abbreviation should get us what we want, since extrapolation would just
	 * be repeating the newest or oldest meanings.
	 *
	 * Use binary search to locate the first transition &gt; cutoff time.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>lo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>hi</name> <init>= <expr><name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>mid</name> <init>= <expr><operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ats</name><index>[<expr><name>mid</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name>cutoff</name> <operator>=</operator> <name>lo</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Scan backwards to find the latest interval using the given abbrev
	 * before the cutoff time.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>cutoff</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_desigidx</name></name> <operator>==</operator> <name>abbrind</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>gmtoff</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>isdst</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Not there, so scan forwards to find the first one after.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>cutoff</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>timecnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>ttisp</name> <operator>=</operator> <operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ttisp</name><operator>-&gt;</operator><name>tt_desigidx</name></name> <operator>==</operator> <name>abbrind</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>gmtoff</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_utoff</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>isdst</name> <operator>=</operator> <name><name>ttisp</name><operator>-&gt;</operator><name>tt_isdst</name></name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* hm, not actually used in any interval? */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * If the given timezone uses only one GMT offset, store that offset
 * into *gmtoff and return true, else return false.
 */</comment>
<function><type><name>bool</name></type>
<name>pg_get_timezone_offset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_tz</name> <modifier>*</modifier></type><name>tz</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>int</name> <modifier>*</modifier></type><name>gmtoff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The zone could have more than one ttinfo, if it's historically used
	 * more than one abbreviation.  We return true as long as they all have
	 * the same gmtoff.
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>tz</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>typecnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tt_utoff</name> <operator>!=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tt_utoff</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>gmtoff</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ttis</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tt_utoff</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the name of the current timezone
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pg_get_timezone_name</name><parameter_list>(<parameter><decl><type><name>pg_tz</name> <modifier>*</modifier></type><name>tz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>tz</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>tz</name><operator>-&gt;</operator><name>TZname</name></name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether timezone is acceptable.
 *
 * What we are doing here is checking for leap-second-aware timekeeping.
 * We need to reject such TZ settings because they'll wreak havoc with our
 * date/time arithmetic.
 */</comment>
<function><type><name>bool</name></type>
<name>pg_tz_acceptable</name><parameter_list>(<parameter><decl><type><name>pg_tz</name> <modifier>*</modifier></type><name>tz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>time2000</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To detect leap-second timekeeping, run pg_localtime for what should be
	 * GMT midnight, 2000-01-01.  Insist that the tm_sec value be zero; any
	 * other result has to be due to leap seconds.
	 */</comment>
	<expr_stmt><expr><name>time2000</name> <operator>=</operator> <operator>(</operator><name>POSTGRES_EPOCH_JDATE</name> <operator>-</operator> <name>UNIX_EPOCH_JDATE</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_DAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tt</name> <operator>=</operator> <call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time2000</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tt</name> <operator>||</operator> <name><name>tt</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
