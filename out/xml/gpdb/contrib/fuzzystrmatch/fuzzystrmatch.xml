<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/contrib/fuzzystrmatch/fuzzystrmatch.c"><comment type="block">/*
 * fuzzystrmatch.c
 *
 * Functions for "fuzzy" comparison of strings
 *
 * Joe Conway &lt;mail@joeconway.com&gt;
 *
 * contrib/fuzzystrmatch/fuzzystrmatch.c
 * Copyright (c) 2001-2019, PostgreSQL Global Development Group
 * ALL RIGHTS RESERVED;
 *
 * metaphone()
 * -----------
 * Modified for PostgreSQL by Joe Conway.
 * Based on CPAN's "Text-Metaphone-1.96" by Michael G Schwern &lt;schwern@pobox.com&gt;
 * Code slightly modified for use as PostgreSQL function (palloc, elog, etc).
 * Metaphone was originally created by Lawrence Philips and presented in article
 * in "Computer Language" December 1990 issue.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE AUTHOR OR DISTRIBUTORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE AUTHOR AND DISTRIBUTORS HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block">/*
 * Soundex
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_soundex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>instr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>outstr</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOUNDEX_LEN</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/*									ABCDEFGHIJKLMNOPQRSTUVWXYZ */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>soundex_table</name> <init>= <expr><literal type="string">"01230120022455012623010202"</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>char</name></type>
<name>soundex_code</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>letter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>letter</name> <operator>=</operator> <call><name>toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>letter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Defend against non-ASCII letters */</comment>
	<if_stmt><if>if <condition>(<expr><name>letter</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>letter</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>soundex_table</name><index>[<expr><name>letter</name> <operator>-</operator> <literal type="char">'A'</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>letter</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Metaphone
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_METAPHONE_STRLEN</name></cpp:macro>		<cpp:value>255</cpp:value></cpp:define>

<comment type="block">/*
 * Original code by Michael G Schwern starts here.
 * Code slightly modified for use as PostgreSQL function.
 */</comment>


<comment type="block" format="doxygen">/**************************************************************************
	metaphone -- Breaks english phrases down into their phonemes.

	Input
		word			--	An english word to be phonized
		max_phonemes	--	How many phonemes to calculate.  If 0, then it
							will phonize the entire phrase.
		phoned_word		--	The final phonized word.  (We'll allocate the
							memory.)
	Output
		error	--	A simple error flag, returns true or false

	NOTES:	ALL non-alpha characters are ignored, this includes whitespace,
	although non-alpha characters will break up phonemes.
****************************************************************************/</comment>


<comment type="block">/*	I add modifications to the traditional metaphone algorithm that you
	might find in books.  Define this if you want metaphone to behave
	traditionally */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>USE_TRADITIONAL_METAPHONE</name></cpp:undef>

<comment type="block">/* Special encodings */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>SH</name></cpp:macro>		<cpp:value>'X'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>TH</name></cpp:macro>		<cpp:value>'0'</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>Lookahead</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>how_far</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_metaphone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_phonemes</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>phoned_word</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Metachar.h ... little bits about characters for metaphone */</comment>


<comment type="block">/*-- Character encoding array &amp; accessing macros --*/</comment>
<comment type="block">/* Stolen directly out of the book... */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>_codes</name><index>[<expr><literal type="number">26</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><literal type="number">1</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>
<comment type="block">/*	a  b c	d e f g  h i j k l m n o p q r s t u v w x y z */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>getcode</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Defend against non-ASCII letters */</comment>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>_codes</name><index>[<expr><name>c</name> <operator>-</operator> <literal type="char">'A'</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isvowel</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(getcode(c) &amp; 1)</cpp:value></cpp:define>	<comment type="block">/* AEIOU */</comment>

<comment type="block">/* These letters are passed through unchanged */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOCHANGE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(getcode(c) &amp; 2)</cpp:value></cpp:define>	<comment type="block">/* FJMNR */</comment>

<comment type="block">/* These form diphthongs when preceding H */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFFECTH</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(getcode(c) &amp; 4)</cpp:value></cpp:define>	<comment type="block">/* CGPST */</comment>

<comment type="block">/* These make C and G soft */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAKESOFT</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(getcode(c) &amp; 8)</cpp:value></cpp:define>	<comment type="block">/* EIY */</comment>

<comment type="block">/* These prevent GH from becoming F */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOGHTOF</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(getcode(c) &amp; 16)</cpp:value></cpp:define>	<comment type="block">/* BDH */</comment>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>levenshtein_with_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>levenshtein_with_costs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ins_c</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>del_c</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sub_c</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>s_bytes</name></decl>,
				<decl><type ref="prev"/><name>t_bytes</name></decl>;</decl_stmt>

	<comment type="block">/* Extract a pointer to the actual character data */</comment>
	<expr_stmt><expr><name>s_data</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t_data</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Determine length of each string in bytes */</comment>
	<expr_stmt><expr><name>s_bytes</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t_bytes</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>varstr_levenshtein</name><argument_list>(<argument><expr><name>s_data</name></expr></argument>, <argument><expr><name>s_bytes</name></expr></argument>, <argument><expr><name>t_data</name></expr></argument>, <argument><expr><name>t_bytes</name></expr></argument>,
									   <argument><expr><name>ins_c</name></expr></argument>, <argument><expr><name>del_c</name></expr></argument>, <argument><expr><name>sub_c</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>levenshtein</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>levenshtein</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>s_bytes</name></decl>,
				<decl><type ref="prev"/><name>t_bytes</name></decl>;</decl_stmt>

	<comment type="block">/* Extract a pointer to the actual character data */</comment>
	<expr_stmt><expr><name>s_data</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t_data</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Determine length of each string in bytes */</comment>
	<expr_stmt><expr><name>s_bytes</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t_bytes</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>varstr_levenshtein</name><argument_list>(<argument><expr><name>s_data</name></expr></argument>, <argument><expr><name>s_bytes</name></expr></argument>, <argument><expr><name>t_data</name></expr></argument>, <argument><expr><name>t_bytes</name></expr></argument>,
									   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>levenshtein_less_equal_with_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>levenshtein_less_equal_with_costs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ins_c</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>del_c</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sub_c</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_d</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>s_bytes</name></decl>,
				<decl><type ref="prev"/><name>t_bytes</name></decl>;</decl_stmt>

	<comment type="block">/* Extract a pointer to the actual character data */</comment>
	<expr_stmt><expr><name>s_data</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t_data</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Determine length of each string in bytes */</comment>
	<expr_stmt><expr><name>s_bytes</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t_bytes</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>varstr_levenshtein_less_equal</name><argument_list>(<argument><expr><name>s_data</name></expr></argument>, <argument><expr><name>s_bytes</name></expr></argument>,
												  <argument><expr><name>t_data</name></expr></argument>, <argument><expr><name>t_bytes</name></expr></argument>,
												  <argument><expr><name>ins_c</name></expr></argument>, <argument><expr><name>del_c</name></expr></argument>, <argument><expr><name>sub_c</name></expr></argument>,
												  <argument><expr><name>max_d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>levenshtein_less_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>levenshtein_less_equal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_d</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>s_bytes</name></decl>,
				<decl><type ref="prev"/><name>t_bytes</name></decl>;</decl_stmt>

	<comment type="block">/* Extract a pointer to the actual character data */</comment>
	<expr_stmt><expr><name>s_data</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t_data</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Determine length of each string in bytes */</comment>
	<expr_stmt><expr><name>s_bytes</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t_bytes</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>varstr_levenshtein_less_equal</name><argument_list>(<argument><expr><name>s_data</name></expr></argument>, <argument><expr><name>s_bytes</name></expr></argument>,
												  <argument><expr><name>t_data</name></expr></argument>, <argument><expr><name>t_bytes</name></expr></argument>,
												  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
												  <argument><expr><name>max_d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Calculates the metaphone of an input string.
 * Returns number of characters requested
 * (suggested value is 4)
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>metaphone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>metaphone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str_i</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>str_i_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str_i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>reqlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>metaph</name></decl>;</decl_stmt>

	<comment type="block">/* return an empty string if we receive one */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>str_i_len</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>str_i_len</name> <operator>&gt;</operator> <name>MAX_METAPHONE_STRLEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument exceeds the maximum length of %d bytes"</literal></expr></argument>,
						<argument><expr><name>MAX_METAPHONE_STRLEN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reqlen</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>reqlen</name> <operator>&gt;</operator> <name>MAX_METAPHONE_STRLEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"output exceeds the maximum length of %d bytes"</literal></expr></argument>,
						<argument><expr><name>MAX_METAPHONE_STRLEN</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>reqlen</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ZERO_LENGTH_CHARACTER_STRING</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"output cannot be empty string"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>_metaphone</name><argument_list>(<argument><expr><name>str_i</name></expr></argument>, <argument><expr><name>reqlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>metaph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>metaph</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Original code by Michael G Schwern starts here.
 * Code slightly modified for use as PostgreSQL
 * function (palloc, etc).
 */</comment>

<comment type="block">/* I suppose I could have been using a character pointer instead of
 * accessing the array directly... */</comment>

<comment type="block">/* Look at the next letter in the word */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Next_Letter</name></cpp:macro> <cpp:value>(toupper((unsigned char) word[w_idx+1]))</cpp:value></cpp:define>
<comment type="block">/* Look at the current letter in the word */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Curr_Letter</name></cpp:macro> <cpp:value>(toupper((unsigned char) word[w_idx]))</cpp:value></cpp:define>
<comment type="block">/* Go N letters back. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Look_Back_Letter</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(w_idx &gt;= (n) ? toupper((unsigned char) word[w_idx-(n)]) : '\0')</cpp:value></cpp:define>
<comment type="block">/* Previous letter.  I dunno, should this return null on failure? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Prev_Letter</name></cpp:macro> <cpp:value>(Look_Back_Letter(1))</cpp:value></cpp:define>
<comment type="block">/* Look two letters down.  It makes sure you don't walk off the string. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>After_Next_Letter</name></cpp:macro> \
	<cpp:value>(Next_Letter != '\0' ? toupper((unsigned char) word[w_idx+2]) : '\0')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Look_Ahead_Letter</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>toupper((unsigned char) Lookahead(word+w_idx, n))</cpp:value></cpp:define>


<comment type="block">/* Allows us to safely look ahead an arbitrary # of letters */</comment>
<comment type="block">/* I probably could have just used strlen... */</comment>
<function><type><specifier>static</specifier> <name>char</name></type>
<name>Lookahead</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>how_far</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>letter_ahead</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* null by default */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>word</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>idx</name> <operator>&lt;</operator> <name>how_far</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
	<comment type="block">/* Edge forward in the string... */</comment>

	<expr_stmt><expr><name>letter_ahead</name> <operator>=</operator> <name><name>word</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>	<comment type="block">/* idx will be either == to how_far or at the
								 * end of the string */</comment>
	<return>return <expr><name>letter_ahead</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* phonize one letter */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Phonize</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>do {(*phoned_word)[p_idx++] = c;} while (0)</cpp:value></cpp:define>
<comment type="block">/* Slap a null character on the end of the phoned word */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>End_Phoned_Word</name></cpp:macro> <cpp:value>do {(*phoned_word)[p_idx] = '\0';} while (0)</cpp:value></cpp:define>
<comment type="block">/* How long is the phoned word? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Phone_Len</name></cpp:macro>	<cpp:value>(p_idx)</cpp:value></cpp:define>

<comment type="block">/* Note is a letter is a 'break' in the word */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Isbreak</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(!isalpha((unsigned char) (c)))</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_metaphone</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,			<comment type="block">/* IN */</comment>
		   <parameter><decl><type><name>int</name></type> <name>max_phonemes</name></decl></parameter>,
		   <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>phoned_word</name></decl></parameter>)</parameter_list>	<comment type="block">/* OUT */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>w_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* point in the phonization we're at. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>p_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* end of the phoned phrase */</comment>

	<comment type="block">/*-- Parameter checks --*/</comment>

	<comment type="block">/*
	 * Shouldn't be necessary, but left these here anyway jec Aug 3, 2001
	 */</comment>

	<comment type="block">/* Negative phoneme length is meaningless */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>max_phonemes</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* internal error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"metaphone: Requested output length must be &gt; 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Empty/null string is meaningless */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>word</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>!</operator><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* internal error */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"metaphone: Input string length must be &gt; 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*-- Allocate memory for our phoned_phrase --*/</comment>
	<if_stmt><if>if <condition>(<expr><name>max_phonemes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>							<comment type="block">/* Assume largest possible */</comment>
		<expr_stmt><expr><operator>*</operator><name>phoned_word</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>phoned_word</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_phonemes</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*-- The first phoneme has to be processed specially. --*/</comment>
	<comment type="block">/* Find our first letter */</comment>
	<for>for <control>(<init>;</init> <condition><expr><operator>!</operator><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>(</operator><name>Curr_Letter</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>w_idx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* On the off chance we were given nothing but crap... */</comment>
		<if_stmt><if>if <condition>(<expr><name>Curr_Letter</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>End_Phoned_Word</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<switch>switch <condition>(<expr><name>Curr_Letter</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* AE becomes E */</comment>
		<case>case <expr><literal type="char">'A'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'E'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>w_idx</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<comment type="block">/* Remember, preserve vowels at the beginning */</comment>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'A'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>w_idx</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
			<comment type="block">/* [GKP]N becomes N */</comment>
		<case>case <expr><literal type="char">'G'</literal></expr>:</case>
		<case>case <expr><literal type="char">'K'</literal></expr>:</case>
		<case>case <expr><literal type="char">'P'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'N'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'N'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>w_idx</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * WH becomes H, WR becomes R W if followed by a vowel
			 */</comment>
		<case>case <expr><literal type="char">'W'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'H'</literal> <operator>||</operator>
				<name>Next_Letter</name> <operator>==</operator> <literal type="char">'R'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><name>Next_Letter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>w_idx</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>isvowel</name><argument_list>(<argument><expr><name>Next_Letter</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'W'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>w_idx</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* else ignore */</comment>
			<break>break;</break>
			<comment type="block">/* X becomes S */</comment>
		<case>case <expr><literal type="char">'X'</literal></expr>:</case>
			<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>w_idx</name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* Vowels are kept */</comment>

			<comment type="block">/*
			 * We did A already case 'A': case 'a':
			 */</comment>
		<case>case <expr><literal type="char">'E'</literal></expr>:</case>
		<case>case <expr><literal type="char">'I'</literal></expr>:</case>
		<case>case <expr><literal type="char">'O'</literal></expr>:</case>
		<case>case <expr><literal type="char">'U'</literal></expr>:</case>
			<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><name>Curr_Letter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>w_idx</name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* do nothing */</comment>
			<break>break;</break>
	</block_content>}</block></switch>



	<comment type="block">/* On to the metaphoning */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>Curr_Letter</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
		 <operator>(</operator><name>max_phonemes</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>Phone_Len</name> <operator>&lt;</operator> <name>max_phonemes</name><operator>)</operator></expr>;</condition>
		 <incr><expr><name>w_idx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * How many letters to skip because an earlier encoding handled
		 * multiple letters
		 */</comment>
		<decl_stmt><decl><type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>skip_letter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


		<comment type="block">/*
		 * THOUGHT:  It would be nice if, rather than having things like...
		 * well, SCI.  For SCI you encode the S, then have to remember to skip
		 * the C.  So the phonome SCI invades both S and C.  It would be
		 * better, IMHO, to skip the C from the S part of the encoding. Hell,
		 * I'm trying it.
		 */</comment>

		<comment type="block">/* Ignore non-alphas */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>(</operator><name>Curr_Letter</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Drop duplicates, except CC */</comment>
		<if_stmt><if>if <condition>(<expr><name>Curr_Letter</name> <operator>==</operator> <name>Prev_Letter</name> <operator>&amp;&amp;</operator>
			<name>Curr_Letter</name> <operator>!=</operator> <literal type="char">'C'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>Curr_Letter</name></expr>)</condition>
		<block>{<block_content>
				<comment type="block">/* B -&gt; B unless in MB */</comment>
			<case>case <expr><literal type="char">'B'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>Prev_Letter</name> <operator>!=</operator> <literal type="char">'M'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'B'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * 'sh' if -CIA- or -CH, but not SCH, except SCHW. (SCHW is
				 * handled in S) S if -CI-, -CE- or -CY- dropped if -SCI-,
				 * SCE-, -SCY- (handed in S) else K
				 */</comment>
			<case>case <expr><literal type="char">'C'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>MAKESOFT</name><argument_list>(<argument><expr><name>Next_Letter</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>				<comment type="block">/* C[IEY] */</comment>
					<if_stmt><if>if <condition>(<expr><name>After_Next_Letter</name> <operator>==</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator>
						<name>Next_Letter</name> <operator>==</operator> <literal type="char">'I'</literal></expr>)</condition>
					<block>{<block_content>			<comment type="block">/* CIA */</comment>
						<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><name>SH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<comment type="block">/* SC[IEY] */</comment>
					<if type="elseif">else if <condition>(<expr><name>Prev_Letter</name> <operator>==</operator> <literal type="char">'S'</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Dropped */</comment>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'H'</literal></expr>)</condition>
				<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_TRADITIONAL_METAPHONE</name></cpp:ifndef>
					<if_stmt><if>if <condition>(<expr><name>After_Next_Letter</name> <operator>==</operator> <literal type="char">'R'</literal> <operator>||</operator>
						<name>Prev_Letter</name> <operator>==</operator> <literal type="char">'S'</literal></expr>)</condition>
					<block>{<block_content>			<comment type="block">/* Christ, School */</comment>
						<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'K'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><name>SH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><name>SH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name>skip_letter</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'K'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * J if in -DGE-, -DGI- or -DGY- else T
				 */</comment>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'G'</literal> <operator>&amp;&amp;</operator>
					<call><name>MAKESOFT</name><argument_list>(<argument><expr><name>After_Next_Letter</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'J'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>skip_letter</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'T'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * F if in -GH and not B--GH, D--GH, -H--GH, -H---GH else
				 * dropped if -GNED, -GN, else dropped if -DGE-, -DGI- or
				 * -DGY- (handled in D) else J if in -GE-, -GI, -GY and not GG
				 * else K
				 */</comment>
			<case>case <expr><literal type="char">'G'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'H'</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>NOGHTOF</name><argument_list>(<argument><expr><call><name>Look_Back_Letter</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
						  <call><name>Look_Back_Letter</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'H'</literal><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'F'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>skip_letter</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* silent */</comment>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'N'</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>Isbreak</name><argument_list>(<argument><expr><name>After_Next_Letter</name></expr></argument>)</argument_list></call> <operator>||</operator>
						<operator>(</operator><name>After_Next_Letter</name> <operator>==</operator> <literal type="char">'E'</literal> <operator>&amp;&amp;</operator>
						 <call><name>Look_Ahead_Letter</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'D'</literal><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* dropped */</comment>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'K'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>MAKESOFT</name><argument_list>(<argument><expr><name>Next_Letter</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						 <name>Prev_Letter</name> <operator>!=</operator> <literal type="char">'G'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'J'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'K'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
				<comment type="block">/* H if before a vowel and not after C,G,P,S,T */</comment>
			<case>case <expr><literal type="char">'H'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>isvowel</name><argument_list>(<argument><expr><name>Next_Letter</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>AFFECTH</name><argument_list>(<argument><expr><name>Prev_Letter</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * dropped if after C else K
				 */</comment>
			<case>case <expr><literal type="char">'K'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>Prev_Letter</name> <operator>!=</operator> <literal type="char">'C'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'K'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * F if before H else P
				 */</comment>
			<case>case <expr><literal type="char">'P'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'H'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'F'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'P'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * K
				 */</comment>
			<case>case <expr><literal type="char">'Q'</literal></expr>:</case>
				<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'K'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * 'sh' in -SH-, -SIO- or -SIA- or -SCHW- else S
				 */</comment>
			<case>case <expr><literal type="char">'S'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'I'</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name>After_Next_Letter</name> <operator>==</operator> <literal type="char">'O'</literal> <operator>||</operator>
					 <name>After_Next_Letter</name> <operator>==</operator> <literal type="char">'A'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><name>SH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'H'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><name>SH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>skip_letter</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_TRADITIONAL_METAPHONE</name></cpp:ifndef>
				<if type="elseif">else if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'C'</literal> <operator>&amp;&amp;</operator>
						 <call><name>Look_Ahead_Letter</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'H'</literal> <operator>&amp;&amp;</operator>
						 <call><name>Look_Ahead_Letter</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'W'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><name>SH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>skip_letter</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * 'sh' in -TIA- or -TIO- else 'th' before H else T
				 */</comment>
			<case>case <expr><literal type="char">'T'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'I'</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name>After_Next_Letter</name> <operator>==</operator> <literal type="char">'O'</literal> <operator>||</operator>
					 <name>After_Next_Letter</name> <operator>==</operator> <literal type="char">'A'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><name>SH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>Next_Letter</name> <operator>==</operator> <literal type="char">'H'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><name>TH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>skip_letter</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'T'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
				<comment type="block">/* F */</comment>
			<case>case <expr><literal type="char">'V'</literal></expr>:</case>
				<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'F'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
				<comment type="block">/* W before a vowel, else dropped */</comment>
			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>isvowel</name><argument_list>(<argument><expr><name>Next_Letter</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'W'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
				<comment type="block">/* KS */</comment>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
				<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'K'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>max_phonemes</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>Phone_Len</name> <operator>&lt;</operator> <name>max_phonemes</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
				<comment type="block">/* Y if followed by a vowel */</comment>
			<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>isvowel</name><argument_list>(<argument><expr><name>Next_Letter</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'Y'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
				<comment type="block">/* S */</comment>
			<case>case <expr><literal type="char">'Z'</literal></expr>:</case>
				<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
				<comment type="block">/* No transformation */</comment>
			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
			<case>case <expr><literal type="char">'J'</literal></expr>:</case>
			<case>case <expr><literal type="char">'L'</literal></expr>:</case>
			<case>case <expr><literal type="char">'M'</literal></expr>:</case>
			<case>case <expr><literal type="char">'N'</literal></expr>:</case>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<expr_stmt><expr><call><name>Phonize</name><argument_list>(<argument><expr><name>Curr_Letter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* nothing */</comment>
				<break>break;</break>
		</block_content>}</block></switch>						<comment type="block">/* END SWITCH */</comment>

		<expr_stmt><expr><name>w_idx</name> <operator>+=</operator> <name>skip_letter</name></expr>;</expr_stmt>
	</block_content>}</block></for>							<comment type="block">/* END FOR */</comment>

	<expr_stmt><expr><name>End_Phoned_Word</name></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>								<comment type="block">/* END metaphone */</comment>


<comment type="block">/*
 * SQL function: soundex(text) returns text
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>soundex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>soundex</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>outstr</name><index>[<expr><name>SOUNDEX_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_soundex</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>outstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>outstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_soundex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>instr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>outstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>outstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>outstr</name><index>[<expr><name>SOUNDEX_LEN</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* Skip leading non-alphabetic characters */</comment>
	<while>while <condition>(<expr><operator>!</operator><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>instr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>instr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>instr</name></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* No string left */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>instr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>outstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Take the first letter as is */</comment>
	<expr_stmt><expr><operator>*</operator><name>outstr</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <call><name>toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>instr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>instr</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>&lt;</operator> <name>SOUNDEX_LEN</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>instr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>soundex_code</name><argument_list>(<argument><expr><operator>*</operator><name>instr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>soundex_code</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>instr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>outstr</name> <operator>=</operator> <call><name>soundex_code</name><argument_list>(<argument><expr><name><name>instr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>outstr</name> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>++</operator><name>outstr</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>++</operator><name>instr</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Fill with 0's */</comment>
	<while>while <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>SOUNDEX_LEN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>outstr</name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>outstr</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>difference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>difference</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sndx1</name><index>[<expr><name>SOUNDEX_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>sndx2</name><index>[<expr><name>SOUNDEX_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>_soundex</name><argument_list>(<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sndx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_soundex</name><argument_list>(<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sndx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SOUNDEX_LEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sndx1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>sndx2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
