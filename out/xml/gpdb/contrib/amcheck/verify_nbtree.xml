<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/contrib/amcheck/verify_nbtree.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * verify_nbtree.c
 *		Verifies the integrity of nbtree indexes based on invariants.
 *
 * For B-Tree indexes, verification includes checking that each page in the
 * target index has items in logical order as reported by an insertion scankey
 * (the insertion scankey sort-wise NULL semantics are needed for
 * verification).
 *
 * When index-to-heap verification is requested, a Bloom filter is used to
 * fingerprint all tuples in the target index, as the index is traversed to
 * verify its structure.  A heap scan later uses Bloom filter probes to verify
 * that every visible heap tuple has a matching index tuple.
 *
 *
 * Copyright (c) 2017-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  contrib/amcheck/verify_nbtree.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/bloomfilter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>


<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block">/*
 * A B-Tree cannot possibly have this many levels, since there must be one
 * block per level, which is bound by the range of BlockNumber:
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>InvalidBtreeLevel</name></cpp:macro>	<cpp:value>((uint32) InvalidBlockNumber)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTreeTupleGetNKeyAtts</name><parameter_list>(<parameter><type><name>itup</name></type></parameter>, <parameter><type><name>rel</name></type></parameter>)</parameter_list></cpp:macro>   \
	<cpp:value>Min(IndexRelationGetNumberOfKeyAttributes(rel), BTreeTupleGetNAtts(itup, rel))</cpp:value></cpp:define>

<comment type="block">/*
 * State associated with verifying a B-Tree index
 *
 * target is the point of reference for a verification operation.
 *
 * Other B-Tree pages may be allocated, but those are always auxiliary (e.g.,
 * they are current target's child pages).  Conceptually, problems are only
 * ever found in the current target page (or for a particular heap tuple during
 * heapallindexed verification).  Each page found by verification's left/right,
 * top/bottom scan becomes the target exactly once.
 */</comment>
<typedef>typedef <type><struct>struct <name>BtreeCheckState</name>
<block>{
	<comment type="block">/*
	 * Unchanging state, established at start of verification:
	 */</comment>

	<comment type="block">/* B-Tree Index Relation and associated heap relation */</comment>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heaprel</name></decl>;</decl_stmt>
	<comment type="block">/* rel is heapkeyspace index? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>heapkeyspace</name></decl>;</decl_stmt>
	<comment type="block">/* ShareLock held on heap/index, rather than AccessShareLock? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>readonly</name></decl>;</decl_stmt>
	<comment type="block">/* Also verifying heap has no unindexed tuples? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>heapallindexed</name></decl>;</decl_stmt>
	<comment type="block">/* Also making sure non-pivot tuples can be found by new search? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rootdescend</name></decl>;</decl_stmt>
	<comment type="block">/* Per-page context */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>targetcontext</name></decl>;</decl_stmt>
	<comment type="block">/* Buffer access strategy */</comment>
	<decl_stmt><decl><type><name>BufferAccessStrategy</name></type> <name>checkstrategy</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Mutable state, for verification of particular page:
	 */</comment>

	<comment type="block">/* Current target page */</comment>
	<decl_stmt><decl><type><name>Page</name></type>		<name>target</name></decl>;</decl_stmt>
	<comment type="block">/* Target block number */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>targetblock</name></decl>;</decl_stmt>
	<comment type="block">/* Target page's LSN */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>targetlsn</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Mutable state, for optional heapallindexed verification:
	 */</comment>

	<comment type="block">/* Bloom filter fingerprints B-Tree index */</comment>
	<decl_stmt><decl><type><name>bloom_filter</name> <modifier>*</modifier></type><name>filter</name></decl>;</decl_stmt>
	<comment type="block">/* Bloom filter fingerprints downlink blocks within tree */</comment>
	<decl_stmt><decl><type><name>bloom_filter</name> <modifier>*</modifier></type><name>downlinkfilter</name></decl>;</decl_stmt>
	<comment type="block">/* Right half of incomplete split marker */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rightsplit</name></decl>;</decl_stmt>
	<comment type="block">/* Debug counter */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>heaptuplespresent</name></decl>;</decl_stmt>
}</block></struct></type> <name>BtreeCheckState</name>;</typedef>

<comment type="block">/*
 * Starting point for verifying an entire B-Tree index level
 */</comment>
<typedef>typedef <type><struct>struct <name>BtreeLevel</name>
<block>{
	<comment type="block">/* Level number (0 is leaf page level). */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>level</name></decl>;</decl_stmt>

	<comment type="block">/* Left most block on level.  Scan of level begins here. */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leftmost</name></decl>;</decl_stmt>

	<comment type="block">/* Is this level reported as "true" root level by meta page? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>istruerootlevel</name></decl>;</decl_stmt>
}</block></struct></type> <name>BtreeLevel</name>;</typedef>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>bt_index_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>bt_index_parent_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bt_index_check_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indrelid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parentcheck</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>heapallindexed</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rootdescend</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>btree_index_checkable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bt_check_every_level</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heaprel</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>heapkeyspace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>readonly</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>heapallindexed</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>rootdescend</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BtreeLevel</name></type> <name>bt_check_level_from_leftmost</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
											   <parameter><decl><type><name>BtreeLevel</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bt_target_page_check</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BTScanInsert</name></type> <name>bt_right_page_check_scankey</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bt_downlink_check</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>targetkey</name></decl></parameter>,
							  <parameter><decl><type><name>BlockNumber</name></type> <name>childblock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bt_downlink_missing_check</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bt_tuple_present_callback</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>,
									  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>tupleIsAlive</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>checkstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IndexTuple</name></type> <name>bt_normalize_tuple</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
									 <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>bt_rootdescend</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>offset_is_negative_infinity</name><parameter_list>(<parameter><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl></parameter>,
											   <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>invariant_l_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>key</name></decl></parameter>,
									  <parameter><decl><type><name>OffsetNumber</name></type> <name>upperbound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>invariant_leq_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
										<parameter><decl><type><name>BTScanInsert</name></type> <name>key</name></decl></parameter>,
										<parameter><decl><type><name>OffsetNumber</name></type> <name>upperbound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>invariant_g_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>key</name></decl></parameter>,
									  <parameter><decl><type><name>OffsetNumber</name></type> <name>lowerbound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>invariant_l_nontarget_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
												<parameter><decl><type><name>BTScanInsert</name></type> <name>key</name></decl></parameter>,
												<parameter><decl><type><name>BlockNumber</name></type> <name>nontargetblock</name></decl></parameter>,
												<parameter><decl><type><name>Page</name></type> <name>nontarget</name></decl></parameter>,
												<parameter><decl><type><name>OffsetNumber</name></type> <name>upperbound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Page</name></type> <name>palloc_btree_page</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>BTScanInsert</name></type> <name>bt_mkscankey_pivotsearch</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
													<parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ItemId</name></type> <name>PageGetItemIdCareful</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>block</name></decl></parameter>,
								   <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>ItemPointer</name></type> <name>BTreeTupleGetHeapTIDCareful</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
													  <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nonpivot</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * bt_index_check(index regclass, heapallindexed boolean)
 *
 * Verify integrity of B-Tree index.
 *
 * Acquires AccessShareLock on heap &amp; index relations.  Does not consider
 * invariants that exist between parent/child pages.  Optionally verifies
 * that heap does not contain any unindexed or incorrectly indexed tuples.
 */</comment>
<function><type><name>Datum</name></type>
<name>bt_index_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indrelid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>heapallindexed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>heapallindexed</name> <operator>=</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>bt_index_check_internal</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>heapallindexed</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bt_index_parent_check(index regclass, heapallindexed boolean)
 *
 * Verify integrity of B-Tree index.
 *
 * Acquires ShareLock on heap &amp; index relations.  Verifies that downlinks in
 * parent pages are valid lower bounds on child pages.  Optionally verifies
 * that heap does not contain any unindexed or incorrectly indexed tuples.
 */</comment>
<function><type><name>Datum</name></type>
<name>bt_index_parent_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indrelid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>heapallindexed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rootdescend</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>heapallindexed</name> <operator>=</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rootdescend</name> <operator>=</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>bt_index_check_internal</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>heapallindexed</name></expr></argument>, <argument><expr><name>rootdescend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper for bt_index_[parent_]check, coordinating the bulk of the work.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bt_index_check_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indrelid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parentcheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>heapallindexed</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>rootdescend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heaprel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>heapkeyspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>parentcheck</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>ShareLock</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We must lock table before index to avoid deadlocks.  However, if the
	 * passed indrelid isn't an index then IndexGetRelation() will fail.
	 * Rather than emitting a not-very-helpful error message, postpone
	 * complaining, expecting that the is-it-an-index test below will fail.
	 *
	 * In hot standby mode this will raise an error when parentcheck is true.
	 */</comment>
	<expr_stmt><expr><name>heapid</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>heapid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>heaprel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>heapid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>heaprel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Open the target index relations separately (like relation_openrv(), but
	 * with heap relation locked first to prevent deadlocking).  In hot
	 * standby mode this will raise an error when parentcheck is true.
	 *
	 * There is no need for the usual indcheckxmin usability horizon test
	 * here, even in the heapallindexed case, because index undergoing
	 * verification only needs to have entries for a new transaction snapshot.
	 * (If this is a parentcheck verification, there is no question about
	 * committed or recently dead heap tuples lacking index entries due to
	 * concurrent activity.)
	 */</comment>
	<expr_stmt><expr><name>indrel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we did the IndexGetRelation call above without any lock, it's
	 * barely possible that a race against an index drop/recreation could have
	 * netted us the wrong table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>heaprel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>heapid</name> <operator>!=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open parent table of index %s"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Relation suitable for checking as B-Tree? */</comment>
	<expr_stmt><expr><call><name>btree_index_checkable</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check index, possibly against table it is an index on */</comment>
	<expr_stmt><expr><name>heapkeyspace</name> <operator>=</operator> <call><name>_bt_heapkeyspace</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bt_check_every_level</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>heaprel</name></expr></argument>, <argument><expr><name>heapkeyspace</name></expr></argument>, <argument><expr><name>parentcheck</name></expr></argument>,
						 <argument><expr><name>heapallindexed</name></expr></argument>, <argument><expr><name>rootdescend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release locks early. That's ok here because nothing in the called
	 * routines will trigger shared cache invalidations to be sent, so we can
	 * relax the usual pattern of only releasing locks after commit.
	 */</comment>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>heaprel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>heaprel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Basic checks about the suitability of a relation for checking as a B-Tree
 * index.
 *
 * NB: Intentionally not checking permissions, the function is normally not
 * callable by non-superusers. If granted, it's useful to be able to check a
 * whole cluster.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>btree_index_checkable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only B-Tree indexes are supported as targets for verification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Relation \"%s\" is not a B-Tree index."</literal></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot access temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" is associated with temporary relation."</literal></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot check index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index is not valid."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Main entry point for B-Tree SQL-callable functions. Walks the B-Tree in
 * logical order, verifying invariants as it goes.  Optionally, verification
 * checks if the heap relation contains any tuples that are not represented in
 * the index but should be.
 *
 * It is the caller's responsibility to acquire appropriate heavyweight lock on
 * the index relation, and advise us if extra checks are safe when a ShareLock
 * is held.  (A lock of the same type must also have been acquired on the heap
 * relation.)
 *
 * A ShareLock is generally assumed to prevent any kind of physical
 * modification to the index structure, including modifications that VACUUM may
 * make.  This does not include setting of the LP_DEAD bit by concurrent index
 * scans, although that is just metadata that is not able to directly affect
 * any check performed here.  Any concurrent process that might act on the
 * LP_DEAD bit being set (recycle space) requires a heavyweight lock that
 * cannot be held while we hold a ShareLock.  (Besides, even if that could
 * happen, the ad-hoc recycling when a page might otherwise split is performed
 * per-page, and requires an exclusive buffer lock, which wouldn't cause us
 * trouble.  _bt_delitems_vacuum() may only delete leaf items, and so the extra
 * parent/child check cannot be affected.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bt_check_every_level</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heaprel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>heapkeyspace</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>readonly</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>heapallindexed</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rootdescend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>previouslevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BtreeLevel</name></type>	<name>current</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name> <init>= <expr><name>SnapshotAny</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * RecentGlobalXmin assertion matches index_getnext_tid().  See note on
	 * RecentGlobalXmin/B-Tree page deletion.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize state for entire verification operation
	 */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BtreeCheckState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heaprel</name></name> <operator>=</operator> <name>heaprel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapkeyspace</name></name> <operator>=</operator> <name>heapkeyspace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name> <operator>=</operator> <name>readonly</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapallindexed</name></name> <operator>=</operator> <name>heapallindexed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>rootdescend</name></name> <operator>=</operator> <name>rootdescend</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>heapallindexed</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>total_elems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>seed</name></decl>;</decl_stmt>

		<comment type="block">/* Size Bloom filter based on estimated number of tuples in index */</comment>
		<expr_stmt><expr><name>total_elems</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
		<comment type="block">/* Random seed relies on backend srandom() call to avoid repetition */</comment>
		<expr_stmt><expr><name>seed</name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Create Bloom filter to fingerprint index */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>filter</name></name> <operator>=</operator> <call><name>bloom_create</name><argument_list>(<argument><expr><name>total_elems</name></expr></argument>, <argument><expr><name>maintenance_work_mem</name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heaptuplespresent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Register our own snapshot in !readonly case, rather than asking
		 * table_index_build_scan() to do this for us later.  This needs to
		 * happen before index fingerprinting begins, so we can later be
		 * certain that index fingerprinting should have reached all tuples
		 * returned by table_index_build_scan().
		 *
		 * In readonly case, we also check for problems with missing
		 * downlinks. A second Bloom filter is used for this.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * GetTransactionSnapshot() always acquires a new MVCC snapshot in
			 * READ COMMITTED mode.  A new snapshot is guaranteed to have all
			 * the entries it requires in the index.
			 *
			 * We must defend against the possibility that an old xact
			 * snapshot was returned at higher isolation levels when that
			 * snapshot is not safe for index scans of the target index.  This
			 * is possible when the snapshot sees tuples that are before the
			 * index's indcheckxmin horizon.  Throwing an error here should be
			 * very rare.  It doesn't seem worth using a secondary snapshot to
			 * avoid this.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indcheckxmin</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indextuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" cannot be verified using transaction snapshot"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type>		<name>total_pages</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Extra readonly downlink check.
			 *
			 * In readonly case, we know that there cannot be a concurrent
			 * page split or a concurrent page deletion, which gives us the
			 * opportunity to verify that every non-ignorable page had a
			 * downlink one level up.  We must be tolerant of interrupted page
			 * splits and page deletions, though.  This is taken care of in
			 * bt_downlink_missing_check().
			 */</comment>
			<expr_stmt><expr><name>total_pages</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>downlinkfilter</name></name> <operator>=</operator> <call><name>bloom_create</name><argument_list>(<argument><expr><name>total_pages</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>rootdescend</name></name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>rootdescend</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot verify that tuples from index \"%s\" can each be found by an independent index search"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Only B-Tree version 4 indexes support rootdescend verification."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Create context for page */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>targetcontext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												 <argument><expr><literal type="string">"amcheck context"</literal></expr></argument>,
												 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>checkstrategy</name></name> <operator>=</operator> <call><name>GetAccessStrategy</name><argument_list>(<argument><expr><name>BAS_BULKREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get true root block from meta-page */</comment>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>palloc_btree_page</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Certain deletion patterns can result in "skinny" B-Tree indexes, where
	 * the fast root and true root differ.
	 *
	 * Start from the true root, not the fast root, unlike conventional index
	 * scans.  This approach is more thorough, and removes the risk of
	 * following a stale fast root from the meta page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>!=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"harmless fast root mismatch in index %s"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Fast root block %u (level %u) differs from true root block %u (level %u)."</literal></expr></argument>,
									<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name></expr></argument>, <argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name></expr></argument>,
									<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name></expr></argument>, <argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Starting at the root, verify every level.  Move left to right, top to
	 * bottom.  Note that there may be no pages other than the meta page (meta
	 * page can indicate that root is P_NONE when the index is totally empty).
	 */</comment>
	<expr_stmt><expr><name>previouslevel</name> <operator>=</operator> <name>InvalidBtreeLevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current</name><operator>.</operator><name>leftmost</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current</name><operator>.</operator><name>istruerootlevel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>current</name><operator>.</operator><name>leftmost</name></name> <operator>!=</operator> <name>P_NONE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Leftmost page on level cannot be right half of incomplete split.
		 * This can go stale immediately in !readonly case.
		 */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>rightsplit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Verify this level, and get left most page for next level down, if
		 * not at leaf level
		 */</comment>
		<expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>bt_check_level_from_leftmost</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>current</name><operator>.</operator><name>leftmost</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" has no valid pages on level below %u or first level"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>previouslevel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>previouslevel</name> <operator>=</operator> <name><name>current</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * * Check whether heap contains unindexed/malformed tuples *
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>heapallindexed</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexinfo</name> <init>= <expr><call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

		<comment type="block">/* Report on extra downlink checks performed in readonly case */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"finished verifying presence of downlink blocks within index \"%s\" with bitset %.2f%% set"</literal></expr></argument>,
									 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <call><name>bloom_prop_bits_set</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>downlinkfilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>bloom_free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>downlinkfilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Create our own scan for table_index_build_scan(), rather than
		 * getting it to do so for us.  This is required so that we can
		 * actually use the MVCC snapshot registered earlier in !readonly
		 * case.
		 *
		 * Note that table_index_build_scan() calls heap_endscan() for us.
		 */</comment>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_strat</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heaprel</name></name></expr></argument>,	<comment type="block">/* relation */</comment>
									 <argument><expr><name>snapshot</name></expr></argument>,	<comment type="block">/* snapshot */</comment>
									 <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* number of keys */</comment>
									 <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* scan key */</comment>
									 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* buffer access strategy OK */</comment>
									 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* syncscan OK? */</comment>

		<comment type="block">/*
		 * Scan will behave as the first scan of a CREATE INDEX CONCURRENTLY
		 * behaves in !readonly case.
		 *
		 * It's okay that we don't actually use the same lock strength for the
		 * heap relation as any other ii_Concurrent caller would in !readonly
		 * case.  We have no reason to care about a concurrent VACUUM
		 * operation, since there isn't going to be a second scan of the heap
		 * that needs to be sure that there was no concurrent recycling of
		 * TIDs.
		 */</comment>
		<expr_stmt><expr><name><name>indexinfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name> <operator>=</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Don't wait for uncommitted tuple xact commit/abort when index is a
		 * unique index on a catalog (or an index used by an exclusion
		 * constraint).  This could otherwise happen in the readonly case.
		 */</comment>
		<expr_stmt><expr><name><name>indexinfo</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexinfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexinfo</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexinfo</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"verifying that tuples from index \"%s\" are present in \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heaprel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_index_build_scan</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heaprel</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>indexinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><name>bt_tuple_present_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></argument>, <argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"finished verifying presence of "</literal> <name>INT64_FORMAT</name> <literal type="string">" tuples from table \"%s\" with bitset %.2f%% set"</literal></expr></argument>,
								 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>heaptuplespresent</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heaprel</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="number">100.0</literal> <operator>*</operator> <call><name>bloom_prop_bits_set</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>filter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>!=</operator> <name>SnapshotAny</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>bloom_free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Be tidy: */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a left-most block at some level, move right, verifying each page
 * individually (with more verification across pages for "readonly"
 * callers).  Caller should pass the true root page as the leftmost initially,
 * working their way down by passing what is returned for the last call here
 * until level 0 (leaf page level) was reached.
 *
 * Returns state for next call, if any.  This includes left-most block number
 * one level lower that should be passed on next level/call, which is set to
 * P_NONE on last call here (when leaf level is verified).  Level numbers
 * follow the nbtree convention: higher levels have higher numbers, because new
 * levels are added only due to a root page split.  Note that prior to the
 * first root page split, the root is also a leaf page, so there is always a
 * level 0 (leaf level), and it's always the last level processed.
 *
 * Note on memory management:  State's per-page context is reset here, between
 * each call to bt_target_page_check().
 */</comment>
<function><type><specifier>static</specifier> <name>BtreeLevel</name></type>
<name>bt_check_level_from_leftmost</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BtreeLevel</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* State to establish early, concerning entire level */</comment>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BtreeLevel</name></type>	<name>nextleveldown</name></decl>;</decl_stmt>

	<comment type="block">/* Variables for iterating across level using right links */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leftcurrent</name> <init>= <expr><name>P_NONE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>current</name> <init>= <expr><name><name>level</name><operator>.</operator><name>leftmost</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Initialize return state */</comment>
	<expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>leftmost</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name>InvalidBtreeLevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>istruerootlevel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Use page-level context for duration of this call */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"verifying level %u%s"</literal></expr></argument>, <argument><expr><name><name>level</name><operator>.</operator><name>level</name></name></expr></argument>,
		 <argument><expr><ternary><condition><expr><name><name>level</name><operator>.</operator><name>istruerootlevel</name></name></expr> ?</condition><then>
		 <expr><literal type="string">" (true root level)"</literal></expr> </then><else>: <expr><ternary><condition><expr><name><name>level</name><operator>.</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">" (leaf level)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<comment type="block">/* Don't rely on CHECK_FOR_INTERRUPTS() calls at lower level */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize state for this iteration */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <call><name>palloc_btree_page</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>=</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Since there cannot be a concurrent VACUUM operation in readonly
			 * mode, and since a page has no links within other pages
			 * (siblings and parent) once it is marked fully deleted, it
			 * should be impossible to land on a fully deleted page in
			 * readonly mode. See bt_downlink_check() for further details.
			 *
			 * The bt_downlink_check() P_ISDELETED() check is repeated here so
			 * that pages that are only reachable through sibling links get
			 * checked.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name> <operator>&amp;&amp;</operator> <call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"downlink or sibling link points to deleted block in index \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Block=%u left block=%u left link from block=%u."</literal></expr></argument>,
											<argument><expr><name>current</name></expr></argument>, <argument><expr><name>leftcurrent</name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block %u fell off the end of index \"%s\""</literal></expr></argument>,
								<argument><expr><name>current</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block %u of index \"%s\" ignored"</literal></expr></argument>,
								<argument><expr><name>current</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<goto>goto <name>nextpage</name>;</goto>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>nextleveldown</name><operator>.</operator><name>leftmost</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * A concurrent page split could make the caller supplied leftmost
			 * block no longer contain the leftmost page, or no longer be the
			 * true root, but where that isn't possible due to heavyweight
			 * locking, check that the first valid page meets caller's
			 * expectations.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_LEFTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block %u is not leftmost in index \"%s\""</literal></expr></argument>,
									<argument><expr><name>current</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>level</name><operator>.</operator><name>istruerootlevel</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISROOT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block %u is not true root in index \"%s\""</literal></expr></argument>,
									<argument><expr><name>current</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Before beginning any non-trivial examination of level, prepare
			 * state for next bt_check_level_from_leftmost() invocation for
			 * the next level for the next level down (if any).
			 *
			 * There should be at least one non-ignorable page per level,
			 * unless this is the leaf level, which is assumed by caller to be
			 * final level.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>

				<comment type="block">/* Internal page -- downlink gets leftmost on next level */</comment>
				<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemIdCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>,
											  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
											  <argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>leftmost</name></name> <operator>=</operator> <call><name>BTreeInnerTupleGetDownLink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Leaf page -- final level caller must process.
				 *
				 * Note that this could also be the root page, if there has
				 * been no root page split yet.
				 */</comment>
				<expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>leftmost</name></name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nextleveldown</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name>InvalidBtreeLevel</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Finished setting up state for this call/level.  Control will
			 * never end up back here in any future loop iteration for this
			 * level.
			 */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * readonly mode can only ever land on live pages and half-dead pages,
		 * so sibling pointers should always be in mutual agreement
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name> <operator>&amp;&amp;</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>!=</operator> <name>leftcurrent</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"left link/right link pair in index \"%s\" not in agreement"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Block=%u left block=%u left link from block=%u."</literal></expr></argument>,
										<argument><expr><name>current</name></expr></argument>, <argument><expr><name>leftcurrent</name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Check level, which must be valid for non-ignorable page */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>level</name><operator>.</operator><name>level</name></name> <operator>!=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"leftmost down link for level points to block in index \"%s\" whose level is not one level down"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Block pointed to=%u expected level=%u level in pointed to block=%u."</literal></expr></argument>,
										<argument><expr><name>current</name></expr></argument>, <argument><expr><name><name>level</name><operator>.</operator><name>level</name></name></expr></argument>, <argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Verify invariants for page */</comment>
		<expr_stmt><expr><call><name>bt_target_page_check</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>nextpage</name>:</label>

		<comment type="block">/* Try to detect circular links */</comment>
		<if_stmt><if>if <condition>(<expr><name>current</name> <operator>==</operator> <name>leftcurrent</name> <operator>||</operator> <name>current</name> <operator>==</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"circular link chain found in block %u of index \"%s\""</literal></expr></argument>,
							<argument><expr><name>current</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Record if page that is about to become target is the right half of
		 * an incomplete page split.  This can go stale immediately in
		 * !readonly case.
		 */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>rightsplit</name></name> <operator>=</operator> <call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>leftcurrent</name> <operator>=</operator> <name>current</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>

		<comment type="block">/* Free page and associated memory for this iteration */</comment>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	while <condition>(<expr><name>current</name> <operator>!=</operator> <name>P_NONE</name></expr>)</condition>;</do>

	<comment type="block">/* Don't change context for caller */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nextleveldown</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function performs the following checks on target page, or pages ancillary to
 * target page:
 *
 * - That every "real" data item is less than or equal to the high key, which
 *	 is an upper bound on the items on the page.  Data items should be
 *	 strictly less than the high key when the page is an internal page.
 *
 * - That within the page, every data item is strictly less than the item
 *	 immediately to its right, if any (i.e., that the items are in order
 *	 within the page, so that the binary searches performed by index scans are
 *	 sane).
 *
 * - That the last data item stored on the page is strictly less than the
 *	 first data item on the page to the right (when such a first item is
 *	 available).
 *
 * - Various checks on the structure of tuples themselves.  For example, check
 *	 that non-pivot tuples have no truncated attributes.
 *
 * Furthermore, when state passed shows ShareLock held, function also checks:
 *
 * - That all child pages respect strict lower bound from parent's pivot
 *	 tuple.
 *
 * - That downlink to block was encountered in parent where that's expected.
 *   (Limited to heapallindexed readonly callers.)
 *
 * This is also where heapallindexed callers use their Bloom filter to
 * fingerprint IndexTuples for later table_index_build_scan() verification.
 *
 * Note:  Memory allocated in this routine is expected to be released by caller
 * resetting state-&gt;targetcontext.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bt_target_page_check</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>topaque</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>topaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"verifying %u items on %s block %u"</literal></expr></argument>, <argument><expr><name>max</name></expr></argument>,
		 <argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"leaf"</literal></expr> </then><else>: <expr><literal type="string">"internal"</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check the number of attributes in high key. Note, rightmost page
	 * doesn't contain a high key, so nothing to check
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

		<comment type="block">/* Verify line pointer before checking tuple */</comment>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemIdCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>,
									  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_check_natts</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
							 <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of high key index tuple attributes in index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Index block=%u natts=%u block type=%s page lsn=%X/%X."</literal></expr></argument>,
										<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>,
										<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"heap"</literal></expr> </then><else>: <expr><literal type="string">"index"</literal></expr></else></ternary></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Loop over page items, starting from first non-highkey item, not high
	 * key (if any).  Most tests are not performed for the "negative infinity"
	 * real item (if any).
	 */</comment>
	<for>for <control>(<init><expr><name>offset</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>offset</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition>
		 <incr><expr><name>offset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>tupsize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTScanInsert</name></type> <name>skey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>lowersizelimit</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemIdCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>,
									  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupsize</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * lp_len should match the IndexTuple reported length exactly, since
		 * lp_len is completely redundant in indexes, and both sources of
		 * tuple length are MAXALIGN()'d.  nbtree does not use lp_len all that
		 * frequently, and is surprisingly tolerant of corrupt lp_len fields.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tupsize</name> <operator>!=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index tuple size does not equal lp_len in index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Index tid=(%u,%u) tuple size=%zu lp_len=%u page lsn=%X/%X."</literal></expr></argument>,
										<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
										<argument><expr><name>tupsize</name></expr></argument>, <argument><expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This could be a torn page problem."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Check the number of index tuple attributes */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_check_natts</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
							 <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>itid</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>htid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>itid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>htid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>,
							<argument><expr><call><name>ItemPointerGetBlockNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ItemPointerGetOffsetNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of index tuple attributes in index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Index tid=%s natts=%u points to %s tid=%s page lsn=%X/%X."</literal></expr></argument>,
										<argument><expr><name>itid</name></expr></argument>,
										<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"heap"</literal></expr> </then><else>: <expr><literal type="string">"index"</literal></expr></else></ternary></expr></argument>,
										<argument><expr><name>htid</name></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Fingerprint downlink blocks in heapallindexed + readonly case */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>heapallindexed</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>readonly</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>childblock</name> <init>= <expr><call><name>BTreeInnerTupleGetDownLink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>bloom_add_element</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>downlinkfilter</name></name></expr></argument>,
							  <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>childblock</name></expr></argument>,
							  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BlockNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Don't try to generate scankey using "negative infinity" item on
		 * internal pages. They are always truncated to zero attributes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>offset_is_negative_infinity</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Readonly callers may optionally verify that non-pivot tuples can
		 * each be found by an independent search that starts from the root
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>rootdescend</name></name> <operator>&amp;&amp;</operator> <call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bt_rootdescend</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>itid</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>htid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>itid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>htid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>,
							<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find tuple using search from root page in index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Index tid=%s points to heap tid=%s page lsn=%X/%X."</literal></expr></argument>,
										<argument><expr><name>itid</name></expr></argument>, <argument><expr><name>htid</name></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Build insertion scankey for current page offset */</comment>
		<expr_stmt><expr><name>skey</name> <operator>=</operator> <call><name>bt_mkscankey_pivotsearch</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make sure tuple size does not exceed the relevant BTREE_VERSION
		 * specific limit.
		 *
		 * BTREE_VERSION 4 (which introduced heapkeyspace rules) requisitioned
		 * a small amount of space from BTMaxItemSize() in order to ensure
		 * that suffix truncation always has enough space to add an explicit
		 * heap TID back to a tuple -- we pessimistically assume that every
		 * newly inserted tuple will eventually need to have a heap TID
		 * appended during a future leaf page split, when the tuple becomes
		 * the basis of the new high key (pivot tuple) for the leaf page.
		 *
		 * Since the reclaimed space is reserved for that purpose, we must not
		 * enforce the slightly lower limit when the extra space has been used
		 * as intended.  In other words, there is only a cross-version
		 * difference in the limit on tuple size within leaf pages.
		 *
		 * Still, we're particular about the details within BTREE_VERSION 4
		 * internal pages.  Pivot tuples may only use the extra space for its
		 * designated purpose.  Enforce the lower limit for pivot tuples when
		 * an explicit heap TID isn't actually present. (In all other cases
		 * suffix truncation is guaranteed to generate a pivot tuple that's no
		 * larger than the first right tuple provided to it by its caller.)
		 */</comment>
		<expr_stmt><expr><name>lowersizelimit</name> <operator>=</operator> <name><name>skey</name><operator>-&gt;</operator><name>heapkeyspace</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BTreeTupleGetHeapTID</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tupsize</name> <operator>&gt;</operator> <operator>(</operator><ternary><condition><expr><name>lowersizelimit</name></expr> ?</condition><then> <expr><call><name>BTMaxItemSize</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
					   <expr><call><name>BTMaxItemSizeNoHeapTid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>itid</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>htid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>itid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>htid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>,
							<argument><expr><call><name>ItemPointerGetBlockNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ItemPointerGetOffsetNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds maximum for index \"%s\""</literal></expr></argument>,
							<argument><expr><name>tupsize</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Index tid=%s points to %s tid=%s page lsn=%X/%X."</literal></expr></argument>,
										<argument><expr><name>itid</name></expr></argument>,
										<argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"heap"</literal></expr> </then><else>: <expr><literal type="string">"index"</literal></expr></else></ternary></expr></argument>,
										<argument><expr><name>htid</name></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Fingerprint leaf page tuples (those that point to the heap) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>heapallindexed</name></name> <operator>&amp;&amp;</operator> <call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>norm</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>norm</name> <operator>=</operator> <call><name>bt_normalize_tuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>bloom_add_element</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>filter</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>norm</name></expr></argument>,
							  <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>norm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Be tidy */</comment>
			<if_stmt><if>if <condition>(<expr><name>norm</name> <operator>!=</operator> <name>itup</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>norm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * * High key check *
		 *
		 * If there is a high key (if this is not the rightmost page on its
		 * entire level), check that high key actually is upper bound on all
		 * page items.
		 *
		 * We prefer to check all items against high key rather than checking
		 * just the last and trusting that the operator class obeys the
		 * transitive law (which implies that all previous items also
		 * respected the high key invariant if they pass the item order
		 * check).
		 *
		 * Ideally, we'd compare every item in the index against every other
		 * item in the index, and not trust opclass obedience of the
		 * transitive law to bridge the gap between children and their
		 * grandparents (as well as great-grandparents, and so on).  We don't
		 * go to those lengths because that would be prohibitively expensive,
		 * and probably not markedly more effective in practice.
		 *
		 * On the leaf level, we check that the key is &lt;= the highkey.
		 * However, on non-leaf levels we check that the key is &lt; the highkey,
		 * because the high key is "just another separator" rather than a copy
		 * of some existing key item; we expect it to be unique among all keys
		 * on the same level.  (Suffix truncation will sometimes produce a
		 * leaf highkey that is an untruncated copy of the lastleft item, but
		 * never any other item, which necessitates weakening the leaf level
		 * check to &lt;=.)
		 *
		 * Full explanation for why a highkey is never truly a copy of another
		 * item from the same level on internal levels:
		 *
		 * While the new left page's high key is copied from the first offset
		 * on the right page during an internal page split, that's not the
		 * full story.  In effect, internal pages are split in the middle of
		 * the firstright tuple, not between the would-be lastleft and
		 * firstright tuples: the firstright key ends up on the left side as
		 * left's new highkey, and the firstright downlink ends up on the
		 * right side as right's new "negative infinity" item.  The negative
		 * infinity tuple is truncated to zero attributes, so we're only left
		 * with the downlink.  In other words, the copying is just an
		 * implementation detail of splitting in the middle of a (pivot)
		 * tuple. (See also: "Notes About Data Representation" in the nbtree
		 * README.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>invariant_leq_offset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>skey</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr> </then><else>:
			  <expr><call><name>invariant_l_offset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>skey</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>itid</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>htid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>itid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>htid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>,
							<argument><expr><call><name>ItemPointerGetBlockNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ItemPointerGetOffsetNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"high key invariant violated for index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Index tid=%s points to %s tid=%s page lsn=%X/%X."</literal></expr></argument>,
										<argument><expr><name>itid</name></expr></argument>,
										<argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"heap"</literal></expr> </then><else>: <expr><literal type="string">"index"</literal></expr></else></ternary></expr></argument>,
										<argument><expr><name>htid</name></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * * Item order check *
		 *
		 * Check that items are stored on page in logical order, by checking
		 * current item is strictly less than next item (if any).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>max</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>invariant_l_offset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>skey</name></expr></argument>, <argument><expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>itid</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>htid</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>nitid</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>nhtid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>itid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>htid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>,
							<argument><expr><call><name>ItemPointerGetBlockNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ItemPointerGetOffsetNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nitid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>,
							 <argument><expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Reuse itup to get pointed-to heap location of second item */</comment>
			<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemIdCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>,
										  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
										  <argument><expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nhtid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u,%u)"</literal></expr></argument>,
							 <argument><expr><call><name>ItemPointerGetBlockNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>ItemPointerGetOffsetNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"item order invariant violated for index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Lower index tid=%s (points to %s tid=%s) "</literal>
										<literal type="string">"higher index tid=%s (points to %s tid=%s) "</literal>
										<literal type="string">"page lsn=%X/%X."</literal></expr></argument>,
										<argument><expr><name>itid</name></expr></argument>,
										<argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"heap"</literal></expr> </then><else>: <expr><literal type="string">"index"</literal></expr></else></ternary></expr></argument>,
										<argument><expr><name>htid</name></expr></argument>,
										<argument><expr><name>nitid</name></expr></argument>,
										<argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"heap"</literal></expr> </then><else>: <expr><literal type="string">"index"</literal></expr></else></ternary></expr></argument>,
										<argument><expr><name>nhtid</name></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * * Last item check *
		 *
		 * Check last item against next/right page's first data item's when
		 * last item on page is reached.  This additional check will detect
		 * transposed pages iff the supposed right sibling page happens to
		 * belong before target in the key space.  (Otherwise, a subsequent
		 * heap verification will probably detect the problem.)
		 *
		 * This check is similar to the item order check that will have
		 * already been performed for every other "real" item on target page
		 * when last item is checked.  The difference is that the next item
		 * (the item that is compared to target's last item) needs to come
		 * from the next/sibling page.  There may not be such an item
		 * available from sibling for various reasons, though (e.g., target is
		 * the rightmost page on level).
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name>offset</name> <operator>==</operator> <name>max</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTScanInsert</name></type> <name>rightkey</name></decl>;</decl_stmt>

			<comment type="block">/* Get item in next/right page */</comment>
			<expr_stmt><expr><name>rightkey</name> <operator>=</operator> <call><name>bt_right_page_check_scankey</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>rightkey</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>invariant_g_offset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>rightkey</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * As explained at length in bt_right_page_check_scankey(),
				 * there is a known !readonly race that could account for
				 * apparent violation of invariant, which we must check for
				 * before actually proceeding with raising error.  Our canary
				 * condition is that target page was deleted.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Get fresh copy of target page */</comment>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <call><name>palloc_btree_page</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Note that we deliberately do not update target LSN */</comment>
					<expr_stmt><expr><name>topaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * All !readonly checks now performed; just return
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cross page item order invariant violated for index \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Last item on page tid=(%u,%u) page lsn=%X/%X."</literal></expr></argument>,
											<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
											<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
											<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * * Downlink check *
		 *
		 * Additional check of child items iff this is an internal page and
		 * caller holds a ShareLock.  This happens for every downlink (item)
		 * in target excluding the negative-infinity downlink (again, this is
		 * because it has no useful value to compare).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>childblock</name> <init>= <expr><call><name>BTreeInnerTupleGetDownLink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>bt_downlink_check</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>skey</name></expr></argument>, <argument><expr><name>childblock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * * Check if page has a downlink in parent *
	 *
	 * This can only be checked in heapallindexed + readonly case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>heapallindexed</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bt_downlink_missing_check</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return a scankey for an item on page to right of current target (or the
 * first non-ignorable page), sufficient to check ordering invariant on last
 * item in current target page.  Returned scankey relies on local memory
 * allocated for the child page, which caller cannot pfree().  Caller's memory
 * context should be reset between calls here.
 *
 * This is the first data item, and so all adjacent items are checked against
 * their immediate sibling item (which may be on a sibling page, or even a
 * "cousin" page at parent boundaries where target's rightlink points to page
 * with different parent page).  If no such valid item is available, return
 * NULL instead.
 *
 * Note that !readonly callers must reverify that target page has not
 * been concurrently deleted.
 */</comment>
<function><type><specifier>static</specifier> <name>BTScanInsert</name></type>
<name>bt_right_page_check_scankey</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>rightitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>firstitup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>targetnext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>rightpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>nline</name></decl>;</decl_stmt>

	<comment type="block">/* Determine target's next block number */</comment>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If target is already rightmost, no right sibling; nothing to do here */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * General notes on concurrent page splits and page deletion:
	 *
	 * Routines like _bt_search() don't require *any* page split interlock
	 * when descending the tree, including something very light like a buffer
	 * pin. That's why it's okay that we don't either.  This avoidance of any
	 * need to "couple" buffer locks is the raison d' etre of the Lehman &amp; Yao
	 * algorithm, in fact.
	 *
	 * That leaves deletion.  A deleted page won't actually be recycled by
	 * VACUUM early enough for us to fail to at least follow its right link
	 * (or left link, or downlink) and find its sibling, because recycling
	 * does not occur until no possible index scan could land on the page.
	 * Index scans can follow links with nothing more than their snapshot as
	 * an interlock and be sure of at least that much.  (See page
	 * recycling/RecentGlobalXmin notes in nbtree README.)
	 *
	 * Furthermore, it's okay if we follow a rightlink and find a half-dead or
	 * dead (ignorable) page one or more times.  There will either be a
	 * further right link to follow that leads to a live page before too long
	 * (before passing by parent's rightmost child), or we will find the end
	 * of the entire level instead (possible when parent page is itself the
	 * rightmost on its level).
	 */</comment>
	<expr_stmt><expr><name>targetnext</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rightpage</name> <operator>=</operator> <call><name>palloc_btree_page</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* We landed on a deleted page, so step right to find a live page */</comment>
		<expr_stmt><expr><name>targetnext</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"level %u leftmost page of index \"%s\" was found deleted or half dead"</literal></expr></argument>,
						<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Deleted page found when building scankey from right sibling."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Be slightly more pro-active in freeing this memory, just in case */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * No ShareLock held case -- why it's safe to proceed.
	 *
	 * Problem:
	 *
	 * We must avoid false positive reports of corruption when caller treats
	 * item returned here as an upper bound on target's last item.  In
	 * general, false positives are disallowed.  Avoiding them here when
	 * caller is !readonly is subtle.
	 *
	 * A concurrent page deletion by VACUUM of the target page can result in
	 * the insertion of items on to this right sibling page that would
	 * previously have been inserted on our target page.  There might have
	 * been insertions that followed the target's downlink after it was made
	 * to point to right sibling instead of target by page deletion's first
	 * phase. The inserters insert items that would belong on target page.
	 * This race is very tight, but it's possible.  This is our only problem.
	 *
	 * Non-problems:
	 *
	 * We are not hindered by a concurrent page split of the target; we'll
	 * never land on the second half of the page anyway.  A concurrent split
	 * of the right page will also not matter, because the first data item
	 * remains the same within the left half, which we'll reliably land on. If
	 * we had to skip over ignorable/deleted pages, it cannot matter because
	 * their key space has already been atomically merged with the first
	 * non-ignorable page we eventually find (doesn't matter whether the page
	 * we eventually find is a true sibling or a cousin of target, which we go
	 * into below).
	 *
	 * Solution:
	 *
	 * Caller knows that it should reverify that target is not ignorable
	 * (half-dead or deleted) when cross-page sibling item comparison appears
	 * to indicate corruption (invariant fails).  This detects the single race
	 * condition that exists for caller.  This is correct because the
	 * continued existence of target block as non-ignorable (not half-dead or
	 * deleted) implies that target page was not merged into from the right by
	 * deletion; the key space at or after target never moved left.  Target's
	 * parent either has the same downlink to target as before, or a &lt;
	 * downlink due to deletion at the left of target.  Target either has the
	 * same highkey as before, or a highkey &lt; before when there is a page
	 * split. (The rightmost concurrently-split-from-target-page page will
	 * still have the same highkey as target was originally found to have,
	 * which for our purposes is equivalent to target's highkey itself never
	 * changing, since we reliably skip over
	 * concurrently-split-from-target-page pages.)
	 *
	 * In simpler terms, we allow that the key space of the target may expand
	 * left (the key space can move left on the left side of target only), but
	 * the target key space cannot expand right and get ahead of us without
	 * our detecting it.  The key space of the target cannot shrink, unless it
	 * shrinks to zero due to the deletion of the original page, our canary
	 * condition.  (To be very precise, we're a bit stricter than that because
	 * it might just have been that the target page split and only the
	 * original target page was deleted.  We can be more strict, just not more
	 * lax.)
	 *
	 * Top level tree walk caller moves on to next page (makes it the new
	 * target) following recovery from this race.  (cf.  The rationale for
	 * child/downlink verification needing a ShareLock within
	 * bt_downlink_check(), where page deletion is also the main source of
	 * trouble.)
	 *
	 * Note that it doesn't matter if right sibling page here is actually a
	 * cousin page, because in order for the key space to be readjusted in a
	 * way that causes us issues in next level up (guiding problematic
	 * concurrent insertions to the cousin from the grandparent rather than to
	 * the sibling from the parent), there'd have to be page deletion of
	 * target's parent page (affecting target's parent's downlink in target's
	 * grandparent page).  Internal page deletion only occurs when there are
	 * no child pages (they were all fully deleted), and caller is checking
	 * that the target's parent has at least one non-deleted (so
	 * non-ignorable) child: the target page.  (Note that the first phase of
	 * deletion atomically marks the page to be deleted half-dead/ignorable at
	 * the same time downlink in its parent is removed, so caller will
	 * definitely not fail to detect that this happened.)
	 *
	 * This trick is inspired by the method backward scans use for dealing
	 * with concurrent page splits; concurrent page deletion is a problem that
	 * similarly receives special consideration sometimes (it's possible that
	 * the backwards scan will re-read its "original" block after failing to
	 * find a right-link to it, having already moved in the opposite direction
	 * (right/"forwards") a few times to try to locate one).  Just like us,
	 * that happens only to determine if there was a concurrent page deletion
	 * of a reference page, and just like us if there was a page deletion of
	 * that reference page it means we can move on from caring about the
	 * reference page.  See the nbtree README for a full description of how
	 * that works.
	 */</comment>
	<expr_stmt><expr><name>nline</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get first data item, if any
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>nline</name> <operator>&gt;=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Return first data item (if any) */</comment>
		<expr_stmt><expr><name>rightitem</name> <operator>=</operator> <call><name>PageGetItemIdCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetnext</name></expr></argument>, <argument><expr><name>rightpage</name></expr></argument>,
										 <argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <name>nline</name> <operator>&gt;=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Return first item after the internal page's "negative infinity"
		 * item
		 */</comment>
		<expr_stmt><expr><name>rightitem</name> <operator>=</operator> <call><name>PageGetItemIdCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetnext</name></expr></argument>, <argument><expr><name>rightpage</name></expr></argument>,
										 <argument><expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * No first item.  Page is probably empty leaf page, but it's also
		 * possible that it's an internal page with only a negative infinity
		 * item.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s block %u of index \"%s\" has no first data item"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"leaf"</literal></expr> </then><else>: <expr><literal type="string">"internal"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>targetnext</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Return first real item scankey.  Note that this relies on right page
	 * memory remaining allocated.
	 */</comment>
	<expr_stmt><expr><name>firstitup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><name>rightitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>bt_mkscankey_pivotsearch</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>firstitup</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Checks one of target's downlink against its child page.
 *
 * Conceptually, the target page continues to be what is checked here.  The
 * target block is still blamed in the event of finding an invariant violation.
 * The downlink insertion into the target is probably where any problem raised
 * here arises, and there is no such thing as a parent link, so doing the
 * verification this way around is much more practical.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bt_downlink_check</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>targetkey</name></decl></parameter>,
				  <parameter><decl><type><name>BlockNumber</name></type> <name>childblock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>copaque</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Caller must have ShareLock on target relation, because of
	 * considerations around page deletion by VACUUM.
	 *
	 * NB: In general, page deletion deletes the right sibling's downlink, not
	 * the downlink of the page being deleted; the deleted page's downlink is
	 * reused for its sibling.  The key space is thereby consolidated between
	 * the deleted page and its right sibling.  (We cannot delete a parent
	 * page's rightmost child unless it is the last child page, and we intend
	 * to also delete the parent itself.)
	 *
	 * If this verification happened without a ShareLock, the following race
	 * condition could cause false positives:
	 *
	 * In general, concurrent page deletion might occur, including deletion of
	 * the left sibling of the child page that is examined here.  If such a
	 * page deletion were to occur, closely followed by an insertion into the
	 * newly expanded key space of the child, a window for the false positive
	 * opens up: the stale parent/target downlink originally followed to get
	 * to the child legitimately ceases to be a lower bound on all items in
	 * the page, since the key space was concurrently expanded "left".
	 * (Insertion followed the "new" downlink for the child, not our now-stale
	 * downlink, which was concurrently physically removed in target/parent as
	 * part of deletion's first phase.)
	 *
	 * Note that while the cross-page-same-level last item check uses a trick
	 * that allows it to perform verification for !readonly callers, a similar
	 * trick seems difficult here.  The trick that that other check uses is,
	 * in essence, to lock down race conditions to those that occur due to
	 * concurrent page deletion of the target; that's a race that can be
	 * reliably detected before actually reporting corruption.
	 *
	 * On the other hand, we'd need to lock down race conditions involving
	 * deletion of child's left page, for long enough to read the child page
	 * into memory (in other words, a scheme with concurrently held buffer
	 * locks on both child and left-of-child pages).  That's unacceptable for
	 * amcheck functions on general principle, though.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify child page has the downlink key from target page (its parent) as
	 * a lower bound; downlink must be strictly less than all keys on the
	 * page.
	 *
	 * Check all items, rather than checking just the first and trusting that
	 * the operator class obeys the transitive law.
	 */</comment>
	<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>palloc_btree_page</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>childblock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>copaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoffset</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since there cannot be a concurrent VACUUM operation in readonly mode,
	 * and since a page has no links within other pages (siblings and parent)
	 * once it is marked fully deleted, it should be impossible to land on a
	 * fully deleted page.
	 *
	 * It does not quite make sense to enforce that the page cannot even be
	 * half-dead, despite the fact the downlink is modified at the same stage
	 * that the child leaf page is marked half-dead.  That's incorrect because
	 * there may occasionally be multiple downlinks from a chain of pages
	 * undergoing deletion, where multiple successive calls are made to
	 * _bt_unlink_halfdead_page() by VACUUM before it can finally safely mark
	 * the leaf page as fully dead.  While _bt_mark_page_halfdead() usually
	 * removes the downlink to the leaf page that is marked half-dead, that's
	 * not guaranteed, so it's possible we'll land on a half-dead page with a
	 * downlink due to an interrupted multi-level page deletion.
	 *
	 * We go ahead with our checks if the child page is half-dead.  It's safe
	 * to do so because we do not test the child's high key, so it does not
	 * matter that the original high key will have been replaced by a dummy
	 * truncated high key within _bt_mark_page_halfdead().  All other page
	 * items are left intact on a half-dead page, so there is still something
	 * to test.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"downlink to deleted page found in index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Parent block=%u child block=%u parent page lsn=%X/%X."</literal></expr></argument>,
									<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>childblock</name></expr></argument>,
									<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>offset</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>offset</name> <operator>&lt;=</operator> <name>maxoffset</name></expr>;</condition>
		 <incr><expr><name>offset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Skip comparison of target page key against "negative infinity"
		 * item, if any.  Checking it would indicate that it's not a strict
		 * lower bound, but that's only because of the hard-coding for
		 * negative infinity items within _bt_compare().
		 *
		 * If nbtree didn't truncate negative infinity tuples during internal
		 * page splits then we'd expect child's negative infinity key to be
		 * equal to the scankey/downlink from target/parent (it would be a
		 * "low key" in this hypothetical scenario, and so it would still need
		 * to be treated as a special case here).
		 *
		 * Negative infinity items can be thought of as a strict lower bound
		 * that works transitively, with the last non-negative-infinity pivot
		 * followed during a descent from the root as its "true" strict lower
		 * bound.  Only a small number of negative infinity items are truly
		 * negative infinity; those that are the first items of leftmost
		 * internal pages.  In more general terms, a negative infinity item is
		 * only negative infinity with respect to the subtree that the page is
		 * at the root of.
		 *
		 * See also: bt_rootdescend(), which can even detect transitive
		 * inconsistencies on cousin leaf pages.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>offset_is_negative_infinity</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>invariant_l_nontarget_offset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetkey</name></expr></argument>, <argument><expr><name>childblock</name></expr></argument>, <argument><expr><name>child</name></expr></argument>,
										  <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"down-link lower bound invariant violated for index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Parent block=%u child index tid=(%u,%u) parent page lsn=%X/%X."</literal></expr></argument>,
										<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>childblock</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if page is missing a downlink that it should have.
 *
 * A page that lacks a downlink/parent may indicate corruption.  However, we
 * must account for the fact that a missing downlink can occasionally be
 * encountered in a non-corrupt index.  This can be due to an interrupted page
 * split, or an interrupted multi-level page deletion (i.e. there was a hard
 * crash or an error during a page split, or while VACUUM was deleting a
 * multi-level chain of pages).
 *
 * Note that this can only be called in readonly mode, so there is no need to
 * be concerned about concurrent page splits or page deletions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bt_downlink_missing_check</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>topaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>copaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>childblk</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapallindexed</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No next level up with downlinks to fingerprint from the true root */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_ISROOT</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Incomplete (interrupted) page splits can account for the lack of a
	 * downlink.  Some inserting transaction should eventually complete the
	 * page split in passing, when it notices that the left sibling page is
	 * P_INCOMPLETE_SPLIT().
	 *
	 * In general, VACUUM is not prepared for there to be no downlink to a
	 * page that it deletes.  This is the main reason why the lack of a
	 * downlink can be reported as corruption here.  It's not obvious that an
	 * invalid missing downlink can result in wrong answers to queries,
	 * though, since index scans that land on the child may end up
	 * consistently moving right. The handling of concurrent page splits (and
	 * page deletions) within _bt_moveright() cannot distinguish
	 * inconsistencies that last for a moment from inconsistencies that are
	 * permanent and irrecoverable.
	 *
	 * VACUUM isn't even prepared to delete pages that have no downlink due to
	 * an incomplete page split, but it can detect and reason about that case
	 * by design, so it shouldn't be taken to indicate corruption.  See
	 * _bt_pagedel() for full details.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>rightsplit</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"harmless interrupted page split detected in index %s"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Block=%u level=%u left sibling=%u page lsn=%X/%X."</literal></expr></argument>,
									<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name><name>topaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>,
									<argument><expr><name><name>topaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr></argument>,
									<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Target's downlink is typically present in parent/fingerprinted */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bloom_lacks_element</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>downlinkfilter</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>,
							 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BlockNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Target is probably the "top parent" of a multi-level page deletion.
	 * We'll need to descend the subtree to make sure that descendant pages
	 * are consistent with that, though.
	 *
	 * If the target page (which must be non-ignorable) is a leaf page, then
	 * clearly it can't be the top parent.  The lack of a downlink is probably
	 * a symptom of a broad problem that could just as easily cause
	 * inconsistencies anywhere else.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"leaf index block lacks downlink in index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Block=%u page lsn=%X/%X."</literal></expr></argument>,
									<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>,
									<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Descend from the target page, which is an internal page */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"checking for interrupted multi-level deletion due to missing downlink in index \"%s\""</literal></expr></argument>,
		 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>level</name> <operator>=</operator> <name><name>topaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemIdCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
								  <argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>childblk</name> <operator>=</operator> <call><name>BTreeInnerTupleGetDownLink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>palloc_btree_page</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>childblk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>copaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Do an extra sanity check in passing on internal pages */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>copaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>!=</operator> <name>level</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"downlink points to block in index \"%s\" whose level is not one level down"</literal></expr></argument>,
									 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Top parent/target block=%u block pointed to=%u expected level=%u level in pointed to block=%u."</literal></expr></argument>,
										<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>childblk</name></expr></argument>,
										<argument><expr><name>level</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>copaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>level</name> <operator>=</operator> <name><name>copaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemIdCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>childblk</name></expr></argument>, <argument><expr><name>child</name></expr></argument>,
									  <argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>childblk</name> <operator>=</operator> <call><name>BTreeInnerTupleGetDownLink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Be slightly more pro-active in freeing this memory, just in case */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Since there cannot be a concurrent VACUUM operation in readonly mode,
	 * and since a page has no links within other pages (siblings and parent)
	 * once it is marked fully deleted, it should be impossible to land on a
	 * fully deleted page.  See bt_downlink_check() for further details.
	 *
	 * The bt_downlink_check() P_ISDELETED() check is repeated here because
	 * bt_downlink_check() does not visit pages reachable through negative
	 * infinity items.  Besides, bt_downlink_check() is unwilling to descend
	 * multiple levels.  (The similar bt_downlink_check() P_ISDELETED() check
	 * within bt_check_level_from_leftmost() won't reach the page either,
	 * since the leaf's live siblings should have their sibling links updated
	 * to bypass the deletion target page when it is marked fully dead.)
	 *
	 * If this error is raised, it might be due to a previous multi-level page
	 * deletion that failed to realize that it wasn't yet safe to mark the
	 * leaf page as fully dead.  A "dangling downlink" will still remain when
	 * this happens.  The fact that the dangling downlink's page (the leaf's
	 * parent/ancestor page) lacked a downlink is incidental.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"downlink to deleted leaf page found in index \"%s\""</literal></expr></argument>,
								 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Top parent/target block=%u leaf block=%u top parent/target lsn=%X/%X."</literal></expr></argument>,
									<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name>childblk</name></expr></argument>,
									<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Iff leaf page is half-dead, its high key top parent link should point
	 * to what VACUUM considered to be the top parent page at the instant it
	 * was interrupted.  Provided the high key link actually points to the
	 * target page, the missing downlink we detected is consistent with there
	 * having been an interrupted multi-level page deletion.  This means that
	 * the subtree with the target page at its root (a page deletion chain) is
	 * in a consistent state, enabling VACUUM to resume deleting the entire
	 * chain the next time it encounters the half-dead leaf page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_ISHALFDEAD</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemIdCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>childblk</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BTreeTupleGetTopParent</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"internal index block lacks downlink in index \"%s\""</literal></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Block=%u level=%u page lsn=%X/%X."</literal></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name><name>topaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>,
								<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>targetlsn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Per-tuple callback from table_index_build_scan, used to determine if index has
 * all the entries that definitely should have been observed in leaf pages of
 * the target index (that is, all IndexTuples that were fingerprinted by our
 * Bloom filter).  All heapallindexed checks occur here.
 *
 * The redundancy between an index and the table it indexes provides a good
 * opportunity to detect corruption, especially corruption within the table.
 * The high level principle behind the verification performed here is that any
 * IndexTuple that should be in an index following a fresh CREATE INDEX (based
 * on the same index definition) should also have been in the original,
 * existing index, which should have used exactly the same representation
 *
 * Since the overall structure of the index has already been verified, the most
 * likely explanation for error here is a corrupt heap page (could be logical
 * or physical corruption).  Index corruption may still be detected here,
 * though.  Only readonly callers will have verified that left links and right
 * links are in agreement, and so it's possible that a leaf page transposition
 * within index is actually the source of corruption detected here (for
 * !readonly callers).  The checks performed only for readonly callers might
 * more accurately frame the problem as a cross-page invariant issue (this
 * could even be due to recovery not replaying all WAL records).  The !readonly
 * ERROR message raised here includes a HINT about retrying with readonly
 * verification, just in case it's a cross-page invariant issue, though that
 * isn't particularly likely.
 *
 * table_index_build_scan() expects to be able to find the root tuple when a
 * heap-only tuple (the live tuple at the end of some HOT chain) needs to be
 * indexed, in order to replace the actual tuple's TID with the root tuple's
 * TID (which is what we're actually passed back here).  The index build heap
 * scan code will raise an error when a tuple that claims to be the root of the
 * heap-only tuple's HOT chain cannot be located.  This catches cases where the
 * original root item offset/root tuple for a HOT chain indicates (for whatever
 * reason) that the entire HOT chain is dead, despite the fact that the latest
 * heap-only tuple should be indexed.  When this happens, sequential scans may
 * always give correct answers, and all indexes may be considered structurally
 * consistent (i.e. the nbtree structural checks would not detect corruption).
 * It may be the case that only index scans give wrong answers, and yet heap or
 * SLRU corruption is the real culprit.  (While it's true that LP_DEAD bit
 * setting will probably also leave the index in a corrupt state before too
 * long, the problem is nonetheless that there is heap corruption.)
 *
 * Heap-only tuple handling within table_index_build_scan() works in a way that
 * helps us to detect index tuples that contain the wrong values (values that
 * don't match the latest tuple in the HOT chain).  This can happen when there
 * is no superseding index tuple due to a faulty assessment of HOT safety,
 * perhaps during the original CREATE INDEX.  Because the latest tuple's
 * contents are used with the root TID, an error will be raised when a tuple
 * with the same TID but non-matching attribute values is passed back to us.
 * Faulty assessment of HOT-safety was behind at least two distinct CREATE
 * INDEX CONCURRENTLY bugs that made it into stable releases, one of which was
 * undetected for many years.  In short, the same principle that allows a
 * REINDEX to repair corruption when there was an (undetected) broken HOT chain
 * also allows us to detect the corruption in many cases.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bt_tuple_present_callback</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tupleIsAlive</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>checkstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>BtreeCheckState</name> <operator>*</operator><operator>)</operator> <name>checkstate</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>,
				<decl><type ref="prev"/><name>norm</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapallindexed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Generate a normalized index tuple for fingerprinting */</comment>
	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>index_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name> <operator>=</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>norm</name> <operator>=</operator> <call><name>bt_normalize_tuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Probe Bloom filter -- tuple should be present */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bloom_lacks_element</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>filter</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>norm</name></expr></argument>,
							<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>norm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"heap tuple (%u,%u) from table \"%s\" lacks matching index tuple within index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heaprel</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name></expr>
				 ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Retrying verification using the function bt_index_parent_check() might provide a more specific error."</literal></expr></argument>)</argument_list></call></expr>
				 </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heaptuplespresent</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Cannot leak memory here */</comment>
	<if_stmt><if>if <condition>(<expr><name>norm</name> <operator>!=</operator> <name>itup</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>norm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Normalize an index tuple for fingerprinting.
 *
 * In general, index tuple formation is assumed to be deterministic by
 * heapallindexed verification, and IndexTuples are assumed immutable.  While
 * the LP_DEAD bit is mutable in leaf pages, that's ItemId metadata, which is
 * not fingerprinted.  Normalization is required to compensate for corner
 * cases where the determinism assumption doesn't quite work.
 *
 * There is currently one such case: index_form_tuple() does not try to hide
 * the source TOAST state of input datums.  The executor applies TOAST
 * compression for heap tuples based on different criteria to the compression
 * applied within btinsert()'s call to index_form_tuple(): it sometimes
 * compresses more aggressively, resulting in compressed heap tuple datums but
 * uncompressed corresponding index tuple datums.  A subsequent heapallindexed
 * verification will get a logically equivalent though bitwise unequal tuple
 * from index_form_tuple().  False positive heapallindexed corruption reports
 * could occur without normalizing away the inconsistency.
 *
 * Returned tuple is often caller's own original tuple.  Otherwise, it is a
 * new representation of caller's original index tuple, palloc()'d in caller's
 * memory context.
 *
 * Note: This routine is not concerned with distinctions about the
 * representation of tuples beyond those that might break heapallindexed
 * verification.  In particular, it won't try to normalize opclass-equal
 * datums with potentially distinct representations (e.g., btree/numeric_ops
 * index datums will not get their display scale normalized-away here).
 * Normalization may need to be expanded to handle more cases in the future,
 * though.  For example, it's possible that non-pivot tuples could in the
 * future have alternative logically equivalent representations due to using
 * the INDEX_ALT_TID_MASK bit to implement intelligent deduplication.
 */</comment>
<function><type><specifier>static</specifier> <name>IndexTuple</name></type>
<name>bt_normalize_tuple</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>normalized</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>toast_free</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>formnewtup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>reformed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Easy case: It's immediately clear that tuple has no varlena datums */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexTupleHasVarwidths</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>itup</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Assume untoasted/already normalized datum initially */</comment>
		<expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>normalized</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
									  <argument><expr><name>tupleDescriptor</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>||</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Callers always pass a tuple that could safely be inserted into the
		 * index without further processing, so an external varlena header
		 * should never be encountered here
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>normalized</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"external varlena datum in tuple that references heap row (%u,%u) in index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>normalized</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>formnewtup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>normalized</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>normalized</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Easier case: Tuple has varlena datums, none of which are compressed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>formnewtup</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>itup</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Hard case: Tuple had compressed varlena datums that necessitate
	 * creating normalized version of the tuple from uncompressed input datums
	 * (normalized input datums).  This is rather naive, but shouldn't be
	 * necessary too often.
	 *
	 * Note that we rely on deterministic index_form_tuple() TOAST compression
	 * of normalized input.
	 */</comment>
	<expr_stmt><expr><name>reformed</name> <operator>=</operator> <call><name>index_form_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>normalized</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>reformed</name><operator>-&gt;</operator><name>t_tid</name></name> <operator>=</operator> <name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>

	<comment type="block">/* Cannot leak memory here */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>toast_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>normalized</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><name>reformed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search for itup in index, starting from fast root page.  itup must be a
 * non-pivot tuple.  This is only supported with heapkeyspace indexes, since
 * we rely on having fully unique keys to find a match with only a single
 * visit to a leaf page, barring an interrupted page split, where we may have
 * to move right.  (A concurrent page split is impossible because caller must
 * be readonly caller.)
 *
 * This routine can detect very subtle transitive consistency issues across
 * more than one level of the tree.  Leaf pages all have a high key (even the
 * rightmost page has a conceptual positive infinity high key), but not a low
 * key.  Their downlink in parent is a lower bound, which along with the high
 * key is almost enough to detect every possible inconsistency.  A downlink
 * separator key value won't always be available from parent, though, because
 * the first items of internal pages are negative infinity items, truncated
 * down to zero attributes during internal page splits.  While it's true that
 * bt_downlink_check() and the high key check can detect most imaginable key
 * space problems, there are remaining problems it won't detect with non-pivot
 * tuples in cousin leaf pages.  Starting a search from the root for every
 * existing leaf tuple detects small inconsistencies in upper levels of the
 * tree that cannot be detected any other way.  (Besides all this, this is
 * probably also useful as a direct test of the code used by index scans
 * themselves.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>bt_rootdescend</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTScanInsert</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTStack</name></type>		<name>stack</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>lbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>exists</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>_bt_mkscankey</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>heapkeyspace</name></name> <operator>&amp;&amp;</operator> <name><name>key</name><operator>-&gt;</operator><name>scantid</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Search from root.
	 *
	 * Ideally, we would arrange to only move right within _bt_search() when
	 * an interrupted page split is detected (i.e. when the incomplete split
	 * bit is found to be set), but for now we accept the possibility that
	 * that could conceal an inconsistency.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readonly</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>rootdescend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>exists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>_bt_search</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lbuf</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTInsertStateData</name></type> <name>insertstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>itup</name></name> <operator>=</operator> <name>itup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>itemsz</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>itup_key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>bounds_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>insertstate</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>lbuf</name></expr>;</expr_stmt>

		<comment type="block">/* Get matching tuple on leaf page */</comment>
		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>_bt_binsrch_insert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>insertstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Compare first &gt;= matching item on leaf page, if any */</comment>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>_bt_compare</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>exists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>_bt_freestack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>exists</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is particular offset within page (whose special state is passed by caller)
 * the page negative-infinity item?
 *
 * As noted in comments above _bt_compare(), there is special handling of the
 * first data item as a "negative infinity" item.  The hard-coding within
 * _bt_compare() makes comparing this item for the purposes of verification
 * pointless at best, since the IndexTuple only contains a valid TID (a
 * reference TID to child page).
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>offset_is_negative_infinity</name><parameter_list>(<parameter><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * For internal pages only, the first item after high key, if any, is
	 * negative infinity item.  Internal pages always have a negative infinity
	 * item, whereas leaf pages never have one.  This implies that negative
	 * infinity item is either first or second line item, or there is none
	 * within page.
	 *
	 * Negative infinity items are a special case among pivot tuples.  They
	 * always have zero attributes, while all other pivot tuples always have
	 * nkeyatts attributes.
	 *
	 * Right-most pages don't have a high key, but could be said to
	 * conceptually have a "positive infinity" high key.  Thus, there is a
	 * symmetry between down link items in parent pages, and high keys in
	 * children.  Together, they represent the part of the key space that
	 * belongs to each page in the index.  For example, all children of the
	 * root page will have negative infinity as a lower bound from root
	 * negative infinity downlink, and positive infinity as an upper bound
	 * (implicitly, from "imaginary" positive infinity high key in root).
	 */</comment>
	<return>return <expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>offset</name> <operator>==</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the invariant hold that the key is strictly less than a given upper
 * bound offset item?
 *
 * Verifies line pointer on behalf of caller.
 *
 * If this function returns false, convention is that caller throws error due
 * to corruption.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>invariant_l_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>key</name></decl></parameter>,
				   <parameter><decl><type><name>OffsetNumber</name></type> <name>upperbound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>pivotsearch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Verify line pointer before checking tuple */</comment>
	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemIdCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
								  <argument><expr><name>upperbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* pg_upgrade'd indexes may legally have equal sibling tuples */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>invariant_leq_offset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>upperbound</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>_bt_compare</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>upperbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * _bt_compare() is capable of determining that a scankey with a
	 * filled-out attribute is greater than pivot tuples where the comparison
	 * is resolved at a truncated attribute (value of attribute in pivot is
	 * minus infinity).  However, it is not capable of determining that a
	 * scankey is _less than_ a tuple on the basis of a comparison resolved at
	 * _scankey_ minus infinity attribute.  Complete an extra step to simulate
	 * having minus infinity values for omitted scankey attribute(s).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>topaque</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>ritup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>uppnkeyatts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>rheaptid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>nonpivot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ritup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>topaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nonpivot</name> <operator>=</operator> <call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>upperbound</name> <operator>&gt;=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>topaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get number of keys + heap TID for item to the right */</comment>
		<expr_stmt><expr><name>uppnkeyatts</name> <operator>=</operator> <call><name>BTreeTupleGetNKeyAtts</name><argument_list>(<argument><expr><name>ritup</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rheaptid</name> <operator>=</operator> <call><name>BTreeTupleGetHeapTIDCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>ritup</name></expr></argument>, <argument><expr><name>nonpivot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Heap TID is tiebreaker key attribute */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>keysz</name></name> <operator>==</operator> <name>uppnkeyatts</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>key</name><operator>-&gt;</operator><name>scantid</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>rheaptid</name> <operator>!=</operator> <name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><name><name>key</name><operator>-&gt;</operator><name>keysz</name></name> <operator>&lt;</operator> <name>uppnkeyatts</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the invariant hold that the key is less than or equal to a given upper
 * bound offset item?
 *
 * Caller should have verified that upperbound's line pointer is consistent
 * using PageGetItemIdCareful() call.
 *
 * If this function returns false, convention is that caller throws error due
 * to corruption.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>invariant_leq_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>key</name></decl></parameter>,
					 <parameter><decl><type><name>OffsetNumber</name></type> <name>upperbound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>pivotsearch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>_bt_compare</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>upperbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the invariant hold that the key is strictly greater than a given lower
 * bound offset item?
 *
 * Caller should have verified that lowerbound's line pointer is consistent
 * using PageGetItemIdCareful() call.
 *
 * If this function returns false, convention is that caller throws error due
 * to corruption.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>invariant_g_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>key</name></decl></parameter>,
				   <parameter><decl><type><name>OffsetNumber</name></type> <name>lowerbound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>pivotsearch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>_bt_compare</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name>lowerbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_upgrade'd indexes may legally have equal sibling tuples */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No need to consider the possibility that scankey has attributes that we
	 * need to force to be interpreted as negative infinity.  _bt_compare() is
	 * able to determine that scankey is greater than negative infinity.  The
	 * distinction between "==" and "&lt;" isn't interesting here, since
	 * corruption is indicated either way.
	 */</comment>
	<return>return <expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the invariant hold that the key is strictly less than a given upper
 * bound offset item, with the offset relating to a caller-supplied page that
 * is not the current target page?
 *
 * Caller's non-target page is a child page of the target, checked as part of
 * checking a property of the target page (i.e. the key comes from the
 * target).  Verifies line pointer on behalf of caller.
 *
 * If this function returns false, convention is that caller throws error due
 * to corruption.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>invariant_l_nontarget_offset</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>key</name></decl></parameter>,
							 <parameter><decl><type><name>BlockNumber</name></type> <name>nontargetblock</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>nontarget</name></decl></parameter>,
							 <parameter><decl><type><name>OffsetNumber</name></type> <name>upperbound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>pivotsearch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Verify line pointer before checking tuple */</comment>
	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemIdCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>nontargetblock</name></expr></argument>, <argument><expr><name>nontarget</name></expr></argument>,
								  <argument><expr><name>upperbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>_bt_compare</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>nontarget</name></expr></argument>, <argument><expr><name>upperbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_upgrade'd indexes may legally have equal sibling tuples */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>key</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* See invariant_l_offset() for an explanation of this extra step */</comment>
	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>child</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>uppnkeyatts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>childheaptid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>copaque</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>nonpivot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>child</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>nontarget</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>copaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>nontarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nonpivot</name> <operator>=</operator> <call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>upperbound</name> <operator>&gt;=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>copaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get number of keys + heap TID for child/non-target item */</comment>
		<expr_stmt><expr><name>uppnkeyatts</name> <operator>=</operator> <call><name>BTreeTupleGetNKeyAtts</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>childheaptid</name> <operator>=</operator> <call><name>BTreeTupleGetHeapTIDCareful</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>nonpivot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Heap TID is tiebreaker key attribute */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>keysz</name></name> <operator>==</operator> <name>uppnkeyatts</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>key</name><operator>-&gt;</operator><name>scantid</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>childheaptid</name> <operator>!=</operator> <name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><name><name>key</name><operator>-&gt;</operator><name>keysz</name></name> <operator>&lt;</operator> <name>uppnkeyatts</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a block number of a B-Tree page, return page in palloc()'d memory.
 * While at it, perform some basic checks of the page.
 *
 * There is never an attempt to get a consistent view of multiple pages using
 * multiple concurrent buffer locks; in general, we only acquire a single pin
 * and buffer lock at a time, which is often all that the nbtree code requires.
 *
 * Operating on a copy of the page is useful because it prevents control
 * getting stuck in an uninterruptible state when an underlying operator class
 * misbehaves.
 */</comment>
<function><type><specifier>static</specifier> <name>Page</name></type>
<name>palloc_btree_page</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoffset</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We copy the page into local storage to avoid holding pin on the buffer
	 * longer than we must.
	 */</comment>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>checkstrategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Perform the same basic sanity checking that nbtree itself performs for
	 * every page:
	 */</comment>
	<expr_stmt><expr><call><name>_bt_checkpage</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Only use copy of page in palloc()'d memory */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>P_ISMETA</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>blocknum</name> <operator>!=</operator> <name>BTREE_METAPAGE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid meta page found at block %u in index \"%s\""</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check page from block that ought to be meta page */</comment>
	<if_stmt><if>if <condition>(<expr><name>blocknum</name> <operator>==</operator> <name>BTREE_METAPAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name> <init>= <expr><call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISMETA</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name><name>metad</name><operator>-&gt;</operator><name>btm_magic</name></name> <operator>!=</operator> <name>BTREE_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" meta page is corrupt"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;</operator> <name>BTREE_MIN_VERSION</name> <operator>||</operator>
			<name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&gt;</operator> <name>BTREE_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"version mismatch in index \"%s\": file version %d, "</literal>
							<literal type="string">"current version %d, minimum supported version %d"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name></expr></argument>, <argument><expr><name>BTREE_VERSION</name></expr></argument>,
							<argument><expr><name>BTREE_MIN_VERSION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Finished with metapage checks */</comment>
		<return>return <expr><name>page</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Deleted pages have no sane "level" field, so can only check non-deleted
	 * page level
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid leaf page level %u for block %u in index \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISDELETED</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid internal page level 0 for block %u in index \"%s\""</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Sanity checks for number of items on page.
	 *
	 * As noted at the beginning of _bt_binsrch(), an internal page must have
	 * children, since there must always be a negative infinity downlink
	 * (there may also be a highkey).  In the case of non-rightmost leaf
	 * pages, there must be at least a highkey.
	 *
	 * This is correct when pages are half-dead, since internal pages are
	 * never half-dead, and leaf pages must have a high key when half-dead
	 * (the rightmost page can never be deleted).  It's also correct with
	 * fully deleted pages: _bt_unlink_halfdead_page() doesn't change anything
	 * about the target page other than setting the page as fully dead, and
	 * setting its xact field.  In particular, it doesn't change the sibling
	 * links in the deletion target itself, since they're required when index
	 * scans land on the deletion target, and then need to move right (or need
	 * to move left, in the case of backward index scans).
	 */</comment>
	<expr_stmt><expr><name>maxoffset</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>maxoffset</name> <operator>&gt;</operator> <name>MaxIndexTuplesPerPage</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Number of items on block %u of index \"%s\" exceeds MaxIndexTuplesPerPage (%u)"</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>MaxIndexTuplesPerPage</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>maxoffset</name> <operator>&lt;</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"internal block %u in index \"%s\" lacks high key and/or at least one downlink"</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>maxoffset</name> <operator>&lt;</operator> <name>P_HIKEY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"non-rightmost leaf block %u in index \"%s\" lacks high key item"</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * In general, internal pages are never marked half-dead, except on
	 * versions of Postgres prior to 9.4, where it can be valid transient
	 * state.  This state is nonetheless treated as corruption by VACUUM on
	 * from version 9.4 on, so do the same here.  See _bt_pagedel() for full
	 * details.
	 *
	 * Internal pages should never have garbage items, either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_ISHALFDEAD</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"internal page block %u in index \"%s\" is half-dead"</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This can be caused by an interrupted VACUUM in version 9.3 or older, before upgrade. Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_HAS_GARBAGE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"internal page block %u in index \"%s\" has garbage items"</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>page</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_mkscankey() wrapper that automatically prevents insertion scankey from
 * being considered greater than the pivot tuple that its values originated
 * from (or some other identical pivot tuple) in the common case where there
 * are truncated/minus infinity attributes.  Without this extra step, there
 * are forms of corruption that amcheck could theoretically fail to report.
 *
 * For example, invariant_g_offset() might miss a cross-page invariant failure
 * on an internal level if the scankey built from the first item on the
 * target's right sibling page happened to be equal to (not greater than) the
 * last item on target page.  The !pivotsearch tiebreaker in _bt_compare()
 * might otherwise cause amcheck to assume (rather than actually verify) that
 * the scankey is greater.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>BTScanInsert</name></type>
<name>bt_mkscankey_pivotsearch</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTScanInsert</name></type> <name>skey</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>skey</name> <operator>=</operator> <call><name>_bt_mkscankey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>pivotsearch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>skey</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PageGetItemId() wrapper that validates returned line pointer.
 *
 * Buffer page/page item access macros generally trust that line pointers are
 * not corrupt, which might cause problems for verification itself.  For
 * example, there is no bounds checking in PageGetItem().  Passing it a
 * corrupt line pointer can cause it to return a tuple/pointer that is unsafe
 * to dereference.
 *
 * Validating line pointers before tuples avoids undefined behavior and
 * assertion failures with corrupt indexes, making the verification process
 * more robust and predictable.
 */</comment>
<function><type><specifier>static</specifier> <name>ItemId</name></type>
<name>PageGetItemIdCareful</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>block</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
					 <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call> <operator>&gt;</operator>
		<name>BLCKSZ</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"line pointer points past end of tuple space in index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Index tid=(%u,%u) lp_off=%u, lp_len=%u lp_flags=%u."</literal></expr></argument>,
									<argument><expr><name>block</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>ItemIdGetFlags</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Verify that line pointer isn't LP_REDIRECT or LP_UNUSED, since nbtree
	 * never uses either.  Verify that line pointer has storage, too, since
	 * even LP_DEAD items should within nbtree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsRedirected</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid line pointer storage in index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Index tid=(%u,%u) lp_off=%u, lp_len=%u lp_flags=%u."</literal></expr></argument>,
									<argument><expr><name>block</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>ItemIdGetFlags</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>itemid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BTreeTupleGetHeapTID() wrapper that lets caller enforce that a heap TID must
 * be present in cases where that is mandatory.
 *
 * This doesn't add much as of BTREE_VERSION 4, since the INDEX_ALT_TID_MASK
 * bit is effectively a proxy for whether or not the tuple is a pivot tuple.
 * It may become more useful in the future, when non-pivot tuples support their
 * own alternative INDEX_ALT_TID_MASK representation.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ItemPointer</name></type>
<name>BTreeTupleGetHeapTIDCareful</name><parameter_list>(<parameter><decl><type><name>BtreeCheckState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>nonpivot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>result</name> <init>= <expr><call><name>BTreeTupleGetHeapTID</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>targetblock</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>targetblock</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nonpivot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block %u or its right sibling block or child block in index \"%s\" contains non-pivot tuple that lacks a heap TID"</literal></expr></argument>,
						<argument><expr><name>targetblock</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
