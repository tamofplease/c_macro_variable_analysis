<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/contrib/test_decoding/test_decoding.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * test_decoding.c
 *		  example logical decoding output plugin
 *
 * Copyright (c) 2012-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		  contrib/test_decoding/test_decoding.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/origin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block">/* These must be available to pg_dlsym() */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>_PG_output_plugin_init</name><parameter_list>(<parameter><decl><type><name>OutputPluginCallbacks</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>include_xids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>include_timestamp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skip_empty_xacts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>xact_wrote_changes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>only_local</name></decl>;</decl_stmt>
}</block></struct></type> <name>TestDecodingData</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_decode_startup</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>OutputPluginOptions</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>is_init</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_decode_shutdown</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_decode_begin_txn</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
								<parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_output_begin</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
							<parameter><decl><type><name>TestDecodingData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
							<parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>last_write</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_decode_commit_txn</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
								 <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>commit_lsn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_decode_change</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
							 <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_decode_truncate</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
							   <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>nrelations</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name><name>relations</name><index>[]</index></name></decl></parameter>,
							   <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pg_decode_filter</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
							 <parameter><decl><type><name>RepOriginId</name></type> <name>origin_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_decode_message</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
							  <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>message_lsn</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>transactional</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
							  <parameter><decl><type><name>Size</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* other plugins can perform things here */</comment>
</block_content>}</block></function>

<comment type="block">/* specify output plugin callbacks */</comment>
<function><type><name>void</name></type>
<name>_PG_output_plugin_init</name><parameter_list>(<parameter><decl><type><name>OutputPluginCallbacks</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertVariableIsOfType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>_PG_output_plugin_init</name></expr></argument>, <argument><expr><name>LogicalOutputPluginInit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>startup_cb</name></name> <operator>=</operator> <name>pg_decode_startup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>begin_cb</name></name> <operator>=</operator> <name>pg_decode_begin_txn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>change_cb</name></name> <operator>=</operator> <name>pg_decode_change</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>truncate_cb</name></name> <operator>=</operator> <name>pg_decode_truncate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>commit_cb</name></name> <operator>=</operator> <name>pg_decode_commit_txn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>filter_by_origin_cb</name></name> <operator>=</operator> <name>pg_decode_filter</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>shutdown_cb</name></name> <operator>=</operator> <name>pg_decode_shutdown</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>message_cb</name></name> <operator>=</operator> <name>pg_decode_message</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* initialize this plugin */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_decode_startup</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>OutputPluginOptions</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_init</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TestDecodingData</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TestDecodingData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
										  <argument><expr><literal type="string">"text conversion context"</literal></expr></argument>,
										  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>include_xids</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>include_timestamp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>skip_empty_xacts</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>only_local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>output_plugin_private</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>output_type</name></name> <operator>=</operator> <name>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>receive_rewrites</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>ctx-&gt;output_plugin_options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"include-xids"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if option does not provide a value, it means its value is true */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>include_xids</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>include_xids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse value \"%s\" for parameter \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"include-timestamp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>include_timestamp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>include_timestamp</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse value \"%s\" for parameter \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force-binary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>force_binary</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>force_binary</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse value \"%s\" for parameter \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>force_binary</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>output_type</name></name> <operator>=</operator> <name>OUTPUT_PLUGIN_BINARY_OUTPUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"skip-empty-xacts"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>

			<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>skip_empty_xacts</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>skip_empty_xacts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse value \"%s\" for parameter \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"only-local"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>

			<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>only_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>only_local</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse value \"%s\" for parameter \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"include-rewrites"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>

			<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opt</name><operator>-&gt;</operator><name>receive_rewrites</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse value \"%s\" for parameter \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option \"%s\" = \"%s\" is unknown"</literal></expr></argument>,
							<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>,
							<argument><expr><ternary><condition><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr> ?</condition><then> <expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"(null)"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* cleanup this plugin's resources */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_decode_shutdown</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TestDecodingData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>output_plugin_private</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* cleanup our own resources via memory context reset */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* BEGIN callback */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_decode_begin_txn</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TestDecodingData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>output_plugin_private</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>xact_wrote_changes</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>skip_empty_xacts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_output_begin</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_output_begin</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>TestDecodingData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>last_write</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>OutputPluginPrepareWrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>last_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>include_xids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN %u"</literal></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>OutputPluginWrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>last_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* COMMIT callback */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_decode_commit_txn</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
					 <parameter><decl><type><name>XLogRecPtr</name></type> <name>commit_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TestDecodingData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>output_plugin_private</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>skip_empty_xacts</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>xact_wrote_changes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>OutputPluginPrepareWrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>include_xids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"COMMIT %u"</literal></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>include_timestamp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" (at %s)"</literal></expr></argument>,
						 <argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>commit_time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>OutputPluginWrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pg_decode_filter</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
				 <parameter><decl><type><name>RepOriginId</name></type> <name>origin_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TestDecodingData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>output_plugin_private</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>only_local</name></name> <operator>&amp;&amp;</operator> <name>origin_id</name> <operator>!=</operator> <name>InvalidRepOriginId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Print literal `outputstr' already represented as string of type `typid'
 * into stringbuf `s'.
 *
 * Some builtin types aren't quoted, the rest is quoted. Escaping is done as
 * if standard_conforming_strings were enabled.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_literal</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>outputstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>valptr</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>typid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
		<case>case <expr><name>OIDOID</name></expr>:</case>
		<case>case <expr><name>FLOAT4OID</name></expr>:</case>
		<case>case <expr><name>FLOAT8OID</name></expr>:</case>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>
			<comment type="block">/* NB: We don't care about Inf, NaN et al. */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>BITOID</name></expr>:</case>
		<case>case <expr><name>VARBITOID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"B'%s'"</literal></expr></argument>, <argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>BOOLOID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>valptr</name> <operator>=</operator> <name>outputstr</name></expr>;</init> <condition><expr><operator>*</operator><name>valptr</name></expr>;</condition> <incr><expr><name>valptr</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>valptr</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>SQL_STR_DOUBLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* print the tuple 'tuple' into the StringInfo s */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tuple_to_stringinfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>natt</name></decl>;</decl_stmt>

	<comment type="block">/* print all columns individually */</comment>
	<for>for <control>(<init><expr><name>natt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>natt</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt> <comment type="block">/* the attribute itself */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name></decl>;</decl_stmt>		<comment type="block">/* type of current attribute */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>	<comment type="block">/* output function */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>origval</name></decl>;</decl_stmt>	<comment type="block">/* possibly toasted Datum */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>		<comment type="block">/* column is null? */</comment>

		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>natt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * don't print dropped columns, we can't be sure everything is
		 * available for them
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Don't print system columns, oid will already have been printed if
		 * present.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>typid</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>

		<comment type="block">/* get Datum from tuple */</comment>
		<expr_stmt><expr><name>origval</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>natt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>&amp;&amp;</operator> <name>skip_nulls</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* print attribute name */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* print attribute type */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* query output function */</comment>
		<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* print separator */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* print data */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>typisvarlena</name> <operator>&amp;&amp;</operator> <call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><name>origval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"unchanged-toast-datum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>typisvarlena</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>print_literal</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>,
						  <argument><expr><call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name>origval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>	<comment type="block">/* definitely detoasted Datum */</comment>

			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>origval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>print_literal</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * callback for individual changed tuples
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_decode_change</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
				 <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TestDecodingData</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>class_form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>output_plugin_private</name></name></expr>;</expr_stmt>

	<comment type="block">/* output BEGIN if we haven't yet */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>skip_empty_xacts</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>xact_wrote_changes</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_output_begin</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>xact_wrote_changes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>class_form</name> <operator>=</operator> <call><name>RelationGetForm</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Avoid leaking memory by using and resetting our own context */</comment>
	<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutputPluginPrepareWrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"table "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,
						   <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(
													  <argument><expr><call><name>get_namespace_name</name><argument_list>(
																		 <argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><ternary><condition><expr><name><name>class_form</name><operator>-&gt;</operator><name>relrewrite</name></name></expr> ?</condition><then>
													  <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>class_form</name><operator>-&gt;</operator><name>relrewrite</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
													  <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>class_form</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" INSERT:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" (no-tuple-data)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>tuple_to_stringinfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" UPDATE:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" old-key:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tuple_to_stringinfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" new-tuple:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" (no-tuple-data)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>tuple_to_stringinfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" DELETE:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* if there was no PK, we only know that a delete happened */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" (no-tuple-data)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<comment type="block">/* In DELETE, only the replica identity is present; display that */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>tuple_to_stringinfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutputPluginWrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_decode_truncate</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nrelations</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name><name>relations</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TestDecodingData</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>output_plugin_private</name></name></expr>;</expr_stmt>

	<comment type="block">/* output BEGIN if we haven't yet */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>skip_empty_xacts</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>xact_wrote_changes</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_output_begin</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>xact_wrote_changes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Avoid leaking memory by using and resetting our own context */</comment>
	<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutputPluginPrepareWrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"table "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrelations</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>,
							   <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>relations</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relations</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">": TRUNCATE:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>restart_seqs</name></name>
		<operator>||</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>cascade</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>restart_seqs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" restart_seqs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>cascade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" cascade"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">" (no-flags)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OutputPluginWrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_decode_message</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
				  <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>transactional</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>OutputPluginPrepareWrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="string">"message: transactional: %d prefix: %s, sz: %zu content:"</literal></expr></argument>,
					 <argument><expr><name>transactional</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OutputPluginWrite</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
