<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/contrib/formatter_fixedwidth/fixedwidth.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/formatter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Do the module magic dance */</comment>
<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>fixedwidth_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>fixedwidth_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>Datum</name></type> <name>fixedwidth_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>fixedwidth_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct <name>formatConfig</name>
<block>{
	<comment type="block">/*
	 * Normally we would have only one list of structs, each struct containing three fields:
	 * name, size, index. The reason we use three lists here is because we work with the infrastructure
	 * function CopyGetAttnums, which expects as input a list of names and returns a list of indexes.
	 * fldIndexes - holds the index of each field fetched from the file, into the fields description array
	 * tupdesc-&gt;attr[...]
	 */</comment>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>fldNames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>fldSizes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>fldIndexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>fldNullsWithBlanks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>fields_tot_size</name></decl>;</decl_stmt>
	
	<comment type="block">/*
	 * formatting parameters
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>         <name>preserve_blanks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>null_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>line_delimiter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>line_delimiter_length</name></decl>;</decl_stmt>
	
	<comment type="block">/*
	 * infrastructure variables required by postgres "type resolution" methods
	 */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>conv_functions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>        <modifier>*</modifier></type><name>typioparams</name></decl>;</decl_stmt>
	
}</block></struct></type> <name>FormatConfig</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>int</name></type>            <name>ncols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>         <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>          <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>            <name>buflen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>         <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>one_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>one_field</name></decl>;</decl_stmt>	<comment type="block">/* temporary string buffer for string expansion */</comment>
	<decl_stmt><decl><type><name>int</name></type>            <name>lineno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		   <name>convert</name></decl>;</decl_stmt> 	<comment type="block">/* true - perform conversion on column value. false - don't */</comment>
}</block></struct></type> <name>format_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> 
<name>init_format_t</name><parameter_list>(<parameter><decl><type><name>format_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ncolumns</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>data</name>            <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>format_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>data</name><operator>)</operator><operator>-&gt;</operator><name>ncols</name></name>   <operator>=</operator> <name>ncolumns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>data</name><operator>)</operator><operator>-&gt;</operator><name>values</name></name>  <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>data</name><operator>)</operator><operator>-&gt;</operator><name>nulls</name></name>   <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>data</name><operator>)</operator><operator>-&gt;</operator><name>lineno</name></name>  <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>data</name><operator>)</operator><operator>-&gt;</operator><name>convert</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>( <argument><expr><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>data</name><operator>)</operator><operator>-&gt;</operator><name>one_val</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>( <argument><expr><operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>data</name><operator>)</operator><operator>-&gt;</operator><name>one_field</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>FORMATTER_SET_USER_CTX</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>*</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	
</block_content>}</block></function>

<comment type="block">/*
 * extract_field
 *
 * extract a field value from a character string 'data_cursor'. If we
 * preserve blanks, then the entire field_total_length is extracted.
 * Otherwise, we extract all bytes except the trailing blanks. The field
 * value is then stored inside 'output'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>extract_field</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data_cursor</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_total_length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>preserve_blanks</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>output</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>actual_length</name></decl>;</decl_stmt>
	
	<comment type="block">/*
	 * the actual length of the string we will restore into the database depends whether
	 * we preserve_blanks or not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>preserve_blanks</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>actual_length</name> <operator>=</operator> <name>field_total_length</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else 
	<block>{<block_content>
		<comment type="block">/*
		 * assume all field characters are blanks
		 */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><name>data_cursor</name> <operator>+</operator> <name>field_total_length</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>actual_length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		
		<while>while <condition>(<expr><name>tail</name> <operator>!=</operator> <name>data_cursor</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tail</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>actual_length</name> <operator>=</operator> <name>tail</name> <operator>-</operator> <name>data_cursor</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>tail</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		
		<if_stmt><if>if <condition>( <expr><operator>(</operator><name>tail</name> <operator>==</operator> <name>data_cursor</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>data_cursor</name> <operator>!=</operator> <literal type="char">' '</literal><operator>)</operator></expr> )</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>actual_length</name>  <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	
	<comment type="block">/* store the extracted field value */</comment>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>data_cursor</name></expr></argument>, <argument><expr><name>actual_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>reset_format_in_config</name><parameter_list>(<parameter><decl><type><name>FormatConfig</name> <modifier>*</modifier></type><name>format_config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>preserve_blanks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>null_value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>line_delimiter</name></name> <operator>=</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>line_delimiter_length</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>format_config</name><operator>-&gt;</operator><name>line_delimiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>fldNames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>fldSizes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>fldIndexes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>fldNullsWithBlanks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>fields_tot_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * load_format_config
 *
 * parse the user specified fixed width keywords. Currently supported
 * keywords are: 'preserve_blanks', 'line_delim' and 'null'. any other
 * unrecognized keyword is treated as a column name (and later on gets
 * verified as a valid column).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_format_config</name><parameter_list>(<parameter><decl><type><name>FormatConfig</name> <modifier>*</modifier></type><name>format_config</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>   <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>   <name>args_num</name> <init>= <expr><call><name>FORMATTER_GET_NUM_ARGS</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>reset_format_in_config</name><argument_list>(<argument><expr><name>format_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>args_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>FORMATTER_GET_NTH_ARG_KEY</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>FORMATTER_GET_NTH_ARG_VAL</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>( <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><literal type="string">"preserve_blanks"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>( <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><literal type="string">"on"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>preserve_blanks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>( <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><literal type="string">"line_delim"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>line_delimiter</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>line_delimiter_length</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>( <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>null_value</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>fldNames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>format_config</name><operator>-&gt;</operator><name>fldNames</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>fldSizes</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>format_config</name><operator>-&gt;</operator><name>fldSizes</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>format_config</name><operator>-&gt;</operator><name>fields_tot_size</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>		
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * encoding_check_str
 *
 * for a given string 'str' of length 'len', check if performing
 * an encoding conversion will modify the original string or not
 * and return the answer. The input string remains *unmodified*.
 * While at it, the encoding converter also verifies that the
 * input string is valid in the client (external table) encoding.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>encoding_check_str</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_import</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>cvt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FORMATTER_ENCODE_STRING</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cvt</name></expr></argument>, <argument><expr><name>is_import</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cvt</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>cvt</name> <operator>!=</operator> <name>str</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cvt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * encoding_encode_strinfo
 *
 * convert a given stringinfo 'strinfo' to the appropriate (pre-defined)
 * encoding (encoding will only be done if really needed).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>encoding_encode_strinfo</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>strinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_import</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>cvt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FORMATTER_ENCODE_STRING</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name><name>strinfo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>strinfo</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>cvt</name></expr></argument>, <argument><expr><name>is_import</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cvt</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>cvt</name> <operator>!=</operator> <name><name>strinfo</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* transfer converted data back to strinfo */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>strinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>strinfo</name></expr></argument>, <argument><expr><name>cvt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cvt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>make_null_val_with_blanks</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>actual_size</name> <init>= <expr><name>field_size</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>( <expr><name>size</name> <operator>&gt;</operator> <name>field_size</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_LENGTH_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the size of the null_value cannot be bigger than the field size"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>ret</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>actual_size</name> <operator>-</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ret</name><index>[<expr><name>actual_size</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_val_with_blanks
 *
 * Pad one string value with blanks, so the size will correspond to the fixedwidth
 * required by the format. Make sure to encode the string into external table
 * encoding before writing it out (if conversion is needed).
 *
 * Arguments:
 *  value           - the field value in string format 
 *  field_size      - the fixedwidth field size, that is required for the value, for it to be added on the output line
 *  buf             - The temporary field buffer used for field value expansion - so it will reach the fixedwidth size
 *
 * Returns:
 * 	blank padded    - padded value of size field_size, in case value is NULL the return string will contain only blanks
 *  value
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>make_val_with_blanks</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_size</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>sz</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * convert value from server encoding to external table encoding. Since
		 * it is possible that the encoded string will vary in size from the
		 * original string we must re-adjust if necessary
		 */</comment>
		<expr_stmt><expr><call><name>encoding_encode_strinfo</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* export */</comment>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Error out if the value is too large, and pad with spaces if it's too
	 * small.
	 */</comment>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;</operator> <name>field_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STRING_DATA_LENGTH_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The size of the value cannot be bigger than the field size value: %s, size: %d, field_size %d"</literal></expr></argument>,
						<argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>field_size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>field_size</name> <operator>-</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fill_null_with_blanks_list</name><parameter_list>(<parameter><decl><type><name>FormatConfig</name> <modifier>*</modifier></type><name>format_in_config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>curSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>field_size</name></decl>;</decl_stmt>
	
	<macro><name>foreach</name><argument_list>(<argument>curSize</argument>, <argument>format_in_config-&gt;fldSizes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>field_size</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>curSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>fldNullsWithBlanks</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>fldNullsWithBlanks</name></name></expr></argument>, 
													   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>make_null_val_with_blanks</name><argument_list>(<argument><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>null_value</name></name></expr></argument>, <argument><expr><name>field_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * validate_format_params
 *
 * verifies that every field specified in the table creation list is also present in the formatting string
 * and vice versa
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_format_params</name><parameter_list>(<parameter><decl><type><name>FormatConfig</name> <modifier>*</modifier></type><name>format_in_config</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_fields_in_format_string</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>fldNames</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_fields_in_table_list</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>num_fields_in_format_string</name> <operator>!=</operator> <name>num_fields_in_table_list</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"mismatch in column length specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The fixed width formatter requires a length specification for each one of the "</literal>
						   <literal type="string">"external table columns being used (currently %d, however format string has %d)."</literal></expr></argument>,
						   <argument><expr><name>num_fields_in_table_list</name></expr></argument>, <argument><expr><name>num_fields_in_format_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>format_in_config-&gt;fldNames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_in_both_lists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_fields_in_table_list</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>is_in_both_lists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>			
		</block_content>}</block></for>
		
		<if_stmt><if>if <condition>(<expr><name>is_in_both_lists</name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing column definition in length specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The fixed width formatter requires a length specification for each one of the "</literal>
							   <literal type="string">"external table columns being used (missing field \"%s\")."</literal></expr></argument>,
							   <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_format_in_config</name><parameter_list>(<parameter><decl><type><name>FormatConfig</name> <modifier>*</modifier></type><name>format_in_config</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ncolumns</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>load_format_config</name><argument_list>(<argument><expr><name>format_in_config</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>validate_format_params</name><argument_list>(<argument><expr><name>format_in_config</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>format_in_config</name><operator>-&gt;</operator><name>null_value</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fill_null_with_blanks_list</name><argument_list>(<argument><expr><name>format_in_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>conv_functions</name></name> <operator>=</operator> <call><name>FORMATTER_GET_CONVERSION_FUNCS</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>typioparams</name></name> <operator>=</operator> <call><name>FORMATTER_GET_TYPIOPARAMS</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	<expr_stmt><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>fldIndexes</name></name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><call><name>FORMATTER_GET_RELATION</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>fldNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_format_out_config</name><parameter_list>(<parameter><decl><type><name>FormatConfig</name> <modifier>*</modifier></type><name>format_out_config</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ncolumns</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>load_format_config</name><argument_list>(<argument><expr><name>format_out_config</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>validate_format_params</name><argument_list>(<argument><expr><name>format_out_config</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>format_out_config</name><operator>-&gt;</operator><name>null_value</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fill_null_with_blanks_list</name><argument_list>(<argument><expr><name>format_out_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name><name>format_out_config</name><operator>-&gt;</operator><name>conv_functions</name></name> <operator>=</operator> <call><name>FORMATTER_GET_CONVERSION_FUNCS</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	<expr_stmt><expr><name><name>format_out_config</name><operator>-&gt;</operator><name>fldIndexes</name></name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><call><name>FORMATTER_GET_RELATION</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>format_out_config</name><operator>-&gt;</operator><name>fldNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> 
<name>get_tuple_info</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>r_ncolumns</name></decl></parameter>, <parameter><decl><type><name>format_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>r_myData</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>, 
			   <parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>FormatConfig</name> <modifier>*</modifier></type><name>format_out_config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleData</name></type>		<name>tuple</name></decl>;</decl_stmt>	
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type>		<name>rec</name>	<init>= <expr><call><name>PG_GETARG_HEAPTUPLEHEADER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	
	<comment type="block">/* Get our internal description of the formatter */</comment>
	<expr_stmt><expr><operator>*</operator><name>r_ncolumns</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ncolumns</name> <init>= <expr><operator>*</operator><name>r_ncolumns</name></expr></init></decl>;</decl_stmt>	
	<expr_stmt><expr><operator>*</operator><name>r_myData</name> <operator>=</operator> <operator>(</operator><name>format_t</name> <operator>*</operator><operator>)</operator> <call><name>FORMATTER_GET_USER_CTX</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>format_t</name> <modifier>*</modifier></type><name>myData</name> <init>= <expr><operator>*</operator><name>r_myData</name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>myData</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>myData</name>          <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>format_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>r_myData</name>       <operator>=</operator> <name>myData</name></expr>;</expr_stmt>
		
		<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>ncols</name></name>   <operator>=</operator> <name>ncolumns</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>values</name></name>  <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>nulls</name></name>   <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>( <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>myData</name><operator>-&gt;</operator><name>one_field</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		
		
		<expr_stmt><expr><call><name>init_format_out_config</name><argument_list>(<argument><expr><name>format_out_config</name></expr></argument>, <argument><expr><name>ncolumns</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<comment type="block">/* Determine required buffer size */</comment>
		<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>buflen</name></name> <operator>=</operator> <name><name>format_out_config</name><operator>-&gt;</operator><name>fields_tot_size</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>format_out_config</name><operator>-&gt;</operator><name>line_delimiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>buflen</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><name><name>myData</name><operator>-&gt;</operator><name>buflen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* allocate at least 128 bytes */</comment>
		<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>myData</name><operator>-&gt;</operator><name>buflen</name></name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><call><name>FORMATTER_SET_USER_CTX</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>myData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>myData</name><operator>-&gt;</operator><name>ncols</name></name> <operator>!=</operator> <name>ncolumns</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"formatter_export: unexpected change of output record type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* break the input tuple into fields */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>rec</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>myData</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>myData</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name><name>myData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_actual_line_size</name><parameter_list>(<parameter><decl><type><name>FormatConfig</name> <modifier>*</modifier></type><name>format_in_config</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line_start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tot_size</name></decl></parameter>, <parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>   <name>row_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>   <name>actual_fields_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>   <name>remaining</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line_end</name></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expected_delim_loc</name> <init>= <expr><name>line_start</name> <operator>+</operator> <name><name>format_in_config</name><operator>-&gt;</operator><name>fields_tot_size</name></name></expr></init></decl>;</decl_stmt>
	
	<comment type="block">/*
	 * the case where there is no line delimiter
	 */</comment>
	<if_stmt><if>if <condition>( <expr><literal type="number">0</literal> <operator>==</operator> <name><name>format_in_config</name><operator>-&gt;</operator><name>line_delimiter_length</name></name></expr> )</condition>
	<block>{<block_content>
		<return>return <expr><name><name>format_in_config</name><operator>-&gt;</operator><name>fields_tot_size</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>( <expr><literal type="number">1</literal> <operator>==</operator> <name><name>format_in_config</name><operator>-&gt;</operator><name>line_delimiter_length</name></name></expr> )</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name>delim</name> <init>= <expr><name><name>format_in_config</name><operator>-&gt;</operator><name>line_delimiter</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="line">// Check the remaining buffer size.		</comment>
		<if_stmt><if>if <condition>( <expr><operator>*</operator><name>expected_delim_loc</name> <operator>==</operator> <name>delim</name> <operator>&amp;&amp;</operator> <name>tot_size</name> <operator>-</operator> <name>cur_size</name> <operator>&gt;</operator> <name><name>format_in_config</name><operator>-&gt;</operator><name>fields_tot_size</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>line_end</name> <operator>=</operator> <name>expected_delim_loc</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>line_end</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>line_start</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		
	</block_content>}</block></if>
	<else>else <comment type="block">/* &gt; 1 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>as_expected</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		
		<for>for <control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>format_in_config</name><operator>-&gt;</operator><name>line_delimiter_length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>( <expr><name><name>expected_delim_loc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>format_in_config</name><operator>-&gt;</operator><name>line_delimiter</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>as_expected</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		
		<if_stmt><if>if <condition>( <expr><name>as_expected</name></expr> )</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>line_end</name> <operator>=</operator> <name>expected_delim_loc</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>line_end</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>line_start</name></expr></argument>, <argument><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>line_delimiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	
	<comment type="block">/*
	 * line_end will be 0, if strchr or strstr did not find the delimiter.
	 * In this case we throw an exception  ( unless this is the last line in the buffer )--&gt; The line delimiter specified in
	 * FormatConfig must be present in the file.
	 */</comment>
	<if_stmt><if>if <condition>( <expr><literal type="number">0</literal> <operator>==</operator> <name>line_end</name></expr> <comment type="block">/*did not find delimiter*/</comment> )</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>remaining</name> <operator>=</operator> <name>tot_size</name> <operator>-</operator> <name>cur_size</name> <operator>-</operator> <name><name>format_in_config</name><operator>-&gt;</operator><name>fields_tot_size</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <name>remaining</name></expr>)</condition> <comment type="block">/* we are at the last line so we cannot find a custom delimiter - we have an OS line delimiter here */</comment>
		<block>{<block_content>
			<return>return <expr><operator>(</operator><name><name>format_in_config</name><operator>-&gt;</operator><name>fields_tot_size</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
		</block_content>}</block></if></if_stmt>
		
		<comment type="block">/*
		 * this is the case where the last line in the buffer is incomplete, that's why the end of line was not found.
		 * the rest of the line is in the next buffer.
		 * When the remaining buffer include a complete line, but no line delimiter.
		 * The remaining buffer size is equal with field total size.
		 */</comment>  
		<if_stmt><if>if <condition>( <expr><operator>(</operator><name>tot_size</name> <operator>-</operator> <name>cur_size</name><operator>)</operator> <operator>&lt;=</operator> <name><name>format_in_config</name><operator>-&gt;</operator><name>fields_tot_size</name></name></expr> )</condition>
		<block>{<block_content>
			<return>return <expr><name>tot_size</name> <operator>-</operator> <name>cur_size</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		
		<comment type="block">/* 
		 * if we are here, it means the file simply does not contain the line delimiter specified in the formatter string.
		 * so we throw an exception
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"line delimiter \"%s\" is missing in data file"</literal></expr></argument>,
						<argument><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>line_delimiter</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The line delimiter specified in the Formatter arguments: \"%s\" is not located in the data file"</literal></expr></argument>,
						   <argument><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>line_delimiter</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>actual_fields_size</name> <operator>=</operator> <name>line_end</name> <operator>-</operator> <name>line_start</name></expr>;</expr_stmt> 
	<if_stmt><if>if <condition>( <expr><name>actual_fields_size</name> <operator>!=</operator> <name><name>format_in_config</name><operator>-&gt;</operator><name>fields_tot_size</name></name></expr> )</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>total_actual_field_size</name> <init>= <expr><name>actual_fields_size</name> <operator>+</operator> <name><name>format_in_config</name><operator>-&gt;</operator><name>line_delimiter_length</name></name></expr></init></decl>;</decl_stmt>
		
		<expr_stmt><expr><call><name>FORMATTER_SET_BAD_ROW_DATA</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>line_start</name></expr></argument>, <argument><expr><name>total_actual_field_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FORMATTER_SET_BYTE_NUMBER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>total_actual_field_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected line size from the formatting string is %d, actual size is %d"</literal></expr></argument>,
						<argument><expr><name><name>format_in_config</name><operator>-&gt;</operator><name>fields_tot_size</name></name></expr></argument>, <argument><expr><name>actual_fields_size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name>row_size</name> <operator>=</operator> <name>actual_fields_size</name> <operator>+</operator> <name><name>format_in_config</name><operator>-&gt;</operator><name>line_delimiter_length</name></name></expr>;</expr_stmt>
	<return>return <expr><name>row_size</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>Datum</name></type> 
<name>fixedwidth_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>           <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> 		<name>m</name></decl>, <decl><type ref="prev"/><name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                 <name>ncolumns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>format_t</name>           <modifier>*</modifier></type><name>myData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>               <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                 <name>datlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>           <modifier>*</modifier></type><name>curIdx</name></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>ListCell</name>           <modifier>*</modifier></type><name>curSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                 <name>field_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>               <modifier>*</modifier></type><name>mapped_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>               <modifier>*</modifier></type><name>mapped_val_with_blanks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		        <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		        <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			        <name>idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>FormatConfig</name></type> <name>format_out_config</name></decl>;</decl_stmt>
	
	<comment type="block">/* Must be called via the external table format manager */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_FORMATTER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fixedwidth_out: not called by format manager"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>FORMATTER_GET_TUPDESC</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_tuple_info</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ncolumns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>format_out_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* =======================================================================
	 *                            MAIN FORMATTING CODE
	 * ======================================================================= */</comment>
	<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>FORMATTER_GET_PER_ROW_MEM_CTX</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	
	<macro><name>forboth</name><argument_list>(<argument>curIdx</argument>, <argument>format_out_config.fldIndexes</argument>, <argument>curSize</argument>, <argument>format_out_config.fldSizes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>field_size</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>curSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idx</name>  <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>curIdx</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>		
		<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name><name>myData</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>myData</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>( <expr><name>isnull</name></expr> )</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>mapped_val_with_blanks</name> <operator>=</operator> <call><name>make_val_with_blanks</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name><name>format_out_config</name><operator>.</operator><name>null_value</name></name></expr></argument>, <argument><expr><name>field_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>myData</name><operator>-&gt;</operator><name>one_field</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else 
		<block>{<block_content>
			<expr_stmt><expr><name>mapped_val</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>format_out_config</name><operator>.</operator><name>conv_functions</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mapped_val_with_blanks</name> <operator>=</operator> <call><name>make_val_with_blanks</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>mapped_val</name></expr></argument>, <argument><expr><name>field_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>myData</name><operator>-&gt;</operator><name>one_field</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>datlen</name></expr>]</index></name></expr></argument>, <argument><expr><name>mapped_val_with_blanks</name></expr></argument>, <argument><expr><name>field_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datlen</name> <operator>+=</operator> <name>field_size</name></expr>;</expr_stmt>
	</block_content>}</block>
	
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>datlen</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>format_out_config</name><operator>.</operator><name>line_delimiter</name></name></expr></argument>, <argument><expr><name><name>format_out_config</name><operator>.</operator><name>line_delimiter_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datlen</name> <operator>+=</operator> <name><name>format_out_config</name><operator>.</operator><name>line_delimiter_length</name></name></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ======================================================================= */</comment>
	
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name><name>myData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>datlen</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name><name>myData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fixedwidth_in
 * each time this function is called, it builds one tuple from the input data buffer
 */</comment>
<function><type><name>Datum</name></type> 
<name>fixedwidth_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>	
	<decl_stmt><decl><type><name>HeapTuple</name></type>			<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>           <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> 		<name>m</name></decl>, <decl><type ref="prev"/><name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>format_t</name>           <modifier>*</modifier></type><name>myData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>               <modifier>*</modifier></type><name>data_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                 <name>ncolumns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			  		<name>data_cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                 <name>data_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>                <name>saw_eof</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>eof_is_lf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>           <modifier>*</modifier></type><name>curIdx</name></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>ListCell</name>           <modifier>*</modifier></type><name>curSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>           <modifier>*</modifier></type><name>cur_null_with_blanks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	
	<decl_stmt><decl><type><name>int</name></type>		            <name>remaining</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                 <name>field_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>   				<name>row_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>               <modifier>*</modifier></type><name>nullval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			        <name>idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>               <modifier>*</modifier></type><name>null_val_with_blanks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>FormatConfig</name></type> <name>format_in_config</name></decl>;</decl_stmt>
	
	<comment type="block">/* Must be called via the external table format manager */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_FORMATTER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fixedwidth_in: not called by format manager"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>FORMATTER_GET_TUPDESC</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* Get our internal description of the formatter */</comment>
	<expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>	
	<expr_stmt><expr><name>myData</name> <operator>=</operator> <operator>(</operator><name>format_t</name> <operator>*</operator><operator>)</operator> <call><name>FORMATTER_GET_USER_CTX</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>myData</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>init_format_in_config</name><argument_list>(<argument><expr><operator>&amp;</operator><name>format_in_config</name></expr></argument>, <argument><expr><name>ncolumns</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_format_t</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myData</name></expr></argument>, <argument><expr><name>ncolumns</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/* start clean */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>myData</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>myData</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get our input data buf and number of valid bytes in it */</comment>
	<expr_stmt><expr><name>data_buf</name> <operator>=</operator> <call><name>FORMATTER_GET_DATABUF</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>FORMATTER_GET_DATALEN</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><name>data_cur</name> <operator>=</operator> <call><name>FORMATTER_GET_DATACURSOR</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>saw_eof</name>  <operator>=</operator> <call><name>FORMATTER_GET_SAW_EOF</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>eof_is_lf</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>format_in_config</name><operator>.</operator><name>line_delimiter</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* =======================================================================
	 *                            MAIN FORMATTING CODE
	 * ======================================================================= */</comment>	
	<comment type="block">/*
	 * tuple data extraction is done in a separate memory context
	 */</comment>
	<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>FORMATTER_GET_PER_ROW_MEM_CTX</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		
	<comment type="block">/*
	 * if data_cur == data_len, it means we finished the current buffer, we will not do any formatting,
	 * instead inside forboth loop we will fall inside "if (remaining &lt; field_size)", so there is NO need to
	 * set the BAD_ROW_DATA error string ---&gt; there will be no formatting errors that throw exceptions
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>data_cur</name> <operator>&lt;</operator> <name>data_len</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* setting the line number for "line size" exceptions that might be thrown in get_actual_line_size */</comment>
		<expr_stmt><expr><call><name>FORMATTER_SET_BAD_ROW_NUM</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name><name>myData</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<comment type="block">/*
		 * myData-&gt;lineno represents the line number in the datafile, when the file was opened
		 * with a conventional editor, so we increase the lineno only when the delimiter is LF
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>eof_is_lf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>lineno</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>	
		<expr_stmt><expr><name>row_size</name> <operator>=</operator> <call><name>get_actual_line_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>format_in_config</name></expr></argument>, <argument><expr><name>data_buf</name> <operator>+</operator> <name>data_cur</name></expr></argument>, <argument><expr><name>data_cur</name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FORMATTER_SET_BAD_ROW_DATA</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>data_buf</name> <operator>+</operator> <name>data_cur</name></expr></argument>, <argument><expr><name>row_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FORMATTER_SET_BYTE_NUMBER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>row_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else 
	<block>{<block_content>
		<comment type="block">/*
		 * This line is not finished. Next buffer will bring the remaining of the line.
		 * So the line number should not grow.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>eof_is_lf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>lineno</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>			
		
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FORMATTER_RETURN_NOTIFICATION</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>FMT_NEED_MORE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>				
	</block_content>}</block></else></if_stmt>
	
	<comment type="block">/*
	 * Encoding of client data to server encoding.
	 *
	 * Ideally we would run a conversion over a line of data and be done.
	 * However, this may change the byte offsets and mess up with the fixed
	 * width of the input data.
	 *
	 * As we want to avoid encoding conversion when necessary (for performance)
	 * We first run a test on a whole line and see if it passes input encoding
	 * validation. if not, an error is emitted. if yes, we make a note whether
	 * the input string was actually modified or not and take note of it in the
	 * convert boolean. In most cases 'convert' will remain false and we're done.
	 * In cases where it is true we postpone the actual conversion of values to
	 * a later stage (per attribute) in order to keep the formatter clean.
	 */</comment>
	<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>convert</name></name> <operator>=</operator> <call><name>encoding_check_str</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>data_buf</name> <operator>+</operator> <name>data_cur</name></expr></argument>, <argument><expr><name>row_size</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>format_in_config</name><operator>.</operator><name>null_value</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cur_null_with_blanks</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>format_in_config</name><operator>.</operator><name>fldNullsWithBlanks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<macro><name>forboth</name><argument_list>(<argument>curIdx</argument>, <argument>format_in_config.fldIndexes</argument>, <argument>curSize</argument>, <argument>format_in_config.fldSizes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>remaining</name>	<operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>field_size</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>curSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullval</name> <operator>=</operator> <name><name>format_in_config</name><operator>.</operator><name>null_value</name></name></expr>;</expr_stmt>		
		<expr_stmt><expr><name>remaining</name> <operator>=</operator> <name>data_len</name> <operator>-</operator> <name>data_cur</name></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&lt;=</operator> <name>field_size</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we will get here only in the case we are working without a line delimiter. Because "remaining smaller then fieldsize"
			 * means that our actual line is smaller than expected size, and if we have a line delimiter this problem will be discovered
			 * in function  get_actual_line_size which is called above.
			 */</comment>
			
			<if_stmt><if>if <condition>(<expr><name>saw_eof</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>remaining</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>data_cur</name> <operator>+=</operator> <name>remaining</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FORMATTER_SET_DATACURSOR</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>data_cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"last line in the file contains an incomplete tuple"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>saw_eof</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>remaining</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we are in a case of no line delimiter, but the end of the file contains one EOL */</comment>
				<expr_stmt><expr><name>data_cur</name> <operator>+=</operator> <name>remaining</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FORMATTER_SET_DATACURSOR</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>data_cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FORMATTER_RETURN_NOTIFICATION</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>FMT_NEED_MORE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>				
				
			</block_content>}</block></if>			 
			<else>else 
			<block>{<block_content>
				<comment type="block">/*
				 * This line is not finished. Next buffer will bring the remaining of the line.
				 * So the line number should not grow.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>eof_is_lf</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>lineno</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>			
				
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FORMATTER_RETURN_NOTIFICATION</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>FMT_NEED_MORE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>				
			</block_content>}</block></else></if_stmt>

		</block_content>}</block></if></if_stmt>
		
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>myData</name><operator>-&gt;</operator><name>one_val</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>idx</name>  <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>curIdx</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><name><name>format_in_config</name><operator>.</operator><name>preserve_blanks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* extract field value while ignoring blanks */</comment>
			<expr_stmt><expr><call><name>extract_field</name><argument_list>(<argument><expr><name>data_buf</name> <operator>+</operator> <name>data_cur</name></expr></argument>, <argument><expr><name>field_size</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>myData</name><operator>-&gt;</operator><name>one_val</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * there are two (2) cases when we set value to null:
			 * a. there is a null value defined in the formatter arguments, and this value was found in the field
			 * b. there is no null value defined and the field contained only blanks
			 */</comment> 
			<if_stmt><if>if <condition>( <expr><operator>!</operator><operator>(</operator> <operator>(</operator><name>nullval</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>myData</name><operator>-&gt;</operator><name>one_val</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>nullval</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>)</operator>  <operator>&amp;&amp;</operator>
				 <comment type="block">/* we are not in case a */</comment>
				 <operator>!</operator><operator>(</operator> <operator>(</operator><name>nullval</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>myData</name><operator>-&gt;</operator><name>one_val</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator> <operator>)</operator></expr> )</condition>
				 <comment type="block">/* and also not in case b */</comment>
			<block>{<block_content>			
				<comment type="block">/* perform encoding conversion on field value if needed */</comment>
				<if_stmt><if>if<condition>(<expr><name><name>myData</name><operator>-&gt;</operator><name>convert</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>encoding_encode_strinfo</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>myData</name><operator>-&gt;</operator><name>one_val</name></name><operator>)</operator></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>format_in_config</name><operator>.</operator><name>conv_functions</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>,
														<argument><expr><name><name>myData</name><operator>-&gt;</operator><name>one_val</name><operator>.</operator><name>data</name></name></expr></argument>,
														<argument><expr><name><name>format_in_config</name><operator>.</operator><name>typioparams</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>,
														<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else 
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nullval</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>cur_null_with_blanks</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null_value was not defined"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"When preserve_blanks is on, a null_value must be defined in the formatter arguments string."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* extract field value while treating blanks as data */</comment>
			<expr_stmt><expr><call><name>extract_field</name><argument_list>(<argument><expr><name>data_buf</name> <operator>+</operator> <name>data_cur</name></expr></argument>, <argument><expr><name>field_size</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>myData</name><operator>-&gt;</operator><name>one_val</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>null_val_with_blanks</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cur_null_with_blanks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_null_with_blanks</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cur_null_with_blanks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>myData</name><operator>-&gt;</operator><name>one_val</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>null_val_with_blanks</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* perform encoding conversion on field value if needed */</comment>
				<if_stmt><if>if<condition>(<expr><name><name>myData</name><operator>-&gt;</operator><name>convert</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>encoding_encode_strinfo</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>myData</name><operator>-&gt;</operator><name>one_val</name></name><operator>)</operator></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>format_in_config</name><operator>.</operator><name>conv_functions</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>,
														<argument><expr><name><name>myData</name><operator>-&gt;</operator><name>one_val</name><operator>.</operator><name>data</name></name></expr></argument>,
														<argument><expr><name><name>format_in_config</name><operator>.</operator><name>typioparams</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>,
														<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>myData</name><operator>-&gt;</operator><name>nulls</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>data_cur</name> <operator>+=</operator> <name>field_size</name></expr>;</expr_stmt>
	</block_content>}</block>	
	
	<comment type="block">/*
	 * go over the line delimiter
	 */</comment>
	<expr_stmt><expr><name>remaining</name> <operator>=</operator> <name>data_len</name> <operator>-</operator> <name>data_cur</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>data_cur</name> <operator>+=</operator> <name><name>format_in_config</name><operator>.</operator><name>line_delimiter_length</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>remaining</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>data_cur</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * wrapping up
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ======================================================================= */</comment>
	
	<expr_stmt><expr><call><name>FORMATTER_SET_DATACURSOR</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>data_cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>myData</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>myData</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FORMATTER_SET_TUPLE</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FORMATTER_RETURN_TUPLE</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
