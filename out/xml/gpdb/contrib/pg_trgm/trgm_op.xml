<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/contrib/pg_trgm/trgm_op.c"><comment type="block">/*
 * contrib/pg_trgm/trgm_op.c
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trgm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_crc.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block">/* GUC variables */</comment>
<decl_stmt><decl><type><name>double</name></type>		<name>similarity_threshold</name> <init>= <expr><literal type="number">0.3f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>word_similarity_threshold</name> <init>= <expr><literal type="number">0.6f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>strict_word_similarity_threshold</name> <init>= <expr><literal type="number">0.5f</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><name>void</name></type>		<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>set_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>show_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>show_trgm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>similarity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>word_similarity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>strict_word_similarity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>similarity_dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>similarity_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>word_similarity_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>word_similarity_commutator_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>word_similarity_dist_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>word_similarity_dist_commutator_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>strict_word_similarity_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>strict_word_similarity_commutator_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>strict_word_similarity_dist_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>strict_word_similarity_dist_commutator_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Trigram with position */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>trgm</name></type>		<name>trg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
}</block></struct></type> <name>pos_trgm</name>;</typedef>

<comment type="block">/* Trigram bound type */</comment>
<typedef>typedef <type><name>uint8</name></type> <name>TrgmBound</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRGM_BOUND_LEFT</name></cpp:macro>				<cpp:value>0x01</cpp:value></cpp:define>	<comment type="block">/* trigram is left bound of word */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRGM_BOUND_RIGHT</name></cpp:macro>			<cpp:value>0x02</cpp:value></cpp:define>	<comment type="block">/* trigram is right bound of word */</comment>

<comment type="block">/* Word similarity flags */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORD_SIMILARITY_CHECK_ONLY</name></cpp:macro>	<cpp:value>0x01</cpp:value></cpp:define>	<comment type="block">/* only check existence of similar
											 * search pattern in text */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORD_SIMILARITY_STRICT</name></cpp:macro>		<cpp:value>0x02</cpp:value></cpp:define>	<comment type="block">/* force bounds of extent to match
											 * word bounds */</comment>

<comment type="block">/*
 * Module load callback
 */</comment>
<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Define custom GUC variables. */</comment>
	<expr_stmt><expr><call><name>DefineCustomRealVariable</name><argument_list>(<argument><expr><literal type="string">"pg_trgm.similarity_threshold"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Sets the threshold used by the % operator."</literal></expr></argument>,
							 <argument><expr><literal type="string">"Valid range is 0.0 .. 1.0."</literal></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>similarity_threshold</name></expr></argument>,
							 <argument><expr><literal type="number">0.3</literal></expr></argument>,
							 <argument><expr><literal type="number">0.0</literal></expr></argument>,
							 <argument><expr><literal type="number">1.0</literal></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DefineCustomRealVariable</name><argument_list>(<argument><expr><literal type="string">"pg_trgm.word_similarity_threshold"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Sets the threshold used by the &lt;% operator."</literal></expr></argument>,
							 <argument><expr><literal type="string">"Valid range is 0.0 .. 1.0."</literal></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>word_similarity_threshold</name></expr></argument>,
							 <argument><expr><literal type="number">0.6</literal></expr></argument>,
							 <argument><expr><literal type="number">0.0</literal></expr></argument>,
							 <argument><expr><literal type="number">1.0</literal></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DefineCustomRealVariable</name><argument_list>(<argument><expr><literal type="string">"pg_trgm.strict_word_similarity_threshold"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Sets the threshold used by the &lt;&lt;% operator."</literal></expr></argument>,
							 <argument><expr><literal type="string">"Valid range is 0.0 .. 1.0."</literal></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>strict_word_similarity_threshold</name></expr></argument>,
							 <argument><expr><literal type="number">0.5</literal></expr></argument>,
							 <argument><expr><literal type="number">0.0</literal></expr></argument>,
							 <argument><expr><literal type="number">1.0</literal></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deprecated function.
 * Use "pg_trgm.similarity_threshold" GUC variable instead of this function.
 */</comment>
<function><type><name>Datum</name></type>
<name>set_limit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>nlimit</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nlimit_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>func_out_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varlena</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>FLOAT4OID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>func_out_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_varlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nlimit_str</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>func_out_oid</name></expr></argument>, <argument><expr><call><name>Float4GetDatum</name><argument_list>(<argument><expr><name>nlimit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"pg_trgm.similarity_threshold"</literal></expr></argument>, <argument><expr><name>nlimit_str</name></expr></argument>,
					<argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>similarity_threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Get similarity threshold for given index scan strategy number.
 */</comment>
<function><type><name>double</name></type>
<name>index_strategy_get_limit</name><parameter_list>(<parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SimilarityStrategyNumber</name></expr>:</case>
			<return>return <expr><name>similarity_threshold</name></expr>;</return>
		<case>case <expr><name>WordSimilarityStrategyNumber</name></expr>:</case>
			<return>return <expr><name>word_similarity_threshold</name></expr>;</return>
		<case>case <expr><name>StrictWordSimilarityStrategyNumber</name></expr>:</case>
			<return>return <expr><name>strict_word_similarity_threshold</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized strategy number: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><literal type="number">0.0</literal></expr>;</return>					<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Deprecated function.
 * Use "pg_trgm.similarity_threshold" GUC variable instead of this function.
 */</comment>
<function><type><name>Datum</name></type>
<name>show_limit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>similarity_threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>comp_trgm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CMPTRGM</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>unique_array</name><parameter_list>(<parameter><decl><type><name>trgm</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>trgm</name>	   <modifier>*</modifier></type><name>curend</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>curend</name> <operator>=</operator> <name>tmp</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>tmp</name> <operator>-</operator> <name>a</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>CMPTRGM</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>curend</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>curend</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CPTRGM</name><argument_list>(<argument><expr><name>curend</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>tmp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></while>

	<return>return <expr><name>curend</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>a</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Finds first word in string, returns pointer to the word,
 * endword points to the character after word
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>find_word</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lenstr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endword</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>charlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>beginword</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>beginword</name> <operator>-</operator> <name>str</name> <operator>&lt;</operator> <name>lenstr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ISWORDCHR</name><argument_list>(<argument><expr><name>beginword</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>beginword</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>beginword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><name>beginword</name> <operator>-</operator> <name>str</name> <operator>&gt;=</operator> <name>lenstr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>endword</name> <operator>=</operator> <name>beginword</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>charlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>endword</name> <operator>-</operator> <name>str</name> <operator>&lt;</operator> <name>lenstr</name> <operator>&amp;&amp;</operator> <call><name>ISWORDCHR</name><argument_list>(<argument><expr><operator>*</operator><name>endword</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>endword</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><operator>*</operator><name>endword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>charlen</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>beginword</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reduce a trigram (three possibly multi-byte characters) to a trgm,
 * which is always exactly three bytes.  If we have three single-byte
 * characters, we just use them as-is; otherwise we form a hash value.
 */</comment>
<function><type><name>void</name></type>
<name>compact_trigram</name><parameter_list>(<parameter><decl><type><name>trgm</name> <modifier>*</modifier></type><name>tptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bytelen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>bytelen</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CPTRGM</name><argument_list>(<argument><expr><name>tptr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>crc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>INIT_LEGACY_CRC32</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMP_LEGACY_CRC32</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>bytelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FIN_LEGACY_CRC32</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * use only 3 upper bytes from crc, hope, it's good enough hashing
		 */</comment>
		<expr_stmt><expr><call><name>CPTRGM</name><argument_list>(<argument><expr><name>tptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Adds trigrams from words (already padded).
 */</comment>
<function><type><specifier>static</specifier> <name>trgm</name> <modifier>*</modifier></type>
<name>make_trigrams</name><parameter_list>(<parameter><decl><type><name>trgm</name> <modifier>*</modifier></type><name>tptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bytelen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>charlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>charlen</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>tptr</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>bytelen</name> <operator>&gt;</operator> <name>charlen</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Find multibyte character boundaries and apply compact_trigram */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>lenfirst</name> <init>= <expr><call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>,
					<decl><type ref="prev"/><name>lenmiddle</name> <init>= <expr><call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>lenfirst</name></expr></argument>)</argument_list></call></expr></init></decl>,
					<decl><type ref="prev"/><name>lenlast</name> <init>= <expr><call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>lenfirst</name> <operator>+</operator> <name>lenmiddle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>str</name><operator>)</operator> <operator>+</operator> <name>lenfirst</name> <operator>+</operator> <name>lenmiddle</name> <operator>+</operator> <name>lenlast</name> <operator>&lt;=</operator> <name>bytelen</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>compact_trigram</name><argument_list>(<argument><expr><name>tptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>lenfirst</name> <operator>+</operator> <name>lenmiddle</name> <operator>+</operator> <name>lenlast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>lenfirst</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tptr</name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>lenfirst</name> <operator>=</operator> <name>lenmiddle</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lenmiddle</name> <operator>=</operator> <name>lenlast</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lenlast</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>lenfirst</name> <operator>+</operator> <name>lenmiddle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Fast path when there are no multibyte characters */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bytelen</name> <operator>==</operator> <name>charlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>ptr</name> <operator>-</operator> <name>str</name> <operator>&lt;</operator> <name>bytelen</name> <operator>-</operator> <literal type="number">2</literal></expr> <comment type="block">/* number of trigrams = strlen - 2 */</comment> )</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CPTRGM</name><argument_list>(<argument><expr><name>tptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>tptr</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>tptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make array of trigrams without sorting and removing duplicate items.
 *
 * trg: where to return the array of trigrams.
 * str: source string, of length slen bytes.
 * bounds: where to return bounds of trigrams (if needed).
 *
 * Returns length of the generated array.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>generate_trgm_only</name><parameter_list>(<parameter><decl><type><name>trgm</name> <modifier>*</modifier></type><name>trg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slen</name></decl></parameter>, <parameter><decl><type><name>TrgmBound</name> <modifier>*</modifier></type><name>bounds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>trgm</name>	   <modifier>*</modifier></type><name>tptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>charlen</name></decl>,
				<decl><type ref="prev"/><name>bytelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bword</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>eword</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>+</operator> <name>LPADDING</name> <operator>+</operator> <name>RPADDING</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>||</operator> <name>slen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tptr</name> <operator>=</operator> <name>trg</name></expr>;</expr_stmt>

	<comment type="block">/* Allocate a buffer for case-folded, blank-padded words */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>slen</name> <operator>*</operator> <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>LPADDING</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>LPADDING</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>buf</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>eword</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>bword</name> <operator>=</operator> <call><name>find_word</name><argument_list>(<argument><expr><name>eword</name></expr></argument>, <argument><expr><name>slen</name> <operator>-</operator> <operator>(</operator><name>eword</name> <operator>-</operator> <name>str</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>eword</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>charlen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IGNORECASE</name></cpp:ifdef>
		<expr_stmt><expr><name>bword</name> <operator>=</operator> <call><name>lowerstr_with_len</name><argument_list>(<argument><expr><name>bword</name></expr></argument>, <argument><expr><name>eword</name> <operator>-</operator> <name>bword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>bword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>bytelen</name> <operator>=</operator> <name>eword</name> <operator>-</operator> <name>bword</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>LPADDING</name></expr></argument>, <argument><expr><name>bword</name></expr></argument>, <argument><expr><name>bytelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IGNORECASE</name></cpp:ifdef>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>bword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>LPADDING</name> <operator>+</operator> <name>bytelen</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>LPADDING</name> <operator>+</operator> <name>bytelen</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

		<comment type="block">/* Calculate trigrams marking their bounds if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>bounds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bounds</name><index>[<expr><name>tptr</name> <operator>-</operator> <name>trg</name></expr>]</index></name> <operator>|=</operator> <name>TRGM_BOUND_LEFT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tptr</name> <operator>=</operator> <call><name>make_trigrams</name><argument_list>(<argument><expr><name>tptr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytelen</name> <operator>+</operator> <name>LPADDING</name> <operator>+</operator> <name>RPADDING</name></expr></argument>,
							 <argument><expr><name>charlen</name> <operator>+</operator> <name>LPADDING</name> <operator>+</operator> <name>RPADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bounds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bounds</name><index>[<expr><name>tptr</name> <operator>-</operator> <name>trg</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>TRGM_BOUND_RIGHT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tptr</name> <operator>-</operator> <name>trg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Guard against possible overflow in the palloc requests below.  (We
 * don't worry about the additive constants, since palloc can detect
 * requests that are a little above MaxAllocSize --- we just need to
 * prevent integer overflow in the multiplications.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>protect_out_of_mem</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>slen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Size</name><operator>)</operator> <operator>(</operator><name>slen</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>&gt;=</operator> <operator>(</operator><name>MaxAllocSize</name> <operator>/</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>trgm</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>Size</name><operator>)</operator> <name>slen</name> <operator>&gt;=</operator> <operator>(</operator><name>MaxAllocSize</name> <operator>/</operator> <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make array of trigrams with sorting and removing duplicate items.
 *
 * str: source string, of length slen bytes.
 *
 * Returns the sorted array of unique trigrams.
 */</comment>
<function><type><name>TRGM</name> <modifier>*</modifier></type>
<name>generate_trgm</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TRGM</name>	   <modifier>*</modifier></type><name>trg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>protect_out_of_mem</name><argument_list>(<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>trg</name> <operator>=</operator> <operator>(</operator><name>TRGM</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>TRGMHDRSIZE</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>trgm</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>slen</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trg</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>ARRKEY</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>generate_trgm_only</name><argument_list>(<argument><expr><call><name>GETARR</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>trg</name></expr></argument>, <argument><expr><call><name>CALCGTSIZE</name><argument_list>(<argument><expr><name>ARRKEY</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>trg</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make trigrams unique.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trgm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>comp_trgm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>unique_array</name><argument_list>(<argument><expr><call><name>GETARR</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>trg</name></expr></argument>, <argument><expr><call><name>CALCGTSIZE</name><argument_list>(<argument><expr><name>ARRKEY</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>trg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make array of positional trigrams from two trigram arrays trg1 and trg2.
 *
 * trg1: trigram array of search pattern, of length len1. trg1 is required
 *		 word which positions don't matter and replaced with -1.
 * trg2: trigram array of text, of length len2. trg2 is haystack where we
 *		 search and have to store its positions.
 *
 * Returns concatenated trigram array.
 */</comment>
<function><type><specifier>static</specifier> <name>pos_trgm</name> <modifier>*</modifier></type>
<name>make_positional_trgm</name><parameter_list>(<parameter><decl><type><name>trgm</name> <modifier>*</modifier></type><name>trg1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><name>trgm</name> <modifier>*</modifier></type><name>trg2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pos_trgm</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>len</name> <init>= <expr><name>len1</name> <operator>+</operator> <name>len2</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>pos_trgm</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pos_trgm</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>trg1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trgm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len2</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><index>[<expr><name>i</name> <operator>+</operator> <name>len1</name></expr>]</index></name><operator>.</operator><name>trg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>trg2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trgm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name> <operator>+</operator> <name>len1</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare position trigrams: compare trigrams first and position second.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>comp_ptrgm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>pos_trgm</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>pos_trgm</name> <operator>*</operator><operator>)</operator> <name>v1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>pos_trgm</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>pos_trgm</name> <operator>*</operator><operator>)</operator> <name>v2</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>CMPTRGM</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>trg</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>trg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cmp</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>index</name></name> <operator>&lt;</operator> <name><name>p2</name><operator>-&gt;</operator><name>index</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <name><name>p2</name><operator>-&gt;</operator><name>index</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Iterative search function which calculates maximum similarity with word in
 * the string. But maximum similarity is calculated only if check_only == false.
 *
 * trg2indexes: array which stores indexes of the array "found".
 * found: array which stores true of false values.
 * ulen1: count of unique trigrams of array "trg1".
 * len2: length of array "trg2" and array "trg2indexes".
 * len: length of the array "found".
 * lags: set of boolean flags parametrizing similarity calculation.
 * bounds: whether each trigram is left/right bound of word.
 *
 * Returns word similarity.
 */</comment>
<function><type><specifier>static</specifier> <name>float4</name></type>
<name>iterate_word_similarity</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>trg2indexes</name></decl></parameter>,
						<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>ulen1</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
						<parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>,
						<parameter><decl><type><name>TrgmBound</name> <modifier>*</modifier></type><name>bounds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>lastpos</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
				<decl><type ref="prev"/><name>ulen2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>upper</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>smlr_cur</name></decl>,
				<decl><type ref="prev"/><name>smlr_max</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>threshold</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bounds</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WORD_SIMILARITY_STRICT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select appropriate threshold */</comment>
	<expr_stmt><expr><name>threshold</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WORD_SIMILARITY_STRICT</name><operator>)</operator></expr> ?</condition><then>
		<expr><name>strict_word_similarity_threshold</name></expr> </then><else>:
		<expr><name>word_similarity_threshold</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Consider first trigram as initial lower bound for strict word
	 * similarity, or initialize it later with first trigram present for plain
	 * word similarity.
	 */</comment>
	<expr_stmt><expr><name>lower</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WORD_SIMILARITY_STRICT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Memorise last position of each trigram */</comment>
	<expr_stmt><expr><name>lastpos</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>lastpos</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len2</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Get index of next trigram */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>trgindex</name> <init>= <expr><name><name>trg2indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Update last position of this trigram */</comment>
		<if_stmt><if>if <condition>(<expr><name>lower</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>found</name><index>[<expr><name>trgindex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>lastpos</name><index>[<expr><name>trgindex</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ulen2</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>found</name><index>[<expr><name>trgindex</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>lastpos</name><index>[<expr><name>trgindex</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Adjust upper bound if trigram is upper bound of word for strict
		 * word similarity, or if trigram is present in required substring for
		 * plain word similarity
		 */</comment>
		<if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WORD_SIMILARITY_STRICT</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name><name>bounds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>TRGM_BOUND_RIGHT</name><operator>)</operator></expr>
			</then><else>: <expr><name><name>found</name><index>[<expr><name>trgindex</name></expr>]</index></name></expr></else></ternary></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>prev_lower</name></decl>,
						<decl><type ref="prev"/><name>tmp_ulen2</name></decl>,
						<decl><type ref="prev"/><name>tmp_lower</name></decl>,
						<decl><type ref="prev"/><name>tmp_count</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>upper</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>lower</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>lower</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ulen2</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>smlr_cur</name> <operator>=</operator> <call><name>CALCSML</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>ulen1</name></expr></argument>, <argument><expr><name>ulen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Also try to adjust lower bound for greater similarity */</comment>
			<expr_stmt><expr><name>tmp_count</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp_ulen2</name> <operator>=</operator> <name>ulen2</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev_lower</name> <operator>=</operator> <name>lower</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>tmp_lower</name> <operator>=</operator> <name>lower</name></expr>;</init> <condition><expr><name>tmp_lower</name> <operator>&lt;=</operator> <name>upper</name></expr>;</condition> <incr><expr><name>tmp_lower</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>float</name></type>		<name>smlr_tmp</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>tmp_trgindex</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Adjust lower bound only if trigram is lower bound of word
				 * for strict word similarity, or consider every trigram as
				 * lower bound for plain word similarity.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WORD_SIMILARITY_STRICT</name><operator>)</operator>
					<operator>||</operator> <operator>(</operator><name><name>bounds</name><index>[<expr><name>tmp_lower</name></expr>]</index></name> <operator>&amp;</operator> <name>TRGM_BOUND_LEFT</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>smlr_tmp</name> <operator>=</operator> <call><name>CALCSML</name><argument_list>(<argument><expr><name>tmp_count</name></expr></argument>, <argument><expr><name>ulen1</name></expr></argument>, <argument><expr><name>tmp_ulen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>smlr_tmp</name> <operator>&gt;</operator> <name>smlr_cur</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>smlr_cur</name> <operator>=</operator> <name>smlr_tmp</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>ulen2</name> <operator>=</operator> <name>tmp_ulen2</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>lower</name> <operator>=</operator> <name>tmp_lower</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>count</name> <operator>=</operator> <name>tmp_count</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If we only check that word similarity is greater than
					 * threshold we do not need to calculate a maximum
					 * similarity.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WORD_SIMILARITY_CHECK_ONLY</name><operator>)</operator>
						<operator>&amp;&amp;</operator> <name>smlr_cur</name> <operator>&gt;=</operator> <name>threshold</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>tmp_trgindex</name> <operator>=</operator> <name><name>trg2indexes</name><index>[<expr><name>tmp_lower</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>lastpos</name><index>[<expr><name>tmp_trgindex</name></expr>]</index></name> <operator>==</operator> <name>tmp_lower</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>tmp_ulen2</name><operator>--</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>found</name><index>[<expr><name>tmp_trgindex</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>tmp_count</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name>smlr_max</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>smlr_max</name></expr></argument>, <argument><expr><name>smlr_cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * if we only check that word similarity is greater than threshold
			 * we do not need to calculate a maximum similarity.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WORD_SIMILARITY_CHECK_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>smlr_max</name> <operator>&gt;=</operator> <name>threshold</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<for>for <control>(<init><expr><name>tmp_lower</name> <operator>=</operator> <name>prev_lower</name></expr>;</init> <condition><expr><name>tmp_lower</name> <operator>&lt;</operator> <name>lower</name></expr>;</condition> <incr><expr><name>tmp_lower</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>tmp_trgindex</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tmp_trgindex</name> <operator>=</operator> <name><name>trg2indexes</name><index>[<expr><name>tmp_lower</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>lastpos</name><index>[<expr><name>tmp_trgindex</name></expr>]</index></name> <operator>==</operator> <name>tmp_lower</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>lastpos</name><index>[<expr><name>tmp_trgindex</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lastpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>smlr_max</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate word similarity.
 * This function prepare two arrays: "trg2indexes" and "found". Then this arrays
 * are used to calculate word similarity using iterate_word_similarity().
 *
 * "trg2indexes" is array which stores indexes of the array "found".
 * In other words:
 * trg2indexes[j] = i;
 * found[i] = true (or false);
 * If found[i] == true then there is trigram trg2[j] in array "trg1".
 * If found[i] == false then there is not trigram trg2[j] in array "trg1".
 *
 * str1: search pattern string, of length slen1 bytes.
 * str2: text in which we are looking for a word, of length slen2 bytes.
 * flags: set of boolean flags parametrizing similarity calculation.
 *
 * Returns word similarity.
 */</comment>
<function><type><specifier>static</specifier> <name>float4</name></type>
<name>calc_word_similarity</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slen1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slen2</name></decl></parameter>,
					 <parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pos_trgm</name>   <modifier>*</modifier></type><name>ptrg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>trgm</name>	   <modifier>*</modifier></type><name>trg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>trgm</name>	   <modifier>*</modifier></type><name>trg2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>,
				<decl><type ref="prev"/><name>len</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>ulen1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>trg2indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrgmBound</name>  <modifier>*</modifier></type><name>bounds</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>protect_out_of_mem</name><argument_list>(<argument><expr><name>slen1</name> <operator>+</operator> <name>slen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make positional trigrams */</comment>
	<expr_stmt><expr><name>trg1</name> <operator>=</operator> <operator>(</operator><name>trgm</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trgm</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>slen1</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>trg2</name> <operator>=</operator> <operator>(</operator><name>trgm</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trgm</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>slen2</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WORD_SIMILARITY_STRICT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bounds</name> <operator>=</operator> <operator>(</operator><name>TrgmBound</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrgmBound</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>slen2</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>bounds</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>generate_trgm_only</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>, <argument><expr><name>slen1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>generate_trgm_only</name><argument_list>(<argument><expr><name>trg2</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>, <argument><expr><name>slen2</name></expr></argument>, <argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptrg</name> <operator>=</operator> <call><name>make_positional_trgm</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>, <argument><expr><name>trg2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>len1</name> <operator>+</operator> <name>len2</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>ptrg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pos_trgm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>comp_ptrgm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Merge positional trigrams array: enumerate each trigram and find its
	 * presence in required word.
	 */</comment>
	<expr_stmt><expr><name>trg2indexes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>found</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ulen1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>CMPTRGM</name><argument_list>(<argument><expr><name><name>ptrg</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>trg</name></expr></argument>, <argument><expr><name><name>ptrg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>found</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>ulen1</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ptrg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>trg2indexes</name><index>[<expr><name><name>ptrg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>found</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name><name>found</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ulen1</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Run iterative procedure to find maximum similarity with word */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>iterate_word_similarity</name><argument_list>(<argument><expr><name>trg2indexes</name></expr></argument>, <argument><expr><name>found</name></expr></argument>, <argument><expr><name>ulen1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
									 <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trg2indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ptrg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Extract the next non-wildcard part of a search string, i.e. a word bounded
 * by '_' or '%' meta-characters, non-word characters or string end.
 *
 * str: source string, of length lenstr bytes (need not be null-terminated)
 * buf: where to return the substring (must be long enough)
 * *bytelen: receives byte length of the found substring
 * *charlen: receives character length of the found substring
 *
 * Returns pointer to end+1 of the found substring in the source string.
 * Returns NULL if no word found (in which case buf, bytelen, charlen not set)
 *
 * If the found word is bounded by non-word characters or string boundaries
 * then this function will include corresponding padding spaces into buf.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_wildcard_part</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lenstr</name></decl></parameter>,
				  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bytelen</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>charlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>beginword</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endword</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_leading_wildcard_meta</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_trailing_wildcard_meta</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_escape</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>clen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find the first word character, remembering whether preceding character
	 * was wildcard meta-character.  Note that the in_escape state persists
	 * from this loop to the next one, since we may exit at a word character
	 * that is in_escape.
	 */</comment>
	<while>while <condition>(<expr><name>beginword</name> <operator>-</operator> <name>str</name> <operator>&lt;</operator> <name>lenstr</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>in_escape</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ISWORDCHR</name><argument_list>(<argument><expr><name>beginword</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>in_escape</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>in_leading_wildcard_meta</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ISESCAPECHAR</name><argument_list>(<argument><expr><name>beginword</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>in_escape</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>ISWILDCARDCHAR</name><argument_list>(<argument><expr><name>beginword</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>in_leading_wildcard_meta</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>ISWORDCHR</name><argument_list>(<argument><expr><name>beginword</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>in_leading_wildcard_meta</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>beginword</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>beginword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Handle string end.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>beginword</name> <operator>-</operator> <name>str</name> <operator>&gt;=</operator> <name>lenstr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add left padding spaces if preceding character wasn't wildcard
	 * meta-character.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>charlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_leading_wildcard_meta</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>LPADDING</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>charlen</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>LPADDING</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>charlen</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Copy data into buf until wildcard meta-character, non-word character or
	 * string boundary.  Strip escapes during copy.
	 */</comment>
	<expr_stmt><expr><name>endword</name> <operator>=</operator> <name>beginword</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>endword</name> <operator>-</operator> <name>str</name> <operator>&lt;</operator> <name>lenstr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>clen</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>endword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>in_escape</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ISWORDCHR</name><argument_list>(<argument><expr><name>endword</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>endword</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>charlen</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Back up endword to the escape character when stopping at an
				 * escaped char, so that subsequent get_wildcard_part will
				 * restart from the escape character.  We assume here that
				 * escape chars are single-byte.
				 */</comment>
				<expr_stmt><expr><name>endword</name><operator>--</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>in_escape</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ISESCAPECHAR</name><argument_list>(<argument><expr><name>endword</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>in_escape</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>ISWILDCARDCHAR</name><argument_list>(<argument><expr><name>endword</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>in_trailing_wildcard_meta</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>ISWORDCHR</name><argument_list>(<argument><expr><name>endword</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>endword</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>charlen</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<break>break;</break></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>endword</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Add right padding spaces if next character isn't wildcard
	 * meta-character.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_trailing_wildcard_meta</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>RPADDING</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>charlen</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>RPADDING</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>charlen</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>bytelen</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name>buf</name></expr>;</expr_stmt>
	<return>return <expr><name>endword</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generates trigrams for wildcard search string.
 *
 * Returns array of trigrams that must occur in any string that matches the
 * wildcard string.  For example, given pattern "a%bcd%" the trigrams
 * " a", "bcd" would be extracted.
 */</comment>
<function><type><name>TRGM</name> <modifier>*</modifier></type>
<name>generate_wildcard_trgm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TRGM</name>	   <modifier>*</modifier></type><name>trg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>buf2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>trgm</name>	   <modifier>*</modifier></type><name>tptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>,
				<decl><type ref="prev"/><name>charlen</name></decl>,
				<decl><type ref="prev"/><name>bytelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eword</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>protect_out_of_mem</name><argument_list>(<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>trg</name> <operator>=</operator> <operator>(</operator><name>TRGM</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>TRGMHDRSIZE</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>trgm</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>slen</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trg</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>ARRKEY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>trg</name></expr></argument>, <argument><expr><name>TRGMHDRSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>+</operator> <name>LPADDING</name> <operator>+</operator> <name>RPADDING</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>||</operator> <name>slen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>trg</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tptr</name> <operator>=</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate a buffer for blank-padded, but not yet case-folded, words */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>slen</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Extract trigrams from each substring extracted by get_wildcard_part.
	 */</comment>
	<expr_stmt><expr><name>eword</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>eword</name> <operator>=</operator> <call><name>get_wildcard_part</name><argument_list>(<argument><expr><name>eword</name></expr></argument>, <argument><expr><name>slen</name> <operator>-</operator> <operator>(</operator><name>eword</name> <operator>-</operator> <name>str</name><operator>)</operator></expr></argument>,
									  <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytelen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>charlen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IGNORECASE</name></cpp:ifdef>
		<expr_stmt><expr><name>buf2</name> <operator>=</operator> <call><name>lowerstr_with_len</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>buf2</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * count trigrams
		 */</comment>
		<expr_stmt><expr><name>tptr</name> <operator>=</operator> <call><name>make_trigrams</name><argument_list>(<argument><expr><name>tptr</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>bytelen</name></expr></argument>, <argument><expr><name>charlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IGNORECASE</name></cpp:ifdef>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <name>tptr</name> <operator>-</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>trg</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make trigrams unique.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trgm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>comp_trgm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>unique_array</name><argument_list>(<argument><expr><call><name>GETARR</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>trg</name></expr></argument>, <argument><expr><call><name>CALCGTSIZE</name><argument_list>(<argument><expr><name>ARRKEY</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>trg</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32</name></type>
<name>trgm2int</name><parameter_list>(<parameter><decl><type><name>trgm</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name><operator>)</operator> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>show_trgm</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TRGM</name>	   <modifier>*</modifier></type><name>trg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>trgm</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>trg</name> <operator>=</operator> <call><name>generate_trgm</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <call><name>ARRNELEM</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRNELEM</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">12</literal></expr></argument>, <argument><expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ISPRINTABLETRGM</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>, <argument><expr><literal type="string">"0x%06x"</literal></expr></argument>, <argument><expr><call><name>trgm2int</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CPTRGM</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(
						<argument><expr><name>d</name></expr></argument>,
						<argument><expr><call><name>ARRNELEM</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>TEXTOID</name></expr></argument>,
						<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						<argument><expr><name>false</name></expr></argument>,
						<argument><expr><literal type="char">'i'</literal></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARRNELEM</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>float4</name></type>
<name>cnt_sml</name><parameter_list>(<parameter><decl><type><name>TRGM</name> <modifier>*</modifier></type><name>trg1</name></decl></parameter>, <parameter><decl><type><name>TRGM</name> <modifier>*</modifier></type><name>trg2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inexact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>trgm</name>	   <modifier>*</modifier></type><name>ptr1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ptr2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr1</name> <operator>=</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr2</name> <operator>=</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>ARRNELEM</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>ARRNELEM</name><argument_list>(<argument><expr><name>trg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* explicit test is needed to avoid 0/0 division when both lengths are 0 */</comment>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>len2</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>float4</name><operator>)</operator> <literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>ptr1</name> <operator>-</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>len1</name> <operator>&amp;&amp;</operator> <name>ptr2</name> <operator>-</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>len2</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>res</name> <init>= <expr><call><name>CMPTRGM</name><argument_list>(<argument><expr><name>ptr1</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ptr1</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ptr2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>ptr1</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr2</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If inexact then len2 is equal to count, because we don't know actual
	 * length of second string in inexact search and we can assume that count
	 * is a lower bound of len2.
	 */</comment>
	<return>return <expr><call><name>CALCSML</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>, <argument><expr><ternary><condition><expr><name>inexact</name></expr> ?</condition><then> <expr><name>count</name></expr> </then><else>: <expr><name>len2</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Returns whether trg2 contains all trigrams in trg1.
 * This relies on the trigram arrays being sorted.
 */</comment>
<function><type><name>bool</name></type>
<name>trgm_contained_by</name><parameter_list>(<parameter><decl><type><name>TRGM</name> <modifier>*</modifier></type><name>trg1</name></decl></parameter>, <parameter><decl><type><name>TRGM</name> <modifier>*</modifier></type><name>trg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>trgm</name>	   <modifier>*</modifier></type><name>ptr1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ptr2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr1</name> <operator>=</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr2</name> <operator>=</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>ARRNELEM</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>ARRNELEM</name><argument_list>(<argument><expr><name>trg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>ptr1</name> <operator>-</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>len1</name> <operator>&amp;&amp;</operator> <name>ptr2</name> <operator>-</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>len2</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>res</name> <init>= <expr><call><name>CMPTRGM</name><argument_list>(<argument><expr><name>ptr1</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ptr2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>ptr1</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr2</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>ptr1</name> <operator>-</operator> <call><name>GETARR</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>len1</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return a palloc'd boolean array showing, for each trigram in "query",
 * whether it is present in the trigram array "key".
 * This relies on the "key" array being sorted, but "query" need not be.
 */</comment>
<function><type><name>bool</name> <modifier>*</modifier></type>
<name>trgm_presence_map</name><parameter_list>(<parameter><decl><type><name>TRGM</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>TRGM</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>trgm</name>	   <modifier>*</modifier></type><name>ptrq</name> <init>= <expr><call><name>GETARR</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ptrk</name> <init>= <expr><call><name>GETARR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lenq</name> <init>= <expr><call><name>ARRNELEM</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>lenk</name> <init>= <expr><call><name>ARRNELEM</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>lenq</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* for each query trigram, do a binary search in the key array */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>lenq</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>lo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>hi</name> <init>= <expr><name>lenk</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>mid</name> <init>= <expr><operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>res</name> <init>= <expr><call><name>CMPTRGM</name><argument_list>(<argument><expr><name>ptrq</name></expr></argument>, <argument><expr><name>ptrk</name> <operator>+</operator> <name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name>ptrq</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>similarity</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TRGM</name>	   <modifier>*</modifier></type><name>trg1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>trg2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>trg1</name> <operator>=</operator> <call><name>generate_trgm</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>trg2</name> <operator>=</operator> <call><name>generate_trgm</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cnt_sml</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>, <argument><expr><name>trg2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>word_similarity</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>calc_word_similarity</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>strict_word_similarity</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>calc_word_similarity</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>WORD_SIMILARITY_STRICT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>similarity_dist</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name> <init>= <expr><call><name>DatumGetFloat4</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>similarity</name></expr></argument>,
														 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>-</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>similarity_op</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name> <init>= <expr><call><name>DatumGetFloat4</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>similarity</name></expr></argument>,
														 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>&gt;=</operator> <name>similarity_threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>word_similarity_op</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>calc_word_similarity</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>WORD_SIMILARITY_CHECK_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>&gt;=</operator> <name>word_similarity_threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>word_similarity_commutator_op</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>calc_word_similarity</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>WORD_SIMILARITY_CHECK_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>&gt;=</operator> <name>word_similarity_threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>word_similarity_dist_op</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>calc_word_similarity</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>-</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>word_similarity_dist_commutator_op</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>calc_word_similarity</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>-</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>strict_word_similarity_op</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>calc_word_similarity</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>WORD_SIMILARITY_CHECK_ONLY</name> <operator>|</operator> <name>WORD_SIMILARITY_STRICT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>&gt;=</operator> <name>strict_word_similarity_threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>strict_word_similarity_commutator_op</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>calc_word_similarity</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>WORD_SIMILARITY_CHECK_ONLY</name> <operator>|</operator> <name>WORD_SIMILARITY_STRICT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name> <operator>&gt;=</operator> <name>strict_word_similarity_threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>strict_word_similarity_dist_op</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>calc_word_similarity</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>WORD_SIMILARITY_STRICT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>-</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>strict_word_similarity_dist_commutator_op</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>calc_word_similarity</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in2</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>in1</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>WORD_SIMILARITY_STRICT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>-</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
