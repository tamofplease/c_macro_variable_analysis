<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/gpcontrib/gp_exttable_fdw/extaccess.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * extaccess.c
 *	  external table access method routines
 *
 * This access layer mimics the heap access API with respect to how it
 * communicates with its respective scan node (external scan node) but
 * instead of accessing the heap pages, it actually "scans" data by
 * reading it from a local flat file or a remote data source.
 *
 * The actual data access, whether local or remote, is done with the
 * curl c library ('libcurl') which uses a 'c-file like' API but behind
 * the scenes actually does all the work of parsing the URI and communicating
 * with the target. In this case if the URI uses the file protocol (file://)
 * curl will try to open the specified file locally. If the URI uses the
 * http protocol (http://) then curl will reach out to that address and
 * get the data from there.
 *
 * As data is being read it gets parsed with the COPY command parsing rules,
 * as if it is data meant for COPY. Therefore, currently, with the lack of
 * single row error handling the first error will raise an error and the
 * query will terminate.
 *
 * Portions Copyright (c) 2007-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    gpcontrib/gp_exttable_fdw/extaccess.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extaccess.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/external.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/formatter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/url.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/valid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsreh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>externalgettup</name><parameter_list>(<parameter><decl><type><name>FileScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitParseState</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>writable</name></decl></parameter>,
			   <parameter><decl><type><name>char</name></type> <name>fmtType</name></decl></parameter>,
			   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rejectlimit</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>islimitinrows</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>logerrors</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FunctionCallPrepareFormatter</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfoBaseData</name> <modifier>*</modifier></type><name>fcinfo</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>nArgs</name></decl></parameter>,
							 <parameter><decl><type><name>CopyState</name></type> <name>pstate</name></decl></parameter>,
							 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>formatter_func</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>formatter_params</name></decl></parameter>,
							 <parameter><decl><type><name>FormatterData</name> <modifier>*</modifier></type><name>formatter</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>,
							 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>convFuncs</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typioparams</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>open_external_readable_source</name><parameter_list>(<parameter><decl><type><name>FileScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ExternalSelectDesc</name></type> <name>desc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>open_external_writable_source</name><parameter_list>(<parameter><decl><type><name>ExternalInsertDesc</name></type> <name>extInsertDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>external_getdata_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>outbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minread</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxread</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>external_getdata</name><parameter_list>(<parameter><decl><type><name>URL_FILE</name> <modifier>*</modifier></type><name>extfile</name></decl></parameter>, <parameter><decl><type><name>CopyState</name></type> <name>pstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>outbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxread</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>external_senddata</name><parameter_list>(<parameter><decl><type><name>URL_FILE</name> <modifier>*</modifier></type><name>extfile</name></decl></parameter>, <parameter><decl><type><name>CopyState</name></type> <name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>external_scan_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>lookupCustomFormatter</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>justifyDatabuf</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *				   external_ interface functions
 * ----------------------------------------------------------------
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILEDEBUGALL</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILEDEBUG_1</name></cpp:macro> \
<cpp:value>elog(DEBUG2, "external_getnext([%s],dir=%d) called", \
	 RelationGetRelationName(scan-&gt;fs_rd), (int) direction)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILEDEBUG_2</name></cpp:macro> \
<cpp:value>elog(DEBUG2, "external_getnext returning EOS")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILEDEBUG_3</name></cpp:macro> \
<cpp:value>elog(DEBUG2, "external_getnext returning tuple")</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILEDEBUG_1</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILEDEBUG_2</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILEDEBUG_3</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* !defined(FILEDEBUGALL) */</comment>


<comment type="block">/* ----------------
 *		external_beginscan	- begin file scan
 * ----------------
 */</comment>
<function><type><name>FileScanDesc</name></type>
<name>external_beginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>scancounter</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>uriList</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>fmtType</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isMasterOnly</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>rejLimit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rejLimitInRows</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>logErrors</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>extOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segindex</name> <init>= <expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>uri</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>custom_formatter_params</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * increment relation ref count while scanning relation
	 *
	 * This is just to make really sure the relcache entry won't go away while
	 * the scan has a pointer to it.  Caller should be holding the rel open
	 * anyway, so this is redundant in all normal scenarios...
	 */</comment>
	<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate and initialize scan descriptor
	 */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <operator>(</operator><name>FileScanDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_ctup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>fs_ctup</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_rd</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_scancounter</name></name> <operator>=</operator> <name>scancounter</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_noop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_formatter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_constraintExprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_hasConstraints</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_hasConstraints</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_isPartition</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>;</expr_stmt>


	<comment type="block">/*
	 * get the external URI assigned to us.
	 *
	 * The URI assigned for this segment is normally in the uriList list at
	 * the index of this segment id. However, if we are executing on COORDINATOR
	 * ONLY the (one and only) entry which is destined for the master will be
	 * at the first entry of the uriList list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this is the normal path for most ext tables */</comment>
		<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>idx</name> <init>= <expr><name>segindex</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Segindex may be -1, for the following case. A slice is executed on
		 * entry db, (for example, gp_segment_configuration), then external table is
		 * executed on another slice. Entry db slice will still call
		 * ExecInitExternalScan (probably we should fix this?), then segindex
		 * = -1 will bomb out here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isMasterOnly</name> <operator>&amp;&amp;</operator> <name>idx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>uriList</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_Null</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uri</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>uri</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name>isMasterOnly</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this is a ON COORDINATOR table. Only get uri if we are the master */</comment>
		<if_stmt><if>if <condition>(<expr><name>segindex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>uriList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_Null</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uri</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>uri</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if a uri is assigned to us - get a reference to it. Some executors
	 * don't have a uri to scan (if # of uri's &lt; # of primary segdbs). in
	 * which case uri will be NULL. If that's the case for this segdb set to
	 * no-op.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>uri</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* set external source (uri) */</comment>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_uri</name></name> <operator>=</operator> <name>uri</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * NOTE: we delay actually opening the data source until
		 * external_getnext()
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* segdb has no work to do. set to no-op */</comment>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_noop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_uri</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_tupDesc</name></name> <operator>=</operator> <name>tupDesc</name></expr>;</expr_stmt>
	<comment type="line">//scan-&gt;attr = tupDesc-&gt;attrs;</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>num_phys_attrs</name></name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>num_phys_attrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>num_phys_attrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pick up the required catalog information for each attribute in the
	 * relation, including the input function and the element type (to pass to
	 * the input function).
	 */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>in_functions</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>num_phys_attrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>typioparams</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>num_phys_attrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>scan</name><operator>-&gt;</operator><name>num_phys_attrs</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* We don't need info for dropped attributes */</comment>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_tupDesc</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>in_func_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>typioparams</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>in_func_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>in_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>custom_formatter_params</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>extOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * pass external table's encoding to copy's options
	 *
	 * don't append to entry-&gt;options directly, we only store the encoding in
	 * entry-&gt;encoding (and ftoptions)
	 */</comment>
	<expr_stmt><expr><name>extOptions</name> <operator>=</operator> <call><name>appendCopyEncodingOption</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>extOptions</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate and init our structure that keeps track of data parsing state
	 */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name> <operator>=</operator> <call><name>BeginCopyFrom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>external_getdata_callback</name></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>scan</name></expr></argument>,
									<argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><operator>(</operator><ternary><condition><expr><call><name>fmttype_is_custom</name><argument_list>(<argument><expr><name>fmtType</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><name>extOptions</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>header_line</name></name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"HEADER means that each one of the data files has a header row"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize all the parsing and state variables */</comment>
	<expr_stmt><expr><call><name>InitParseState</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>fmtType</name></expr></argument>,
				   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_uri</name></name></expr></argument>, <argument><expr><name>rejLimit</name></expr></argument>, <argument><expr><name>rejLimitInRows</name></expr></argument>, <argument><expr><name>logErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fmttype_is_custom</name><argument_list>(<argument><expr><name>fmtType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Custom format: get formatter name and find it in the catalog
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>

		<comment type="block">/* parseFormatString should have seen a formatter name */</comment>
		<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>lookupCustomFormatter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>custom_formatter_params</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we found our function. set it up for calling */</comment>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_custom_formatter_func</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_custom_formatter_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_custom_formatter_params</name></name> <operator>=</operator> <name>custom_formatter_params</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_formatter</name></name> <operator>=</operator> <operator>(</operator><name>FormatterData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FormatterData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>fs_formatter</name><operator>-&gt;</operator><name>fmt_databuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_formatter</name><operator>-&gt;</operator><name>fmt_perrow_ctx</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* pgstat_initstats(relation); */</comment>

	<return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------
*		external_rescan  - (re)start a scan of an external file
* ----------------
*/</comment>
<function><type><name>void</name></type>
<name>external_rescan</name><parameter_list>(<parameter><decl><type><name>FileScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Close previous scan if it was already open */</comment>
	<expr_stmt><expr><call><name>external_stopscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The first call to external_getnext will re-open the scan */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The file parse state of external scan is invalid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* reset some parse state variables */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>reached_eof</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>cur_attname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
*		external_endscan - end a scan
* ----------------
*/</comment>
<function><type><name>void</name></type>
<name>external_endscan</name><parameter_list>(<parameter><decl><type><name>FileScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_rd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * decrement relation reference count and free scan descriptor storage
		 */</comment>
		<expr_stmt><expr><call><name>RelationDecrementReferenceCount</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>values</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>nulls</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>in_functions</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>in_functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>in_functions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>typioparams</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>typioparams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>typioparams</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>rowcontext</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * delete the row context
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>rowcontext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*----
	 * if SREH was active:
	 * 1) QEs: send a libpq message to QD with num of rows rejected in this segment
	 * 2) Free SREH resources
	 *----
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>errMode</name></name> <operator>!=</operator> <name>ALL_OR_NOTHING</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SendNumRows</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>rejectcount</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>destroyCdbSreh</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_formatter</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * TODO: check if this space is automatically freed. if not, then see
		 * what about freeing the user context
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_formatter</name><operator>-&gt;</operator><name>fmt_databuf</name><operator>.</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_formatter</name><operator>-&gt;</operator><name>fmt_databuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_formatter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_formatter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * free parse state memory
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>attribute_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>force_quote_flags</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>force_quote_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>force_notnull_flags</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>force_notnull_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Close the external file
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>fs_noop</name></name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>fs_file</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * QueryFinishPending == true means QD have got
		 * enough tuples and query can return correctly,
		 * so slient errors when closing external file.
		 */</comment>
		<expr_stmt><expr><call><name>url_fclose</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_file</name></name></expr></argument>, <argument><expr><operator>!</operator><name>QueryFinishPending</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------
*		external_stopscan - closes an external resource without dismantling the scan context
* ----------------
*/</comment>
<function><type><name>void</name></type>
<name>external_stopscan</name><parameter_list>(<parameter><decl><type><name>FileScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Close the external file
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>fs_noop</name></name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>fs_file</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>url_fclose</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_file</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_rd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*	----------------
 *		external_getnext_init - prepare ExternalSelectDesc struct before external_getnext
 *	----------------
 */</comment>
<function><type><name>ExternalSelectDesc</name></type>
<name>external_getnext_init</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExternalSelectDesc</name></type>
		<name>desc</name> <init>= <expr><operator>(</operator><name>ExternalSelectDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExternalSelectDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>projInfo</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ps_ProjInfo</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
*		external_getnext
*
*		Parse a data file and return its rows in heap tuple form
* ----------------------------------------------------------------
*/</comment>
<function><type><name>HeapTuple</name></type>
<name>external_getnext</name><parameter_list>(<parameter><decl><type><name>FileScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>ExternalSelectDesc</name></type> <name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_noop</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * open the external source (local file or http).
	 *
	 * NOTE: external_beginscan() seems like the natural place for this call.
	 * However, in queries with more than one gang each gang will initialized
	 * all the nodes of the plan (but actually executed only the nodes in it's
	 * local slice) This means that external_beginscan() (and
	 * external_endscan() too) will get called more than needed and we'll end
	 * up opening too many http connections when they are not expected (see
	 * MPP-1261). Therefore we instead do it here on the first time around
	 * only.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>fs_file</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>open_external_readable_source</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Note: no locking manipulations needed */</comment>
	<expr_stmt><expr><name>FILEDEBUG_1</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>externalgettup</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>FILEDEBUG_2</name></expr>;</expr_stmt>			<comment type="block">/* external_getnext returning EOS */</comment>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if we get here it means we have a new current scan tuple
	 */</comment>
	<expr_stmt><expr><name>FILEDEBUG_3</name></expr>;</expr_stmt>				<comment type="block">/* external_getnext returning tuple */</comment>

	<expr_stmt><expr><call><name>pgstat_count_heap_getnext</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * external_insert_init
 *
 * before using external_insert() to insert tuples we need to call
 * this function to initialize our various structures and state..
 */</comment>
<function><type><name>ExternalInsertDesc</name></type>
<name>external_insert_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExternalInsertDesc</name></type> <name>extInsertDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtTableEntry</name> <modifier>*</modifier></type><name>extentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>copyFmtOpts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>custom_formatter_params</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>on_clause</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the ExtTableEntry information for this table
	 */</comment>
	<expr_stmt><expr><name>extentry</name> <operator>=</operator> <call><name>GetExtTableEntry</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>on_clause</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>execlocations</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate and initialize the insert descriptor
	 */</comment>
	<expr_stmt><expr><name>extInsertDesc</name> <operator>=</operator> <operator>(</operator><name>ExternalInsertDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExternalInsertDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_noop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_noop</name></name> <operator>=</operator> <operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_formatter_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>extentry</name><operator>-&gt;</operator><name>command</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * EXECUTE
		 *
		 * build the command string, 'execute:&lt;command&gt;'
		 */</comment>
		<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_uri</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"execute:%s"</literal></expr></argument>, <argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* LOCATION - gpfdist or custom */</comment>

		<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>uri_str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>segindex</name> <init>= <expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_segs</name> <init>= <expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_urls</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>urilocations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>my_url</name> <init>= <expr><name>segindex</name> <operator>%</operator> <name>num_urls</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>num_urls</name> <operator>&gt;</operator> <name>num_segs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"external table has more URLs than available primary segments that can write into them"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* get a url to use. we use seg number modulo total num of urls */</comment>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>urilocations</name></name></expr></argument>, <argument><expr><name>my_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>uri_str</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_uri</name></name> <operator>=</operator> <name>uri_str</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
		elog(NOTICE, "seg %d got url number %d: %s", segindex, my_url, uri_str);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Allocate and init our structure that keeps track of data parsing state
	 */</comment>
	<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name></name> <operator>=</operator> <operator>(</operator><name>CopyStateData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_tupDesc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Writing to an external table is like COPY TO: we get tuples from the executor,
	 * we format them into the format requested, and write the output to an external
	 * sink.
	 */</comment>

	<expr_stmt><expr><name>custom_formatter_params</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * pass external table's encoding to copy's options
	 *
	 * don't append to entry-&gt;options directly, we only store the encoding in
	 * entry-&gt;encoding (and ftoptions)
	 */</comment>
	<expr_stmt><expr><name>copyFmtOpts</name> <operator>=</operator> <call><name>appendCopyEncodingOption</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name></name> <operator>=</operator> <call><name>BeginCopyToForeignTable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name>fmttype_is_custom</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>fmtcode</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><name>copyFmtOpts</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitParseState</name><argument_list>(<argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name></name></expr></argument>,
				   <argument><expr><name>rel</name></expr></argument>,
				   <argument><expr><name>true</name></expr></argument>,
				   <argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>fmtcode</name></name></expr></argument>,
				   <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_uri</name></name></expr></argument>,
				   <argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>rejectlimit</name></name></expr></argument>,
				   <argument><expr><operator>(</operator><name><name>extentry</name><operator>-&gt;</operator><name>rejectlimittype</name></name> <operator>==</operator> <literal type="char">'r'</literal><operator>)</operator></expr></argument>,
				   <argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>logerrors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fmttype_is_custom</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>fmtcode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Custom format: get formatter name and find it in the catalog
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>lookupCustomFormatter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>custom_formatter_params</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we found our function. set it up for calling  */</comment>
		<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_custom_formatter_func</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>, <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_custom_formatter_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_custom_formatter_params</name></name> <operator>=</operator> <name>custom_formatter_params</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_formatter_data</name></name> <operator>=</operator> <operator>(</operator><name>FormatterData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FormatterData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_formatter_data</name><operator>-&gt;</operator><name>fmt_perrow_ctx</name></name> <operator>=</operator> <name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>extInsertDesc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * external_insert - format the tuple into text and write to the external source
 *
 * Note the following major differences from heap_insert
 *
 * - wal is always bypassed here.
 * - transaction information is of no interest.
 * - tuples are sent always to the destination (local file or remote target).
 *
 * Like heap_insert(), this function can modify the input tuple!
 */</comment>
<function><type><name>void</name></type>
<name>external_insert</name><parameter_list>(<parameter><decl><type><name>ExternalInsertDesc</name></type> <name>extInsertDesc</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_tupDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyStateData</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>customFormat</name> <init>= <expr><operator>(</operator><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_custom_formatter_func</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_noop</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Open our output file or output stream if not yet open */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_file</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_noop</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>open_external_writable_source</name><argument_list>(<argument><expr><name>extInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * deconstruct the tuple and format it into text
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>customFormat</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* TEXT or CSV */</comment>
		<expr_stmt><expr><call><name>CopyOneRowTo</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* custom format. convert tuple using user formatter */</comment>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>instup</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * There is some redundancy between FormatterData and
		 * ExternalInsertDesc we may be able to consolidate data structures a
		 * little.
		 */</comment>
		<decl_stmt><decl><type><name>FormatterData</name> <modifier>*</modifier></type><name>formatter</name> <init>= <expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_formatter_data</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* must have been created during insert_init */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>formatter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* per call formatter prep */</comment>
		<expr_stmt><expr><call><name>FunctionCallPrepareFormatter</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>,
									 <argument><expr><literal type="number">1</literal></expr></argument>,
									 <argument><expr><name>pstate</name></expr></argument>,
									 <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_custom_formatter_func</name></name></expr></argument>,
									 <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_custom_formatter_params</name></name></expr></argument>,
									 <argument><expr><name>formatter</name></expr></argument>,
									 <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_rel</name></name></expr></argument>,
									 <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_tupDesc</name></name></expr></argument>,
									 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>out_functions</name></name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark the correct record type in the passed tuple */</comment>

		<comment type="block">/*
		 * get the heap tuple out of the tuple table slot, making sure we have a
		 * writable copy. (the function can scribble on the tuple)
		 */</comment>
		<expr_stmt><expr><name>instup</name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name><name>instup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>instup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name><name>instup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name><name>instup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>instup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_perrow_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We do not expect a null result */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %u returned NULL"</literal></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>DatumGetByteaP</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CopyOneCustomRowTo</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>instup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Write the data into the external source */</comment>
	<expr_stmt><expr><call><name>external_senddata</name><argument_list>(<argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_file</name></name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset our buffer to start clean next round */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * external_insert_finish
 *
 * when done inserting all the data via external_insert() we need to call
 * this function to flush all remaining data in the buffer into the file.
 */</comment>
<function><type><name>void</name></type>
<name>external_insert_finish</name><parameter_list>(<parameter><decl><type><name>ExternalInsertDesc</name></type> <name>extInsertDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Close the external source
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_file</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>url_fflush</name><argument_list>(<argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_file</name></name></expr></argument>, <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>url_fclose</name><argument_list>(<argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_file</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_formatter_data</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_formatter_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>extInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ==========================================================================
 * The follwing macros aid in major refactoring of data processing code (in
 * externalgettup() ). We use macros because in some cases the code must be in
 * line in order to work (for example elog_dismiss() in PG_CATCH) while in
 * other cases we'd like to inline the code for performance reasons.
 *
 * NOTE that an almost identical set of macros exists in copy.c for the COPY
 * command. If you make changes here you may want to consider taking a look.
 * ==========================================================================
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXT_RESET_LINEBUF</name></cpp:macro> \
<cpp:value>pstate-&gt;line_buf.len = 0; \
pstate-&gt;line_buf.data[0] = '\0'; \
pstate-&gt;line_buf.cursor = 0;</cpp:value></cpp:define>

<comment type="block">/*
 * A data error happened. This code block will always be inside a PG_CATCH()
 * block right when a higher stack level produced an error. We handle the error
 * by checking which error mode is set (SREH or all-or-nothing) and do the right
 * thing accordingly. Note that we MUST have this code in a macro (as opposed
 * to a function) as elog_dismiss() has to be inlined with PG_CATCH in order to
 * access local error state variables.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILEAM_HANDLE_ERROR</name></cpp:macro> \
<cpp:value>if (pstate-&gt;errMode == ALL_OR_NOTHING) \
{ \
	<comment type="block">/* re-throw error and abort */</comment> \
	PG_RE_THROW(); \
} \
else \
{ \
	<comment type="block">/* SREH - release error state */</comment> \
\
	ErrorData	*edata; \
	MemoryContext oldcontext;\
\
	<comment type="block">/* SREH must only handle data errors. all other errors must not be caught */</comment>\
	if(ERRCODE_TO_CATEGORY(elog_geterrcode()) != ERRCODE_DATA_EXCEPTION)\
	{\
		PG_RE_THROW(); \
	}\
\
	<comment type="block">/* save a copy of the error info */</comment> \
	oldcontext = MemoryContextSwitchTo(pstate-&gt;cdbsreh-&gt;badrowcontext);\
	edata = CopyErrorData();\
	MemoryContextSwitchTo(oldcontext);\
\
	if (!elog_dismiss(DEBUG5)) \
		PG_RE_THROW(); <comment type="block">/* &lt;-- hope to never get here! */</comment> \
\
	truncateEol(&amp;pstate-&gt;line_buf, pstate-&gt;eol_type); \
	pstate-&gt;cdbsreh-&gt;rawdata-&gt;cursor = 0; \
	pstate-&gt;cdbsreh-&gt;rawdata-&gt;data = pstate-&gt;line_buf.data; \
	pstate-&gt;cdbsreh-&gt;rawdata-&gt;len = pstate-&gt;line_buf.len; \
	pstate-&gt;cdbsreh-&gt;is_server_enc = pstate-&gt;line_buf_converted; \
	pstate-&gt;cdbsreh-&gt;linenumber = pstate-&gt;cur_lineno; \
	pstate-&gt;cdbsreh-&gt;processed++; \
\
	<comment type="block">/* set the error message. Use original msg and add column name if available */</comment> \
	if (pstate-&gt;cur_attname)\
	{\
		pstate-&gt;cdbsreh-&gt;errmsg = psprintf("%s, column %s", \
				edata-&gt;message, \
				pstate-&gt;cur_attname); \
	}\
	else\
	{\
		pstate-&gt;cdbsreh-&gt;errmsg = pstrdup(edata-&gt;message); \
	}\
\
	HandleSingleRowError(pstate-&gt;cdbsreh); \
	FreeErrorData(edata);\
	if (!IsRejectLimitReached(pstate-&gt;cdbsreh)) \
		pfree(pstate-&gt;cdbsreh-&gt;errmsg); \
}</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>externalgettup_defined</name><parameter_list>(<parameter><decl><type><name>FileScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>pstate</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get a line */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NextCopyFrom</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>values</name></name></expr></argument>,
					  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* convert to heap tuple */</comment>

	<comment type="block">/*
	 * XXX This is bad code.  Planner should be able to decide
	 * whether we need heaptuple or memtuple upstream, so make the
	 * right decision here.
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_tupDesc</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>externalgettup_custom</name><parameter_list>(<parameter><decl><type><name>FileScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>pstate</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormatterData</name> <modifier>*</modifier></type><name>formatter</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>fs_formatter</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctxt</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>formatter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* while didn't finish processing the entire file */</comment>
	<comment type="block">/* raw_buf_len was set to 0 in BeginCopyFrom() or external_rescan() */</comment>
	<while>while <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name><name>pstate</name><operator>-&gt;</operator><name>reached_eof</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* need to fill our buffer with data? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>bytesread</name> <init>= <expr><call><name>external_getdata</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_file</name></name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>raw_buf</name></name></expr></argument>, <argument><expr><name>RAW_BUF_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>bytesread</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>formatter</name><operator>-&gt;</operator><name>fmt_databuf</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>raw_buf</name></name></expr></argument>, <argument><expr><name>bytesread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>=</operator> <name>bytesread</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* HEADER not yet supported ... */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"header line in custom format is not yet supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* while there is still data in our buffer */</comment>
		<while>while <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>error_caught</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Invoke the custom formatter function.
			 */</comment>
			<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* per call formatter prep */</comment>
				<expr_stmt><expr><call><name>FunctionCallPrepareFormatter</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>,
						<argument><expr><name>pstate</name></expr></argument>,
						<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_custom_formatter_func</name></name></expr></argument>,
						<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_custom_formatter_params</name></name></expr></argument>,
						<argument><expr><name>formatter</name></expr></argument>,
						<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_rd</name></name></expr></argument>,
						<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_tupDesc</name></name></expr></argument>,
						<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>in_functions</name></name></expr></argument>,
						<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>typioparams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<expr_stmt><expr><name>error_caught</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_perrow_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Save any bad row information that was set by the user
				 * in the formatter UDF (if any). Then handle the error in
				 * FILEAM_HANDLE_ERROR.
				 */</comment>
				<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <name><name>formatter</name><operator>-&gt;</operator><name>fmt_badrow_num</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_badrow_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_badrow_data</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>line_buf</name></name></expr></argument>,
								<argument><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_badrow_data</name></name></expr></argument>,
								<argument><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_badrow_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_databuf</name><operator>.</operator><name>cursor</name></name> <operator>+=</operator> <name><name>formatter</name><operator>-&gt;</operator><name>fmt_badrow_len</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_databuf</name><operator>.</operator><name>cursor</name></name> <operator>&gt;</operator> <name><name>formatter</name><operator>-&gt;</operator><name>fmt_databuf</name><operator>.</operator><name>len</name></name> <operator>||</operator>
							<name><name>formatter</name><operator>-&gt;</operator><name>fmt_databuf</name><operator>.</operator><name>cursor</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_databuf</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <name><name>formatter</name><operator>-&gt;</operator><name>fmt_databuf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>FILEAM_HANDLE_ERROR</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Examine the function results. If an error was caught we
			 * already handled it, so after checking the reject limit,
			 * loop again and call the UDF for the next tuple.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>error_caught</name></expr>)</condition>
			<block>{<block_content>
				<switch>switch <condition>(<expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_notification</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>FMT_NONE</name></expr>:</case>

						<comment type="block">/* got a tuple back */</comment>

						<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>formatter</name><operator>-&gt;</operator><name>fmt_tuple</name></name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>processed</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_perrow_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<return>return <expr><name>tuple</name></expr>;</return>

					<case>case <expr><name>FMT_NEED_MORE_DATA</name></expr>:</case>

						<comment type="block">/*
						 * Callee consumed all data in the buffer. Prepare
						 * to read more data into it.
						 */</comment>
						<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>raw_buf_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>justifyDatabuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>formatter</name><operator>-&gt;</operator><name>fmt_databuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>

					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported formatter notification (%d)"</literal></expr></argument>,
								<argument><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_notification</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ErrorIfRejectLimitReached</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>cdbsreh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_databuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The formatter needs more data, but we have reached
		 * EOF. This is an error.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected end of file"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if we got here we finished reading all the data.
	 */</comment>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
*		externalgettup	form another tuple from the data file.
*		This is the workhorse - make sure it's fast!
*
*		Initialize the scan if not already done.
*		Verify that we are scanning forward only.
*
* ----------------
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>externalgettup</name><argument_list>(<argument><expr><name>FileScanDesc</name> <name>scan</name></expr></argument>,
               <argument><expr><name>ScanDirection</name> <name>dir</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>custom</name> <init>= <expr><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>fs_custom_formatter_func</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>externalscan_error_context</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>externalscan_error_context</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>external_scan_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>externalscan_error_context</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>scan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>externalscan_error_context</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>externalscan_error_context</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>custom</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>externalgettup_defined</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* text/csv */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>externalgettup_custom</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* custom */</comment>

	<comment type="block">/* Restore the previous error callback */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>externalscan_error_context</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<return>return <expr><name>tup</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * setCustomFormatter
 *
 * Given a formatter name and a function signature (pre-determined
 * by whether it is readable or writable) find such a function in
 * the catalog and store it to be used later.
 *
 * WET function: 1 record arg, return bytea.
 * RET function: 0 args, returns record.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>lookupCustomFormatter</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>formatter_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>funcname</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>returnOid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The formatter is defined as a "formatter=&lt;name&gt;" tuple in the options
	 * array. Extract into a separate list in order to scan the catalog for
	 * the function definition.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>*options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"formatter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>formatter_name</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>funcname</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>formatter_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>options</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><operator>*</operator><name>options</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"formatter function not found in table options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>iswritable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>returnOid</name> <operator>=</operator> <name>BYTEAOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>returnOid</name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"formatter function \"%s\" of type %s was not found"</literal></expr></argument>,
						<argument><expr><name>formatter_name</name></expr></argument>,
						<argument><expr><operator>(</operator><ternary><condition><expr><name>iswritable</name></expr> ?</condition><then> <expr><literal type="string">"writable"</literal></expr> </then><else>: <expr><literal type="string">"readable"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Create it with CREATE FUNCTION."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check return type matches */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>returnOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"formatter function \"%s\" of type %s has an incorrect return type"</literal></expr></argument>,
						<argument><expr><name>formatter_name</name></expr></argument>,
						<argument><expr><operator>(</operator><ternary><condition><expr><name>iswritable</name></expr> ?</condition><then> <expr><literal type="string">"writable"</literal></expr> </then><else>: <expr><literal type="string">"readable"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check allowed volatility */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>func_volatile</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PROVOLATILE_STABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"formatter function %s is not declared STABLE"</literal></expr></argument>,
						<argument><expr><name>formatter_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>procOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the data parsing state.
 *
 * This includes format descriptions (delimiter, quote...), format type
 * (text, csv), etc...
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitParseState</name><parameter_list>(<parameter><decl><type><name>CopyState</name></type> <name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>,
			   <parameter><decl><type><name>char</name></type> <name>fmtType</name></decl></parameter>,
			   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rejectlimit</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>islimitinrows</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>logerrors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Error handling setup
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rejectlimit</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Default error handling - "all-or-nothing" */</comment>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>cdbsreh</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* no SREH */</comment>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>errMode</name></name> <operator>=</operator> <name>ALL_OR_NOTHING</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* select the SREH mode */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_LOG_TO_FILE</name><argument_list>(<argument><expr><name>logerrors</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* errors into file */</comment>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>errMode</name></name> <operator>=</operator> <name>SREH_LOG</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* no error log */</comment>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>errMode</name></name> <operator>=</operator> <name>SREH_IGNORE</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Single row error handling */</comment>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>cdbsreh</name></name> <operator>=</operator> <call><name>makeCdbSreh</name><argument_list>(<argument><expr><name>rejectlimit</name></expr></argument>,
									  <argument><expr><name>islimitinrows</name></expr></argument>,
									  <argument><expr><name>uri</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>,
									  <argument><expr><name>logerrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>cdbsreh</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Initialize 'out_functions', like CopyTo() would. */</comment>
	<decl_stmt><decl><type><name>CopyState</name></type> <name>cstate</name> <init>= <expr><name>pstate</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_phys_attrs</name> <init>= <expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>cstate-&gt;attnumlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>out_func_oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isvarlena</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTypeBinaryOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>out_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>out_functions</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* and 'fe_mgbuf' */</comment>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a temporary memory context that we can reset once per row to
	 * recover palloc'd memory.  This avoids any problems with leaks inside
	 * datatype input or output routines, and should be faster than retail
	 * pfree's anyway.
	 */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>rowcontext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											   <argument><expr><literal type="string">"ExtTableMemCxt"</literal></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Prepare the formatter data to be used inside the formatting UDF.
 * This function should be called every time before invoking the
 * UDF, for both insert and scan operations. Even though there's some
 * redundancy here, it is needed in order to reset some per-call state
 * that should be examined by the caller upon return from the UDF.
 *
 * Also, set up the function call context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FunctionCallPrepareFormatter</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfoBaseData</name> <modifier>*</modifier></type><name>fcinfo</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>nArgs</name></decl></parameter>,
							 <parameter><decl><type><name>CopyState</name></type> <name>pstate</name></decl></parameter>,
							 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>formatter_func</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>formatter_params</name></decl></parameter>,
							 <parameter><decl><type><name>FormatterData</name> <modifier>*</modifier></type><name>formatter</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>,
							 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>convFuncs</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typioparams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_FormatterData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_relation</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_tupDesc</name></name> <operator>=</operator> <name>tupDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_notification</name></name> <operator>=</operator> <name>FMT_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_badrow_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_badrow_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_args</name></name> <operator>=</operator> <name>formatter_params</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_conv_funcs</name></name> <operator>=</operator> <name>convFuncs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_saw_eof</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>reached_eof</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_typioparams</name></name> <operator>=</operator> <name>typioparams</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_perrow_ctx</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>rowcontext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_needs_transcoding</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_conversion_proc</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>enc_conversion_proc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatter</name><operator>-&gt;</operator><name>fmt_external_encoding</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>( <comment type="block">/* FunctionCallInfoData */</comment> <argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>,
							  <comment type="block">/* FmgrInfo */</comment> <argument><expr><name>formatter_func</name></expr></argument>,
							  <comment type="block">/* nArgs */</comment> <argument><expr><name>nArgs</name></expr></argument>,
							  <comment type="block">/* collation */</comment> <argument><expr><name>InvalidOid</name></expr></argument>,
							  <comment type="block">/* Call Context */</comment> <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>formatter</name></expr></argument>,
							  <comment type="block">/* ResultSetInfo */</comment> <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * open the external source for scanning (RET only)
 *
 * an external source is one of the following:
 * 1) a local file (requested by 'file')
 * 2) a remote http server
 * 3) a remote gpfdist server
 * 4) a command to execute
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>open_external_readable_source</name><parameter_list>(<parameter><decl><type><name>FileScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ExternalSelectDesc</name></type> <name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>extvar_t</name></type>	<name>extvar</name></decl>;</decl_stmt>

	<comment type="block">/* set up extvar */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extvar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>extvar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>external_set_env_vars_ext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extvar</name></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_uri</name></name></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>escape</name></name></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>quote</name></name></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>eol_type</name></name></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name><operator>-&gt;</operator><name>header_line</name></name></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_scancounter</name></name></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_custom_formatter_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* actually open the external source */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_file</name></name> <operator>=</operator> <call><name>url_fopen</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_uri</name></name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument> <comment type="block">/* for read */</comment> ,
							  <argument><expr><operator>&amp;</operator><name>extvar</name></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name></expr></argument>,
							  <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * open the external source for writing (WET only)
 *
 * an external source is one of the following:
 * 1) a local file (requested by 'tablespace' protocol)
 * 2) a command to execute
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>open_external_writable_source</name><parameter_list>(<parameter><decl><type><name>ExternalInsertDesc</name></type> <name>extInsertDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>extvar_t</name></type>	<name>extvar</name></decl>;</decl_stmt>

	<comment type="block">/* set up extvar */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extvar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>extvar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>external_set_env_vars_ext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extvar</name></expr></argument>,
							  <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_uri</name></name></expr></argument>,
							  <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name><operator>-&gt;</operator><name>csv_mode</name></name></expr></argument>,
							  <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name><operator>-&gt;</operator><name>escape</name></name></expr></argument>,
							  <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name><operator>-&gt;</operator><name>quote</name></name></expr></argument>,
							  <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name><operator>-&gt;</operator><name>eol_type</name></name></expr></argument>,
							  <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name><operator>-&gt;</operator><name>header_line</name></name></expr></argument>,
							  <argument><expr><literal type="number">0</literal></expr></argument>,
						 <argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_custom_formatter_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* actually open the external source */</comment>
	<expr_stmt><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_file</name></name> <operator>=</operator> <call><name>url_fopen</name><argument_list>(<argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_uri</name></name></expr></argument>,
										<argument><expr><name>true</name></expr></argument> <comment type="block">/* forwrite */</comment> ,
										<argument><expr><operator>&amp;</operator><name>extvar</name></expr></argument>,
										<argument><expr><name><name>extInsertDesc</name><operator>-&gt;</operator><name>ext_pstate</name></name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch more data from the source, and feed it to the COPY FROM machinery
 * for parsing.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>external_getdata_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>outbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minread</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxread</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileScanDesc</name></type> <name>scan</name> <init>= <expr><operator>(</operator><name>FileScanDesc</name><operator>)</operator> <name>extra</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>external_getdata</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_file</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name></expr></argument>, <argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>maxread</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get a chunk of data from the external data file.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>external_getdata</name><parameter_list>(<parameter><decl><type><name>URL_FILE</name> <modifier>*</modifier></type><name>extfile</name></decl></parameter>, <parameter><decl><type><name>CopyState</name></type> <name>pstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>outbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxread</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytesread</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * CK: this code is very delicate. The caller expects this: - if url_fread
	 * returns something, and the EOF is reached, it this call must return
	 * with both the content and the reached_eof flag set. - failing to do so will
	 * result in skipping the last line.
	 */</comment>
	<expr_stmt><expr><name>bytesread</name> <operator>=</operator> <call><name>url_fread</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>outbuf</name></expr></argument>, <argument><expr><name>maxread</name></expr></argument>, <argument><expr><name>extfile</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>url_feof</name><argument_list>(<argument><expr><name>extfile</name></expr></argument>, <argument><expr><name>bytesread</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>reached_eof</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>bytesread</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>url_ferror</name><argument_list>(<argument><expr><name>extfile</name></expr></argument>, <argument><expr><name>bytesread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from external file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>bytesread</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * send a chunk of data from the external data file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>external_senddata</name><parameter_list>(<parameter><decl><type><name>URL_FILE</name> <modifier>*</modifier></type><name>extfile</name></decl></parameter>, <parameter><decl><type><name>CopyState</name></type> <name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>fe_msgbuf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>ebuf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nwrote</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ebuflen</name> <init>= <expr><literal type="number">512</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>nwrote</name> <operator>=</operator> <call><name>url_fwrite</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>extfile</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>url_ferror</name><argument_list>(<argument><expr><name>extfile</name></expr></argument>, <argument><expr><name>nwrote</name></expr></argument>, <argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>ebuflen</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ebuf</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to external resource: %s"</literal></expr></argument>,
							<argument><expr><name>ebuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to external resource: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>linenumber_atoi</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bufsz</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>linenumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>linenumber</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"N/A"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>linenumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * error context callback for external table scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>external_scan_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileScanDesc</name></type> <name>scan</name> <init>= <expr><operator>(</operator><name>FileScanDesc</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>fs_pstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * early exit for custom format error. We don't have metadata to report
	 * on. TODO: this actually will override any errcontext that the user
	 * wants to set. maybe another approach is needed here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>fs_custom_formatter_func</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"External table %s"</literal></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* error is relevant to a particular column */</comment>

		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"External table %s, line %s of %s, column %s"</literal></expr></argument>,
				   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>,
				   <argument><expr><call><name>linenumber_atoi</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_uri</name></name></expr></argument>,
				   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* error is relevant to a particular line */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_converted</name></name> <operator>||</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>line_buf</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>line_buf</name> <operator>=</operator> <call><name>limit_printout_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>truncateEolStr</name><argument_list>(<argument><expr><name>line_buf</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"External table %s, line %s of %s: \"%s\""</literal></expr></argument>,
					   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>,
					   <argument><expr><call><name>linenumber_atoi</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_uri</name></name></expr></argument>, <argument><expr><name>line_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>line_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Here, the line buffer is still in a foreign encoding, and
			 * indeed it's quite likely that the error is precisely a failure
			 * to do encoding conversion (ie, bad data).  We dare not try to
			 * convert it, and at present there's no way to regurgitate it
			 * without conversion.  So we have to punt and just report the
			 * line number.
			 *
			 * since the gpfdist protocol does not transfer line numbers
			 * correclty in certain places - if line number is 0 we just do
			 * not print it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"External table %s, line %s of file %s"</literal></expr></argument>,
						   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>,
						   <argument><expr><call><name>linenumber_atoi</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"External table %s, file %s"</literal></expr></argument>,
						   <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_relname</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>fs_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * justifyDatabuf
 *
 * shift all data remaining in the buffer (anything from cursor to
 * end of buffer) to the beginning of the buffer, and readjust the
 * cursor and length to the new end of buffer position.
 *
 * 3 possible cases:
 *	 1 - cursor at beginning of buffer (whole buffer is a partial row) - nothing to do.
 *	 2 - cursor at end of buffer (last row ended in the last byte of the buffer)
 *	 3 - cursor at middle of buffer (remaining bytes are a partial row)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>justifyDatabuf</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* 1 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do */</comment>
	</block_content>}</block></if>
	<comment type="block">/* 2 */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name> <operator>==</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* 3 */</comment>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>position</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>remaining</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* slide data back (data may overlap so use memmove not memcpy) */</comment>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>position</name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>remaining</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>		<comment type="block">/* be consistent with
										 * appendBinaryStringInfo() */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>appendCopyEncodingOption</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>copyFmtOpts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>lappend</name><argument_list>(<argument><expr><name>copyFmtOpts</name></expr></argument>,
				   <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"encoding"</literal></expr></argument>,
							   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeString</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
