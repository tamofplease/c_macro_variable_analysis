<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/gpcontrib/gp_replica_check/gp_replica_check.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gistxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/ginxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relmapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<comment type="block">/*
 * If a file comparison fails, how many times to retry before admitting
 * that it really differs?
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_RETRIES</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>

<comment type="block">/*
 * How many seconds to wait for checkpoint record to be applied in standby?
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_CHECKPOINT_SYNC_TIMEOUT</name></cpp:macro> <cpp:value>600</cpp:value></cpp:define>

<comment type="block">/*
 * This value is used as divisor to split a sec, used to speficy sleep time
 * waiting between retries for checkpoint to make through to mirror.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAITS_PER_SEC</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/*
 * Not all the FSM and VM changes are WAL-logged and its OK if they are out of
 * date. So it is OK to skip them for consistency check.
 *
 * Temporary tables (starting with "t_") shouldn't be replicated anyway.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>should_skip</name><parameter_list>(<parameter><type><name>filename</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(pg_strncasecmp(filename, "pg", 2) == 0 \
								|| pg_strncasecmp(filename, "t_", 2) == 0 \
								|| pg_strncasecmp(filename, ".", 1) == 0 \
								|| pg_strncasecmp(filename + strlen(filename) - 4, "_fsm", 4) == 0 \
								|| pg_strncasecmp(filename + strlen(filename) - 3, "_vm", 3) == 0 \
								|| pg_strncasecmp(filename + strlen(filename) - 5, "_init", 5) == 0)</cpp:value></cpp:define>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<function_decl><type><specifier>extern</specifier> <name>Datum</name></type> <name>gp_replica_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct <name>RelfilenodeEntry</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>relfilenode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>relname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl>;</decl_stmt>
}</block></struct></type> <name>RelfilenodeEntry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>RelationTypeData</name>
<block>{
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>include</name></decl>;</decl_stmt>
}</block></struct></type> <name>RelationTypeData</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_INCLUDE_RELATION_TYPES</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/*
 * This is a static pre-defined array for now as currently, this tool works
 * only for pre-defined access methods. As most likely will need masking
 * functions to perform proper comparisons for newer access methods. Plus,
 * having on the fly access methods is not at all common phenomenon. If and
 * when in future new access method is added, can update this array or enhance
 * the tool to dynamically create this array based on pg_am table.
 *
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>RelationTypeData</name></type> <name><name>relation_types</name><index>[<expr><name>MAX_INCLUDE_RELATION_TYPES</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"heap"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"btree"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"hash"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"gist"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"gin"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ao_row"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ao_column"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"brin"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"spgist"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"bitmap"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"unknown relam"</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_relation_types</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>include_relation_types</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelationTypeData</name></type> <name>get_relation_type_data</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relam</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relkind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mask_block</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pagedata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relam</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relkind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>compare_files</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>primaryfilepath</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>mirrorfilepath</name></decl></parameter>, <parameter><decl><type><name>RelfilenodeEntry</name> <modifier>*</modifier></type><name>rentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>sync_wait</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name><modifier>*</modifier></type> <name>get_relfilenode_map</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelfilenodeEntry</name><modifier>*</modifier></type> <name>get_relfilenode_entry</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relfilenode</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>relfilenode_map</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_relation_types</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>include_relation_types</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>elemlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>include_relation_types</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"List syntax is invalid."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tok</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>

		<comment type="block">/* Check for 'all' */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>type</name> <operator>&lt;</operator> <name>MAX_INCLUDE_RELATION_TYPES</name></expr>;</condition> <incr><expr><name>type</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>relation_types</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>include</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>

			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>type</name> <operator>&lt;</operator> <name>MAX_INCLUDE_RELATION_TYPES</name></expr>;</condition> <incr><expr><name>type</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name><name>relation_types</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>relation_types</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>include</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unrecognized key word: \"%s\"."</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RelationTypeData</name></type>
<name>get_relation_type_data</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relam</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch<condition>(<expr><name>relam</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>HEAP_TABLE_AM_OID</name></expr>:</case>
			<return>return <expr><name><name>relation_types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
		<case>case <expr><name>BTREE_AM_OID</name></expr>:</case>
			<return>return <expr><name><name>relation_types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
		<case>case <expr><name>HASH_AM_OID</name></expr>:</case>
			<return>return <expr><name><name>relation_types</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</return>
		<case>case <expr><name>GIST_AM_OID</name></expr>:</case>
			<return>return <expr><name><name>relation_types</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</return>
		<case>case <expr><name>GIN_AM_OID</name></expr>:</case>
			<return>return <expr><name><name>relation_types</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</return>
		<case>case <expr><name>AO_ROW_TABLE_AM_OID</name></expr>:</case>
			<return>return <expr><name><name>relation_types</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</return>
		<case>case <expr><name>AO_COLUMN_TABLE_AM_OID</name></expr>:</case>
			<return>return <expr><name><name>relation_types</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>;</return>
		<case>case <expr><name>BRIN_AM_OID</name></expr>:</case>
			<return>return <expr><name><name>relation_types</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>;</return>
		<case>case <expr><name>SPGIST_AM_OID</name></expr>:</case>
			<return>return <expr><name><name>relation_types</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</return>
		<case>case <expr><name>BITMAP_AM_OID</name></expr>:</case>
			<return>return <expr><name><name>relation_types</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr>;</return>
		<default>default:</default>
			<return>return <expr><name><name>relation_types</name><index>[<expr><name>MAX_INCLUDE_RELATION_TYPES</name></expr>]</index></name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>mask_block</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pagedata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relam</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch<condition>(<expr><name>relam</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BTREE_AM_OID</name></expr>:</case>
			<expr_stmt><expr><call><name>btree_mask</name><argument_list>(<argument><expr><name>pagedata</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>GIST_AM_OID</name></expr>:</case>
			<expr_stmt><expr><call><name>gist_mask</name><argument_list>(<argument><expr><name>pagedata</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>GIN_AM_OID</name></expr>:</case>
			<expr_stmt><expr><call><name>gin_mask</name><argument_list>(<argument><expr><name>pagedata</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/* heap table */</comment>
		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>seq_mask</name><argument_list>(<argument><expr><name>pagedata</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_mask</name><argument_list>(<argument><expr><name>pagedata</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Perform a checkpoint, and wait for it to be sent to and applied in all
 * replicas.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sync_wait</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>retry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>ckpt_lsn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Request a checkpoint on first call, to flush out data changes from
	 * shared buffer to disk.
	 */</comment>
	<expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_IMMEDIATE</name> <operator>|</operator> <name>CHECKPOINT_FORCE</name> <operator>|</operator> <name>CHECKPOINT_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ckpt_lsn</name> <operator>=</operator> <call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>retry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>retry</name> <operator>&lt;</operator> <name>NUM_CHECKPOINT_SYNC_TIMEOUT</name> <operator>*</operator> <name>WAITS_PER_SEC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SyncRepLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_senders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/*
			 * Because we can have more than one type of walreciever connected at
			 * any time, there may be other walrecievers (like pg_basebackup) in
			 * the walsnds list.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_for_gp_walreceiver</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* fail early in-case primary and mirror are not in sync */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pid</name> <operator>==</operator> <literal type="number">0</literal>
				<operator>||</operator> <name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>!=</operator> <name>WALSNDSTATE_STREAMING</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"primary and mirror not in sync"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SyncRepLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>apply</name> <operator>&lt;</operator> <name>ckpt_lsn</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SyncRepLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The above loop did not break early on any wal sender so they should
		 * all be in sync.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_wal_senders</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000</literal> <operator>/</operator> <name>WAITS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retry</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>compare_files</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>primaryfilepath</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>mirrorfilepath</name></decl></parameter>, <parameter><decl><type><name>RelfilenodeEntry</name> <modifier>*</modifier></type><name>rentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type>		<name>primaryFile</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>mirrorFile</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attempts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>any_retries</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>primaryFileExists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mirrorFileExists</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blockno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there's any discrepancy between the files below, we will loop back
	 * here. If NUM_RETRIES is reached, return error.
	 */</comment>
<label><name>retry</name>:</label>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the files were still open from previous attempt, close them first. */</comment>
	<if_stmt><if>if <condition>(<expr><name>primaryFile</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>primaryFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>primaryFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>mirrorFile</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>mirrorFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mirrorFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>attempts</name> <operator>==</operator> <name>NUM_RETRIES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s files \"%s\" and \"%s\" for relation \"%s\" mismatch at blockno %d, gave up after %d retries"</literal></expr></argument>,
						<argument><expr><call><name>get_relation_type_data</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>name</name></expr></argument>,
						<argument><expr><name>primaryfilepath</name></expr></argument>, <argument><expr><name>mirrorfilepath</name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>, <argument><expr><name>attempts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>attempts</name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>attempts</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>any_retries</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/*
		 * Request a checkpoint on first call, to flush out data changes from
		 * shared buffer to disk.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sync_wait</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Attempt to open both files.
	 */</comment>
	<expr_stmt><expr><name>primaryFileExists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>primaryFile</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>primaryfilepath</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>primaryFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>primaryFileExists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>primaryfilepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>mirrorFileExists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mirrorFile</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>mirrorfilepath</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mirrorFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>mirrorFileExists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>mirrorfilepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Did it succeed? Neither one, just one of them, or both? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>primaryFileExists</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>mirrorFileExists</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"file \"%s\" was concurrently deleted on primary and mirror"</literal></expr></argument>, <argument><expr><name>primaryfilepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>primaryFileExists</name> <operator>&amp;&amp;</operator> <name>mirrorFileExists</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"file \"%s\" was concurrently deleted on primary"</literal></expr></argument>, <argument><expr><name>primaryfilepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>retry</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>primaryFileExists</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>mirrorFileExists</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"file \"%s\" was concurrently deleted on mirror"</literal></expr></argument>, <argument><expr><name>mirrorfilepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>retry</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, both files were opened successfully. Compare them block-by block.
	 *
	 * Note: if this is not the first attempt, we keep the block number across attempts,
	 * rather than always starting from the beginning of the file.
	 */</comment>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>primaryFileBuf</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>mirrorFileBuf</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>primaryFileBytesRead</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>mirrorFileBytesRead</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>diff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>off_t</name></type>		<name>offset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>do_check</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>do_check</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>blockno</name> <operator>*</operator> <name>BLCKSZ</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>primaryFileBytesRead</name> <operator>=</operator> <call><name>FileRead</name><argument_list>(<argument><expr><name>primaryFile</name></expr></argument>, <argument><expr><name>primaryFileBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>primaryFileBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
										<argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>primaryFileBytesRead</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"could not read from file \"%s\", block %u: %m"</literal></expr></argument>, <argument><expr><name>primaryfilepath</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>mirrorFileBytesRead</name> <operator>=</operator> <call><name>FileRead</name><argument_list>(<argument><expr><name>mirrorFile</name></expr></argument>, <argument><expr><name>mirrorFileBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mirrorFileBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
									   <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mirrorFileBytesRead</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"could not read from file \"%s\", block %u: %m"</literal></expr></argument>, <argument><expr><name>mirrorfilepath</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>primaryFileBytesRead</name> <operator>!=</operator> <name>mirrorFileBytesRead</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* length mismatch */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s files \"%s\" and \"%s\" for relation \"%s\" mismatch at blockno %u, primary length: %i, mirror length: %i"</literal></expr></argument>,
							<argument><expr><call><name>get_relation_type_data</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>name</name></expr></argument>,
							<argument><expr><name>primaryfilepath</name></expr></argument>, <argument><expr><name>mirrorfilepath</name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>,
							<argument><expr><name>primaryFileBytesRead</name></expr></argument>, <argument><expr><name>mirrorFileBytesRead</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>primaryFileBytesRead</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* reached EOF */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>rentry</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>HEAP_TABLE_AM_OID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>primaryFileBytesRead</name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"short read of %d bytes from heap file \"%s\", block %u: %m"</literal></expr></argument>, <argument><expr><name>primaryFileBytesRead</name></expr></argument>, <argument><expr><name>primaryfilepath</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>retry</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/*
			 * Perform some basic sanity checks before handing the block to
			 * mask_block(). It might throw a hard ERROR on a bogus block,
			 * so we better catch that here so we can retry.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsVerified</name><argument_list>(<argument><expr><name>primaryFileBuf</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"invalid page header or checksum in heap file \"%s\", block %u"</literal></expr></argument>, <argument><expr><name>primaryfilepath</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>retry</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsVerified</name><argument_list>(<argument><expr><name>mirrorFileBuf</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"invalid page header or checksum in heap file \"%s\", block %u"</literal></expr></argument>, <argument><expr><name>mirrorfilepath</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>retry</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * PG supports block bulk-extend. In such case some pages are
			 * extended, initialized but not xlogged. On mirror those pages are
			 * just zero filled so we'd skip comparison for these pages.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>primaryFileBuf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PageIsNew</name><argument_list>(<argument><expr><name>mirrorFileBuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>do_check</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name>primaryFileBuf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name>mirrorFileBuf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mask_block</name><argument_list>(<argument><expr><name>primaryFileBuf</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mask_block</name><argument_list>(<argument><expr><name>mirrorFileBuf</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>do_check</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>diff</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>primaryFileBuf</name></expr></argument>, <argument><expr><name>mirrorFileBuf</name></expr></argument>, <argument><expr><name>primaryFileBytesRead</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* different contents */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s files \"%s\" and \"%s\" for relation \"%s\" mismatch by %i at blockno %u"</literal></expr></argument>,
							<argument><expr><call><name>get_relation_type_data</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>name</name></expr></argument>,
							<argument><expr><name>primaryfilepath</name></expr></argument>, <argument><expr><name>mirrorfilepath</name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
							<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Success! Advance to next block, and reset the retry-counter */</comment>
		<expr_stmt><expr><name>attempts</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>blockno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Reached end of file successfully! */</comment>

	<if_stmt><if>if <condition>(<expr><name>primaryFile</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>primaryFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>mirrorFile</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>mirrorFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The NOTICEs about differences can make the user think that something's
	 * wrong, even though they are normal if there is any concurrent activity.
	 * So if we emitted those NOTICEs, emit another NOTICE to reassure the
	 * user it was all right in the end.
	 *
	 * (It's next to impossible to quiesce the cluster so well that there would be
	 * no activity. Hint bits can be set even by read-only queries, for example.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>any_retries</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"succeeded after retrying"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HTAB</name><modifier>*</modifier></type>
<name>get_relfilenode_map</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>relfilenodemap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>relfilenodectl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hash_flags</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relfilenodectl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>relfilenodectl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relfilenodectl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relfilenodectl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelfilenodeEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relfilenodectl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>oid_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash_flags</name> <operator>=</operator> <operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>relfilenodemap</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"relfilenode map"</literal></expr></argument>, <argument><expr><literal type="number">50000</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>relfilenodectl</name></expr></argument>, <argument><expr><name>hash_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while<condition>(<expr><operator>(</operator><name>tup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classtuple</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>classtuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name>
			 <operator>||</operator> <name><name>classtuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* unlogged tables do not propagate to replica servers */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classtuple</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>RelfilenodeEntry</name> <modifier>*</modifier></type><name>rentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>rnode</name></decl>;</decl_stmt>
		<comment type="block">/* Its relmapped relation, need to fetch the mapping from relmap file */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classtuple</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rnode</name> <operator>=</operator> <call><name>RelationMapOidToFilenode</name><argument_list>(<argument><expr><name><name>classtuple</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>,
											 <argument><expr><name><name>classtuple</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rnode</name> <operator>=</operator> <name><name>classtuple</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>rentry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>relfilenodemap</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rentry</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>rnode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rentry</name><operator>-&gt;</operator><name>relam</name></name> <operator>=</operator> <name><name>classtuple</name><operator>-&gt;</operator><name>relam</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rentry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>classtuple</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classtuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>relfilenodemap</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RelfilenodeEntry</name><modifier>*</modifier></type>
<name>get_relfilenode_entry</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relfilenode</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>relfilenode_map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>rnode</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelfilenodeEntry</name> <modifier>*</modifier></type><name>rentry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>relfilenode_map</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>rentry</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gp_replica_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>gp_replica_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>primarydirpath</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mirrordirpath</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relation_types</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>dir_equal</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>primarydir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>mirrordir</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_relation_types</name><argument_list>(<argument><expr><name>relation_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* TODO: Currently, we only scan the default tablespace */</comment>
	<expr_stmt><expr><name>primarydirpath</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
							  <argument><expr><name>primarydirpath</name></expr></argument>,
							  <argument><expr><call><name>GetDatabasePath</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>DEFAULTTABLESPACE_OID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mirrordirpath</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
							 <argument><expr><name>mirrordirpath</name></expr></argument>,
							 <argument><expr><call><name>GetDatabasePath</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>DEFAULTTABLESPACE_OID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Checkpoint, so that all the changes are on disk.
	 *
	 * XXX: There is currently no guarantee that the standby has performed a
	 * restartpoint based on the checkpoint record. If it hasn't, any recent
	 * changes are not visible to us in the standby yet, and the file
	 * comparison will find that the files don't match. That's OK, we will
	 * issue a new checkpoint, wait, and retry a few times, so the standby
	 * should converge to the same state as the master eventually, hopefully
	 * before we give up.
	 */</comment>
	<expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_IMMEDIATE</name> <operator>|</operator> <name>CHECKPOINT_FORCE</name> <operator>|</operator> <name>CHECKPOINT_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store information from pg_class for each relfilenode */</comment>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>relfilenode_map</name> <init>= <expr><call><name>get_relfilenode_map</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For each relfilenode in primary, if it is of type specified from user
	 * input, do comparison with its corresponding file on the mirror
	 */</comment>
	<expr_stmt><expr><name>primarydir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>primarydirpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>dent</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>primarydir</name></expr></argument>, <argument><expr><name>primarydirpath</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>primaryfilename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>mirrorfilename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d_name_copy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relfilenode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>match</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>should_skip</name><argument_list>(<argument><expr><name><name>dent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>d_name_copy</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>dent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relfilenode</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>d_name_copy</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>RelfilenodeEntry</name> <modifier>*</modifier></type><name>rentry</name> <init>= <expr><call><name>get_relfilenode_entry</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>, <argument><expr><name>relfilenode_map</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* not a valid relfilenode */</comment>
		<if_stmt><if>if <condition>(<expr><name>rentry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relfilenode %s not present in primary's pg_class"</literal></expr></argument>,
							<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* skip if relation has no AM (like a partitioned table or view) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rentry</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* skip if relation type not requested by user input */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_relation_type_data</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>include</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>d_name_copy</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>d_name_copy</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rentry</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>d_name_copy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>primaryfilename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>primarydirpath</name></expr></argument>, <argument><expr><name><name>dent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mirrorfilename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>mirrordirpath</name></expr></argument>, <argument><expr><name><name>dent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* do the file comparison */</comment>
		<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>compare_files</name><argument_list>(<argument><expr><name>primaryfilename</name></expr></argument>, <argument><expr><name>mirrorfilename</name></expr></argument>, <argument><expr><name>rentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dir_equal</name> <operator>=</operator> <name>dir_equal</name> <operator>&amp;&amp;</operator> <name>match</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>primarydir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open up mirrordirpath and verify each mirror file exist in the primary hash table */</comment>
	<expr_stmt><expr><name>mirrordir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>mirrordirpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>dent</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>mirrordir</name></expr></argument>, <argument><expr><name>mirrordirpath</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d_name_copy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relfilenode</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>should_skip</name><argument_list>(<argument><expr><name><name>dent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>d_name_copy</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>dent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relfilenode</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>d_name_copy</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>RelfilenodeEntry</name> <modifier>*</modifier></type><name>rentry</name> <init>= <expr><call><name>get_relfilenode_entry</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>, <argument><expr><name>relfilenode_map</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>rentry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>d_name_copy</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>d_name_copy</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>rentry-&gt;segments</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>d_name_copy</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <call><name>get_relation_type_data</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>include</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"found extra %s file on mirror: %s/%s"</literal></expr></argument>,
									<argument><expr><call><name>get_relation_type_data</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>, <argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call><operator>.</operator><name>name</name></expr></argument>,
									<argument><expr><name>mirrordirpath</name></expr></argument>,
									<argument><expr><name><name>dent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"found extra unknown file on mirror: %s/%s"</literal></expr></argument>,
							<argument><expr><name>mirrordirpath</name></expr></argument>, <argument><expr><name><name>dent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>mirrordir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>relfilenode_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>dir_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
