<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/gpcontrib/orafce/sqlparse.c"><comment type="block">/* A Bison parser, made by GNU Bison 3.5.  */</comment>

<comment type="block">/* Bison implementation for Yacc-like parsers in C

   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
   Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</comment>

<comment type="block">/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */</comment>

<comment type="block">/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */</comment>

<comment type="block">/* All symbols defined below should begin with yy or YY, to avoid
   infringing on user name space.  This should be done even for local
   variables, as they might otherwise be expanded by user macros.
   There are some unavoidable exceptions within include files to
   define necessary library symbols; they are noted "INFRINGES ON
   USER NAME SPACE" below.  */</comment>

<comment type="block">/* Undocumented macros, especially those whose name start with YY_,
   are private implementation details.  Do not rely on them.  */</comment>

<comment type="block">/* Identify Bison output.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYBISON</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* Bison version.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYBISON_VERSION</name></cpp:macro> <cpp:value>"3.5"</cpp:value></cpp:define>

<comment type="block">/* Skeleton name.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYSKELETON_NAME</name></cpp:macro> <cpp:value>"yacc.c"</cpp:value></cpp:define>

<comment type="block">/* Pure parsers.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYPURE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* Push parsers.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYPUSH</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* Pull parsers.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYPULL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>


<comment type="block">/* Substitute the variable and function names.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyparse</name></cpp:macro>         <cpp:value>orafce_sql_yyparse</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yylex</name></cpp:macro>           <cpp:value>orafce_sql_yylex</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyerror</name></cpp:macro>         <cpp:value>orafce_sql_yyerror</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yydebug</name></cpp:macro>         <cpp:value>orafce_sql_yydebug</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yynerrs</name></cpp:macro>         <cpp:value>orafce_sql_yynerrs</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yylval</name></cpp:macro>          <cpp:value>orafce_sql_yylval</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yychar</name></cpp:macro>          <cpp:value>orafce_sql_yychar</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yylloc</name></cpp:macro>          <cpp:value>orafce_sql_yylloc</cpp:value></cpp:define>

<comment type="block">/* First part of user prologue.  */</comment>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>8</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYDEBUG</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYLLOC_DEFAULT</name><parameter_list>(<parameter><type><name>Current</name></type></parameter>, <parameter><type><name>Rhs</name></type></parameter>, <parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
if (N) \
(Current) = (Rhs)[1]; \
else \
(Current) = (Rhs)[0]; \
} while (0)</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orafce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plvlex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOVE_TO_S</name><parameter_list>(<parameter><type><name>src</name></type></parameter>,<parameter><type><name>dest</name></type></parameter>,<parameter><type><name>col</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>dest-&gt;col = src.col ? pstrdup(src.col) : NULL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOVE_TO</name><parameter_list>(<parameter><type><name>src</name></type></parameter>,<parameter><type><name>dest</name></type></parameter>,<parameter><type><name>col</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>dest-&gt;col = src.col</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILL_NODE</name><parameter_list>(<parameter><type><name>src</name></type></parameter>,<parameter><type><name>dest</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>MOVE_TO_S(src,dest,str), \
	MOVE_TO(src,dest,keycode), \
	MOVE_TO(src,dest,lloc), \
	MOVE_TO_S(src,dest,sep), \
	MOVE_TO(src,dest,modificator)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>orafce_lexnode</name> <modifier>*</modifier></type><name>__node</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREATE_NODE</name><parameter_list>(<parameter><type><name>src</name></type></parameter>,<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> 	\
  <cpp:value>( \
    __node = (orafce_lexnode*) palloc(sizeof(orafce_lexnode)), \
    __node-&gt;typenode = X_##type, \
    __node-&gt;classname = #type, \
    FILL_NODE(src,__node), \
    __node)</cpp:value></cpp:define>


<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>yylex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>      <comment type="block">/* defined as fdate_yylex in fdatescan.l */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>scanbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>scanbuflen</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>orafce_sql_yyerror</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYMALLOC</name></cpp:macro>	<cpp:value>malloc</cpp:value></cpp:define>	<comment type="block">/* XXX: should use palloc? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYFREE</name></cpp:macro>		<cpp:value>free</cpp:value></cpp:define>	<comment type="block">/* XXX: should use pfree? */</comment>


<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>129</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>

<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>YY_CAST</name></cpp:ifndef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_CAST</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>Val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static_cast&lt;Type&gt; (Val)</cpp:value></cpp:define>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_REINTERPRET_CAST</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>Val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>reinterpret_cast&lt;Type&gt; (Val)</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_CAST</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>Val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((Type) (Val))</cpp:value></cpp:define>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_REINTERPRET_CAST</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>Val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((Type) (Val))</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>YY_NULLPTR</name></cpp:ifndef>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__cplusplus</name></expr></cpp:if>
<cpp:if>#   <cpp:directive>if</cpp:directive> <expr><literal type="number">201103L</literal> <operator>&lt;=</operator> <name>__cplusplus</name></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NULLPTR</name></cpp:macro> <cpp:value>nullptr</cpp:value></cpp:define>
<cpp:else>#   <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NULLPTR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NULLPTR</name></cpp:macro> <cpp:value>((void*)0)</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Enabling verbose error messages.  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYERROR_VERBOSE</name></cpp:ifdef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>YYERROR_VERBOSE</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYERROR_VERBOSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYERROR_VERBOSE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Use api.header.include to #include this header
   instead of duplicating it here.  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_ORAFCE_SQL_YY_SQLPARSE_H_INCLUDED</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_ORAFCE_SQL_YY_SQLPARSE_H_INCLUDED</name></cpp:macro></cpp:define>
<comment type="block">/* Debug traces.  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYDEBUG</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYDEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYDEBUG</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>orafce_sql_yydebug</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Token type.  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYTOKENTYPE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYTOKENTYPE</name></cpp:macro></cpp:define>
  <enum>enum <name>yytokentype</name>
  <block>{
    <decl><name>X_IDENT</name> <init>= <expr><literal type="number">258</literal></expr></init></decl>,
    <decl><name>X_NCONST</name> <init>= <expr><literal type="number">259</literal></expr></init></decl>,
    <decl><name>X_SCONST</name> <init>= <expr><literal type="number">260</literal></expr></init></decl>,
    <decl><name>X_OP</name> <init>= <expr><literal type="number">261</literal></expr></init></decl>,
    <decl><name>X_PARAM</name> <init>= <expr><literal type="number">262</literal></expr></init></decl>,
    <decl><name>X_COMMENT</name> <init>= <expr><literal type="number">263</literal></expr></init></decl>,
    <decl><name>X_WHITESPACE</name> <init>= <expr><literal type="number">264</literal></expr></init></decl>,
    <decl><name>X_KEYWORD</name> <init>= <expr><literal type="number">265</literal></expr></init></decl>,
    <decl><name>X_OTHERS</name> <init>= <expr><literal type="number">266</literal></expr></init></decl>,
    <decl><name>X_TYPECAST</name> <init>= <expr><literal type="number">267</literal></expr></init></decl>
  }</block>;</enum>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Value type.  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <name>defined</name> <name>YYSTYPE</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>defined</name> <name>YYSTYPE_IS_DECLARED</name></expr></cpp:if>
<union>union <name>YYSTYPE</name>
<block>{
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>63</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>

	<decl_stmt><decl><type><name>int</name></type> 	<name>ival</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>orafce_lexnode</name>	<modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
	<struct>struct
	<block>{
		<decl_stmt><decl><type><name>char</name> 	<modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>keycode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>lloc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>modificator</name></decl>;</decl_stmt>
	}</block>				<decl><name>val</name></decl>;</struct>

<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>208</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>

}</block>;</union>
<typedef>typedef <type><name><name>union</name> <name>YYSTYPE</name></name></type> <name>YYSTYPE</name>;</typedef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTYPE_IS_TRIVIAL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTYPE_IS_DECLARED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Location type.  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <name>defined</name> <name>YYLTYPE</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>defined</name> <name>YYLTYPE_IS_DECLARED</name></expr></cpp:if>
<typedef>typedef <type><name><name>struct</name> <name>YYLTYPE</name></name></type> <name>YYLTYPE</name>;</typedef>
<struct>struct <name>YYLTYPE</name>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>first_line</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>first_column</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>last_line</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>last_column</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYLTYPE_IS_DECLARED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYLTYPE_IS_TRIVIAL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><specifier>extern</specifier> <name>YYSTYPE</name></type> <name>orafce_sql_yylval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>YYLTYPE</name></type> <name>orafce_sql_yylloc</name></decl>;</decl_stmt>
<function_decl><type><name>int</name></type> <name>orafce_sql_yyparse</name> <parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !YY_ORAFCE_SQL_YY_SQLPARSE_H_INCLUDED  */</comment>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>short</name></cpp:ifdef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>short</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
   &lt;limits.h&gt; and (if available) &lt;stdint.h&gt; are included
   so that the code can choose integer types of a good width.  */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__PTRDIFF_MAX__</name></cpp:ifndef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__STDC_VERSION__</name> <operator>&amp;&amp;</operator> <literal type="number">199901</literal> <operator>&lt;=</operator> <name>__STDC_VERSION__</name></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_STDINT_H</name></cpp:macro></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Narrow types that promote to a signed type and that can represent a
   signed or unsigned integer of at least N bits.  In tables they can
   save space and decrease cache pressure.  Promoting to a signed type
   helps avoid bugs in integer arithmetic.  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__INT_LEAST8_MAX__</name></cpp:ifdef>
<typedef>typedef <type><name>__INT_LEAST8_TYPE__</name></type> <name>yytype_int8</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>YY_STDINT_H</name></expr></cpp:elif>
<typedef>typedef <type><name>int_least8_t</name></type> <name>yytype_int8</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>signed</name> <name>char</name></type> <name>yytype_int8</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__INT_LEAST16_MAX__</name></cpp:ifdef>
<typedef>typedef <type><name>__INT_LEAST16_TYPE__</name></type> <name>yytype_int16</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>YY_STDINT_H</name></expr></cpp:elif>
<typedef>typedef <type><name>int_least16_t</name></type> <name>yytype_int16</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>short</name></type> <name>yytype_int16</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__UINT_LEAST8_MAX__</name> <operator>&amp;&amp;</operator> <name>__UINT_LEAST8_MAX__</name> <operator>&lt;=</operator> <name>__INT_MAX__</name></expr></cpp:if>
<typedef>typedef <type><name>__UINT_LEAST8_TYPE__</name></type> <name>yytype_uint8</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><operator>!</operator><name>defined</name> <name>__UINT_LEAST8_MAX__</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>YY_STDINT_H</name> \
       <operator>&amp;&amp;</operator> <name>UINT_LEAST8_MAX</name> <operator>&lt;=</operator> <name>INT_MAX</name><operator>)</operator></expr></cpp:elif>
<typedef>typedef <type><name>uint_least8_t</name></type> <name>yytype_uint8</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>__UINT_LEAST8_MAX__</name> <operator>&amp;&amp;</operator> <name>UCHAR_MAX</name> <operator>&lt;=</operator> <name>INT_MAX</name></expr></cpp:elif>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>yytype_uint8</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>short</name></type> <name>yytype_uint8</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__UINT_LEAST16_MAX__</name> <operator>&amp;&amp;</operator> <name>__UINT_LEAST16_MAX__</name> <operator>&lt;=</operator> <name>__INT_MAX__</name></expr></cpp:if>
<typedef>typedef <type><name>__UINT_LEAST16_TYPE__</name></type> <name>yytype_uint16</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><operator>!</operator><name>defined</name> <name>__UINT_LEAST16_MAX__</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>YY_STDINT_H</name> \
       <operator>&amp;&amp;</operator> <name>UINT_LEAST16_MAX</name> <operator>&lt;=</operator> <name>INT_MAX</name><operator>)</operator></expr></cpp:elif>
<typedef>typedef <type><name>uint_least16_t</name></type> <name>yytype_uint16</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>__UINT_LEAST16_MAX__</name> <operator>&amp;&amp;</operator> <name>USHRT_MAX</name> <operator>&lt;=</operator> <name>INT_MAX</name></expr></cpp:elif>
<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>yytype_uint16</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>int</name></type> <name>yytype_uint16</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYPTRDIFF_T</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__PTRDIFF_TYPE__</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>__PTRDIFF_MAX__</name></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYPTRDIFF_T</name></cpp:macro> <cpp:value>__PTRDIFF_TYPE__</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYPTRDIFF_MAXIMUM</name></cpp:macro> <cpp:value>__PTRDIFF_MAX__</cpp:value></cpp:define>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>PTRDIFF_MAX</name></expr></cpp:elif>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>ptrdiff_t</name></cpp:ifndef>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYPTRDIFF_T</name></cpp:macro> <cpp:value>ptrdiff_t</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYPTRDIFF_MAXIMUM</name></cpp:macro> <cpp:value>PTRDIFF_MAX</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYPTRDIFF_T</name></cpp:macro> <cpp:value>long</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYPTRDIFF_MAXIMUM</name></cpp:macro> <cpp:value>LONG_MAX</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYSIZE_T</name></cpp:ifndef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>__SIZE_TYPE__</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSIZE_T</name></cpp:macro> <cpp:value>__SIZE_TYPE__</cpp:value></cpp:define>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>size_t</name></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSIZE_T</name></cpp:macro> <cpp:value>size_t</cpp:value></cpp:define>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__STDC_VERSION__</name> <operator>&amp;&amp;</operator> <literal type="number">199901</literal> <operator>&lt;=</operator> <name>__STDC_VERSION__</name></expr></cpp:elif>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSIZE_T</name></cpp:macro> <cpp:value>size_t</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSIZE_T</name></cpp:macro> <cpp:value>unsigned</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYSIZE_MAXIMUM</name></cpp:macro>                                  \
  <cpp:value>YY_CAST (YYPTRDIFF_T,                                 \
           (YYPTRDIFF_MAXIMUM &lt; YY_CAST (YYSIZE_T, -1)  \
            ? YYPTRDIFF_MAXIMUM                         \
            : YY_CAST (YYSIZE_T, -1)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYSIZEOF</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>YY_CAST (YYPTRDIFF_T, sizeof (X))</cpp:value></cpp:define>

<comment type="block">/* Stored state numbers (used for stacks). */</comment>
<typedef>typedef <type><name>yytype_int8</name></type> <name>yy_state_t</name>;</typedef>

<comment type="block">/* State numbers in computations.  */</comment>
<typedef>typedef <type><name>int</name></type> <name>yy_state_fast_t</name>;</typedef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>YYENABLE_NLS</name> <operator>&amp;&amp;</operator> <name>YYENABLE_NLS</name></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>ENABLE_NLS</name></expr></cpp:if>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>&lt;libintl.h&gt;</cpp:file></cpp:include> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_</name><parameter_list>(<parameter><type><name>Msgid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>dgettext ("bison-runtime", Msgid)</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>YY_</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_</name><parameter_list>(<parameter><type><name>Msgid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Msgid</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_ATTRIBUTE_PURE</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__GNUC__</name> <operator>&amp;&amp;</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>__GNUC__</name> <operator>+</operator> <operator>(</operator><literal type="number">96</literal> <operator>&lt;=</operator> <name>__GNUC_MINOR__</name><operator>)</operator></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_ATTRIBUTE_PURE</name></cpp:macro> <cpp:value>__attribute__ ((__pure__))</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_ATTRIBUTE_PURE</name></cpp:macro></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_ATTRIBUTE_UNUSED</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__GNUC__</name> <operator>&amp;&amp;</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>__GNUC__</name> <operator>+</operator> <operator>(</operator><literal type="number">7</literal> <operator>&lt;=</operator> <name>__GNUC_MINOR__</name><operator>)</operator></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_ATTRIBUTE_UNUSED</name></cpp:macro> <cpp:value>__attribute__ ((__unused__))</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_ATTRIBUTE_UNUSED</name></cpp:macro></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Suppress unused-variable warnings by "using" E.  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <name>defined</name> <name>lint</name> <operator>||</operator> <name>defined</name> <name>__GNUC__</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYUSE</name><parameter_list>(<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void) (E))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYUSE</name><parameter_list>(<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* empty */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__GNUC__</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>defined</name> <name>__ICC</name> <operator>&amp;&amp;</operator> <literal type="number">407</literal> <operator>&lt;=</operator> <name>__GNUC__</name> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <name>__GNUC_MINOR__</name></expr></cpp:if>
<comment type="block">/* Suppress an incorrect diagnostic about yylval being uninitialized.  */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN</name></cpp:macro>                            \
    <cpp:value>_Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_IGNORE_MAYBE_UNINITIALIZED_END</name></cpp:macro>      \
    <cpp:value>_Pragma ("GCC diagnostic pop")</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_INITIAL_VALUE</name><parameter_list>(<parameter><type><name>Value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Value</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN</name></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_IGNORE_MAYBE_UNINITIALIZED_END</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_INITIAL_VALUE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_INITIAL_VALUE</name><parameter_list>(<parameter><type><name>Value</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* Nothing. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__cplusplus</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>__GNUC__</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>defined</name> <name>__ICC</name> <operator>&amp;&amp;</operator> <literal type="number">6</literal> <operator>&lt;=</operator> <name>__GNUC__</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_IGNORE_USELESS_CAST_BEGIN</name></cpp:macro>                          \
    <cpp:value>_Pragma ("GCC diagnostic push")                            \
    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_IGNORE_USELESS_CAST_END</name></cpp:macro>            \
    <cpp:value>_Pragma ("GCC diagnostic pop")</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_IGNORE_USELESS_CAST_BEGIN</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_IGNORE_USELESS_CAST_BEGIN</name></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_IGNORE_USELESS_CAST_END</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_ASSERT</name><parameter_list>(<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void) (0 &amp;&amp; (E)))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <name>defined</name> <name>yyoverflow</name> <operator>||</operator> <name>YYERROR_VERBOSE</name></expr></cpp:if>

<comment type="block">/* The parser invokes alloca or malloc; define the necessary symbols.  */</comment>

<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>YYSTACK_USE_ALLOCA</name></cpp:ifdef>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>YYSTACK_USE_ALLOCA</name></expr></cpp:if>
<cpp:ifdef>#   <cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTACK_ALLOC</name></cpp:macro> <cpp:value>__builtin_alloca</cpp:value></cpp:define>
<cpp:elif>#   <cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__BUILTIN_VA_ARG_INCR</name></expr></cpp:elif>
<cpp:include>#    <cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
<cpp:elif>#   <cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>_AIX</name></expr></cpp:elif>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTACK_ALLOC</name></cpp:macro> <cpp:value>__alloca</cpp:value></cpp:define>
<cpp:elif>#   <cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>_MSC_VER</name></expr></cpp:elif>
<cpp:include>#    <cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>alloca</name></cpp:macro> <cpp:value>_alloca</cpp:value></cpp:define>
<cpp:else>#   <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTACK_ALLOC</name></cpp:macro> <cpp:value>alloca</cpp:value></cpp:define>
<cpp:if>#    <cpp:directive>if</cpp:directive> <expr><operator>!</operator> <name>defined</name> <name>_ALLOCA_H</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>defined</name> <name>EXIT_SUCCESS</name></expr></cpp:if>
<cpp:include>#     <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
      <comment type="block">/* Use EXIT_SUCCESS as a witness for stdlib.h.  */</comment>
<cpp:ifndef>#     <cpp:directive>ifndef</cpp:directive> <name>EXIT_SUCCESS</name></cpp:ifndef>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>EXIT_SUCCESS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#     <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>YYSTACK_ALLOC</name></cpp:ifdef>
   <comment type="block">/* Pacify GCC's 'empty if-body' warning.  */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTACK_FREE</name><parameter_list>(<parameter><type><name>Ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { <comment type="block">/* empty */</comment>; } while (0)</cpp:value></cpp:define>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>YYSTACK_ALLOC_MAXIMUM</name></cpp:ifndef>
    <comment type="block">/* The OS might guarantee only one guard page at the bottom of the stack,
       and a page size can be as small as 4096 bytes.  So we cannot safely
       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
       to allow for a few compiler-allocated temporary stack slots.  */</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTACK_ALLOC_MAXIMUM</name></cpp:macro> <cpp:value>4032</cpp:value></cpp:define> <comment type="block">/* reasonable circa 2006 */</comment>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTACK_ALLOC</name></cpp:macro> <cpp:value>YYMALLOC</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTACK_FREE</name></cpp:macro> <cpp:value>YYFREE</cpp:value></cpp:define>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>YYSTACK_ALLOC_MAXIMUM</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTACK_ALLOC_MAXIMUM</name></cpp:macro> <cpp:value>YYSIZE_MAXIMUM</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>__cplusplus</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>defined</name> <name>EXIT_SUCCESS</name> \
       <operator>&amp;&amp;</operator> <operator>!</operator> <operator>(</operator><operator>(</operator><name>defined</name> <name>YYMALLOC</name> <operator>||</operator> <name>defined</name> <name>malloc</name><operator>)</operator> \
             <operator>&amp;&amp;</operator> <operator>(</operator><name>defined</name> <name>YYFREE</name> <operator>||</operator> <name>defined</name> <name>free</name><operator>)</operator><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
<cpp:ifndef>#   <cpp:directive>ifndef</cpp:directive> <name>EXIT_SUCCESS</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>EXIT_SUCCESS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>YYMALLOC</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YYMALLOC</name></cpp:macro> <cpp:value>malloc</cpp:value></cpp:define>
<cpp:if>#   <cpp:directive>if</cpp:directive> <expr><operator>!</operator> <name>defined</name> <name>malloc</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>defined</name> <name>EXIT_SUCCESS</name></expr></cpp:if>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>malloc</name> <parameter_list>(<parameter><decl><type><name>YYSIZE_T</name></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>YYFREE</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YYFREE</name></cpp:macro> <cpp:value>free</cpp:value></cpp:define>
<cpp:if>#   <cpp:directive>if</cpp:directive> <expr><operator>!</operator> <name>defined</name> <name>free</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>defined</name> <name>EXIT_SUCCESS</name></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>free</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ! defined yyoverflow || YYERROR_VERBOSE */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator> <name>defined</name> <name>yyoverflow</name> \
     <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator> <name>defined</name> <name>__cplusplus</name> \
         <operator>||</operator> <operator>(</operator><name>defined</name> <name>YYLTYPE_IS_TRIVIAL</name> <operator>&amp;&amp;</operator> <name>YYLTYPE_IS_TRIVIAL</name> \
             <operator>&amp;&amp;</operator> <name>defined</name> <name>YYSTYPE_IS_TRIVIAL</name> <operator>&amp;&amp;</operator> <name>YYSTYPE_IS_TRIVIAL</name><operator>)</operator><operator>)</operator><operator>)</operator></expr></cpp:if>

<comment type="block">/* A type that is properly aligned for any stack member.  */</comment>
<union>union <name>yyalloc</name>
<block>{
  <decl_stmt><decl><type><name>yy_state_t</name></type> <name>yyss_alloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>YYSTYPE</name></type> <name>yyvs_alloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>YYLTYPE</name></type> <name>yyls_alloc</name></decl>;</decl_stmt>
}</block>;</union>

<comment type="block">/* The size of the maximum gap between one aligned stack and the next.  */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTACK_GAP_MAXIMUM</name></cpp:macro> <cpp:value>(YYSIZEOF (union yyalloc) - 1)</cpp:value></cpp:define>

<comment type="block">/* The size of an array large to enough to hold all stacks, each with
   N elements.  */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTACK_BYTES</name><parameter_list>(<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro> \
     <cpp:value>((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE) \
             + YYSIZEOF (YYLTYPE)) \
      + 2 * YYSTACK_GAP_MAXIMUM)</cpp:value></cpp:define>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYCOPY_NEEDED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* Relocate STACK from its old location to the new one.  The
   local variables YYSIZE and YYSTACKSIZE give the old and new number of
   elements in the stack, and YYPTR gives the new location of the
   stack.  Advance YYPTR to a properly aligned location for the next
   stack.  */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTACK_RELOCATE</name><parameter_list>(<parameter><type><name>Stack_alloc</name></type></parameter>, <parameter><type><name>Stack</name></type></parameter>)</parameter_list></cpp:macro>                           \
    <cpp:value>do                                                                  \
      {                                                                 \
        YYPTRDIFF_T yynewbytes;                                         \
        YYCOPY (&amp;yyptr-&gt;Stack_alloc, Stack, yysize);                    \
        Stack = &amp;yyptr-&gt;Stack_alloc;                                    \
        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
      }                                                                 \
    while (0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>YYCOPY_NEEDED</name> <operator>&amp;&amp;</operator> <name>YYCOPY_NEEDED</name></expr></cpp:if>
<comment type="block">/* Copy COUNT objects from SRC to DST.  The source and destination do
   not overlap.  */</comment>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>YYCOPY</name></cpp:ifndef>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__GNUC__</name> <operator>&amp;&amp;</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>__GNUC__</name></expr></cpp:if>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YYCOPY</name><parameter_list>(<parameter><type><name>Dst</name></type></parameter>, <parameter><type><name>Src</name></type></parameter>, <parameter><type><name>Count</name></type></parameter>)</parameter_list></cpp:macro> \
      <cpp:value>__builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>YYCOPY</name><parameter_list>(<parameter><type><name>Dst</name></type></parameter>, <parameter><type><name>Src</name></type></parameter>, <parameter><type><name>Count</name></type></parameter>)</parameter_list></cpp:macro>              \
      <cpp:value>do                                        \
        {                                       \
          YYPTRDIFF_T yyi;                      \
          for (yyi = 0; yyi &lt; (Count); yyi++)   \
            (Dst)[yyi] = (Src)[yyi];            \
        }                                       \
      while (0)</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !YYCOPY_NEEDED */</comment>

<comment type="block">/* YYFINAL -- State number of the termination state.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYFINAL</name></cpp:macro>  <cpp:value>13</cpp:value></cpp:define>
<comment type="block">/* YYLAST -- Last index in YYTABLE.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYLAST</name></cpp:macro>   <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/* YYNTOKENS -- Number of terminals.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYNTOKENS</name></cpp:macro>  <cpp:value>13</cpp:value></cpp:define>
<comment type="block">/* YYNNTS -- Number of nonterminals.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYNNTS</name></cpp:macro>  <cpp:value>4</cpp:value></cpp:define>
<comment type="block">/* YYNRULES -- Number of rules.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYNRULES</name></cpp:macro>  <cpp:value>13</cpp:value></cpp:define>
<comment type="block">/* YYNSTATES -- Number of states.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYNSTATES</name></cpp:macro>  <cpp:value>15</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYUNDEFTOK</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYMAXUTOK</name></cpp:macro>   <cpp:value>267</cpp:value></cpp:define>


<comment type="block">/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex, with out-of-bounds checking.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYTRANSLATE</name><parameter_list>(<parameter><type><name>YYX</name></type></parameter>)</parameter_list></cpp:macro>                                                \
  <cpp:value>(0 &lt;= (YYX) &amp;&amp; (YYX) &lt;= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)</cpp:value></cpp:define>

<comment type="block">/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int8</name></type> <name><name>yytranslate</name><index>[]</index></name> <init>=
<expr><block>{
       <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,
       <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">3</literal></expr>,     <expr><literal type="number">4</literal></expr>,
       <expr><literal type="number">5</literal></expr>,     <expr><literal type="number">6</literal></expr>,     <expr><literal type="number">7</literal></expr>,     <expr><literal type="number">8</literal></expr>,     <expr><literal type="number">9</literal></expr>,    <expr><literal type="number">10</literal></expr>,    <expr><literal type="number">11</literal></expr>,    <expr><literal type="number">12</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYDEBUG</name></expr></cpp:if>
  <comment type="block">/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int8</name></type> <name><name>yyrline</name><index>[]</index></name> <init>=
<expr><block>{
       <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">91</literal></expr>,    <expr><literal type="number">91</literal></expr>,    <expr><literal type="number">95</literal></expr>,    <expr><literal type="number">96</literal></expr>,   <expr><literal type="number">100</literal></expr>,   <expr><literal type="number">101</literal></expr>,   <expr><literal type="number">102</literal></expr>,   <expr><literal type="number">103</literal></expr>,   <expr><literal type="number">104</literal></expr>,
     <expr><literal type="number">105</literal></expr>,   <expr><literal type="number">106</literal></expr>,   <expr><literal type="number">107</literal></expr>,   <expr><literal type="number">108</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYDEBUG</name> <operator>||</operator> <name>YYERROR_VERBOSE</name> <operator>||</operator> <literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>yytname</name><index>[]</index></name> <init>=
<expr><block>{
  <expr><literal type="string">"$end"</literal></expr>, <expr><literal type="string">"error"</literal></expr>, <expr><literal type="string">"$undefined"</literal></expr>, <expr><literal type="string">"X_IDENT"</literal></expr>, <expr><literal type="string">"X_NCONST"</literal></expr>, <expr><literal type="string">"X_SCONST"</literal></expr>,
  <expr><literal type="string">"X_OP"</literal></expr>, <expr><literal type="string">"X_PARAM"</literal></expr>, <expr><literal type="string">"X_COMMENT"</literal></expr>, <expr><literal type="string">"X_WHITESPACE"</literal></expr>, <expr><literal type="string">"X_KEYWORD"</literal></expr>, <expr><literal type="string">"X_OTHERS"</literal></expr>,
  <expr><literal type="string">"X_TYPECAST"</literal></expr>, <expr><literal type="string">"$accept"</literal></expr>, <expr><literal type="string">"root"</literal></expr>, <expr><literal type="string">"elements"</literal></expr>, <expr><literal type="string">"anyelement"</literal></expr>, <expr><name>YY_NULLPTR</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>YYPRINT</name></cpp:ifdef>
<comment type="block">/* YYTOKNUM[NUM] -- (External) token number corresponding to the
   (internal) symbol number NUM (which must be that of a token).  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int16</name></type> <name><name>yytoknum</name><index>[]</index></name> <init>=
<expr><block>{
       <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">256</literal></expr>,   <expr><literal type="number">257</literal></expr>,   <expr><literal type="number">258</literal></expr>,   <expr><literal type="number">259</literal></expr>,   <expr><literal type="number">260</literal></expr>,   <expr><literal type="number">261</literal></expr>,   <expr><literal type="number">262</literal></expr>,   <expr><literal type="number">263</literal></expr>,   <expr><literal type="number">264</literal></expr>,
     <expr><literal type="number">265</literal></expr>,   <expr><literal type="number">266</literal></expr>,   <expr><literal type="number">267</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYPACT_NINF</name></cpp:macro> <cpp:value>(-4)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yypact_value_is_default</name><parameter_list>(<parameter><type><name>Yyn</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((Yyn) == YYPACT_NINF)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYTABLE_NINF</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yytable_value_is_error</name><parameter_list>(<parameter><type><name>Yyn</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>0</cpp:value></cpp:define>

  <comment type="block">/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
     STATE-NUM.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int8</name></type> <name><name>yypact</name><index>[]</index></name> <init>=
<expr><block>{
      <expr><operator>-</operator><literal type="number">3</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,
       <expr><literal type="number">9</literal></expr>,    <expr><operator>-</operator><literal type="number">3</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
     Performed when YYTABLE does not specify something else to do.  Zero
     means the default is an error.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int8</name></type> <name><name>yydefact</name><index>[]</index></name> <init>=
<expr><block>{
       <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">5</literal></expr>,     <expr><literal type="number">6</literal></expr>,     <expr><literal type="number">7</literal></expr>,     <expr><literal type="number">8</literal></expr>,     <expr><literal type="number">9</literal></expr>,    <expr><literal type="number">10</literal></expr>,    <expr><literal type="number">11</literal></expr>,    <expr><literal type="number">12</literal></expr>,    <expr><literal type="number">13</literal></expr>,
       <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">3</literal></expr>,     <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">4</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* YYPGOTO[NTERM-NUM].  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int8</name></type> <name><name>yypgoto</name><index>[]</index></name> <init>=
<expr><block>{
      <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">4</literal></expr>,    <expr><operator>-</operator><literal type="number">1</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* YYDEFGOTO[NTERM-NUM].  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int8</name></type> <name><name>yydefgoto</name><index>[]</index></name> <init>=
<expr><block>{
      <expr><operator>-</operator><literal type="number">1</literal></expr>,    <expr><literal type="number">10</literal></expr>,    <expr><literal type="number">11</literal></expr>,    <expr><literal type="number">12</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
     positive, shift that token.  If negative, reduce the rule whose
     number is the opposite.  If YYTABLE_NINF, syntax error.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int8</name></type> <name><name>yytable</name><index>[]</index></name> <init>=
<expr><block>{
       <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">3</literal></expr>,     <expr><literal type="number">4</literal></expr>,     <expr><literal type="number">5</literal></expr>,     <expr><literal type="number">6</literal></expr>,     <expr><literal type="number">7</literal></expr>,     <expr><literal type="number">8</literal></expr>,     <expr><literal type="number">9</literal></expr>,    <expr><literal type="number">13</literal></expr>,
      <expr><literal type="number">14</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int8</name></type> <name><name>yycheck</name><index>[]</index></name> <init>=
<expr><block>{
       <expr><literal type="number">3</literal></expr>,     <expr><literal type="number">4</literal></expr>,     <expr><literal type="number">5</literal></expr>,     <expr><literal type="number">6</literal></expr>,     <expr><literal type="number">7</literal></expr>,     <expr><literal type="number">8</literal></expr>,     <expr><literal type="number">9</literal></expr>,    <expr><literal type="number">10</literal></expr>,    <expr><literal type="number">11</literal></expr>,     <expr><literal type="number">0</literal></expr>,
      <expr><literal type="number">11</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
     symbol of state STATE-NUM.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int8</name></type> <name><name>yystos</name><index>[]</index></name> <init>=
<expr><block>{
       <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">3</literal></expr>,     <expr><literal type="number">4</literal></expr>,     <expr><literal type="number">5</literal></expr>,     <expr><literal type="number">6</literal></expr>,     <expr><literal type="number">7</literal></expr>,     <expr><literal type="number">8</literal></expr>,     <expr><literal type="number">9</literal></expr>,    <expr><literal type="number">10</literal></expr>,    <expr><literal type="number">11</literal></expr>,
      <expr><literal type="number">14</literal></expr>,    <expr><literal type="number">15</literal></expr>,    <expr><literal type="number">16</literal></expr>,     <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">16</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int8</name></type> <name><name>yyr1</name><index>[]</index></name> <init>=
<expr><block>{
       <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">13</literal></expr>,    <expr><literal type="number">14</literal></expr>,    <expr><literal type="number">15</literal></expr>,    <expr><literal type="number">15</literal></expr>,    <expr><literal type="number">16</literal></expr>,    <expr><literal type="number">16</literal></expr>,    <expr><literal type="number">16</literal></expr>,    <expr><literal type="number">16</literal></expr>,    <expr><literal type="number">16</literal></expr>,
      <expr><literal type="number">16</literal></expr>,    <expr><literal type="number">16</literal></expr>,    <expr><literal type="number">16</literal></expr>,    <expr><literal type="number">16</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>yytype_int8</name></type> <name><name>yyr2</name><index>[]</index></name> <init>=
<expr><block>{
       <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">2</literal></expr>,     <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">1</literal></expr>,
       <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">1</literal></expr>,     <expr><literal type="number">1</literal></expr>
}</block></expr></init></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyerrok</name></cpp:macro>         <cpp:value>(yyerrstatus = 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyclearin</name></cpp:macro>       <cpp:value>(yychar = YYEMPTY)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYEMPTY</name></cpp:macro>         <cpp:value>(-2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYEOF</name></cpp:macro>           <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYACCEPT</name></cpp:macro>        <cpp:value>goto yyacceptlab</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYABORT</name></cpp:macro>         <cpp:value>goto yyabortlab</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYERROR</name></cpp:macro>         <cpp:value>goto yyerrorlab</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYRECOVERING</name><parameter_list>()</parameter_list></cpp:macro>  <cpp:value>(!!yyerrstatus)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYBACKUP</name><parameter_list>(<parameter><type><name>Token</name></type></parameter>, <parameter><type><name>Value</name></type></parameter>)</parameter_list></cpp:macro>                                    \
  <cpp:value>do                                                              \
    if (yychar == YYEMPTY)                                        \
      {                                                           \
        yychar = (Token);                                         \
        yylval = (Value);                                         \
        YYPOPSTACK (yylen);                                       \
        yystate = *yyssp;                                         \
        goto yybackup;                                            \
      }                                                           \
    else                                                          \
      {                                                           \
        yyerror (result, YY_("syntax error: cannot back up")); \
        YYERROR;                                                  \
      }                                                           \
  while (0)</cpp:value></cpp:define>

<comment type="block">/* Error token number */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYTERROR</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYERRCODE</name></cpp:macro>       <cpp:value>256</cpp:value></cpp:define>


<comment type="block">/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
   If N is 0, then set CURRENT to the empty location which ends
   the previous symbol: RHS[0] (always defined).  */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYLLOC_DEFAULT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYLLOC_DEFAULT</name><parameter_list>(<parameter><type><name>Current</name></type></parameter>, <parameter><type><name>Rhs</name></type></parameter>, <parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>                                \
    <cpp:value>do                                                                  \
      if (N)                                                            \
        {                                                               \
          (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;        \
          (Current).first_column = YYRHSLOC (Rhs, 1).first_column;      \
          (Current).last_line    = YYRHSLOC (Rhs, N).last_line;         \
          (Current).last_column  = YYRHSLOC (Rhs, N).last_column;       \
        }                                                               \
      else                                                              \
        {                                                               \
          (Current).first_line   = (Current).last_line   =              \
            YYRHSLOC (Rhs, 0).last_line;                                \
          (Current).first_column = (Current).last_column =              \
            YYRHSLOC (Rhs, 0).last_column;                              \
        }                                                               \
    while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYRHSLOC</name><parameter_list>(<parameter><type><name>Rhs</name></type></parameter>, <parameter><type><name>K</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((Rhs)[K])</cpp:value></cpp:define>


<comment type="block">/* Enable debugging if requested.  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYDEBUG</name></expr></cpp:if>

<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>YYFPRINTF</name></cpp:ifndef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include> <comment type="block">/* INFRINGES ON USER NAME SPACE */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YYFPRINTF</name></cpp:macro> <cpp:value>fprintf</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYDPRINTF</name><parameter_list>(<parameter><type><name>Args</name></type></parameter>)</parameter_list></cpp:macro>                        \
<cpp:value>do {                                            \
  if (yydebug)                                  \
    YYFPRINTF Args;                             \
} while (0)</cpp:value></cpp:define>


<comment type="block">/* YY_LOCATION_PRINT -- Print the location on the stream.
   This macro was not mandated originally: define only if we know
   we won't break user code: when these are the locations we know.  */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_LOCATION_PRINT</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>YYLTYPE_IS_TRIVIAL</name> <operator>&amp;&amp;</operator> <name>YYLTYPE_IS_TRIVIAL</name></expr></cpp:if>

<comment type="block">/* Print *YYLOCP on YYO.  Private, do not rely on its existence. */</comment>

<function><type><name>YY_ATTRIBUTE_UNUSED</name>
<specifier>static</specifier> <name>int</name></type>
<name>yy_location_print_</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>yyo</name></decl></parameter>, <parameter><decl><type><name>YYLTYPE</name> <specifier>const</specifier> <modifier>*</modifier> <specifier>const</specifier></type> <name>yylocp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>end_col</name> <init>= <expr><ternary><condition><expr><literal type="number">0</literal> <operator>!=</operator> <name><name>yylocp</name><operator>-&gt;</operator><name>last_column</name></name></expr> ?</condition><then> <expr><name><name>yylocp</name><operator>-&gt;</operator><name>last_column</name></name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name><name>yylocp</name><operator>-&gt;</operator><name>first_line</name></name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>res</name> <operator>+=</operator> <call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>yyo</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>yylocp</name><operator>-&gt;</operator><name>first_line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name><name>yylocp</name><operator>-&gt;</operator><name>first_column</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>+=</operator> <call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>yyo</name></expr></argument>, <argument><expr><literal type="string">".%d"</literal></expr></argument>, <argument><expr><name><name>yylocp</name><operator>-&gt;</operator><name>first_column</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name><name>yylocp</name><operator>-&gt;</operator><name>last_line</name></name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>yylocp</name><operator>-&gt;</operator><name>first_line</name></name> <operator>&lt;</operator> <name><name>yylocp</name><operator>-&gt;</operator><name>last_line</name></name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>res</name> <operator>+=</operator> <call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>yyo</name></expr></argument>, <argument><expr><literal type="string">"-%d"</literal></expr></argument>, <argument><expr><name><name>yylocp</name><operator>-&gt;</operator><name>last_line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>end_col</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>res</name> <operator>+=</operator> <call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>yyo</name></expr></argument>, <argument><expr><literal type="string">".%d"</literal></expr></argument>, <argument><expr><name>end_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>end_col</name> <operator>&amp;&amp;</operator> <name><name>yylocp</name><operator>-&gt;</operator><name>first_column</name></name> <operator>&lt;</operator> <name>end_col</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>+=</operator> <call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>yyo</name></expr></argument>, <argument><expr><literal type="string">"-%d"</literal></expr></argument>, <argument><expr><name>end_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <return>return <expr><name>res</name></expr>;</return>
 </block_content>}</block></function>

<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_LOCATION_PRINT</name><parameter_list>(<parameter><type><name>File</name></type></parameter>, <parameter><type><name>Loc</name></type></parameter>)</parameter_list></cpp:macro>          \
  <cpp:value>yy_location_print_ (File, &amp;(Loc))</cpp:value></cpp:define>

<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_LOCATION_PRINT</name><parameter_list>(<parameter><type><name>File</name></type></parameter>, <parameter><type><name>Loc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_SYMBOL_PRINT</name><parameter_list>(<parameter><type><name>Title</name></type></parameter>, <parameter><type><name>Type</name></type></parameter>, <parameter><type><name>Value</name></type></parameter>, <parameter><type><name>Location</name></type></parameter>)</parameter_list></cpp:macro>                    \
<cpp:value>do {                                                                      \
  if (yydebug)                                                            \
    {                                                                     \
      YYFPRINTF (stderr, "%s ", Title);                                   \
      yy_symbol_print (stderr,                                            \
                  Type, Value, Location, result); \
      YYFPRINTF (stderr, "\n");                                           \
    }                                                                     \
} while (0)</cpp:value></cpp:define>


<comment type="block">/*-----------------------------------.
| Print this symbol's value on YYO.  |
`-----------------------------------*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>yy_symbol_value_print</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>yyo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yytype</name></decl></parameter>, <parameter><decl><type><name>YYSTYPE</name> <specifier>const</specifier> <modifier>*</modifier> <specifier>const</specifier></type> <name>yyvaluep</name></decl></parameter>, <parameter><decl><type><name>YYLTYPE</name> <specifier>const</specifier> <modifier>*</modifier> <specifier>const</specifier></type> <name>yylocationp</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>yyoutput</name> <init>= <expr><name>yyo</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>YYUSE</name> <argument_list>(<argument><expr><name>yyoutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>YYUSE</name> <argument_list>(<argument><expr><name>yylocationp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>YYUSE</name> <argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>yyvaluep</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>YYPRINT</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>yytype</name> <operator>&lt;</operator> <name>YYNTOKENS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>YYPRINT</name> <argument_list>(<argument><expr><name>yyo</name></expr></argument>, <argument><expr><name><name>yytoknum</name><index>[<expr><name>yytype</name></expr>]</index></name></expr></argument>, <argument><expr><operator>*</operator><name>yyvaluep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN</name></type>
  <name>YYUSE</name> <argument_list>(<argument><expr><name>yytype</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><name>YY_IGNORE_MAYBE_UNINITIALIZED_END</name></expr></expr_stmt>
</block_content>}</block></function>


<comment type="block">/*---------------------------.
| Print this symbol on YYO.  |
`---------------------------*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>yy_symbol_print</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>yyo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yytype</name></decl></parameter>, <parameter><decl><type><name>YYSTYPE</name> <specifier>const</specifier> <modifier>*</modifier> <specifier>const</specifier></type> <name>yyvaluep</name></decl></parameter>, <parameter><decl><type><name>YYLTYPE</name> <specifier>const</specifier> <modifier>*</modifier> <specifier>const</specifier></type> <name>yylocationp</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>yyo</name></expr></argument>, <argument><expr><literal type="string">"%s %s ("</literal></expr></argument>,
             <argument><expr><ternary><condition><expr><name>yytype</name> <operator>&lt;</operator> <name>YYNTOKENS</name></expr> ?</condition><then> <expr><literal type="string">"token"</literal></expr> </then><else>: <expr><literal type="string">"nterm"</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>yytname</name><index>[<expr><name>yytype</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>YY_LOCATION_PRINT</name> <argument_list>(<argument><expr><name>yyo</name></expr></argument>, <argument><expr><operator>*</operator><name>yylocationp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>yyo</name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>yy_symbol_value_print</name> <argument_list>(<argument><expr><name>yyo</name></expr></argument>, <argument><expr><name>yytype</name></expr></argument>, <argument><expr><name>yyvaluep</name></expr></argument>, <argument><expr><name>yylocationp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>yyo</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>yy_stack_print</name> <parameter_list>(<parameter><decl><type><name>yy_state_t</name> <modifier>*</modifier></type><name>yybottom</name></decl></parameter>, <parameter><decl><type><name>yy_state_t</name> <modifier>*</modifier></type><name>yytop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Stack now"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>yybottom</name> <operator>&lt;=</operator> <name>yytop</name></expr>;</condition> <incr><expr><name>yybottom</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>yybot</name> <init>= <expr><operator>*</operator><name>yybottom</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name>yybot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  <expr_stmt><expr><call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_STACK_PRINT</name><parameter_list>(<parameter><type><name>Bottom</name></type></parameter>, <parameter><type><name>Top</name></type></parameter>)</parameter_list></cpp:macro>                            \
<cpp:value>do {                                                            \
  if (yydebug)                                                  \
    yy_stack_print ((Bottom), (Top));                           \
} while (0)</cpp:value></cpp:define>


<comment type="block">/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>yy_reduce_print</name> <parameter_list>(<parameter><decl><type><name>yy_state_t</name> <modifier>*</modifier></type><name>yyssp</name></decl></parameter>, <parameter><decl><type><name>YYSTYPE</name> <modifier>*</modifier></type><name>yyvsp</name></decl></parameter>, <parameter><decl><type><name>YYLTYPE</name> <modifier>*</modifier></type><name>yylsp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yyrule</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>yylno</name> <init>= <expr><name><name>yyrline</name><index>[<expr><name>yyrule</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>yynrhs</name> <init>= <expr><name><name>yyr2</name><index>[<expr><name>yyrule</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>yyi</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Reducing stack by rule %d (line %d):\n"</literal></expr></argument>,
             <argument><expr><name>yyrule</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>yylno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* The symbols being reduced.  */</comment>
  <for>for <control>(<init><expr><name>yyi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>yyi</name> <operator>&lt;</operator> <name>yynrhs</name></expr>;</condition> <incr><expr><name>yyi</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"   $%d = "</literal></expr></argument>, <argument><expr><name>yyi</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>yy_symbol_print</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>,
                       <argument><expr><name><name>yystos</name><index>[<expr><name><name>yyssp</name><index>[<expr><name>yyi</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>yynrhs</name></expr>]</index></name></expr>]</index></name></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name><name>yyvsp</name><index>[<expr><operator>(</operator><name>yyi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>yynrhs</name><operator>)</operator></expr>]</index></name></expr></argument>
                       , <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>yylsp</name><index>[<expr><operator>(</operator><name>yyi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>yynrhs</name><operator>)</operator></expr>]</index></name><operator>)</operator></expr></argument>                       , <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>YYFPRINTF</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_REDUCE_PRINT</name><parameter_list>(<parameter><type><name>Rule</name></type></parameter>)</parameter_list></cpp:macro>          \
<cpp:value>do {                                    \
  if (yydebug)                          \
    yy_reduce_print (yyssp, yyvsp, yylsp, Rule, result); \
} while (0)</cpp:value></cpp:define>

<comment type="block">/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>yydebug</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !YYDEBUG */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYDPRINTF</name><parameter_list>(<parameter><type><name>Args</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_SYMBOL_PRINT</name><parameter_list>(<parameter><type><name>Title</name></type></parameter>, <parameter><type><name>Type</name></type></parameter>, <parameter><type><name>Value</name></type></parameter>, <parameter><type><name>Location</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_STACK_PRINT</name><parameter_list>(<parameter><type><name>Bottom</name></type></parameter>, <parameter><type><name>Top</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YY_REDUCE_PRINT</name><parameter_list>(<parameter><type><name>Rule</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !YYDEBUG */</comment>


<comment type="block">/* YYINITDEPTH -- initial size of the parser's stacks.  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYINITDEPTH</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYINITDEPTH</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM &lt; YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYMAXDEPTH</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYMAXDEPTH</name></cpp:macro> <cpp:value>10000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYERROR_VERBOSE</name></expr></cpp:if>

<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>yystrlen</name></cpp:ifndef>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__GLIBC__</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>_STRING_H</name></expr></cpp:if>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>yystrlen</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(YY_CAST (YYPTRDIFF_T, strlen (S)))</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Return the length of YYSTR.  */</comment>
<function><type><specifier>static</specifier> <name>YYPTRDIFF_T</name></type>
<name>yystrlen</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>yystr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>YYPTRDIFF_T</name></type> <name>yylen</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>yylen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>yystr</name><index>[<expr><name>yylen</name></expr>]</index></name></expr>;</condition> <incr><expr><name>yylen</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <continue>continue;</continue></block_content></block></for>
  <return>return <expr><name>yylen</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>yystpcpy</name></cpp:ifndef>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__GLIBC__</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>_STRING_H</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>_GNU_SOURCE</name></expr></cpp:if>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>yystpcpy</name></cpp:macro> <cpp:value>stpcpy</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>yystpcpy</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>yydest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>yysrc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>yyd</name> <init>= <expr><name>yydest</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>yys</name> <init>= <expr><name>yysrc</name></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>yyd</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>yys</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
    <continue>continue;</continue></block_content></block></while>

  <return>return <expr><name>yyd</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>yytnamerr</name></cpp:ifndef>
<comment type="block">/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
   quotes and backslashes, so that it's suitable for yyerror.  The
   heuristic is that double-quoting is unnecessary unless the string
   contains an apostrophe, a comma, or backslash (other than
   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
   null, do not copy; instead, return the length of what the result
   would have been.  */</comment>
<function><type><specifier>static</specifier> <name>YYPTRDIFF_T</name></type>
<name>yytnamerr</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>yyres</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>yystr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>yystr</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>YYPTRDIFF_T</name></type> <name>yyn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>yyp</name> <init>= <expr><name>yystr</name></expr></init></decl>;</decl_stmt>

      <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control><block type="pseudo"><block_content>
        <switch>switch <condition>(<expr><operator>*</operator><operator>++</operator><name>yyp</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><literal type="char">'\''</literal></expr>:</case>
          <case>case <expr><literal type="char">','</literal></expr>:</case>
            <goto>goto <name>do_not_strip_quotes</name>;</goto>

          <case>case <expr><literal type="char">'\\'</literal></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>yyp</name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
              <goto>goto <name>do_not_strip_quotes</name>;</goto></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
              <goto>goto <name>append</name>;</goto></block_content></block></else></if_stmt>

          <label><name>append</name>:</label>
          <default>default:</default>
            <if_stmt><if>if <condition>(<expr><name>yyres</name></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><name><name>yyres</name><index>[<expr><name>yyn</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>yyp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>yyn</name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>

          <case>case <expr><literal type="char">'"'</literal></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>yyres</name></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><name><name>yyres</name><index>[<expr><name>yyn</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>yyn</name></expr>;</return>
          </block_content>}</block></switch></block_content></block></for>
    <label><name>do_not_strip_quotes</name>:</label> <empty_stmt>;</empty_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>yyres</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>yystpcpy</name> <argument_list>(<argument><expr><name>yyres</name></expr></argument>, <argument><expr><name>yystr</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>yyres</name></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>yystrlen</name> <argument_list>(<argument><expr><name>yystr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
   about the unexpected token YYTOKEN for the state stack whose top is
   YYSSP.

   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
   not large enough to hold the message.  In that case, also set
   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
   required number of bytes is too large to store.  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>yysyntax_error</name> <parameter_list>(<parameter><decl><type><name>YYPTRDIFF_T</name> <modifier>*</modifier></type><name>yymsg_alloc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>yymsg</name></decl></parameter>,
                <parameter><decl><type><name>yy_state_t</name> <modifier>*</modifier></type><name>yyssp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yytoken</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <enum>enum <block>{ <decl><name>YYERROR_VERBOSE_ARGS_MAXIMUM</name> <init>= <expr><literal type="number">5</literal></expr></init></decl> }</block>;</enum>
  <comment type="block">/* Internationalized format string. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>yyformat</name> <init>= <expr><name>YY_NULLPTR</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Arguments of yyformat: reported tokens (one for the "unexpected",
     one per "expected"). */</comment>
  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name><name>yyarg</name><index>[<expr><name>YYERROR_VERBOSE_ARGS_MAXIMUM</name></expr>]</index></name></decl>;</decl_stmt>
  <comment type="block">/* Actual size of YYARG. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>yycount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Cumulated lengths of YYARG.  */</comment>
  <decl_stmt><decl><type><name>YYPTRDIFF_T</name></type> <name>yysize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* There are many possibilities here to consider:
     - If this state is a consistent state with a default action, then
       the only way this function was invoked is if the default action
       is an error action.  In that case, don't check for expected
       tokens because there are none.
     - The only way there can be no lookahead present (in yychar) is if
       this state is a consistent state with a default action.  Thus,
       detecting the absence of a lookahead is sufficient to determine
       that there is no unexpected or expected token to report.  In that
       case, just report a simple "syntax error".
     - Don't assume there isn't a lookahead just because this state is a
       consistent state with a default action.  There might have been a
       previous inconsistent state, consistent state with a non-default
       action, or user semantic action that manipulated yychar.
     - Of course, the expected token list depends on states to have
       correct lookahead information, and it depends on the parser not
       to perform extra reductions after fetching a lookahead from the
       scanner and before detecting a syntax error.  Thus, state merging
       (from LALR or IELR) and default reductions corrupt the expected
       token list.  However, the list is correct for canonical LR with
       one exception: it will still contain any token that will not be
       accepted due to an error action in a later state.
  */</comment>
  <if_stmt><if>if <condition>(<expr><name>yytoken</name> <operator>!=</operator> <name>YYEMPTY</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>yyn</name> <init>= <expr><name><name>yypact</name><index>[<expr><operator>*</operator><name>yyssp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>YYPTRDIFF_T</name></type> <name>yysize0</name> <init>= <expr><call><name>yytnamerr</name> <argument_list>(<argument><expr><name>YY_NULLPTR</name></expr></argument>, <argument><expr><name><name>yytname</name><index>[<expr><name>yytoken</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>yysize</name> <operator>=</operator> <name>yysize0</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>yyarg</name><index>[<expr><name>yycount</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>yytname</name><index>[<expr><name>yytoken</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>yypact_value_is_default</name> <argument_list>(<argument><expr><name>yyn</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Start YYX at -YYN if negative to avoid negative indexes in
             YYCHECK.  In other words, skip the first -YYN actions for
             this state because they are default actions.  */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>yyxbegin</name> <init>= <expr><ternary><condition><expr><name>yyn</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>yyn</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
          <comment type="block">/* Stay within bounds of both yycheck and yytname.  */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>yychecklim</name> <init>= <expr><name>YYLAST</name> <operator>-</operator> <name>yyn</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>yyxend</name> <init>= <expr><ternary><condition><expr><name>yychecklim</name> <operator>&lt;</operator> <name>YYNTOKENS</name></expr> ?</condition><then> <expr><name>yychecklim</name></expr> </then><else>: <expr><name>YYNTOKENS</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>yyx</name></decl>;</decl_stmt>

          <for>for <control>(<init><expr><name>yyx</name> <operator>=</operator> <name>yyxbegin</name></expr>;</init> <condition><expr><name>yyx</name> <operator>&lt;</operator> <name>yyxend</name></expr>;</condition> <incr><expr><operator>++</operator><name>yyx</name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>yycheck</name><index>[<expr><name>yyx</name> <operator>+</operator> <name>yyn</name></expr>]</index></name> <operator>==</operator> <name>yyx</name> <operator>&amp;&amp;</operator> <name>yyx</name> <operator>!=</operator> <name>YYTERROR</name>
                <operator>&amp;&amp;</operator> <operator>!</operator><call><name>yytable_value_is_error</name> <argument_list>(<argument><expr><name><name>yytable</name><index>[<expr><name>yyx</name> <operator>+</operator> <name>yyn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
              <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>yycount</name> <operator>==</operator> <name>YYERROR_VERBOSE_ARGS_MAXIMUM</name></expr>)</condition>
                  <block>{<block_content>
                    <expr_stmt><expr><name>yycount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>yysize</name> <operator>=</operator> <name>yysize0</name></expr>;</expr_stmt>
                    <break>break;</break>
                  </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>yyarg</name><index>[<expr><name>yycount</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>yytname</name><index>[<expr><name>yyx</name></expr>]</index></name></expr>;</expr_stmt>
                <block>{<block_content>
                  <decl_stmt><decl><type><name>YYPTRDIFF_T</name></type> <name>yysize1</name>
                    <init>= <expr><name>yysize</name> <operator>+</operator> <call><name>yytnamerr</name> <argument_list>(<argument><expr><name>YY_NULLPTR</name></expr></argument>, <argument><expr><name><name>yytname</name><index>[<expr><name>yyx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <if_stmt><if>if <condition>(<expr><name>yysize</name> <operator>&lt;=</operator> <name>yysize1</name> <operator>&amp;&amp;</operator> <name>yysize1</name> <operator>&lt;=</operator> <name>YYSTACK_ALLOC_MAXIMUM</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>yysize</name> <operator>=</operator> <name>yysize1</name></expr>;</expr_stmt></block_content></block></if>
                  <else>else<block type="pseudo"><block_content>
                    <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></else></if_stmt>
                </block_content>}</block>
              </block_content>}</block></if></if_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name>yycount</name></expr>)</condition>
    <block>{<block_content>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYCASE_</name><parameter_list>(<parameter><type><name>N</name></type></parameter>, <parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro>                      \
      <cpp:value>case N:                               \
        yyformat = S;                       \
      break</cpp:value></cpp:define>
    <default>default:</default> <comment type="block">/* Avoid compiler warnings. */</comment>
      <expr_stmt><expr><call><name>YYCASE_</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>YY_</name><argument_list>(<argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>YYCASE_</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>YY_</name><argument_list>(<argument><expr><literal type="string">"syntax error, unexpected %s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>YYCASE_</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>YY_</name><argument_list>(<argument><expr><literal type="string">"syntax error, unexpected %s, expecting %s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>YYCASE_</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>YY_</name><argument_list>(<argument><expr><literal type="string">"syntax error, unexpected %s, expecting %s or %s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>YYCASE_</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>YY_</name><argument_list>(<argument><expr><literal type="string">"syntax error, unexpected %s, expecting %s or %s or %s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>YYCASE_</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><call><name>YY_</name><argument_list>(<argument><expr><literal type="string">"syntax error, unexpected %s, expecting %s or %s or %s or %s"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>YYCASE_</name></cpp:undef>
    </block_content>}</block></switch>

  <block>{<block_content>
    <comment type="block">/* Don't count the "%s"s in the final size, but reserve room for
       the terminator.  */</comment>
    <decl_stmt><decl><type><name>YYPTRDIFF_T</name></type> <name>yysize1</name> <init>= <expr><name>yysize</name> <operator>+</operator> <operator>(</operator><call><name>yystrlen</name> <argument_list>(<argument><expr><name>yyformat</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <name>yycount</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>yysize</name> <operator>&lt;=</operator> <name>yysize1</name> <operator>&amp;&amp;</operator> <name>yysize1</name> <operator>&lt;=</operator> <name>YYSTACK_ALLOC_MAXIMUM</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>yysize</name> <operator>=</operator> <name>yysize1</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>yymsg_alloc</name> <operator>&lt;</operator> <name>yysize</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>yymsg_alloc</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>yysize</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name>yysize</name> <operator>&lt;=</operator> <operator>*</operator><name>yymsg_alloc</name>
             <operator>&amp;&amp;</operator> <operator>*</operator><name>yymsg_alloc</name> <operator>&lt;=</operator> <name>YYSTACK_ALLOC_MAXIMUM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>yymsg_alloc</name> <operator>=</operator> <name>YYSTACK_ALLOC_MAXIMUM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Avoid sprintf, as that infringes on the user's name space.
     Don't have undefined behavior even if the translation
     produced a string with the wrong number of "%s"s.  */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>yyp</name> <init>= <expr><operator>*</operator><name>yymsg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>yyi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>yyp</name> <operator>=</operator> <operator>*</operator><name>yyformat</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>yyp</name> <operator>==</operator> <literal type="char">'%'</literal> <operator>&amp;&amp;</operator> <name><name>yyformat</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <name>yyi</name> <operator>&lt;</operator> <name>yycount</name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>yyp</name> <operator>+=</operator> <call><name>yytnamerr</name> <argument_list>(<argument><expr><name>yyp</name></expr></argument>, <argument><expr><name><name>yyarg</name><index>[<expr><name>yyi</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>yyformat</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
          <expr_stmt><expr><operator>++</operator><name>yyp</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>++</operator><name>yyformat</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt></block_content></block></while>
  </block_content>}</block>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* YYERROR_VERBOSE */</comment>

<comment type="block">/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>yydestruct</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>yymsg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>yytype</name></decl></parameter>, <parameter><decl><type><name>YYSTYPE</name> <modifier>*</modifier></type><name>yyvaluep</name></decl></parameter>, <parameter><decl><type><name>YYLTYPE</name> <modifier>*</modifier></type><name>yylocationp</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>YYUSE</name> <argument_list>(<argument><expr><name>yyvaluep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>YYUSE</name> <argument_list>(<argument><expr><name>yylocationp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>YYUSE</name> <argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>yymsg</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>yymsg</name> <operator>=</operator> <literal type="string">"Deleting"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>YY_SYMBOL_PRINT</name> <argument_list>(<argument><expr><name>yymsg</name></expr></argument>, <argument><expr><name>yytype</name></expr></argument>, <argument><expr><name>yyvaluep</name></expr></argument>, <argument><expr><name>yylocationp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN</name></type>
  <name>YYUSE</name> <argument_list>(<argument><expr><name>yytype</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><name>YY_IGNORE_MAYBE_UNINITIALIZED_END</name></expr></expr_stmt>
</block_content>}</block></function>




<comment type="block">/* The lookahead symbol.  */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>yychar</name></decl>;</decl_stmt>

<comment type="block">/* The semantic value of the lookahead symbol.  */</comment>
<decl_stmt><decl><type><name>YYSTYPE</name></type> <name>yylval</name></decl>;</decl_stmt>
<comment type="block">/* Location data for the lookahead symbol.  */</comment>
<decl_stmt><decl><type><name>YYLTYPE</name></type> <name>yylloc</name>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>YYLTYPE_IS_TRIVIAL</name> <operator>&amp;&amp;</operator> <name>YYLTYPE_IS_TRIVIAL</name></expr></cpp:if>
  <init>= <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
;</decl_stmt>
<comment type="block">/* Number of syntax errors so far.  */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>yynerrs</name></decl>;</decl_stmt>


<comment type="block">/*----------.
| yyparse.  |
`----------*/</comment>

<function><type><name>int</name></type>
<name>yyparse</name> <parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>yy_state_fast_t</name></type> <name>yystate</name></decl>;</decl_stmt>
    <comment type="block">/* Number of tokens to shift before error messages enabled.  */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>yyerrstatus</name></decl>;</decl_stmt>

    <comment type="block">/* The stacks and their tools:
       'yyss': related to states.
       'yyvs': related to semantic values.
       'yyls': related to locations.

       Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */</comment>

    <comment type="block">/* The state stack.  */</comment>
    <decl_stmt><decl><type><name>yy_state_t</name></type> <name><name>yyssa</name><index>[<expr><name>YYINITDEPTH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>yy_state_t</name> <modifier>*</modifier></type><name>yyss</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>yy_state_t</name> <modifier>*</modifier></type><name>yyssp</name></decl>;</decl_stmt>

    <comment type="block">/* The semantic value stack.  */</comment>
    <decl_stmt><decl><type><name>YYSTYPE</name></type> <name><name>yyvsa</name><index>[<expr><name>YYINITDEPTH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>YYSTYPE</name> <modifier>*</modifier></type><name>yyvs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>YYSTYPE</name> <modifier>*</modifier></type><name>yyvsp</name></decl>;</decl_stmt>

    <comment type="block">/* The location stack.  */</comment>
    <decl_stmt><decl><type><name>YYLTYPE</name></type> <name><name>yylsa</name><index>[<expr><name>YYINITDEPTH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>YYLTYPE</name> <modifier>*</modifier></type><name>yyls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>YYLTYPE</name> <modifier>*</modifier></type><name>yylsp</name></decl>;</decl_stmt>

    <comment type="block">/* The locations where the error started and ended.  */</comment>
    <decl_stmt><decl><type><name>YYLTYPE</name></type> <name><name>yyerror_range</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>YYPTRDIFF_T</name></type> <name>yystacksize</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>yyn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>yyresult</name></decl>;</decl_stmt>
  <comment type="block">/* Lookahead token as an internal (translated) token number.  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>yytoken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <comment type="block">/* The variables used to return semantic value and location from the
     action routines.  */</comment>
  <decl_stmt><decl><type><name>YYSTYPE</name></type> <name>yyval</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>YYLTYPE</name></type> <name>yyloc</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYERROR_VERBOSE</name></expr></cpp:if>
  <comment type="block">/* Buffer for error messages, and its allocated size.  */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>yymsgbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>yymsg</name> <init>= <expr><name>yymsgbuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>YYPTRDIFF_T</name></type> <name>yymsg_alloc</name> <init>= <expr><sizeof>sizeof <name>yymsgbuf</name></sizeof></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYPOPSTACK</name><parameter_list>(<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>(yyvsp -= (N), yyssp -= (N), yylsp -= (N))</cpp:value></cpp:define>

  <comment type="block">/* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>yylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>yyssp</name> <operator>=</operator> <name>yyss</name> <operator>=</operator> <name>yyssa</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yyvsp</name> <operator>=</operator> <name>yyvs</name> <operator>=</operator> <name>yyvsa</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yylsp</name> <operator>=</operator> <name>yyls</name> <operator>=</operator> <name>yylsa</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yystacksize</name> <operator>=</operator> <name>YYINITDEPTH</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>YYDPRINTF</name> <argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"Starting parse\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>yystate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>yyerrstatus</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>yynerrs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>yychar</name> <operator>=</operator> <name>YYEMPTY</name></expr>;</expr_stmt> <comment type="block">/* Cause a token to be read.  */</comment>
  <expr_stmt><expr><name><name>yylsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>yylloc</name></expr>;</expr_stmt>
  <goto>goto <name>yysetstate</name>;</goto>


<comment type="block">/*------------------------------------------------------------.
| yynewstate -- push a new state, which is found in yystate.  |
`------------------------------------------------------------*/</comment>
<label><name>yynewstate</name>:</label>
  <comment type="block">/* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */</comment>
  <expr_stmt><expr><name>yyssp</name><operator>++</operator></expr>;</expr_stmt>


<comment type="block">/*--------------------------------------------------------------------.
| yysetstate -- set current state (the top of the stack) to yystate.  |
`--------------------------------------------------------------------*/</comment>
<label><name>yysetstate</name>:</label>
  <expr_stmt><expr><call><name>YYDPRINTF</name> <argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"Entering state %d\n"</literal><operator>,</operator> <name>yystate</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>YY_ASSERT</name> <argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>yystate</name> <operator>&amp;&amp;</operator> <name>yystate</name> <operator>&lt;</operator> <name>YYNSTATES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>YY_IGNORE_USELESS_CAST_BEGIN</name>
  <modifier>*</modifier></type><name>yyssp</name> <init>= <expr><call><name>YY_CAST</name> <argument_list>(<argument><expr><name>yy_state_t</name></expr></argument>, <argument><expr><name>yystate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <macro><name>YY_IGNORE_USELESS_CAST_END</name></macro>

  <if_stmt><if>if <condition>(<expr><name>yyss</name> <operator>+</operator> <name>yystacksize</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>yyssp</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>yyoverflow</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>defined</name> <name>YYSTACK_RELOCATE</name></expr></cpp:if>
    <goto>goto <name>yyexhaustedlab</name>;</goto></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <block>{<block_content>
      <comment type="block">/* Get the current used size of the three stacks, in elements.  */</comment>
      <decl_stmt><decl><type><name>YYPTRDIFF_T</name></type> <name>yysize</name> <init>= <expr><name>yyssp</name> <operator>-</operator> <name>yyss</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>yyoverflow</name></expr></cpp:if>
      <block>{<block_content>
        <comment type="block">/* Give user a chance to reallocate the stack.  Use copies of
           these so that the &amp;'s don't force the real ones into
           memory.  */</comment>
        <decl_stmt><decl><type><name>yy_state_t</name> <modifier>*</modifier></type><name>yyss1</name> <init>= <expr><name>yyss</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>YYSTYPE</name> <modifier>*</modifier></type><name>yyvs1</name> <init>= <expr><name>yyvs</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>YYLTYPE</name> <modifier>*</modifier></type><name>yyls1</name> <init>= <expr><name>yyls</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */</comment>
        <expr_stmt><expr><call><name>yyoverflow</name> <argument_list>(<argument><expr><call><name>YY_</name><argument_list>(<argument><expr><literal type="string">"memory exhausted"</literal></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>yyss1</name></expr></argument>, <argument><expr><name>yysize</name> <operator>*</operator> <call><name>YYSIZEOF</name> <argument_list>(<argument><expr><operator>*</operator><name>yyssp</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>yyvs1</name></expr></argument>, <argument><expr><name>yysize</name> <operator>*</operator> <call><name>YYSIZEOF</name> <argument_list>(<argument><expr><operator>*</operator><name>yyvsp</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>yyls1</name></expr></argument>, <argument><expr><name>yysize</name> <operator>*</operator> <call><name>YYSIZEOF</name> <argument_list>(<argument><expr><operator>*</operator><name>yylsp</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>yystacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>yyss</name> <operator>=</operator> <name>yyss1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>yyvs</name> <operator>=</operator> <name>yyvs1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>yyls</name> <operator>=</operator> <name>yyls1</name></expr>;</expr_stmt>
      </block_content>}</block>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* defined YYSTACK_RELOCATE */</comment>
      <comment type="block">/* Extend the stack our own way.  */</comment>
      <if_stmt><if>if <condition>(<expr><name>YYMAXDEPTH</name> <operator>&lt;=</operator> <name>yystacksize</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>yyexhaustedlab</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>yystacksize</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>YYMAXDEPTH</name> <operator>&lt;</operator> <name>yystacksize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>yystacksize</name> <operator>=</operator> <name>YYMAXDEPTH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <block>{<block_content>
        <decl_stmt><decl><type><name>yy_state_t</name> <modifier>*</modifier></type><name>yyss1</name> <init>= <expr><name>yyss</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>union</name> <name>yyalloc</name></name> <modifier>*</modifier></type><name>yyptr</name> <init>=
          <expr><call><name>YY_CAST</name> <argument_list>(<argument><expr>union <name>yyalloc</name> <operator>*</operator></expr></argument>,
                   <argument><expr><call><name>YYSTACK_ALLOC</name> <argument_list>(<argument><expr><call><name>YY_CAST</name> <argument_list>(<argument><expr><name>YYSIZE_T</name></expr></argument>, <argument><expr><call><name>YYSTACK_BYTES</name> <argument_list>(<argument><expr><name>yystacksize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator> <name>yyptr</name></expr>)</condition><block type="pseudo"><block_content>
          <goto>goto <name>yyexhaustedlab</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>YYSTACK_RELOCATE</name> <argument_list>(<argument><expr><name>yyss_alloc</name></expr></argument>, <argument><expr><name>yyss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>YYSTACK_RELOCATE</name> <argument_list>(<argument><expr><name>yyvs_alloc</name></expr></argument>, <argument><expr><name>yyvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>YYSTACK_RELOCATE</name> <argument_list>(<argument><expr><name>yyls_alloc</name></expr></argument>, <argument><expr><name>yyls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>YYSTACK_RELOCATE</name></cpp:undef>
        <if_stmt><if>if <condition>(<expr><name>yyss1</name> <operator>!=</operator> <name>yyssa</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>YYSTACK_FREE</name> <argument_list>(<argument><expr><name>yyss1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name>yyssp</name> <operator>=</operator> <name>yyss</name> <operator>+</operator> <name>yysize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>yyvsp</name> <operator>=</operator> <name>yyvs</name> <operator>+</operator> <name>yysize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>yylsp</name> <operator>=</operator> <name>yyls</name> <operator>+</operator> <name>yysize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>YY_IGNORE_USELESS_CAST_BEGIN</name></type>
      <name>YYDPRINTF</name> <argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"Stack size increased to %ld\n"</literal><operator>,</operator>
                  <call><name>YY_CAST</name> <argument_list>(<argument><expr><name>long</name></expr></argument>, <argument><expr><name>yystacksize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
      <macro><name>YY_IGNORE_USELESS_CAST_END</name></macro>

      <if_stmt><if>if <condition>(<expr><name>yyss</name> <operator>+</operator> <name>yystacksize</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>yyssp</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>YYABORT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined yyoverflow &amp;&amp; !defined YYSTACK_RELOCATE */</comment>

  <if_stmt><if>if <condition>(<expr><name>yystate</name> <operator>==</operator> <name>YYFINAL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>YYACCEPT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <goto>goto <name>yybackup</name>;</goto>


<comment type="block">/*-----------.
| yybackup.  |
`-----------*/</comment>
<label><name>yybackup</name>:</label>
  <comment type="block">/* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */</comment>

  <comment type="block">/* First try to decide what to do without reference to lookahead token.  */</comment>
  <expr_stmt><expr><name>yyn</name> <operator>=</operator> <name><name>yypact</name><index>[<expr><name>yystate</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>yypact_value_is_default</name> <argument_list>(<argument><expr><name>yyn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>yydefault</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Not known =&gt; get a lookahead token if don't already have one.  */</comment>

  <comment type="block">/* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */</comment>
  <if_stmt><if>if <condition>(<expr><name>yychar</name> <operator>==</operator> <name>YYEMPTY</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>YYDPRINTF</name> <argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"Reading a token: "</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>yychar</name> <operator>=</operator> <call><name>yylex</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>yychar</name> <operator>&lt;=</operator> <name>YYEOF</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>yychar</name> <operator>=</operator> <name>yytoken</name> <operator>=</operator> <name>YYEOF</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>YYDPRINTF</name> <argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator> <literal type="string">"Now at end of input.\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
      <expr_stmt><expr><name>yytoken</name> <operator>=</operator> <call><name>YYTRANSLATE</name> <argument_list>(<argument><expr><name>yychar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>YY_SYMBOL_PRINT</name> <argument_list>(<argument><expr><literal type="string">"Next token is"</literal></expr></argument>, <argument><expr><name>yytoken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <comment type="block">/* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */</comment>
  <expr_stmt><expr><name>yyn</name> <operator>+=</operator> <name>yytoken</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>yyn</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>YYLAST</name> <operator>&lt;</operator> <name>yyn</name> <operator>||</operator> <name><name>yycheck</name><index>[<expr><name>yyn</name></expr>]</index></name> <operator>!=</operator> <name>yytoken</name></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>yydefault</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>yyn</name> <operator>=</operator> <name><name>yytable</name><index>[<expr><name>yyn</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>yyn</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>yytable_value_is_error</name> <argument_list>(<argument><expr><name>yyn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>yyerrlab</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>yyn</name> <operator>=</operator> <operator>-</operator><name>yyn</name></expr>;</expr_stmt>
      <goto>goto <name>yyreduce</name>;</goto>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Count tokens shifted since error; after three, turn off error
     status.  */</comment>
  <if_stmt><if>if <condition>(<expr><name>yyerrstatus</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>yyerrstatus</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Shift the lookahead token.  */</comment>
  <expr_stmt><expr><call><name>YY_SYMBOL_PRINT</name> <argument_list>(<argument><expr><literal type="string">"Shifting"</literal></expr></argument>, <argument><expr><name>yytoken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>yystate</name> <operator>=</operator> <name>yyn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN</name>
  <operator>*</operator><operator>++</operator><name>yyvsp</name> <operator>=</operator> <name>yylval</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>YY_IGNORE_MAYBE_UNINITIALIZED_END</name>
  <operator>*</operator><operator>++</operator><name>yylsp</name> <operator>=</operator> <name>yylloc</name></expr>;</expr_stmt>

  <comment type="block">/* Discard the shifted token.  */</comment>
  <expr_stmt><expr><name>yychar</name> <operator>=</operator> <name>YYEMPTY</name></expr>;</expr_stmt>
  <goto>goto <name>yynewstate</name>;</goto>


<comment type="block">/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/</comment>
<label><name>yydefault</name>:</label>
  <expr_stmt><expr><name>yyn</name> <operator>=</operator> <name><name>yydefact</name><index>[<expr><name>yystate</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>yyn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>yyerrlab</name>;</goto></block_content></block></if></if_stmt>
  <goto>goto <name>yyreduce</name>;</goto>


<comment type="block">/*-----------------------------.
| yyreduce -- do a reduction.  |
`-----------------------------*/</comment>
<label><name>yyreduce</name>:</label>
  <comment type="block">/* yyn is the number of a rule to reduce with.  */</comment>
  <expr_stmt><expr><name>yylen</name> <operator>=</operator> <name><name>yyr2</name><index>[<expr><name>yyn</name></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */</comment>
  <expr_stmt><expr><name>yyval</name> <operator>=</operator> <name><name>yyvsp</name><index>[<expr><literal type="number">1</literal><operator>-</operator><name>yylen</name></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Default location. */</comment>
  <expr_stmt><expr><call><name>YYLLOC_DEFAULT</name> <argument_list>(<argument><expr><name>yyloc</name></expr></argument>, <argument><expr><operator>(</operator><name>yylsp</name> <operator>-</operator> <name>yylen</name><operator>)</operator></expr></argument>, <argument><expr><name>yylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>yyerror_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>yyloc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>YY_REDUCE_PRINT</name> <argument_list>(<argument><expr><name>yyn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>yyn</name></expr>)</condition>
    <block>{<block_content>
  <case>case <expr><literal type="number">2</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>91</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                     <block>{<block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name>result</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>list</name><operator>)</operator></expr>;</expr_stmt> </block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1495</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>

  <case>case <expr><literal type="number">3</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>95</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                           <block>{<block_content> <expr_stmt><expr><operator>(</operator><name><name>yyval</name><operator>.</operator><name>list</name></name><operator>)</operator> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>node</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1501</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>

  <case>case <expr><literal type="number">4</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>96</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                                      <block>{<block_content> <expr_stmt><expr><operator>(</operator><name><name>yyval</name><operator>.</operator><name>list</name></name><operator>)</operator> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>list</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>node</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1507</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>

  <case>case <expr><literal type="number">5</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>100</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                                <block>{<block_content> <expr_stmt><expr><operator>(</operator><name><name>yyval</name><operator>.</operator><name>node</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>orafce_lexnode</name><operator>*</operator><operator>)</operator> <call><name>CREATE_NODE</name><argument_list>(<argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>val</name><operator>)</operator></expr></argument>, <argument><expr><name>IDENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  </block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1513</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>

  <case>case <expr><literal type="number">6</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>101</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                                <block>{<block_content> <expr_stmt><expr><operator>(</operator><name><name>yyval</name><operator>.</operator><name>node</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>orafce_lexnode</name><operator>*</operator><operator>)</operator> <call><name>CREATE_NODE</name><argument_list>(<argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>val</name><operator>)</operator></expr></argument>, <argument><expr><name>NCONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1519</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>

  <case>case <expr><literal type="number">7</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>102</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                                <block>{<block_content> <expr_stmt><expr><operator>(</operator><name><name>yyval</name><operator>.</operator><name>node</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>orafce_lexnode</name><operator>*</operator><operator>)</operator> <call><name>CREATE_NODE</name><argument_list>(<argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>val</name><operator>)</operator></expr></argument>, <argument><expr><name>SCONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1525</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>

  <case>case <expr><literal type="number">8</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>103</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                                <block>{<block_content> <expr_stmt><expr><operator>(</operator><name><name>yyval</name><operator>.</operator><name>node</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>orafce_lexnode</name><operator>*</operator><operator>)</operator> <call><name>CREATE_NODE</name><argument_list>(<argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>val</name><operator>)</operator></expr></argument>, <argument><expr><name>OP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    </block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1531</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>

  <case>case <expr><literal type="number">9</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>104</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                                        <block>{<block_content> <expr_stmt><expr><operator>(</operator><name><name>yyval</name><operator>.</operator><name>node</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>orafce_lexnode</name><operator>*</operator><operator>)</operator> <call><name>CREATE_NODE</name><argument_list>(<argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>val</name><operator>)</operator></expr></argument>, <argument><expr><name>PARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1537</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>

  <case>case <expr><literal type="number">10</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>105</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                                <block>{<block_content> <expr_stmt><expr><operator>(</operator><name><name>yyval</name><operator>.</operator><name>node</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>orafce_lexnode</name><operator>*</operator><operator>)</operator> <call><name>CREATE_NODE</name><argument_list>(<argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>val</name><operator>)</operator></expr></argument>, <argument><expr><name>COMMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    </block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1543</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>

  <case>case <expr><literal type="number">11</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>106</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                                <block>{<block_content> <expr_stmt><expr><operator>(</operator><name><name>yyval</name><operator>.</operator><name>node</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>orafce_lexnode</name><operator>*</operator><operator>)</operator> <call><name>CREATE_NODE</name><argument_list>(<argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>val</name><operator>)</operator></expr></argument>, <argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1549</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>

  <case>case <expr><literal type="number">12</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>107</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                                <block>{<block_content> <expr_stmt><expr><operator>(</operator><name><name>yyval</name><operator>.</operator><name>node</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>orafce_lexnode</name><operator>*</operator><operator>)</operator> <call><name>CREATE_NODE</name><argument_list>(<argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>val</name><operator>)</operator></expr></argument>, <argument><expr><name>KEYWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1555</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>

  <case>case <expr><literal type="number">13</literal></expr>:</case>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>108</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>
                                <block>{<block_content> <expr_stmt><expr><operator>(</operator><name><name>yyval</name><operator>.</operator><name>node</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>orafce_lexnode</name><operator>*</operator><operator>)</operator> <call><name>CREATE_NODE</name><argument_list>(<argument><expr><operator>(</operator><name><name>yyvsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>val</name><operator>)</operator></expr></argument>, <argument><expr><name>OTHERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  </block_content>}</block>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1561</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>
    <break>break;</break>


<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1565</cpp:number> <cpp:file>"sqlparse.c"</cpp:file></cpp:line>

      <default>default:</default> <break>break;</break>
    </block_content>}</block></switch>
  <comment type="block">/* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */</comment>
  <expr_stmt><expr><call><name>YY_SYMBOL_PRINT</name> <argument_list>(<argument><expr><literal type="string">"-&gt; $$ ="</literal></expr></argument>, <argument><expr><name><name>yyr1</name><index>[<expr><name>yyn</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yyloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>YYPOPSTACK</name> <argument_list>(<argument><expr><name>yylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>yylen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>YY_STACK_PRINT</name> <argument_list>(<argument><expr><name>yyss</name></expr></argument>, <argument><expr><name>yyssp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><operator>++</operator><name>yyvsp</name> <operator>=</operator> <name>yyval</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>++</operator><name>yylsp</name> <operator>=</operator> <name>yyloc</name></expr>;</expr_stmt>

  <comment type="block">/* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>yylhs</name> <init>= <expr><name><name>yyr1</name><index>[<expr><name>yyn</name></expr>]</index></name> <operator>-</operator> <name>YYNTOKENS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>yyi</name> <init>= <expr><name><name>yypgoto</name><index>[<expr><name>yylhs</name></expr>]</index></name> <operator>+</operator> <operator>*</operator><name>yyssp</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>yystate</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>yyi</name> <operator>&amp;&amp;</operator> <name>yyi</name> <operator>&lt;=</operator> <name>YYLAST</name> <operator>&amp;&amp;</operator> <name><name>yycheck</name><index>[<expr><name>yyi</name></expr>]</index></name> <operator>==</operator> <operator>*</operator><name>yyssp</name></expr>
               ?</condition><then> <expr><name><name>yytable</name><index>[<expr><name>yyi</name></expr>]</index></name></expr>
               </then><else>: <expr><name><name>yydefgoto</name><index>[<expr><name>yylhs</name></expr>]</index></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block>

  <goto>goto <name>yynewstate</name>;</goto>


<comment type="block">/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/</comment>
<label><name>yyerrlab</name>:</label>
  <comment type="block">/* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */</comment>
  <expr_stmt><expr><name>yytoken</name> <operator>=</operator> <ternary><condition><expr><name>yychar</name> <operator>==</operator> <name>YYEMPTY</name></expr> ?</condition><then> <expr><name>YYEMPTY</name></expr> </then><else>: <expr><call><name>YYTRANSLATE</name> <argument_list>(<argument><expr><name>yychar</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* If not already recovering from an error, report this error.  */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>yyerrstatus</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><operator>++</operator><name>yynerrs</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <name>YYERROR_VERBOSE</name></expr></cpp:if>
      <expr_stmt><expr><call><name>yyerror</name> <argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>YY_</name><argument_list>(<argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>YYSYNTAX_ERROR</name></cpp:macro> <cpp:value>yysyntax_error (&amp;yymsg_alloc, &amp;yymsg, \
                                        yyssp, yytoken)</cpp:value></cpp:define>
      <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>yymsgp</name> <init>= <expr><call><name>YY_</name><argument_list>(<argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>yysyntax_error_status</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>yysyntax_error_status</name> <operator>=</operator> <name>YYSYNTAX_ERROR</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>yysyntax_error_status</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>yymsgp</name> <operator>=</operator> <name>yymsg</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>yysyntax_error_status</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
          <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>yymsg</name> <operator>!=</operator> <name>yymsgbuf</name></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>YYSTACK_FREE</name> <argument_list>(<argument><expr><name>yymsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>yymsg</name> <operator>=</operator> <call><name>YY_CAST</name> <argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><call><name>YYSTACK_ALLOC</name> <argument_list>(<argument><expr><call><name>YY_CAST</name> <argument_list>(<argument><expr><name>YYSIZE_T</name></expr></argument>, <argument><expr><name>yymsg_alloc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>yymsg</name></expr>)</condition>
              <block>{<block_content>
                <expr_stmt><expr><name>yymsg</name> <operator>=</operator> <name>yymsgbuf</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>yymsg_alloc</name> <operator>=</operator> <sizeof>sizeof <name>yymsgbuf</name></sizeof></expr>;</expr_stmt>
                <expr_stmt><expr><name>yysyntax_error_status</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
              </block_content>}</block></if>
            <else>else
              <block>{<block_content>
                <expr_stmt><expr><name>yysyntax_error_status</name> <operator>=</operator> <name>YYSYNTAX_ERROR</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>yymsgp</name> <operator>=</operator> <name>yymsg</name></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>yyerror</name> <argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>yymsgp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>yysyntax_error_status</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
          <goto>goto <name>yyexhaustedlab</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>YYSYNTAX_ERROR</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>yyerror_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>yylloc</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>yyerrstatus</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* If just tried and failed to reuse lookahead token after an
         error, discard it.  */</comment>

      <if_stmt><if>if <condition>(<expr><name>yychar</name> <operator>&lt;=</operator> <name>YYEOF</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Return failure if at end of input.  */</comment>
          <if_stmt><if>if <condition>(<expr><name>yychar</name> <operator>==</operator> <name>YYEOF</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>YYABORT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
          <expr_stmt><expr><call><name>yydestruct</name> <argument_list>(<argument><expr><literal type="string">"Error: discarding"</literal></expr></argument>,
                      <argument><expr><name>yytoken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylloc</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>yychar</name> <operator>=</operator> <name>YYEMPTY</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Else will try to reuse lookahead token after shifting the error
     token.  */</comment>
  <goto>goto <name>yyerrlab1</name>;</goto>


<comment type="block">/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/</comment>
<label><name>yyerrorlab</name>:</label>
  <comment type="block">/* Pacify compilers when the user code never invokes YYERROR and the
     label yyerrorlab therefore never appears in user code.  */</comment>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>YYERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */</comment>
  <expr_stmt><expr><call><name>YYPOPSTACK</name> <argument_list>(<argument><expr><name>yylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>yylen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>YY_STACK_PRINT</name> <argument_list>(<argument><expr><name>yyss</name></expr></argument>, <argument><expr><name>yyssp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>yystate</name> <operator>=</operator> <operator>*</operator><name>yyssp</name></expr>;</expr_stmt>
  <goto>goto <name>yyerrlab1</name>;</goto>


<comment type="block">/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/</comment>
<label><name>yyerrlab1</name>:</label>
  <expr_stmt><expr><name>yyerrstatus</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>      <comment type="block">/* Each real token shifted decrements this.  */</comment>

  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
      <expr_stmt><expr><name>yyn</name> <operator>=</operator> <name><name>yypact</name><index>[<expr><name>yystate</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>yypact_value_is_default</name> <argument_list>(<argument><expr><name>yyn</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name>yyn</name> <operator>+=</operator> <name>YYTERROR</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>yyn</name> <operator>&amp;&amp;</operator> <name>yyn</name> <operator>&lt;=</operator> <name>YYLAST</name> <operator>&amp;&amp;</operator> <name><name>yycheck</name><index>[<expr><name>yyn</name></expr>]</index></name> <operator>==</operator> <name>YYTERROR</name></expr>)</condition>
            <block>{<block_content>
              <expr_stmt><expr><name>yyn</name> <operator>=</operator> <name><name>yytable</name><index>[<expr><name>yyn</name></expr>]</index></name></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>yyn</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Pop the current state because it cannot handle the error token.  */</comment>
      <if_stmt><if>if <condition>(<expr><name>yyssp</name> <operator>==</operator> <name>yyss</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>YYABORT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><name><name>yyerror_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>yylsp</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>yydestruct</name> <argument_list>(<argument><expr><literal type="string">"Error: popping"</literal></expr></argument>,
                  <argument><expr><name><name>yystos</name><index>[<expr><name>yystate</name></expr>]</index></name></expr></argument>, <argument><expr><name>yyvsp</name></expr></argument>, <argument><expr><name>yylsp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>YYPOPSTACK</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>yystate</name> <operator>=</operator> <operator>*</operator><name>yyssp</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>YY_STACK_PRINT</name> <argument_list>(<argument><expr><name>yyss</name></expr></argument>, <argument><expr><name>yyssp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

  <expr_stmt><expr><name>YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN</name>
  <operator>*</operator><operator>++</operator><name>yyvsp</name> <operator>=</operator> <name>yylval</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>YY_IGNORE_MAYBE_UNINITIALIZED_END</name></type>

  <name><name>yyerror_range</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><name>yylloc</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Using YYLLOC is tempting, but would change the location of
     the lookahead.  YYLOC is available though.  */</comment>
  <expr_stmt><expr><call><name>YYLLOC_DEFAULT</name> <argument_list>(<argument><expr><name>yyloc</name></expr></argument>, <argument><expr><name>yyerror_range</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>++</operator><name>yylsp</name> <operator>=</operator> <name>yyloc</name></expr>;</expr_stmt>

  <comment type="block">/* Shift the error token.  */</comment>
  <expr_stmt><expr><call><name>YY_SYMBOL_PRINT</name> <argument_list>(<argument><expr><literal type="string">"Shifting"</literal></expr></argument>, <argument><expr><name><name>yystos</name><index>[<expr><name>yyn</name></expr>]</index></name></expr></argument>, <argument><expr><name>yyvsp</name></expr></argument>, <argument><expr><name>yylsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>yystate</name> <operator>=</operator> <name>yyn</name></expr>;</expr_stmt>
  <goto>goto <name>yynewstate</name>;</goto>


<comment type="block">/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/</comment>
<label><name>yyacceptlab</name>:</label>
  <expr_stmt><expr><name>yyresult</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <goto>goto <name>yyreturn</name>;</goto>


<comment type="block">/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/</comment>
<label><name>yyabortlab</name>:</label>
  <expr_stmt><expr><name>yyresult</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <goto>goto <name>yyreturn</name>;</goto>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>yyoverflow</name> <operator>||</operator> <name>YYERROR_VERBOSE</name></expr></cpp:if>
<comment type="block">/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/</comment>
<label><name>yyexhaustedlab</name>:</label>
  <expr_stmt><expr><call><name>yyerror</name> <argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>YY_</name><argument_list>(<argument><expr><literal type="string">"memory exhausted"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>yyresult</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <comment type="block">/* Fall through.  */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*-----------------------------------------------------.
| yyreturn -- parsing is finished, return the result.  |
`-----------------------------------------------------*/</comment>
<label><name>yyreturn</name>:</label>
  <if_stmt><if>if <condition>(<expr><name>yychar</name> <operator>!=</operator> <name>YYEMPTY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */</comment>
      <expr_stmt><expr><name>yytoken</name> <operator>=</operator> <call><name>YYTRANSLATE</name> <argument_list>(<argument><expr><name>yychar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>yydestruct</name> <argument_list>(<argument><expr><literal type="string">"Cleanup: discarding lookahead"</literal></expr></argument>,
                  <argument><expr><name>yytoken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yylloc</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <comment type="block">/* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */</comment>
  <expr_stmt><expr><call><name>YYPOPSTACK</name> <argument_list>(<argument><expr><name>yylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>YY_STACK_PRINT</name> <argument_list>(<argument><expr><name>yyss</name></expr></argument>, <argument><expr><name>yyssp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>yyssp</name> <operator>!=</operator> <name>yyss</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>yydestruct</name> <argument_list>(<argument><expr><literal type="string">"Cleanup: popping"</literal></expr></argument>,
                  <argument><expr><name><name>yystos</name><index>[<expr><operator>*</operator><name>yyssp</name></expr>]</index></name></expr></argument>, <argument><expr><name>yyvsp</name></expr></argument>, <argument><expr><name>yylsp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>YYPOPSTACK</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>yyoverflow</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><name>yyss</name> <operator>!=</operator> <name>yyssa</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>YYSTACK_FREE</name> <argument_list>(<argument><expr><name>yyss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YYERROR_VERBOSE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>yymsg</name> <operator>!=</operator> <name>yymsgbuf</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>YYSTACK_FREE</name> <argument_list>(<argument><expr><name>yymsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>yyresult</name></expr>;</return>
</block_content>}</block></function>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>110</cpp:number> <cpp:file>"sqlparse.y"</cpp:file></cpp:line>


<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>YYLTYPE</name></cpp:undef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlscan.c"</cpp:file></cpp:include>
</unit>
