<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/gpcontrib/orafce/file.c"><comment type="block">/*
 * Attention - this functionality doesn't work when Orace is not linked with
 * correct runtime library. The combination "vcruntime140.dll" is working for
 * PostgreSQL 12 (vcruntime140d.dll doesn't work). Probably this runtime should
 * be same like Postgres server runtime (what is used can be detected by
 * dependency walker). Without correct linking the server crash when IO related
 * functionality is used.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_CRT_SECURE_NO_DEPRECATE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"orafce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtins.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ERRCODE_NO_DATA_FOUND</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_NO_DATA_FOUND</name></cpp:macro>				<cpp:value>MAKE_SQLSTATE('P','0', '0','0','2')</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_OPERATION</name></cpp:macro>		<cpp:value>"UTL_FILE_INVALID_OPERATION"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_ERROR</name></cpp:macro>				<cpp:value>"UTL_FILE_WRITE_ERROR"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_ERROR</name></cpp:macro>				<cpp:value>"UTL_FILE_READ_ERROR"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_FILEHANDLE</name></cpp:macro>		<cpp:value>"UTL_FILE_INVALID_FILEHANDLE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_MAXLINESIZE</name></cpp:macro>		<cpp:value>"UTL_FILE_INVALID_MAXLINESIZE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_MODE</name></cpp:macro>			<cpp:value>"UTL_FILE_INVALID_MODE"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>INVALID_PATH</name></cpp:macro>			<cpp:value>"UTL_FILE_INVALID_PATH"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALUE_ERROR</name></cpp:macro>				<cpp:value>"UTL_FILE_VALUE_ERROR"</cpp:value></cpp:define>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_fopen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_is_open</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_get_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_get_nextline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_put</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_put_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_new_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_putf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_fflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_fclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_fclose_all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_fremove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_frename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_fcopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_fgetattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>utl_file_tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CUSTOM_EXCEPTION</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>, <parameter><type><name>detail</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>ereport(ERROR, \
		(errcode(ERRCODE_RAISE_EXCEPTION), \
		 errmsg("%s", msg), \
		 errdetail("%s", detail)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRERROR_EXCEPTION</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { char *strerr = strerror(errno); CUSTOM_EXCEPTION(msg, strerr); } while(0);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_FILEHANDLE_EXCEPTION</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>CUSTOM_EXCEPTION(INVALID_FILEHANDLE, "Used file handle isn't valid.")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_FILE_HANDLE</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>if (PG_ARGISNULL(0)) \
		CUSTOM_EXCEPTION(INVALID_FILEHANDLE, "Used file handle isn't valid.")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NON_EMPTY_TEXT</name><parameter_list>(<parameter><type><name>dat</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>if (VARSIZE(dat) - VARHDRSZ == 0) \
		ereport(ERROR, \
			(errcode(ERRCODE_INVALID_PARAMETER_VALUE), \
			 errmsg("invalid parameter"), \
			 errdetail("Empty string isn't allowed.")));</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOT_NULL_ARG</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>if (PG_ARGISNULL(n)) \
		ereport(ERROR, \
			(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED), \
			 errmsg("null value not allowed"), \
			 errhint("%dth argument is NULL.", n)));</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_LINESIZE</name></cpp:macro>		<cpp:value>32767</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_LINESIZE</name><parameter_list>(<parameter><type><name>max_linesize</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if ((max_linesize) &lt; 1 || (max_linesize) &gt; MAX_LINESIZE) \
			CUSTOM_EXCEPTION(INVALID_MAXLINESIZE, "maxlinesize is out of range"); \
	} while(0)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>FileSlot</name>
<block>{
	<decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>max_linesize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>encoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>	<name>id</name></decl>;</decl_stmt>
}</block></struct></type> <name>FileSlot</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SLOTS</name></cpp:macro>		<cpp:value>50</cpp:value></cpp:define>			<comment type="block">/* Oracle 10g supports 50 files */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_SLOTID</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>			<comment type="block">/* invalid slot id */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>FileSlot</name></type>	<name><name>slots</name><index>[<expr><name>MAX_SLOTS</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* initilaized with zeros */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int32</name></type>	<name>slotid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>			<comment type="block">/* next slot id */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_secure_locality</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_safe_path</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>location</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>copy_text_file</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>srcfile</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>dstfile</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>start_line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>end_line</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * get_descriptor(FILE *file) find any free slot for FILE pointer.
 * If isn't realloc array slots and add 32 new free slots.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_descriptor</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_linesize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>==</operator> <name>INVALID_SLOTID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <operator>++</operator><name>slotid</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>==</operator> <name>INVALID_SLOTID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <operator>++</operator><name>slotid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* skip INVALID_SLOTID */</comment>
			<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>file</name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>max_linesize</name> <operator>=</operator> <name>max_linesize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>encoding</name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
			<return>return <expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>INVALID_SLOTID</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* return stored pointer to FILE */</comment>
<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>get_stream</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>max_linesize</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>INVALID_SLOTID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>INVALID_FILEHANDLE_EXCEPTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>==</operator> <name>d</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>max_linesize</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>max_linesize</name> <operator>=</operator> <name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>max_linesize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>encoding</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>encoding</name> <operator>=</operator> <name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>encoding</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>file</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>INVALID_FILEHANDLE_EXCEPTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>	<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>IO_EXCEPTION</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>errno</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EACCES</name></expr>:</case>
		<case>case <expr><name>ENAMETOOLONG</name></expr>:</case>
		<case>case <expr><name>ENOENT</name></expr>:</case>
		<case>case <expr><name>ENOTDIR</name></expr>:</case>
			<expr_stmt><expr><call><name>STRERROR_EXCEPTION</name><argument_list>(<argument><expr><name>INVALID_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>STRERROR_EXCEPTION</name><argument_list>(<argument><expr><name>INVALID_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * FUNCTION UTL_FILE.FOPEN(location text,
 *			   filename text,
 *			   open_mode text,
 *			   max_linesize integer)
 *          RETURNS UTL_FILE.FILE_TYPE;
 *
 * The FOPEN function opens specified file and returns file handle.
 *  open_mode: ['R', 'W', 'A']
 *  max_linesize: [1 .. 32767]
 *
 * Exceptions:
 *  INVALID_MODE, INVALID_OPERATION, INVALID_PATH, INVALID_MAXLINESIZE
 */</comment>
<function><type><name>Datum</name></type>
<name>utl_file_fopen</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>open_mode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_linesize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fullname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>d</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>open_mode</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>NON_EMPTY_TEXT</name><argument_list>(<argument><expr><name>open_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>max_linesize</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_LINESIZE</name><argument_list>(<argument><expr><name>max_linesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_char_to_encoding</name><argument_list>(<argument><expr><name>encname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid encoding name \"%s\""</literal></expr></argument>, <argument><expr><name>encname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>open_mode</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CUSTOM_EXCEPTION</name><argument_list>(<argument><expr><name>INVALID_MODE</name></expr></argument>, <argument><expr><literal type="string">"open mode is different than [R,W,A]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>VARDATA</name><argument_list>(<argument><expr><name>open_mode</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'a'</literal></expr>:</case>
		<case>case <expr><literal type="char">'A'</literal></expr>:</case>
			<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="string">"a"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'r'</literal></expr>:</case>
		<case>case <expr><literal type="char">'R'</literal></expr>:</case>
			<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="string">"r"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'w'</literal></expr>:</case>
		<case>case <expr><literal type="char">'W'</literal></expr>:</case>
			<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="string">"w"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>CUSTOM_EXCEPTION</name><argument_list>(<argument><expr><name>INVALID_MODE</name></expr></argument>, <argument><expr><literal type="string">"open mode is different than [R,W,A]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* open file */</comment>
	<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>get_safe_path</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We cannot use AllocateFile here because those files are automatically
	 * closed at the end of (sub)transactions, but we want to keep them open
	 * for oracle compatibility.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NOT_USED</name></expr></cpp:if>
	<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>convert_encoding_server_to_platform</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>file</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>IO_EXCEPTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>get_descriptor</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>max_linesize</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>INVALID_SLOTID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
		     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"program limit exceeded"</literal></expr></argument>)</argument_list></call><operator>,</operator>
		     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Too much concurrent opened files"</literal></expr></argument>)</argument_list></call><operator>,</operator>
		     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can only open a maximum of ten files for each session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>utl_file_is_open</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>	<name>d</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>==</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_LENGTH</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>if (l &gt; max_linesize) \
		CUSTOM_EXCEPTION(VALUE_ERROR, "buffer is too short");</cpp:value></cpp:define>

<comment type="block">/* read line from file. set eof if is EOF */</comment>

<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>get_line</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max_linesize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>iseof</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bpt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>csize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>eof</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>max_linesize</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bpt</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>csize</name> <operator>&lt;</operator> <name>max_linesize</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>eof</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> 	<comment type="block">/* I was able read one char */</comment>

		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition>  <comment type="block">/* lookin ahead \n */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* last char */</comment>

			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* skip \r\n */</comment>
			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>++</operator><name>csize</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>bpt</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eof</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>decoded</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_verify_mbstr</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>size2int</name><argument_list>(<argument><expr><name>csize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>decoded</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_do_encoding_conversion</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>buffer</name></expr></argument>,
									 <argument><expr><call><name>size2int</name><argument_list>(<argument><expr><name>csize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>decoded</name> <operator>==</operator> <name>buffer</name></expr> ?</condition><then> <expr><name>csize</name></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>decoded</name> <operator>!=</operator> <name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>iseof</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>errno</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">0</literal></expr>:</case>
				<break>break;</break>

			<case>case <expr><name>EBADF</name></expr>:</case>
				<expr_stmt><expr><call><name>CUSTOM_EXCEPTION</name><argument_list>(<argument><expr><name>INVALID_OPERATION</name></expr></argument>, <argument><expr><literal type="string">"file descriptor isn't valid for reading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>STRERROR_EXCEPTION</name><argument_list>(<argument><expr><name>READ_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><operator>*</operator><name>iseof</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FUNCTION UTL_FILE.GET_LINE(file UTL_TYPE.FILE_TYPE, line int DEFAULT NULL)
 *          RETURNS text;
 *
 * Reads one line from file.
 *
 * Exceptions:
 *  NO_DATA_FOUND, INVALID_FILEHANDLE, INVALID_OPERATION, READ_ERROR
 */</comment>
<function><type><name>Datum</name></type>
<name>utl_file_get_line</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>max_linesize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>encoding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* keep compiler quiet */</comment>
	<decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>iseof</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FILE_HANDLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>get_stream</name><argument_list>(<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_linesize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 'len' overwrites max_linesize, but must be smaller than max_linesize */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>	<name>len</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>CHECK_LINESIZE</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>max_linesize</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>max_linesize</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_line</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>max_linesize</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iseof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>iseof</name></expr>)</condition><block type="pseudo"><block_content>
	    	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
		    		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no data found"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FUNCTION UTL_FILE.GET_NEXTLINE(file UTL_TYPE.FILE_TYPE)
 *          RETURNS text;
 *
 * Reads one line from file or retutns NULL
 * by Steven Feuerstein.
 *
 * Exceptions:
 *  INVALID_FILEHANDLE, INVALID_OPERATION, READ_ERROR
 */</comment>
<function><type><name>Datum</name></type>
<name>utl_file_get_nextline</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>max_linesize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* keep compiler quiet */</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>encoding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>			<comment type="block">/* keep compiler quiet */</comment>
	<decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>iseof</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FILE_HANDLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>get_stream</name><argument_list>(<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_linesize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_line</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>max_linesize</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iseof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>iseof</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_flush</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>fflush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EBADF</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CUSTOM_EXCEPTION</name><argument_list>(<argument><expr><name>INVALID_OPERATION</name></expr></argument>, <argument><expr><literal type="string">"File is not an opened, or is not open for writing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>STRERROR_EXCEPTION</name><argument_list>(<argument><expr><name>WRITE_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FUNCTION UTL_FILE.PUT(file UTL_FILE.FILE_TYPE, buffer text)
 *          RETURNS bool;
 *
 * The PUT function puts data out to specified file. Buffer length allowed is
 * 32K or 1024 (max_linesize);
 *
 * Exceptions:
 *  INVALID_FILEHANDLE, INVALID_OPERATION, WRITE_ERROR, VALUE_ERROR
 *
 * Note: returns bool because I cannot do envelope over void function
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_ERRNO_PUT</name><parameter_list>()</parameter_list></cpp:macro>  \
	<cpp:value>switch (errno) \
	{ \
		case EBADF: \
			CUSTOM_EXCEPTION(INVALID_OPERATION, "file descriptor isn't valid for writing"); \
			break; \
		default: \
			STRERROR_EXCEPTION(WRITE_ERROR); \
	}</cpp:value></cpp:define>

<comment type="block">/* encode(t, encoding) */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>encode_text</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>encoded</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>encoded</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_do_encoding_conversion</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>src</name></expr></argument>,
					<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>src</name> <operator>==</operator> <name>encoded</name></expr> ?</condition><then> <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>encoded</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* fwrite(encode(args[n], encoding), f) */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>do_write</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max_linesize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>encode_text</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_LENGTH</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CHECK_ERRNO_PUT</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>str</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>do_put</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>max_linesize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* keep compiler quiet */</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>encoding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>			<comment type="block">/* keep compiler quiet */</comment>

	<expr_stmt><expr><call><name>CHECK_FILE_HANDLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>get_stream</name><argument_list>(<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_linesize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>do_write</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>max_linesize</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>f</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>utl_file_put</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>do_put</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_new_line</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lines</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>lines</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<if_stmt><if>if <condition>(<expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><call><name>CHECK_ERRNO_PUT</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if_stmt><if>if <condition>(<expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"\r\n"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><call><name>CHECK_ERRNO_PUT</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>utl_file_put_line</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>autoflush</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>do_put</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>autoflush</name> <operator>=</operator> <call><name>PG_GETARG_IF_EXISTS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>do_new_line</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>autoflush</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_flush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>utl_file_new_line</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>lines</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FILE_HANDLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>get_stream</name><argument_list>(<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lines</name> <operator>=</operator> <call><name>PG_GETARG_IF_EXISTS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>INT32</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>do_new_line</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FUNCTION UTL_FILE.PUTF(file UTL_FILE.FILE_TYPE,
 *			format text,
 *			arg1 text,
 *			arg2 text,
 *			arg3 text,
 *			arg4 text,
 *			arg5 text)
 *	    RETURNS bool;
 *
 * Puts formated data to file. Allows %s like subst symbol.
 *
 * Exception:
 *  INVALID_FILEHANDLE, INVALID_OPERATION, WRITE_ERROR
 */</comment>
<function><type><name>Datum</name></type>
<name>utl_file_putf</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>max_linesize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>encoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>format_length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>fpt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>cur_par</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>cur_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FILE_HANDLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>get_stream</name><argument_list>(<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_linesize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>format</name> <operator>=</operator> <call><name>encode_text</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>format_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>fpt</name> <operator>=</operator> <name>format</name></expr>;</init> <condition><expr><name>format_length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>fpt</name><operator>++</operator></expr><operator>,</operator> <expr><name>format_length</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>format_length</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* last char */</comment>
			<expr_stmt><expr><call><name>CHECK_LENGTH</name><argument_list>(<argument><expr><operator>++</operator><name>cur_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>fpt</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CHECK_ERRNO_PUT</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* ansi compatible string */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fpt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>fpt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_LENGTH</name><argument_list>(<argument><expr><operator>++</operator><name>cur_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CHECK_ERRNO_PUT</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>fpt</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>format_length</name><operator>--</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fpt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fpt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CHECK_LENGTH</name><argument_list>(<argument><expr><operator>++</operator><name>cur_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'%'</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CHECK_ERRNO_PUT</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>fpt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <operator>++</operator><name>cur_par</name> <operator>&lt;=</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>cur_par</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cur_len</name> <operator>+=</operator> <call><name>do_write</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>cur_par</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>max_linesize</name> <operator>-</operator> <name>cur_len</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>fpt</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>format_length</name><operator>--</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>CHECK_LENGTH</name><argument_list>(<argument><expr><operator>++</operator><name>cur_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fputc</name><argument_list>(<argument><expr><name><name>fpt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CHECK_ERRNO_PUT</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FUNCTION UTL_FILE.FFLUSH(file UTL_FILE.FILE_TYPE)
 *          RETURNS void;
 *
 * This function makes sure that all pending data for the specified file is written
 * physically out to file.
 *
 * Exceptions:
 *  INVALID_FILEHANDLE, INVALID_OPERATION, WRITE_ERROR
 */</comment>
<function><type><name>Datum</name></type>
<name>utl_file_fflush</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FILE_HANDLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>get_stream</name><argument_list>(<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>do_flush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FUNCTION UTL_FILE.FCLOSE(file UTL_FILE.FILE_TYPE)
 *          RETURNS NULL
 *
 * Close an open file. This function reset file handle to NULL on Oracle platform.
 * It isn't possible in PostgreSQL, and then you have to call fclose function
 * like:
 *        file := utl_file.fclose(file);
 *
 * Exception:
 *  INVALID_FILEHANDLE, WRITE_ERROR
 */</comment>
<function><type><name>Datum</name></type>
<name>utl_file_fclose</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>d</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>==</operator> <name>d</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>file</name> <operator>&amp;&amp;</operator> <call><name>fclose</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EBADF</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CUSTOM_EXCEPTION</name><argument_list>(<argument><expr><name>INVALID_FILEHANDLE</name></expr></argument>, <argument><expr><literal type="string">"File is not an opened"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>STRERROR_EXCEPTION</name><argument_list>(<argument><expr><name>WRITE_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>INVALID_SLOTID</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>INVALID_FILEHANDLE_EXCEPTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FUNCTION UTL_FILE.FCLOSE_ALL()
 *          RETURNS void
 *
 * Close all opened files.
 *
 * Exceptions: WRITE_ERROR
 */</comment>
<function><type><name>Datum</name></type>
<name>utl_file_fclose_all</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>!=</operator> <name>INVALID_SLOTID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>file</name> <operator>&amp;&amp;</operator> <call><name>fclose</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EBADF</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CUSTOM_EXCEPTION</name><argument_list>(<argument><expr><name>INVALID_FILEHANDLE</name></expr></argument>, <argument><expr><literal type="string">"File is not an opened"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>STRERROR_EXCEPTION</name><argument_list>(<argument><expr><name>WRITE_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>INVALID_SLOTID</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * utl_file_dir security .. is solved with aux. table.
 *
 * Raise exception if don't find string in table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_secure_locality</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>SPIPlanPtr</name></type>	<name>plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type>		<name><name>argtypes</name><index>[]</index></name> <init>= <expr><block>{<expr><name>TEXTOID</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>	<name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="char">' '</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SELECT 1 FROM utl_file.utl_file_dir
	 *   WHERE CASE WHEN substring(dir from '.$') = '/' THEN
	 *     substring($1, 1, length(dir)) = dir
	 *   ELSE
	 *     substring($1, 1, length(dir) + 1) = dir || '/'
	 *   END
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Don't use LIKE not to escape '_' and '%' */</comment>
		<decl_stmt><decl><type><name>SPIPlanPtr</name></type> <name>p</name> <init>= <expr><call><name>SPI_prepare</name><argument_list>(
		    <argument><expr><literal type="string">"SELECT 1 FROM utl_file.utl_file_dir"</literal>
	 	        <literal type="string">" WHERE CASE WHEN substring(dir from '.$') = '/' THEN"</literal>
	 	        <literal type="string">"  substring($1, 1, length(dir)) = dir"</literal>
	 	        <literal type="string">" ELSE"</literal>
	 	        <literal type="string">"  substring($1, 1, length(dir) + 1) = dir || '/'"</literal>
	 	        <literal type="string">" END"</literal></expr></argument>,
		    <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>plan</name> <operator>=</operator> <call><name>SPI_saveplan</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SPI_prepare_failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>SPI_OK_SELECT</name> <operator>!=</operator> <call><name>SPI_execute_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can't execute sql"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_RAISE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><name>INVALID_PATH</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"you cannot access locality"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"locality is not found in utl_file_dir table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>safe_named_location</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>SPIPlanPtr</name></type>	<name>plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>		<name>old_cxt</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type>		<name><name>argtypes</name><index>[]</index></name> <init>= <expr><block>{<expr><name>TEXTOID</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>	<name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="char">' '</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Don't use LIKE not to escape '_' and '%' */</comment>
		<decl_stmt><decl><type><name>SPIPlanPtr</name></type> <name>p</name> <init>= <expr><call><name>SPI_prepare</name><argument_list>(
		    <argument><expr><literal type="string">"SELECT dir FROM utl_file.utl_file_dir WHERE dirname = $1"</literal></expr></argument>,
		    <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>plan</name> <operator>=</operator> <call><name>SPI_saveplan</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SPI_prepare_failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>SPI_OK_SELECT</name> <operator>!=</operator> <call><name>SPI_execute_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can't execute sql"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>loc</name> <init>= <expr><call><name>SPI_getvalue</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>loc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_safe_path - make a fullpath and check security.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_safe_path</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>location_or_dirname</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fullname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>check_locality</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NON_EMPTY_TEXT</name><argument_list>(<argument><expr><name>location_or_dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NON_EMPTY_TEXT</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>safe_named_location</name><argument_list>(<argument><expr><name>location_or_dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>location</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>		<name>aux_pos</name> <init>= <expr><call><name>size2int</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>aux_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>aux_pos</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>aux_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fullname</name><index>[<expr><name>aux_pos</name></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fullname</name> <operator>+</operator> <name>aux_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aux_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fullname</name><index>[<expr><name>aux_pos</name> <operator>+</operator> <name>aux_len</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* location is safe (ensured by dirname) */</comment>
		<expr_stmt><expr><name>check_locality</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>aux_pos</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>location_or_dirname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>aux_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>aux_pos</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>aux_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>location_or_dirname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aux_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fullname</name><index>[<expr><name>aux_pos</name></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fullname</name> <operator>+</operator> <name>aux_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aux_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fullname</name><index>[<expr><name>aux_pos</name> <operator>+</operator> <name>aux_len</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>check_locality</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* check locality in canonizalized form of path */</comment>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>check_locality</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_secure_locality</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>fullname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CREATE FUNCTION utl_file.fremove(
 *     location		text,
 *     filename		text)
 */</comment>
<function><type><name>Datum</name></type>
<name>utl_file_fremove</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fullname</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>get_safe_path</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>IO_EXCEPTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CREATE FUNCTION utl_file.frename(
 *     location		text,
 *     filename		text,
 *     dest_dir		text,
 *     dest_file	text,
 *     overwrite	boolean DEFAULT false)
 */</comment>
<function><type><name>Datum</name></type>
<name>utl_file_frename</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srcpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dstpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>overwrite</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>overwrite</name> <operator>=</operator> <call><name>PG_GETARG_IF_EXISTS</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>srcpath</name> <operator>=</operator> <call><name>get_safe_path</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dstpath</name> <operator>=</operator> <call><name>get_safe_path</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>overwrite</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type>	<name>st</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>dstpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CUSTOM_EXCEPTION</name><argument_list>(<argument><expr><name>WRITE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"File exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>IO_EXCEPTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* rename() overwrites existing files. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>srcpath</name></expr></argument>, <argument><expr><name>dstpath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>IO_EXCEPTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CREATE FUNCTION utl_file.fcopy(
 *     src_location		text,
 *     src_filename		text,
 *     dest_location	text,
 *     dest_filename	text,
 *     start_line		integer DEFAULT NULL
 *     end_line			integer DEFAULT NULL)
 */</comment>
<function><type><name>Datum</name></type>
<name>utl_file_fcopy</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srcpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dstpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>start_line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>end_line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>srcfile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>dstfile</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>srcpath</name> <operator>=</operator> <call><name>get_safe_path</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dstpath</name> <operator>=</operator> <call><name>get_safe_path</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>start_line</name> <operator>=</operator> <call><name>PG_GETARG_IF_EXISTS</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>INT32</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>start_line</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"start_line must be positive (%d passed)"</literal></expr></argument>, <argument><expr><name>start_line</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>end_line</name> <operator>=</operator> <call><name>PG_GETARG_IF_EXISTS</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>INT32</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>end_line</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end_line must be positive (%d passed)"</literal></expr></argument>, <argument><expr><name>end_line</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>srcfile</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>srcpath</name></expr></argument>, <argument><expr><literal type="string">"rt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>srcfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* failed to open src file. */</comment>
		<expr_stmt><expr><call><name>IO_EXCEPTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>dstfile</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>dstpath</name></expr></argument>, <argument><expr><literal type="string">"wt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dstfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* failed to open dst file. */</comment>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>IO_EXCEPTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>copy_text_file</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>, <argument><expr><name>dstfile</name></expr></argument>, <argument><expr><name>start_line</name></expr></argument>, <argument><expr><name>end_line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>IO_EXCEPTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>dstfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy srcfile to dstfile. Return 0 if succeeded, or non-0 if error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>copy_text_file</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>srcfile</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>dstfile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>end_line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAX_LINESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* skip first start_line. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>start_line</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<do>do
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>MAX_LINESIZE</name></expr></argument>, <argument><expr><name>srcfile</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while<condition>(<expr><name><name>buffer</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition>;</do>
	</block_content>}</block></for>

	<comment type="block">/* copy until end_line. */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>end_line</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<do>do
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>MAX_LINESIZE</name></expr></argument>, <argument><expr><name>srcfile</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>dstfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block> while<condition>(<expr><name><name>buffer</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition>;</do>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CREATE FUNCTION utl_file.fgetattr(
 *     location		text,
 *     filename		text
 * ) RETURNS (
 *     fexists		boolean,
 *     file_length	bigint,
 *     blocksize	integer)
 */</comment>
<function><type><name>Datum</name></type>
<name>utl_file_fgetattr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fullname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type>	<name>st</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOT_NULL_ARG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>get_safe_path</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_blksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">512</literal></expr>;</expr_stmt>	<comment type="block">/* NTFS block size */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>utl_file_tmpdir</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmpdir</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TMPDIR"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmpdir</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tmpdir</name> <operator>=</operator> <literal type="string">"/tmp"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tmpdir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>GetTempPathA</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>ret</name> <operator>&gt;</operator> <name>MAXPGPATH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CUSTOM_EXCEPTION</name><argument_list>(<argument><expr><name>INVALID_PATH</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
