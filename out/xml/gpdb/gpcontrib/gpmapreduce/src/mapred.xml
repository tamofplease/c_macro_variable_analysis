<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/gpcontrib/gpmapreduce/src/mapred.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mapred.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;except.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mapred_errors.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>     <comment type="block">/* for file "access" test */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scalarfree</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>							\
	<cpp:value>do {										\
		if (x) {								\
			free(x);							\
			x = NULL;							\
		}										\
	} while (0)</cpp:value></cpp:define>


<comment type="block">/* instantiate the extern from mapred.h */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>mapred_kind_name</name><index>[<expr><name>MAPRED_MAXKIND</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>=
<expr><block>{
	<expr><literal type="string">"&lt;NULL&gt;"</literal></expr>,
	<expr><literal type="string">"DOCUMENT"</literal></expr>,
	<expr><literal type="string">"INPUT"</literal></expr>,
	<expr><literal type="string">"OUTPUT"</literal></expr>,
	<expr><literal type="string">"MAP"</literal></expr>,
	<expr><literal type="string">"TRANSITION"</literal></expr>,
	<expr><literal type="string">"CONSOLIDATE"</literal></expr>,
	<expr><literal type="string">"FINALIZE"</literal></expr>,
	<expr><literal type="string">"REDUCE"</literal></expr>,
	<expr><literal type="string">"TASK"</literal></expr>,
	<expr><literal type="string">"RUN"</literal></expr>,
	<expr><literal type="string">"INTERNAL"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* instantiate default parameter names from mapred.h */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>default_parameter_names</name><index>[<expr><name>MAPRED_MAXKIND</name><operator>+</operator><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>=
<expr><block>{
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_NO_KIND */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_DOCUMENT */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_INPUT */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_OUTPUT */</comment>
	<expr><block>{<expr><literal type="string">"key"</literal></expr>, <expr><literal type="string">"value"</literal></expr>}</block></expr>,      <comment type="block">/* MAPRED_MAPPER */</comment>
	<expr><block>{<expr><literal type="string">"state"</literal></expr>, <expr><literal type="string">"value"</literal></expr>}</block></expr>,    <comment type="block">/* MAPRED_TRANSITION */</comment>
	<expr><block>{<expr><literal type="string">"state1"</literal></expr>, <expr><literal type="string">"state2"</literal></expr>}</block></expr>,  <comment type="block">/* MAPRED_COMBINER */</comment>
	<expr><block>{<expr><literal type="string">"state"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,       <comment type="block">/* MAPRED_FINALIZER */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_REDUCER */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_TASK */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_EXECUTION */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>           <comment type="block">/* MAPRED_ADT */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* instantiate default parameter names from mapred.h */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>default_return_names</name><index>[<expr><name>MAPRED_MAXKIND</name><operator>+</operator><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>=
<expr><block>{
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_NO_KIND */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_DOCUMENT */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_INPUT */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_OUTPUT */</comment>
	<expr><block>{<expr><literal type="string">"key"</literal></expr>, <expr><literal type="string">"value"</literal></expr>}</block></expr>,      <comment type="block">/* MAPRED_MAPPER */</comment>
	<expr><block>{<expr><literal type="string">"value"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,       <comment type="block">/* MAPRED_TRANSITION */</comment>
	<expr><block>{<expr><literal type="string">"value"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,       <comment type="block">/* MAPRED_COMBINER */</comment>
	<expr><block>{<expr><literal type="string">"value"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,       <comment type="block">/* MAPRED_FINALIZER */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_REDUCER */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_TASK */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,          <comment type="block">/* MAPRED_EXECUTION */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>           <comment type="block">/* MAPRED_ADT */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * libpq Errors that we care about
 * (would be better to add &lt;errcodes.h&gt; to the include path)
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>IN_FAILED_SQL_TRANSACTION</name> <init>= <expr><literal type="string">"25P02"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>OBJ_DOES_NOT_EXIST</name>        <init>= <expr><literal type="string">"42P01"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>SCHEMA_DOES_NOT_EXIST</name>     <init>= <expr><literal type="string">"3F000"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>DISTRIBUTION_NOTICE</name> <init>= <expr><literal type="string">"NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* local prototypes */</comment>
<function_decl><type><name>void</name> <modifier>*</modifier></type>         <name>mapred_malloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>             <name>mapred_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>buffer_t</name> <modifier>*</modifier></type>        <name>makebuffer</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bufsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>grow</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>                <name>bufreset</name><parameter_list>(<parameter><decl><type><name>buffer_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>                  <name>bufcat</name><parameter_list>(<parameter><decl><type><name>buffer_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>bufp</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>   <name>ignore_notice_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>    <name>print_notice_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>    <name>mapred_setup_columns</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>boolean</name></type> <name>mapred_create_object</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>,
							 <parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>    <name>mapred_remove_object</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>,
							 <parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>      <name>mapred_run_queries</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>mapred_resolve_dependencies</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>mapred_resolve_ref</name><parameter_list>(<parameter><decl><type><name>mapred_olist_t</name> <modifier>*</modifier></type><name>olist</name></decl></parameter>, <parameter><decl><type><name>mapred_reference_t</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>mapred_resolve_object</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>,
						   <parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>exec_count</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>lookup_function_in_catalog</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>,
								<parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>mapred_obj_error</name><parameter_list>(<parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
	__attribute__<parameter_list>(<parameter/></parameter_list>(format<parameter_list>(<parameter><decl><type><name>PG_PRINTF_ATTRIBUTE</name></type></decl></parameter>, <parameter/></parameter_list>2<operator>,</operator> 3</function_decl>)))<empty_stmt>;</empty_stmt>

<comment type="block">/* Wrappers around malloc/free to handle error conditions more cleanly */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>mapred_malloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>global_debug_flag</name> <operator>&amp;&amp;</operator> <name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Allocating %d bytes: "</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>m</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MEMORY_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Memory allocation failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>global_debug_flag</name> <operator>&amp;&amp;</operator> <name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%p\n"</literal></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>copyscalar</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>							\
	<cpp:value>strcpy(mapred_malloc(strlen(s)+1), s)</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>mapred_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>global_debug_flag</name> <operator>&amp;&amp;</operator> <name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Freeing memory: %p\n"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>mapred_obj_error</name><parameter_list>(<parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type> <name>arg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"    - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s '%s': "</literal></expr></argument>, <argument><expr><name><name>mapred_kind_name</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name><name>mapred_kind_name</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>line</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">", at line %d\n"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>MAPRED_PARSE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mapred_obj_debug</name><parameter_list>(<parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mapred_plist_t</name> <modifier>*</modifier></type><name>plist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>obj</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Object is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: \n"</literal></expr></argument>, <argument><expr><name><name>mapred_kind_name</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  NAME: '%s': \n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>MAPRED_NO_KIND</name></expr>:</case>
		<case>case <expr><name>MAPRED_DOCUMENT</name></expr>:</case>
		<case>case <expr><name>MAPRED_ADT</name></expr>:</case>
		<case>case <expr><name>MAPRED_INPUT</name></expr>:</case>
		<case>case <expr><name>MAPRED_OUTPUT</name></expr>:</case>
		<case>case <expr><name>MAPRED_TASK</name></expr>:</case>
		<case>case <expr><name>MAPRED_EXECUTION</name></expr>:</case>
		<case>case <expr><name>MAPRED_REDUCER</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  DEBUG: 'debug output not yet implemented'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>MAPRED_MAPPER</name></expr>:</case>
		<case>case <expr><name>MAPRED_TRANSITION</name></expr>:</case>
		<case>case <expr><name>MAPRED_COMBINER</name></expr>:</case>
		<case>case <expr><name>MAPRED_FINALIZER</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  LANGUAGE: %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr> ?</condition><then>
					<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  PARAMETERS: ["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s %s%s"</literal></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
						<argument><expr><ternary><condition><expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  RETURNS: ["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s %s%s"</literal></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
						<argument><expr><ternary><condition><expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  LIBRARY: %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>library</name></name></expr> ?</condition><then>
					<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>library</name></name></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  FUNCTION: %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>body</name></name></expr> ?</condition><then>
					<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>body</name></name></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/* -------------------------------------------------------------------------- */</comment>
<comment type="block">/* Functions that play with buffers                                           */</comment>
<comment type="block">/* -------------------------------------------------------------------------- */</comment>
<function><type><name>buffer_t</name> <modifier>*</modifier></type><name>makebuffer</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bufsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>grow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>buffer_t</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>bufsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>grow</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>buffer</name></name>   <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>b</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>bufsize</name></name>  <operator>=</operator> <name>bufsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>grow</name></name>     <operator>=</operator> <name>grow</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* to re-use a buffer just "reset" it */</comment>
<function><type><name>void</name></type> <name>bufreset</name><parameter_list>(<parameter><decl><type><name>buffer_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>b</name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>bufsize</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>grow</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A simple wrapper around a strncpy that handles resizing an input buffer
 * when needed.
 */</comment>
<function><type><name>void</name></type> <name>bufcat</name><parameter_list>(<parameter><decl><type><name>buffer_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>bufp</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>buffer_t</name>  <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>     <name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>bufp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>bufp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>*</operator><name>bufp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the buffer is too small, grow it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>bufsize</name></name> <operator>&lt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>position</name></name> <operator>+</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>buffer_t</name> <modifier>*</modifier></type><name>newbuf</name></decl>;</decl_stmt>

		<comment type="block">/* use the minumum of "grow" and the new length for the grow amount */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>grow</name></name> <operator>&lt;=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>grow</name></name> <operator>=</operator> <name>len</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>makebuffer</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>bufsize</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>grow</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>grow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newbuf</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>position</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newbuf</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>position</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name>newbuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>b</name> <operator>=</operator> <name>newbuf</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We are now guaranteed that we have enough space in the buffer */</comment>
	<expr_stmt><expr><call><name>XASSERT</name><argument_list>( <argument><expr><name><name>b</name><operator>-&gt;</operator><name>bufsize</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;</operator> <name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>buffer</name></name><operator>+</operator><name><name>b</name><operator>-&gt;</operator><name>position</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>position</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>position</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Currently we just ignore all warnings, may eventually do something
 * smarter, but this is preferable to dumping them to libpq's default
 * of dumping them to stderr.
 */</comment>
<function><type><name>void</name></type> <name>ignore_notice_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>print_notice_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>DISTRIBUTION_NOTICE</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>DISTRIBUTION_NOTICE</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"   - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If a function is already defined in the database we need to be able to
 * lookup the function information directly from the catalog.  This is
 * fairly similar to func_get_detail in backend/parser/parse_func.c, but
 * the lookup from yaml is slightly different because we don't know the
 * context that the function is in, but we _might_ have been told some
 * of the parameter information already.
 */</comment>
<function><type><name>void</name></type> <name>lookup_function_in_catalog</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>,
								<parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>			<modifier>*</modifier></type><name>result</name>	 <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>			<modifier>*</modifier></type><name>result2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_plist_t</name>		<modifier>*</modifier></type><name>plist</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>plist2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_plist_t</name>		<modifier>*</modifier></type><name>newitem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_plist_t</name>		<modifier>*</modifier></type><name>returns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>buffer_t</name>			<modifier>*</modifier></type><name>buffer</name>	 <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>				<modifier>*</modifier></type><name>tmp1</name>	 <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>				<modifier>*</modifier></type><name>tmp2</name>	 <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>				<modifier>*</modifier></type><name>tmp3</name>	 <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_LEN</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>char</name></type>				<name><name>str</name><index>[<expr><name>STR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>i</name></decl>, <decl><type ref="prev"/><name>nargs</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MAPRED_MAPPER</name>     <operator>||</operator>
			<name><name>obj</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MAPRED_TRANSITION</name> <operator>||</operator>
			<name><name>obj</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MAPRED_COMBINER</name>   <operator>||</operator>
			<name><name>obj</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MAPRED_FINALIZER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>internal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>internal_returns</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<macro><name>XTRY</name></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>makebuffer</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Try to lookup the specified function */</comment>
		<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
			   <argument><expr><literal type="string">"SELECT proretset, prorettype::regtype, pronargs,\n"</literal>
			   <literal type="string">"       proargnames, proargmodes, \n"</literal>
			   <literal type="string">"       (proargtypes::regtype[])[0:pronargs] as proargtypes,\n"</literal>
			   <literal type="string">"       proallargtypes::regtype[],\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have return types defined in the yaml then we want to resolve
		 * them to their authorative names for comparison purposes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"       ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'::regtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* If we don't know the type, punt */</comment>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'-'::regtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"] as yaml_rettypes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"       null::regtype[] as yaml_rettypes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
			   <argument><expr><literal type="string">"FROM   pg_proc\n"</literal>
			   <literal type="string">"WHERE  prokind = 'f'\n"</literal>
			   <literal type="string">"  AND  proname = lower('"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"')\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fill in the known parameter types */</comment>
		<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"  AND  (proargtypes::regtype[])[0:pronargs] = ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>nargs</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'::regtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_LEN</name></expr></argument>, <argument><expr><literal type="string">"]\n  AND pronargs=%d\n"</literal></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Run the SQL */</comment>
		<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>||</operator> <name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bufreset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The SQL statement failed:
			 * Most likely scenario is a bad datatype causing the regtype cast
			 * to fail.
			 */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>code</name>  <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"errcode=\"%s\"\n"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Todo: validate expected error code */</comment>

			<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"SQL Error resolving function: \n  %s"</literal></expr></argument>,
							 <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No such function */</comment>
			<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"No such function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Ambiguous function, supply a function "</literal>
							 <literal type="string">"prototype for disambiguation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>          <name>len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>boolean</name></type>		 <name>retset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>          <name>nargs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>argtypes</name>	 <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>argnames</name>	 <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>argmodes</name>	 <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>allargtypes</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>rettype</name>	 <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>yaml_rettypes</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>type</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>typetokens</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nametokens</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>mode</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>modetokens</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>boolean</name></type>     <name>name_end</name></decl>, <decl><type ref="prev"/><name>mode_end</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Column 0: proretset */</comment>
			<expr_stmt><expr><name>retset</name> <operator>=</operator> <operator>(</operator><name><name>value</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Column 1: prorettype */</comment>
			<expr_stmt><expr><name>rettype</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Column 2: pronargs */</comment>
			<expr_stmt><expr><name>nargs</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Arrays are formatted as:  "{value,value,...}"
			 * of which we only want "value,value, ..."
			 * so find the part of the string between the braces
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>   <comment type="block">/* Column 3: proargnames */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>argnames</name> <operator>=</operator> <name>value</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>argnames</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>   <comment type="block">/* Column 4: proargmodes */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>argmodes</name> <operator>=</operator> <name>value</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>argmodes</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition>   <comment type="block">/* Column 5: proargtypes */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>argtypes</name> <operator>=</operator> <name>value</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition>   <comment type="block">/* Column 6: proallargtypes */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>allargtypes</name> <operator>=</operator> <name>value</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>allargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>allargtypes</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition>   <comment type="block">/* Column 7: yaml_rettypes */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>yaml_rettypes</name> <operator>=</operator> <name>value</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>yaml_rettypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>yaml_rettypes</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * These constraints should all be enforced in the catalog, so
			 * if something is wrong then it's a coding error above.
			 */</comment>
			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we just derived the parameters from the catalog then we
			 * need complete our internal metadata.
			 */</comment>
			<expr_stmt><expr><name>plist</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* strtok is destructive and we need to preserve the original
				 * string, so we make some annoying copies prior to strtok.
				 */</comment>
				<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp3</name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>typetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nametokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>tmp3</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>modetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Name and mode are used for IN/OUT parameters and may not be
				 * present.  In the event that they are we are looking for:
				 *   - the "i" (in) arguments
				 *   - the "b" (inout) arguments
				 * we skip over:
				 *   - the "o" (out) arguments.
				 *   - the "t" (table out) arguments.
				 *
				 * Further it is possible for some of the arguments to be named
				 * and others to be unnamed.  The unnamed arguments will show
				 * up as "" (two quotes, not an empty string) if there is an
				 * argnames defined.
				 *
				 * If argmodes is not defined then all names in proargnames
				 * refer to input arguments.
				 */</comment>

				<while>while <condition>(<expr><name>mode</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nametokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>modetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>
				<expr_stmt><expr><name>name_end</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <name>name</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>mode_end</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <name>mode</name><operator>)</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>type</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Keep track of which parameter we are on */</comment>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;=</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If a name was not specified by the user, and was not
					 * specified by the in/out parameters then we assign it a
					 * default name.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* single argument functions always default to "value" */</comment>
						<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"value"</literal></expr>;</expr_stmt></block_content></block></if>

						<comment type="block">/* Base name on default parameter names for the first
						 * two arguments */</comment>
						<if type="elseif">else if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>default_parameter_names</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>]</index><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * If we still didn't decide on a name, make up
						 * something useless.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_LEN</name></expr></argument>, <argument><expr><literal type="string">"parameter%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>name</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plist</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>plist</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>(</operator><name>mapred_plist_t</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name> <operator>=</operator> <name>plist</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>(</operator><name>mapred_plist_t</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/* Procede to the next parameter */</comment>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>typetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name_end</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nametokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>name_end</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <name>name</name><operator>)</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mode_end</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>modetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>mode_end</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <name>mode</name><operator>)</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<while>while <condition>(<expr><name>mode</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name_end</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nametokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>name_end</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <name>name</name><operator>)</operator></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mode_end</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>modetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>mode_end</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <name>mode</name><operator>)</operator></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></while>
				</block_content>}</block></while>

				<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>tmp3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp3</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Check that the number of parameters received is appropriate.
			 * This would be better moved to a generalized validation routine.
			 */</comment>
			<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
			<block>{<block_content>

				<case>case <expr><name>MAPRED_MAPPER</name></expr>:</case>
					<comment type="block">/*
					 * It would probably be possible to start supporting zero
					 * argument mappers, but:
					 *   1) It would require more modifications
					 *   2) Doesn't currently have a known use case
					 *   3) Has easy workarounds
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Transition functions require "</literal>
										 <literal type="string">"two or more parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>MAPRED_TRANSITION</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Transition functions require "</literal>
										 <literal type="string">"two or more parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>retset</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Transition functions cannot "</literal>
										 <literal type="string">"be table functions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>MAPRED_COMBINER</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Consolidate functions require "</literal>
										 <literal type="string">"exactly two parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>retset</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Consolidate functions cannot "</literal>
										 <literal type="string">"be table functions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>MAPRED_FINALIZER</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Finalize functions require "</literal>
										 <literal type="string">"exactly one parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>

			<comment type="block">/* Fill in return type information */</comment>
			<if_stmt><if>if <condition>(<expr><name>retset</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MAPRED_MODE_MULTI</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>MAPRED_MODE_SINGLE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Determine the return type information, there are 3 primary
			 * subcases:
			 *
			 *  1) Function is defined with OUT/TABLE parameters.
			 *  2) Function returns a simple type.
			 *  3) Function returns a complex type.
			 *  4) Return type is void [error]
			 */</comment>
			<expr_stmt><expr><name>plist</name> <operator>=</operator> <name>returns</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>argmodes</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>argmodes</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>

				<comment type="block">/* strtok is destructive and we need to preserve the original
				 * string, so we make some annoying copies prior to strtok.
				 */</comment>
				<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>allargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp3</name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>typetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nametokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>tmp3</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>modetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>mode</name></expr>)</condition>
				<block>{<block_content>
					<while>while <condition>(<expr><name>mode</name> <operator>&amp;&amp;</operator>
						   <call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"o"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						   <call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						   <call><name>strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* skip input parameters */</comment>
						<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>typetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nametokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>modetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></while>
					<if_stmt><if>if <condition>(<expr><name>mode</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>newitem</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Note we haven't made local copies of these, we will
						 * do this after resolution when validating against any
						 * RETURNS defined in the yaml, if any.
						 */</comment>

						<if_stmt><if>if<condition>( <expr><name>NULL</name> <operator>!=</operator> <name>name</name> <operator>&amp;&amp;</operator>
								<literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
								<literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"\"\""</literal></expr></argument>)</argument_list></call></expr> )</condition>
						<block>{<block_content>
							<comment type="block">/*if name defined in db, just use it*/</comment>
							<expr_stmt><expr><name><name>newitem</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/*else just obey the default name in db*/</comment>
							<expr_stmt><expr><call><name>snprintf</name><argument_list>( <argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_LEN</name></expr></argument>, <argument><expr><literal type="string">"column%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>newitem</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>

						<expr_stmt><expr><name><name>newitem</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>newitem</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>plist</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>returns</name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><name>plist</name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>typetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nametokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>modetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>

				<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>tmp3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp3</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If the arguments were not defined in the function definition then
			 * we check to see if this was a complex type by looking up the type
			 * information in pg_attribute.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>returns</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
					   <argument><expr><literal type="string">"SELECT attname, atttypid::regtype\n"</literal>
					   <literal type="string">"FROM   pg_attribute a\n"</literal>
					   <literal type="string">"JOIN   pg_class c on (a.attrelid = c.oid)\n"</literal>
					   <literal type="string">"WHERE  not a.attisdropped\n"</literal>
					   <literal type="string">"  AND  a.attnum &gt; 0\n"</literal>
					   <literal type="string">"  AND  c.reltype = '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
					   <argument><expr><literal type="string">"'::regtype\n"</literal>
					   <literal type="string">"ORDER BY -attnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result2</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufreset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Error resolving function: %s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* We have a complex type, build the return list */</comment>
					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result2</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>newitem</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newitem</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newitem</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newitem</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>returns</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>returns</name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If the return types were not defined in either the argument list
			 * nor the catalog then we assume it is a simple type.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>returns</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Check against "void" which is a special return type that
				 * means there is no return value - which we don't support for
				 * mapreduce.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>, <argument><expr><literal type="string">"void"</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Function returns void"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>returns</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>returns</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>returns</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>returns</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We now should have a returns list, compare it against the RETURNS
			 * list given in the yaml.  The yaml overrides return names, but can
			 * not override return types.  If the return types are incompatible
			 * raise an error.
			 */</comment>
			<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>internal_returns</name></name> <operator>=</operator> <name>returns</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The first thing to do is normalize the given return types
				 * with their formal names.  This will, for example turn a type
				 * like "float8" =&gt; "double precision".  The input name might
				 * be correct (float8) but we need it represented as the formal
				 * name so that we can compare against the formal name we got
				 * when we looked up the function in the catalog.
				 */</comment>
				<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>yaml_rettypes</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>typetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>plist</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* should be an equal number */</comment>

					<comment type="block">/*
					 * If we have a type specified replace it with the one we
					 * resolved from the select stmt, otherwise just keep it
					 * as NULL and fill it in during the compare against what
					 * was in the catalog.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * When in an array the typname may get wrapped in
						 * double quotes, if so we need to strip them back out.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>type</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>type</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>typetokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>


				<comment type="block">/* Compare against actual function return types */</comment>
				<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>plist2</name> <operator>=</operator> <name>returns</name></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>plist</name> <operator>&amp;&amp;</operator> <name>plist2</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* always defined in YAML */</comment>
					<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>plist2</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* always defined in SQL */</comment>

					<comment type="block">/*
					 * In the YAML it is possible to have a name without a type,
					 * if that is the case then simply take the SQL type.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name><name>plist2</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>plist2</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>plist</name>  <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>plist2</name> <operator>=</operator> <name><name>plist2</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
				</block_content>}</block></while>
				<if_stmt><if>if <condition>(<expr><name>plist</name> <operator>||</operator> <name>plist2</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"RETURN parameter '%s %s' != '%s %s'"</literal></expr></argument>,
									 <argument><expr><ternary><condition><expr><name>plist</name></expr> ?</condition><then> <expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"\"\""</literal></expr></else></ternary></expr></argument>,
									 <argument><expr><ternary><condition><expr><name>plist</name></expr> ?</condition><then> <expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary></expr></argument>,
									 <argument><expr><ternary><condition><expr><name>plist2</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name><name>plist2</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><name><name>plist2</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><literal type="string">"\"\""</literal></expr></else></ternary></expr></argument>,
									 <argument><expr><ternary><condition><expr><name>plist2</name></expr> ?</condition><then> <expr><name><name>plist2</name><operator>-&gt;</operator><name>type</name></name></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name> <operator>=</operator> <name>returns</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name>returns</name></expr>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * if plist-&gt;name is not null and empty string,
					 * then use that name
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator>
							<literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
							<literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"\"\""</literal></expr></argument>)</argument_list></call></expr> )</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<comment type="block">/*
					 * else We need generate a name anyway
					 */</comment>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Manufacture a name for a column based on default
						 * naming rules.
						 */</comment>
						<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>default_return_names</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>]</index><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_LEN</name></expr></argument>, <argument><expr><literal type="string">"parameter%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>name</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>copyscalar</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<macro><name>XFINALLY</name></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>result2</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>tmp1</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>tmp2</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>tmp3</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>tmp3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block>
	<expr_stmt><expr><name>XTRY_END</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mapred_run_document</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_olist_t</name> <modifier>*</modifier></type><name>olist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>boolean</name></type>         <name>done</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>boolean</name></type>         <name>executes</name></decl>;</decl_stmt>

	<comment type="block">/* Ignore NOTICE messages from database */</comment>
	<expr_stmt><expr><call><name>PQsetNoticeReceiver</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>ignore_notice_handler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Establish a name-prefix for temporary objects */</comment>
	<expr_stmt><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"mapreduce_%d_"</literal></expr></argument>, <argument><expr><call><name>PQbackendPID</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * Resolution of dependecies was defered until now so that
	 * a database connection could be available to look up any
	 * dependencies that are not defined within the YAML document.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  - Resolving Dependencies:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>mapred_resolve_dependencies</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"    - DONE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>XTRY</name></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * By running things within a transaction we can effectively
		 * obscure the mapreduce sql definitions.  They could still
		 * be exposed by a savy user via mapreduce views that access
		 * the catalog tables, but it's a cleaner method of handling
		 * things.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"BEGIN TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_SQL_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* With dependencies resolved we can now try creating objects */</comment>
		<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  - Creating Objects\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * we don't try to create any executes until all non-executes are
		 * successfully created
		 */</comment>
		<expr_stmt><expr><name>executes</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<do>do
		<block>{<block_content>
			<decl_stmt><decl><type><name>boolean</name></type> <name>progress</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We keep a buffer of errors during parsing, and display them at
			 * the end if they haven't been resolved.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name> <operator>=</operator> <call><name>makebuffer</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>bufreset</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Loop through the objects, creating each in turn.
			 * If an object has dependencies that have not been created yet
			 * it will return false and we will make additional passes through
			 * the object list
			 */</comment>
			<expr_stmt><expr><name>done</name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>olist</name> <operator>=</operator> <name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr>;</init> <condition><expr><name>olist</name></expr>;</condition> <incr><expr><name>olist</name> <operator>=</operator> <name><name>olist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><name><name>olist</name><operator>-&gt;</operator><name>object</name></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>created</name></name> <operator>&amp;&amp;</operator>
					<operator>(</operator><name>executes</name> <operator>||</operator> <name><name>obj</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>MAPRED_EXECUTION</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>MAPRED_ADT</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"    - %s:\n"</literal></expr></argument>,
								<argument><expr><name><name>mapred_kind_name</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"       NAME: %s\n"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mapred_create_object</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>progress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * If all non-execute objects have been created then switch over
			 * and start creating the execution jobs
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>done</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>executes</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>executes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we looped through the list, we are not done, and no progress
			 * was made then we have an infinite cycle and should probably stop.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>progress</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name> <operator>&amp;&amp;</operator> <name><name>doc</name><operator>-&gt;</operator><name>errors</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>errors</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>,
					   <argument><expr><literal type="string">"Unable to make forward progress creating objects\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

		</block_content>}</block> while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

		<comment type="block">/* objects created, execute queries */</comment>
		<expr_stmt><expr><call><name>mapred_run_queries</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<macro><name>XCATCH</name><argument_list>(<argument>MAPRED_SQL_ERROR</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"    - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XRERAISE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<macro><name>XFINALLY</name></macro>
	<block>{<block_content>
		<comment type="block">/* Remove all the objects that we created */</comment>
		<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>||</operator> <name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>olist</name> <operator>=</operator> <name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr>;</init> <condition><expr><name>olist</name></expr>;</condition> <incr><expr><name>olist</name> <operator>=</operator> <name><name>olist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mapred_remove_object</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name><name>olist</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>||</operator> <name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We always commit the transaction, even on failure since the failure
		 * may have occured after we generated some output tables and we want
		 * to keep the partial results.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"COMMIT TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"    - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>XTRY_END</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>mapred_resolve_dependencies</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mapred_olist_t</name>     <modifier>*</modifier></type><name>olist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>                 <name>exec_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Walk the list of objects */</comment>
	<for>for <control>(<init><expr><name>olist</name> <operator>=</operator> <name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr>;</init> <condition><expr><name>olist</name></expr>;</condition> <incr><expr><name>olist</name> <operator>=</operator> <name><name>olist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>mapred_resolve_object</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name><name>olist</name><operator>-&gt;</operator><name>object</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>mapred_resolve_object</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>,
						   <parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>exec_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mapred_olist_t</name>  <modifier>*</modifier></type><name>newlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>   <comment type="block">/* sub-object */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>           <name>len</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Objects with no dependencies */</comment>
		<case>case <expr><name>MAPRED_OUTPUT</name></expr>:</case>
		<case>case <expr><name>MAPRED_ADT</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>MAPRED_INPUT</name></expr>:</case>
			<comment type="block">/*
			 * For FILE/GPFDIST/EXEC inputs we will create a name-prefixed
			 * version of the object to prevent name collisions, and then
			 * create a second temporary view over the external table to
			 * support access to the input by "name".  This involves creating
			 * a second copy of the input which we place directly after the
			 * original input in the document object list.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_INPUT_GPFDIST</name> <operator>||</operator>
				<name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_INPUT_FILE</name>    <operator>||</operator>
				<name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_INPUT_EXEC</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>newinput</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_olist_t</name>  <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>newinput</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>newinput</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newinput</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>MAPRED_INPUT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newinput</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>newinput</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newinput</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>MAPRED_INPUT_QUERY</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newinput</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>desc</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>newinput</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
						 <argument><expr><literal type="string">"select * from %s%s"</literal></expr></argument>,
						 <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Find parent input in the doclist and add the new object
				 * immediately after it.
				 */</comment>
				<for>for <control>(<init><expr><name>parent</name> <operator>=</operator> <name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr>;</init>
					 <condition><expr><name>parent</name> <operator>&amp;&amp;</operator> <name><name>parent</name><operator>-&gt;</operator><name>object</name></name> <operator>!=</operator> <name>obj</name></expr>;</condition>
					 <incr><expr><name>parent</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_olist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <name>newinput</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>newlist</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>


		<case>case <expr><name>MAPRED_MAPPER</name></expr>:</case>
		<case>case <expr><name>MAPRED_TRANSITION</name></expr>:</case>
		<case>case <expr><name>MAPRED_COMBINER</name></expr>:</case>
		<case>case <expr><name>MAPRED_FINALIZER</name></expr>:</case>


			<comment type="block">/*
			 * If the function is an internal function then we try to resolve
			 * the function by looking it up in the catalog.
			 */</comment>
			<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>internal_returns</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>internal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>internal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>lookup_function_in_catalog</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<comment type="block">/* ??? */</comment>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>

			<comment type="block">/*
			 * The function types may manufacture a dependency on an adt,
			 * but have no other dependencies.
			 */</comment>
			<if type="elseif">else if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>MAPRED_ADT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">7</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s%s_rtype"</literal></expr></argument>,
						 <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>adt</name><operator>.</operator><name>returns</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>rtype</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>rtype</name><operator>.</operator><name>object</name></name> <operator>=</operator> <name>sub</name></expr>;</expr_stmt>

				<comment type="block">/* Add the ADT to the list of document objects */</comment>
				<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_olist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <name>sub</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>newlist</name></expr>;</expr_stmt>

				<comment type="block">/* And resolve the sub-object */</comment>
				<expr_stmt><expr><call><name>mapred_resolve_object</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>exec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>rtype</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>rtype</name><operator>.</operator><name>object</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>


		<case>case <expr><name>MAPRED_REDUCER</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * If we have a function, but no object then we assume that it is
			 * a database function.  Create a dummy object to handle this case.
			 */</comment>
			<expr_stmt><expr><call><name>mapred_resolve_ref</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>transition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>transition</name><operator>.</operator><name>name</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>transition</name><operator>.</operator><name>object</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>transition</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>MAPRED_TRANSITION</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>line</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>transition</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_olist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <name>sub</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>newlist</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>transition</name><operator>.</operator><name>object</name></name> <operator>=</operator> <name>sub</name></expr>;</expr_stmt>

				<comment type="block">/* And resolve the sub-object */</comment>
				<expr_stmt><expr><call><name>mapred_resolve_object</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>exec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>mapred_resolve_ref</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>combiner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>combiner</name><operator>.</operator><name>name</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>combiner</name><operator>.</operator><name>object</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>combiner</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>MAPRED_COMBINER</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>line</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>combiner</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_olist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <name>sub</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>newlist</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>combiner</name><operator>.</operator><name>object</name></name> <operator>=</operator> <name>sub</name></expr>;</expr_stmt>

				<comment type="block">/* And resolve the sub-object */</comment>
				<expr_stmt><expr><call><name>mapred_resolve_object</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>exec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>mapred_resolve_ref</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>name</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>object</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>MAPRED_FINALIZER</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>line</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_olist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <name>sub</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>newlist</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>object</name></name> <operator>=</operator> <name>sub</name></expr>;</expr_stmt>

				<comment type="block">/* And resolve the sub-object */</comment>
				<expr_stmt><expr><call><name>mapred_resolve_object</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>exec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>


		<case>case <expr><name>MAPRED_TASK</name></expr>:</case>
		<case>case <expr><name>MAPRED_EXECUTION</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * Resolving a task may require recursion to resolve other
			 * tasks to work out parameter lists.  We keep track of
			 * our resolution state in order to detect potential
			 * infinite recursion issues.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>mapred_task_resolved</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/* Assign a name to anonymous executions */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>size_t</name></type>     <name>len</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>execute</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* 10 characters for max int digits, 4 for "run_" */</comment>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%srun_%d"</literal></expr></argument>,
						 <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><operator>++</operator><operator>(</operator><operator>*</operator><name>exec_count</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Check for infinite recursion */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>mapred_task_resolving</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Infinite recursion detected while "</literal>
								 <literal type="string">"trying to resove TASK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>mapred_task_resolving</name></expr>;</expr_stmt>

			<comment type="block">/* Validate object types */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>input</name><operator>.</operator><name>name</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mapred_resolve_ref</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>input</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt>

				<comment type="block">/* If we can't find the input, throw an error */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sub</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Can't find INPUT object */</comment>
					<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"SOURCE '%s' not found in document"</literal></expr></argument>,
									 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>input</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object Resolution Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * The input must either be an INPUT or a TASK
				 */</comment>
				<switch>switch <condition>(<expr><name><name>sub</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>MAPRED_INPUT</name></expr>:</case>
						<break>break;</break>

					<case>case <expr><name>MAPRED_TASK</name></expr>:</case>
						<comment type="block">/* This objects input is the sub objects output */</comment>
						<expr_stmt><expr><call><name>mapred_resolve_object</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>exec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

						<comment type="block">/* Otherwise generate an error */</comment>
					<default>default:</default>

						<comment type="block">/* SOURCE wasn't an INPUT */</comment>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"SOURCE '%s' is neither an INPUT nor a TASK"</literal></expr></argument>,
										 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>input</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object Resolution Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>name</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mapred_resolve_ref</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sub</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Create an internal map function */</comment>
					<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>MAPRED_MAPPER</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>line</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_olist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <name>sub</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newlist</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>newlist</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>object</name></name> <operator>=</operator> <name>sub</name></expr>;</expr_stmt>

					<comment type="block">/* And resolve the sub-object */</comment>
					<expr_stmt><expr><call><name>mapred_resolve_object</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>exec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Allow any function type */</comment>
					<switch>switch <condition>(<expr><name><name>sub</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>MAPRED_MAPPER</name></expr>:</case>
						<case>case <expr><name>MAPRED_TRANSITION</name></expr>:</case>
						<case>case <expr><name>MAPRED_COMBINER</name></expr>:</case>
						<case>case <expr><name>MAPRED_FINALIZER</name></expr>:</case>
							<break>break;</break>

						<default>default:</default>
							<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"MAP '%s' is not a MAP object"</literal></expr></argument>,
											 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object Resolution Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>name</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mapred_resolve_ref</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sub</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* FIXME: non-yaml reducers */</comment>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>sub</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MAPRED_REDUCER</name></expr>)</condition>
				<block>{<block_content>   <comment type="block">/* Validate Reducer */</comment>
					<expr_stmt><expr><call><name>mapred_resolve_object</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>exec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>   <comment type="block">/* It's an object, but not a REDUCER */</comment>
					<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"REDUCE '%s' is not a REDUCE object"</literal></expr></argument>,
									 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object Resolution Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>output</name><operator>.</operator><name>name</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>mapred_resolve_ref</name><argument_list>(<argument><expr><name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>output</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>sub</name> <operator>&amp;&amp;</operator> <name><name>sub</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>MAPRED_OUTPUT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"TARGET '%s' is not an OUTPUT object"</literal></expr></argument>,
									 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>output</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object Resolution Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sub</name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>output</name><operator>.</operator><name>name</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"TARGET '%s' is not defined in "</literal>
									 <literal type="string">"document"</literal></expr></argument>,
									 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>output</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object Resolution Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* clear resolving bit and set resolved bit */</comment>
			<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>!</operator><name>mapred_task_resolving</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>mapred_task_resolved</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>mapred_obj_debug</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * mapred_setup_columns -
 *   setup column lists (input, output, grouping, etc)
 *
 *   This is usually able to be determined directly from the YAML,
 *   but for some things (defined in the database rather than in
 *   the YAML, eg QUERY INPUTS) we can not determine the columns
 *   until the object has been created.  Which can trickle down to
 *   any object that depends on it.
 *
 *   For this reason we don't setup the columns during the parse phase,
 *   but rather just before or just after we actually create the object
 *   once we know that all the dependencies have already been created.
 */</comment>
<function><type><name>void</name></type> <name>mapred_setup_columns</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>        <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* switch based on object type */</comment>
	<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>MAPRED_ADT</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>MAPRED_INPUT</name></expr>:</case>

			<comment type="block">/*
			 * Should be called after creation, otherwise catalog queries
			 * could fail.
			 */</comment>
			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>created</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* setup the column list for database defined inputs */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_INPUT_TABLE</name> <operator>||</operator>
				<name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_INPUT_QUERY</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This gets the ordered list of columns for the first
				 * input of the given name in the user's search path.
				 */</comment>
				<decl_stmt><decl><type><name>buffer_t</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><call><name>makebuffer</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
					   <argument><expr><literal type="string">"SELECT  attname, "</literal>
					   <literal type="string">"        pg_catalog.format_type(atttypid, atttypmod)\n"</literal>
					   <literal type="string">"FROM    pg_catalog.pg_attribute\n"</literal>
					   <literal type="string">"WHERE   attnum &gt; 0 AND attrelid = lower('"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_INPUT_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
					   <argument><expr><literal type="string">"')::regclass\n"</literal>
					   <literal type="string">"ORDER BY   -attnum;\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>&amp;&amp;</operator>
					<call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>mapred_plist_t</name> <modifier>*</modifier></type><name>newitem</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

					<comment type="block">/* Destroy any previous default values we setup */</comment>
					<expr_stmt><expr><call><name>mapred_destroy_plist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>columns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * The columns were sorted reverse order above so
					 * the list can be generated back -&gt; front
					 */</comment>
					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<comment type="block">/* Add the column to the list */</comment>
						<expr_stmt><expr><name>newitem</name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newitem</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>newitem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newitem</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>newitem</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newitem</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>columns</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>columns</name></name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_INPUT_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>desc</name></name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Table '%s' contains no rows"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>OBJ_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call> <operator>||</operator>
							 <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>SCHEMA_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call></expr> )</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Table '%s' not found"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Table '%s' unknown error: %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>


		<case>case <expr><name>MAPRED_OUTPUT</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>MAPRED_MAPPER</name></expr>:</case>
		<case>case <expr><name>MAPRED_TRANSITION</name></expr>:</case>
		<case>case <expr><name>MAPRED_COMBINER</name></expr>:</case>
		<case>case <expr><name>MAPRED_FINALIZER</name></expr>:</case>
			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>


		<case>case <expr><name>MAPRED_REDUCER</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>transition</name> <init>= <expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>transition</name><operator>.</operator><name>object</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>transition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>transition</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>parameters</name></name> <operator>=</operator>
				<name><name>transition</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Use the return result of:
			 *   1) The finalizer
			 *   2) The combiner, or
			 *   3) The transition
			 *
			 * in that order, if the return is not derivable then
			 * fall into the default value of a single text column
			 * named "value"
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>combiner</name><operator>.</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>combiner</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>transition</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>returns</name></name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>returns</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If unable to determine the returns based on the reducer
				 * components (generally due to use of SQL functions) then
				 * use the default of a single text column named "value".
				 */</comment>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>returns</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>returns</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <literal type="string">"value"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>returns</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="string">"text"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>returns</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>


		<case>case <expr><name>MAPRED_TASK</name></expr>:</case>
		<case>case <expr><name>MAPRED_EXECUTION</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>mapred_plist_t</name> <modifier>*</modifier></type><name>scan</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>mapred_plist_t</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * The input must either be an INPUT or a TASK
			 */</comment>
			<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>input</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name><name>sub</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>MAPRED_INPUT</name></expr>:</case>
					<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>parameters</name></name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>columns</name></name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>MAPRED_TASK</name></expr>:</case>
					<comment type="block">/* union the input tasks returns and grouping */</comment>
					<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name></expr>;</init>
						 <condition><expr><name>scan</name></expr>;</condition>
						 <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>parameters</name></name> <operator>=</operator>
								<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>parameters</name></name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator>
								<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>last</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></for>
					<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name></name></expr>;</init>
						 <condition><expr><name>scan</name></expr>;</condition>
						 <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>parameters</name></name> <operator>=</operator>
								<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>parameters</name></name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator>
								<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>last</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></for>
					<break>break;</break>

				<default>default:</default>
					<comment type="block">/* Should have already been validated */</comment>
					<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>name</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sub</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* FIXME: Lookup function in database */</comment>
					<comment type="block">/* for now... do nothing */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Allow any function type */</comment>
					<switch>switch <condition>(<expr><name><name>sub</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>MAPRED_MAPPER</name></expr>:</case>
						<case>case <expr><name>MAPRED_TRANSITION</name></expr>:</case>
						<case>case <expr><name>MAPRED_COMBINER</name></expr>:</case>
						<case>case <expr><name>MAPRED_FINALIZER</name></expr>:</case>
							<break>break;</break>

						<default>default:</default>
							<comment type="block">/* Should have already been validated */</comment>
							<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>name</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>mapred_clist_t</name> <modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_plist_t</name> <modifier>*</modifier></type><name>source</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * The grouping columns for a task are the columns produced
				 * by the input/mapper that are not consumed by the reducer.
				 *
				 * A special exception is made for a column named "key" which
				 * is always a grouping column.
				 *
				 * FIXME: deal with non-yaml map functions
				 *
				 * FIXME: deal with KEY specifications
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>object</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>object</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>parameters</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sub</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * The output of a built in function is defined to be
					 * "value", with an input of "value", everything else
					 * is defined to be a grouping column.
					 */</comment>
					<expr_stmt><expr><name>last</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>source</name></expr>;</init> <condition><expr><name>scan</name></expr>;</condition> <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name> <operator>=</operator>
									<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name></expr>;</expr_stmt>
							</block_content>}</block></if>
							<else>else
							<block>{<block_content>
								<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator>
									<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>last</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
							</block_content>}</block></else></if_stmt>
							<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Validate Reducer */</comment>
					<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MAPRED_REDUCER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * source is the set of input columns that the reducer has
					 * to work with.
					 *
					 * Loop the reducer "keys" clause to determine what keys are
					 * present.
					 */</comment>
					<expr_stmt><expr><name>last</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>keys</name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>keys</name></name></expr>;</init> <condition><expr><name>keys</name></expr>;</condition> <incr><expr><name>keys</name> <operator>=</operator> <name><name>keys</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
					<block>{<block_content>
						<comment type="block">/*
						 * If there is a '*' in the keys then it catches all
						 * unreferenced columns.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>keys</name><operator>-&gt;</operator><name>value</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>keys</name><operator>-&gt;</operator><name>value</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Add all sources not found in either parameters,
							 * or explicitly mentioned in keys
							 */</comment>
							<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>source</name></expr>;</init> <condition><expr><name>scan</name></expr>;</condition> <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
							<block>{<block_content>
								<decl_stmt><decl><type><name>mapred_plist_t</name> <modifier>*</modifier></type><name>pscan</name></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>mapred_clist_t</name> <modifier>*</modifier></type><name>kscan</name></decl>;</decl_stmt>

								<for>for <control>(<init><expr><name>pscan</name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>parameters</name></name></expr>;</init>
									 <condition><expr><name>pscan</name></expr>;</condition>
									 <incr><expr><name>pscan</name> <operator>=</operator> <name><name>pscan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
								<block>{<block_content>
									<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pscan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
										<break>break;</break></block_content></block></if></if_stmt>
								</block_content>}</block></for>
								<if_stmt><if>if <condition>(<expr><name>pscan</name></expr>)</condition><block type="pseudo"><block_content>
									<continue>continue;</continue></block_content></block></if></if_stmt>   <comment type="block">/* found in parameters */</comment>
								<for>for <control>(<init><expr><name>kscan</name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>keys</name></name></expr>;</init>
									 <condition><expr><name>kscan</name></expr>;</condition>
									 <incr><expr><name>kscan</name> <operator>=</operator> <name><name>kscan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
								<block>{<block_content>
									<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>kscan</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
										<break>break;</break></block_content></block></if></if_stmt>
								</block_content>}</block></for>
								<if_stmt><if>if <condition>(<expr><name>kscan</name></expr>)</condition><block type="pseudo"><block_content>
									<continue>continue;</continue></block_content></block></if></if_stmt>   <comment type="block">/* found in keys */</comment>

								<comment type="block">/* we have an unmatched source, add to grouping */</comment>
								<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name> <operator>=</operator>
										<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name></expr>;</expr_stmt>
								</block_content>}</block></if>
								<else>else
								<block>{<block_content>
									<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator>
										<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>last</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
								</block_content>}</block></else></if_stmt>
								<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
							</block_content>}</block></for>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* Look for the referenced key in the source list */</comment>
							<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>source</name></expr>;</init> <condition><expr><name>scan</name></expr>;</condition> <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
								<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>keys</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<comment type="block">/* we have a match, add the key to grouping */</comment>
									<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name></expr>)</condition>
									<block>{<block_content>
										<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name> <operator>=</operator>
											<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name></expr>;</expr_stmt>
									</block_content>}</block></if>
									<else>else
									<block>{<block_content>
										<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator>
											<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>last</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
									</block_content>}</block></else></if_stmt>
									<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
									<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
									<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
									<break>break;</break>
								</block_content>}</block></if></if_stmt></block_content></block></for>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If there is a reducer then the "returns" columns are the
			 * output of the reducer, and must be unioned with the grouping
			 * columns for final output.
			 *
			 * If there is no reducer then the returns columns are the
			 * returns columns of the mapper or the input
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>name</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If it is a built in function then we'll just fall into the
				 * default of a single text column named "value".
				 */</comment>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name></name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>name</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>sub</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name></name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>parameters</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If unable to determine the returns based on the reducer
				 * components (generally due to use of SQL functions) then
				 * use the default of a single text column named "value".
				 */</comment>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name></name> <operator>=</operator> <call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <literal type="string">"value"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="string">"text"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mapred_resolve_ref</name><parameter_list>(<parameter><decl><type><name>mapred_olist_t</name> <modifier>*</modifier></type><name>olist</name></decl></parameter>, <parameter><decl><type><name>mapred_reference_t</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Scan the list of objects until we find one with a matching name */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>olist</name></expr>;</condition> <incr><expr><name>olist</name> <operator>=</operator> <name><name>olist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <name><name>olist</name><operator>-&gt;</operator><name>object</name></name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Some basic destructors */</comment>
<function><type><name>void</name></type> <name>mapred_destroy_object</name><parameter_list>(<parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>objh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We are passed a handle to the object, get the actual pointer and point
	 * the handle to NULL so that it is not stale once we free the list below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>objh</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>objh</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>obj</name> <operator>=</operator> <operator>*</operator><name>objh</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>objh</name> <operator>=</operator> <operator>(</operator><name>mapred_object_t</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* What fields are valid is dependent on what kind of object it is */</comment>
	<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>MAPRED_NO_KIND</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>MAPRED_DOCUMENT</name></expr>:</case>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>document</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>document</name><operator>.</operator><name>database</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>document</name><operator>.</operator><name>user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>document</name><operator>.</operator><name>host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>mapred_destroy_olist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>document</name><operator>.</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>mapred_destroy_olist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>document</name><operator>.</operator><name>execute</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>MAPRED_INPUT</name></expr>:</case>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>delimiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>mapred_destroy_clist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>mapred_destroy_plist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>columns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>MAPRED_OUTPUT</name></expr>:</case>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>MAPRED_MAPPER</name></expr>:</case>
		<case>case <expr><name>MAPRED_TRANSITION</name></expr>:</case>
		<case>case <expr><name>MAPRED_COMBINER</name></expr>:</case>
		<case>case <expr><name>MAPRED_FINALIZER</name></expr>:</case>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>mapred_destroy_plist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if<condition>( <expr><name><name>obj</name><operator>-&gt;</operator><name>internal</name></name> <operator>&amp;&amp;</operator>
					<name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>internal_returns</name></name> <operator>!=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr> )</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>mapred_destroy_plist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>internal_returns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>mapred_destroy_plist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>MAPRED_REDUCER</name></expr>:</case>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>transition</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>combiner</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>initialize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>MAPRED_TASK</name></expr>:</case>
		<case>case <expr><name>MAPRED_EXECUTION</name></expr>:</case>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>input</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>output</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/*
		 * ADT just borrowed the parameter list from the owning function,
		 * so it has nothing else to delete.
		 */</comment>
		<case>case <expr><name>MAPRED_ADT</name></expr>:</case>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mapred_destroy_olist</name><parameter_list>(<parameter><decl><type><name>mapred_olist_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>olisth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mapred_olist_t</name> <modifier>*</modifier></type><name>olist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_olist_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We are passed a handle to the olist, get the actual pointer and point
	 * the handle to NULL so that it is not stale once we free the list below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>olisth</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>olisth</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>olist</name> <operator>=</operator> <operator>*</operator><name>olisth</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>olisth</name> <operator>=</operator> <operator>(</operator><name>mapred_olist_t</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Walk the list destroying each item as we come to it. */</comment>
	<while>while <condition>(<expr><name>olist</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>mapred_destroy_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>olist</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>olist</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>olist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>olist</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>mapred_destroy_clist</name><parameter_list>(<parameter><decl><type><name>mapred_clist_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>clisth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mapred_clist_t</name> <modifier>*</modifier></type><name>clist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_clist_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We are passed a handle to the olist, get the actual pointer and point
	 * the handle to NULL so that it is not stale once we free the list below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>clisth</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>clisth</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>clist</name> <operator>=</operator> <operator>*</operator><name>clisth</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>clisth</name> <operator>=</operator> <operator>(</operator><name>mapred_clist_t</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Walk the list destroying each item as we come to it. */</comment>
	<while>while <condition>(<expr><name>clist</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>clist</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>clist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>clist</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>mapred_destroy_plist</name><parameter_list>(<parameter><decl><type><name>mapred_plist_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>plisth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mapred_plist_t</name> <modifier>*</modifier></type><name>plist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_plist_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We are passed a handle to the olist, get the actual pointer and point
	 * the handle to NULL so that it is not stale once we free the list below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plisth</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>plisth</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>plist</name> <operator>=</operator> <operator>*</operator><name>plisth</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>plisth</name> <operator>=</operator> <operator>(</operator><name>mapred_plist_t</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Walk the list destroying each item as we come to it. */</comment>
	<while>while <condition>(<expr><name>plist</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>scalarfree</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>plist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>plist</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>




<comment type="block">/* -------------------------------------------------------------------------- */</comment>
<comment type="block">/* Functions that get things done                                             */</comment>
<comment type="block">/* -------------------------------------------------------------------------- */</comment>
<function><type><name>void</name></type> <name>mapred_run_queries</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mapred_olist_t</name>  <modifier>*</modifier></type><name>olist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_plist_t</name>  <modifier>*</modifier></type><name>columns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>output</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>        <modifier>*</modifier></type><name>result</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>            <modifier>*</modifier></type><name>outfile</name> <init>= <expr><name>stdout</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>buffer_t</name>        <modifier>*</modifier></type><name>buffer</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>XTRY</name></macro>
	<block>{<block_content>
		<comment type="block">/* allocates 512 bytes, extending by 512 bytes if we run out. */</comment>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>makebuffer</name><argument_list>(<argument><expr><literal type="number">512</literal></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Loop through all objects */</comment>
		<for>for <control>(<init><expr><name>olist</name> <operator>=</operator> <name><name>doc</name><operator>-&gt;</operator><name>objects</name></name></expr>;</init> <condition><expr><name>olist</name></expr>;</condition> <incr><expr><name>olist</name> <operator>=</operator> <name><name>olist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MAPRED_EXECUTION</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>boolean</name></type> <name>exists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Reset the buffer from any previous executions */</comment>
				<expr_stmt><expr><call><name>bufreset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>output</name> <operator>=</operator> <name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>output</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 *  [CREATE TABLE &lt;name&gt; AS ]
				 *    SELECT * FROM &lt;name&gt;
				 *    ORDER BY &lt;column-list&gt;
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>output</name> <operator>&amp;&amp;</operator> <name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_OUTPUT_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* does the table already exist? */</comment>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
						   <argument><expr><literal type="string">"SELECT n.nspname \n"</literal>
						   <literal type="string">"FROM   pg_catalog.pg_class c JOIN \n"</literal>
						   <literal type="string">"       pg_catalog.pg_namespace n on \n"</literal>
						   <literal type="string">"       (c.relnamespace = n.oid) \n"</literal>
						   <literal type="string">"WHERE  n.nspname = ANY(current_schemas(true)) \n"</literal>
						   <literal type="string">"  AND  c.relname = lower('"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>&amp;&amp;</operator>
						<call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>exists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>bufreset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>exists</name> <operator>&amp;&amp;</operator> <name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>mode</name></name> <operator>==</operator> <name>MAPRED_OUTPUT_MODE_REPLACE</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"DROP TABLE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT mapreduce_save"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"RELEASE SAVEPOINT mapreduce_save"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* rollback to savepoint */</comment>
							<expr_stmt><expr><call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK TO SAVEPOINT mapreduce_save"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"RELEASE SAVEPOINT mapreduce_save"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"   - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Error: %s\n"</literal></expr></argument>,
									<argument><expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="string">"Table '%s' can't be replaced"</literal></expr></argument>,
											 <argument><expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<expr_stmt><expr><call><name>bufreset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>exists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Handle Explain for OUTPUT TABLE */</comment>
					<if_stmt><if>if <condition>(<expr><name>global_explain_flag</name> <operator>&amp;</operator> <name>global_analyze</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"EXPLAIN ANALYZE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>global_explain_flag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"EXPLAIN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>mode</name></name> <operator>==</operator> <name>MAPRED_OUTPUT_MODE_APPEND</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* exists, mode is neither replace or append =&gt; error */</comment>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="string">"Table '%s' already exists"</literal></expr></argument>,
										 <argument><expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<comment type="block">/* Handle Explain for non-table output */</comment>
				<if type="elseif">else if <condition>(<expr><name>global_explain_flag</name> <operator>&amp;</operator> <name>global_analyze</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"EXPLAIN ANALYZE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>global_explain_flag</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"EXPLAIN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * add the DISTRIBUTED BY clause for output tables
				 * OR, the ORDER BY clause for other output formats
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>output</name> <operator>&amp;&amp;</operator> <name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_OUTPUT_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If there are no key columns then leave off the
					 * distributed by clause and let the server choose.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>exists</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

					<if type="elseif">else if <condition>(<expr><name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" DISTRIBUTED BY ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>columns</name> <operator>=</operator> <name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name></expr>;</expr_stmt>
						<while>while <condition>(<expr><name>columns</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>columns</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>columns</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>columns</name> <operator>=</operator> <name><name>columns</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
						</block_content>}</block></while>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * don't have any hints for what the distribution keys
						 * should be, so we do nothing and let the database
						 * decide
						 */</comment>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name></name> <operator>||</operator>
						<name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>columns</name> <operator>=</operator> <name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name></expr>;</expr_stmt>
						<while>while <condition>(<expr><name>columns</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>columns</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>columns</name><operator>-&gt;</operator><name>next</name></name> <operator>||</operator> <name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>columns</name> <operator>=</operator> <name><name>columns</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
						</block_content>}</block></while>
						<expr_stmt><expr><name>columns</name> <operator>=</operator> <name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt>
						<while>while <condition>(<expr><name>columns</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>columns</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>columns</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>columns</name> <operator>=</operator> <name><name>columns</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
						</block_content>}</block></while>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Tell the user what job we are running */</comment>
				<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  - RUN: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>||</operator> <name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>olist</name><operator>-&gt;</operator><name>object</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/* But we only execute it if we are not in "print-only" mode */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>global_print_flag</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* If we have an output file, open it for write now */</comment>
					<if_stmt><if>if <condition>(<expr><name>output</name> <operator>&amp;&amp;</operator> <name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_OUTPUT_FILE</name></expr>)</condition>
					<block>{<block_content>
						<switch>switch <condition>(<expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>mode</name></name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>MAPRED_OUTPUT_MODE_NONE</name></expr>:</case>
								<comment type="block">/* check if the file exists */</comment>
								<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="string">"file '%s' already exists"</literal></expr></argument>,
													 <argument><expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								</block_content>}</block></if></if_stmt>
								<comment type="block">/* Fallthrough */</comment>

							<case>case <expr><name>MAPRED_OUTPUT_MODE_REPLACE</name></expr>:</case>
								<expr_stmt><expr><name>outfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>

							<case>case <expr><name>MAPRED_OUTPUT_MODE_APPEND</name></expr>:</case>
								<expr_stmt><expr><name>outfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>, <argument><expr><literal type="string">"ab"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>

							<default>default:</default>
								<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></switch>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outfile</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="string">"could not open file '%s' for write"</literal></expr></argument>,
											 <argument><expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>outfile</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * Enable notices for user queries since they may contain
					 * debugging info.
					 */</comment>
					<expr_stmt><expr><call><name>PQsetNoticeReceiver</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>print_notice_handler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PQsetNoticeReceiver</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>ignore_notice_handler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Output is STDOUT or FILE */</comment>
						<case>case  <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name>PQprintOpt</name></type> <name>options</name></decl>;</decl_stmt>
							<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>options</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/*
							 * Formatting:
							 *   STDOUT = fancy formatting
							 *   FILE   = plain formatting
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name>outfile</name> <operator>==</operator> <name>stdout</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name><name>options</name><operator>.</operator><name>header</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>options</name><operator>.</operator><name>align</name></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>options</name><operator>.</operator><name>fieldSep</name></name>  <operator>=</operator> <literal type="string">"|"</literal></expr>;</expr_stmt>
							</block_content>}</block></if>
							<if type="elseif">else if <condition>(<expr><name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>delimiter</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name><name>options</name><operator>.</operator><name>fieldSep</name></name> <operator>=</operator> <name><name>output</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>output</name><operator>.</operator><name>delimiter</name></name></expr>;</expr_stmt>
							</block_content>}</block></if>
							<else>else
							<block>{<block_content>
								<comment type="block">/* "\t" is our default delimiter */</comment>
								<expr_stmt><expr><name><name>options</name><operator>.</operator><name>fieldSep</name></name>  <operator>=</operator> <literal type="string">"\t"</literal></expr>;</expr_stmt>
							</block_content>}</block></else></if_stmt>

							<expr_stmt><expr><call><name>PQprint</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block>

						<comment type="block">/* OUTPUT is a table */</comment>
						<case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
							<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"DONE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>

						<comment type="block">/* An error of some kind */</comment>
						<default>default:</default>
							<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_SQL_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Execution Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></switch>
					<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>outfile</name> <operator>&amp;&amp;</operator> <name>outfile</name> <operator>!=</operator> <name>stdout</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>outfile</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
	<macro><name>XFINALLY</name></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>outfile</name> <operator>&amp;&amp;</operator> <name>outfile</name> <operator>!=</operator> <name>stdout</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>outfile</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>XTRY_END</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>boolean</name></type> <name>mapred_create_object</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>,
							 <parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mapred_clist_t</name> <modifier>*</modifier></type><name>clist</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_plist_t</name> <modifier>*</modifier></type><name>plist</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mapred_plist_t</name> <modifier>*</modifier></type><name>plist2</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>     <modifier>*</modifier></type><name>ckind</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>buffer_t</name>       <modifier>*</modifier></type><name>buffer</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>buffer_t</name>       <modifier>*</modifier></type><name>qbuffer</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>       <modifier>*</modifier></type><name>result</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If the object was created in a prior pass, then do nothing */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>created</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Otherwise attempt to create the object */</comment>
	<macro><name>XTRY</name></macro>
	<block>{<block_content>
		<comment type="block">/* allocates 1024 bytes, extending by 1024 bytes if we run out */</comment>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>makebuffer</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>MAPRED_INPUT</name></expr>:</case>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>MAPRED_INPUT_TABLE</name></expr>:</case>
						<comment type="block">/* Nothing to actually create */</comment>
						<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>created</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>MAPRED_INPUT_FILE</name></expr>:</case>
					<case>case <expr><name>MAPRED_INPUT_GPFDIST</name></expr>:</case>
						<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* Allocate and produce buffer */</comment>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE EXTERNAL TABLE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>columns</name></name></expr>;</init>
							 <condition><expr><name>plist</name></expr>;</condition>
							 <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
						<block>{<block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"  LOCATION("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<for>for <control>(<init><expr><name>clist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>files</name></name></expr>;</init>
							 <condition><expr><name>clist</name></expr>;</condition>
							 <incr><expr><name>clist</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
						<block>{<block_content>
							<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>domain_port</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>path</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_INPUT_GPFDIST</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'gpfdist://"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'file://"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

							<comment type="block">/*
							 * The general syntax of a URL is    scheme://domain:port/path?query_string#fragment_id
							 * clist-&gt;value should contain just           domain:port/path?query_string#fragment_id
							 */</comment>
							<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>clist</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Failed to find '/' indicating start of path (%s)"</literal></expr></argument>,
												 <argument><expr><name><name>clist</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>,
									   <argument><expr><literal type="string">"Invalid INPUT source specification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>clist</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Missing domain and port before '/' indicating start of path (%s)"</literal></expr></argument>,
												 <argument><expr><name><name>clist</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>,
									   <argument><expr><literal type="string">"Invalid INPUT source specification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<expr_stmt><expr><name>domain_port</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>path</name>        <operator>=</operator> <name>p</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

							<comment type="block">/*
							 * Overwrite the / separating the domain:port from the path
							 * with a nul and move back one byte to check for a trailing ':'.
							 * We put the / back in when copying into the destination buffer.
							 */</comment>
							<expr_stmt><expr><operator>*</operator><name>p</name><operator>--</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Missing path after '/' (%s)"</literal></expr></argument>,
												 <argument><expr><name><name>clist</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>,
									   <argument><expr><literal type="string">"Invalid INPUT source specification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<comment type="block">/*
							 * We allow a trailing ':'  (e.g. host:/filepath)
							 * but we must not copy it into the external table url.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>domain_port</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Missing host before '/' (%s)"</literal></expr></argument>,
												 <argument><expr><name><name>clist</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>,
									   <argument><expr><literal type="string">"Invalid INPUT source specification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>domain_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"',\n           "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"')\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>format</name></name> <operator>==</operator> <name>MAPRED_FORMAT_CSV</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"  FORMAT 'CSV'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"  FORMAT 'TEXT'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>delimiter</name></name> <operator>||</operator>
							<name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>escape</name></name>    <operator>||</operator>
							<name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>quote</name></name>     <operator>||</operator>
							<name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>null</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" ( "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>delimiter</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"DELIMITER '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>delimiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"' "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>escape</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"ESCAPE '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>escape</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"' "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>quote</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"QUOTE '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>quote</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"' "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>null</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"NULL '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>null</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"' "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>error_limit</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>char</name></type> <name><name>intbuf</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></decl>;</decl_stmt>
							<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>intbuf</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
									 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>error_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\n  SEGMENT REJECT LIMIT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>intbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">";\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>MAPRED_INPUT_EXEC</name></expr>:</case>
						<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE EXTERNAL WEB TABLE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>columns</name></name></expr>;</init>
							 <condition><expr><name>plist</name></expr>;</condition>
							 <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
						<block>{<block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"EXECUTE '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>format</name></name> <operator>==</operator> <name>MAPRED_FORMAT_CSV</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"  FORMAT 'CSV'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"  FORMAT 'TEXT'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>delimiter</name></name> <operator>||</operator>
							<name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>quote</name></name>     <operator>||</operator>
							<name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>null</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" ( "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>delimiter</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"DELIMITER '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>delimiter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"' "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>quote</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"QUOTE '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>quote</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"' "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>null</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"NULL '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>null</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"' "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>error_limit</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>char</name></type> <name><name>intbuf</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></decl>;</decl_stmt>
							<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>intbuf</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
									 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>error_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\n  SEGMENT REJECT LIMIT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>intbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">";\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>MAPRED_INPUT_QUERY</name></expr>:</case>
						<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 *  CREATE TEMPORARY VIEW &lt;name&gt; AS
						 *  &lt;desc&gt;;
						 */</comment>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE TEMPORARY VIEW "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">";\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>MAPRED_INPUT_NONE</name></expr>:</case>
					<default>default:</default>
						<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
				<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>||</operator> <name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-- INPUT %s\n"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>MAPRED_OUTPUT</name></expr>:</case>
				<comment type="block">/*
				 * Outputs have no backend objects created directly.
				 * For output tables we may issue a create table as
				 * select, but that occurs at run-time.
				 */</comment>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>created</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mapred_setup_columns</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * The function types have different defaults and generate
				 * slightly different error messages, but basically do the
				 * same thing.
				 */</comment>
			<case>case <expr><name>MAPRED_MAPPER</name></expr>:</case>
			<case>case <expr><name>MAPRED_TRANSITION</name></expr>:</case>
			<case>case <expr><name>MAPRED_COMBINER</name></expr>:</case>
			<case>case <expr><name>MAPRED_FINALIZER</name></expr>:</case>
				<expr_stmt><expr><name>ckind</name> <operator>=</operator> <name><name>mapred_kind_name</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>]</index></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * 'kind' specific initialization accomplished above, now handle
				 * the generic function creation.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>||</operator> <name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-- %s %s\n"</literal></expr></argument>, <argument><expr><name>ckind</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Nothing to do if we already looked up the function in the
				 * catalog.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>created</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Non-internal functions should have these defined */</comment>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>mapred_setup_columns</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>rtype</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>NULL</name> <operator>==</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>internal_returns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * fill in the buffer:
				 *
				 *    CREATE FUNCTION &lt;name&gt;(&lt;parameters&gt;)
				 *    RETURNS [SETOF] &lt;rtype&gt; LANGUAGE &lt;lang&gt; AS
				 *    $$
				 *    &lt;body&gt;
				 *    $$ [STRICT] [IMMUTABLE];
				 *
				 */</comment>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE FUNCTION "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Handle parameter list */</comment>
				<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr>;</init>
					 <condition><expr><name>plist</name></expr>;</condition>
					 <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/* Handle Return clause */</comment>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">")\nRETURNS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>mode</name></name> <operator>==</operator> <name>MAPRED_MODE_MULTI</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"SETOF "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>rtype</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Handle LANGUAGE clause, every langauge but 'C' and 'SQL'
				 * has 'pl' prefixing it
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><literal type="string">"C"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><literal type="string">"SQL"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><literal type="string">"PL"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" LANGUAGE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" LANGUAGE pl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* python only has an untrusted form */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><literal type="string">"python"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"u"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Handle procedural language specific formatting for the
				 * function definition.
				 *
				 * C language functions are defined using the two parameter
				 * form:  AS "library", "function".
				 *
				 * Perl functions append the yaml file line number via a
				 *  #line declaration.
				 *
				 * Python functions try to append the yaml file line number
				 * by inserting a bunch of newlines.  (only works for runtime
				 * errors, not compiletime errors).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><literal type="string">"C"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"$$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>library</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"$$, $$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"$$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><literal type="string">"plperl"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>||</operator>
						 <operator>!</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><literal type="string">"perl"</literal></expr></argument>,   <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type> <name><name>lineno</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lineno</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"$$\n#line "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name><name>buffer</name><operator>-&gt;</operator><name>position</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"$$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><literal type="string">"plpython"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>||</operator>
						 <operator>!</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><literal type="string">"python"</literal></expr></argument>,   <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>language</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Python very stubborn about not letting you manually
					 * adjust line number.  So instead we take the stupid route
					 * and just insert N newlines.
					*/</comment>
					<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"$$\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>lineno</name></name><operator>-</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name><name>buffer</name><operator>-&gt;</operator><name>position</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"$$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Some generic other language, take our best guess */</comment>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"$$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"$$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* Handle options */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>mapred_function_strict</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" STRICT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>mapred_function_immutable</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" IMMUTABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* All done */</comment>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">";\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>MAPRED_REDUCER</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>transition</name> <init>= <expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>transition</name><operator>.</operator><name>object</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>combiner</name>   <init>= <expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>combiner</name><operator>.</operator><name>object</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>finalizer</name>  <init>= <expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>object</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>transition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>transition</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the reducer depends on an object that hasn't been created
				 * then return false, it will be resolved during a second pass
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>transition</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>transition</name><operator>-&gt;</operator><name>created</name></name><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name>combiner</name>   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>created</name></name><operator>)</operator>   <operator>||</operator>
					<operator>(</operator><name>finalizer</name>  <operator>&amp;&amp;</operator> <operator>!</operator><name><name>finalizer</name><operator>-&gt;</operator><name>created</name></name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>&amp;&amp;</operator> <name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-- deferring REDUCE %s\n"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>||</operator> <name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-- REDUCE %s\n"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Now, set things up to create the thing */</comment>
				<expr_stmt><expr><call><name>mapred_setup_columns</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>transition</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>plist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <comment type="block">/* state */</comment>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* parameters */</comment>

				<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>ordering</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE ORDERED AGGREGATE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE AGGREGATE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Get the state type, and write out the aggregate parameters
				 * based on the parameter list of the transition function.
				 */</comment>
				<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>transition</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") (\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"  stype = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>initialize</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">",\n  initcond = '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>initialize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">",\n  sfunc = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transition</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>transition</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>combiner</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">",\n  combinefunc = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * To handle set returning finalizers the finalizer is pushed
				 * into the task definition rather than being placed in the
				 * uda where it belongs.
				 */</comment>
				<comment type="block">/*
				 if (obj-&gt;u.reducer.finalizer.name)
				 {
				    bufcat(&amp;buffer, ",\n  finalfunc = ");
				    bufcat(&amp;buffer, obj-&gt;u.reducer.finalizer.name);
				 }
				*/</comment>

				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\n);\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>MAPRED_TASK</name></expr>:</case>
			<case>case <expr><name>MAPRED_EXECUTION</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>input</name>    <init>= <expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>input</name><operator>.</operator><name>object</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>mapper</name>   <init>= <expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>object</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>reducer</name>  <init>= <expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>object</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_plist_t</name>  <modifier>*</modifier></type><name>columns</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_plist_t</name>  <modifier>*</modifier></type><name>ingrouping</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_plist_t</name>  <modifier>*</modifier></type><name>newitem</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_plist_t</name>  <modifier>*</modifier></type><name>grouping</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_plist_t</name>  <modifier>*</modifier></type><name>last</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>mapred_plist_t</name>  <modifier>*</modifier></type><name>scan</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>buffer_t</name>        <modifier>*</modifier></type><name>swap</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>execute</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>input</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>qbuffer</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>qbuffer</name> <operator>=</operator> <call><name>makebuffer</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufreset</name><argument_list>(<argument><expr><name>qbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/*
				 * If the task depends on an object that hasn't been created then
				 * return false, it will be resolved during a second pass
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>input</name>   <operator>&amp;&amp;</operator> <operator>!</operator><name><name>input</name><operator>-&gt;</operator><name>created</name></name><operator>)</operator>  <operator>||</operator>
					<operator>(</operator><name>mapper</name>  <operator>&amp;&amp;</operator> <operator>!</operator><name><name>mapper</name><operator>-&gt;</operator><name>created</name></name><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name>reducer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>reducer</name><operator>-&gt;</operator><name>created</name></name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>&amp;&amp;</operator> <name>global_debug_flag</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>execute</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-- deferring EXECUTION\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-- deferring TASK %s\n"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>||</operator> <name>global_debug_flag</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>execute</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-- EXECUTION\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-- TASK %s\n"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * 1) Handle the INPUT, two cases:
				 *   1a) There is no MAP/REDUCE:  "SELECT * FROM &lt;input&gt;"
				 *   1b) There is a MAP and/or REDUCE:  "&lt;input&gt;"
				 */</comment>
				<expr_stmt><expr><call><name>mapred_setup_columns</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>name</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Allocate the buffer for the input. */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>input</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_INPUT_TABLE</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qbuffer</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qbuffer</name></expr></argument>, <argument><expr><name><name>input</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qbuffer</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qbuffer</name></expr></argument>, <argument><expr><name><name>input</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Input is just the name or description of the input */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>input</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>MAPRED_INPUT_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qbuffer</name></expr></argument>, <argument><expr><name><name>input</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qbuffer</name></expr></argument>, <argument><expr><name><name>input</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * How we get the columns depends a bit on the input.
				 * Is the input actually an "MAPRED_INPUT" object, or is it
				 * a "MAPRED_TASK" object?
				 */</comment>
				<switch>switch <condition>(<expr><name><name>input</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>MAPRED_INPUT</name></expr>:</case>
						<expr_stmt><expr><name>columns</name> <operator>=</operator> <name><name>input</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>columns</name></name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>MAPRED_TASK</name></expr>:</case>
						<expr_stmt><expr><name>columns</name>    <operator>=</operator> <name><name>input</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>ingrouping</name> <operator>=</operator> <name><name>input</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>columns</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"Unable to determine return "</literal>
											 <literal type="string">"columns for TASK '%s'"</literal></expr></argument>,
											 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>input</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_INTERNAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>

					<default>default:</default>
						<expr_stmt><expr><call><name>mapred_obj_error</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="string">"SOURCE '%s' is not an INPUT or "</literal>
										 <literal type="string">"TASK object"</literal></expr></argument>,
										 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>input</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_PARSE_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * 2) Handle the MAPPER, two cases
				 *  2a) The Mapper returns an generated ADT that needs extraction
				 *           "SELECT key(m), ...
				 *            FROM (SELECT &lt;map(...) as m FROM &lt;input&gt;) mapsubq
				 *  2b) The Mapper returns a single column:
				 *           "SELECT &lt;map&gt;(...) FROM &lt;input&gt;"
				 */</comment>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>mapper</name> <operator>||</operator> <operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>mapper</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>mapper</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>mapper</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>plist2</name> <operator>=</operator> <name><name>mapper</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>internal_returns</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>plist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
					<block>{<block_content> <comment type="block">/* 2a */</comment>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<for>for <control>(<init>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr> )</control>
						<block>{<block_content>
							<if_stmt><if>if<condition>( <expr><name><name>obj</name><operator>-&gt;</operator><name>internal</name></name></expr> )</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>plist2</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>plist2</name> <operator>=</operator> <name><name>plist2</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
							</block_content>}</block></if>
							<else>else
							<block>{<block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></else></if_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"(m)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" as "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\nFROM ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* shared code */</comment>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mapper</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>mapper</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>mapper</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr>;</expr_stmt>
					<for>for <control>(<init>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
					<block>{<block_content>
						<comment type="block">/* Check if this parameter is one of the input columns */</comment>
						<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>columns</name></expr>;</init> <condition><expr><name>scan</name></expr>;</condition> <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt></block_content></block></for>

						<comment type="block">/* Task inputs also need to scan the grouping columns */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition><block type="pseudo"><block_content>
							<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>ingrouping</name></expr>;</init> <condition><expr><name>scan</name></expr>;</condition> <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
								<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<break>break;</break>
								</block_content>}</block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

						<comment type="block">/* Check if this parameter is in global_plist */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition><block type="pseudo"><block_content>
							<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>global_plist</name></expr>;</init> <condition><expr><name>scan</name></expr>;</condition> <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
								<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<comment type="block">/*
									 * (HACK)
									 * Note that global_plist overloads the
									 * plist structure using the "type" field
									 * to store "value".
									 * (HACK)
									 */</comment>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'::"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<break>break;</break>
								</block_content>}</block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>


						<comment type="block">/*
						 * If we couldn't find it issue a warning and
						 * set to NULL
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"       "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
									<argument><expr><literal type="string">"WARNING: unset parameter - "</literal>
									<literal type="string">"%s(%s =&gt; NULL)\n"</literal></expr></argument>,
									<argument><expr><name><name>mapper</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"NULL::"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/* Add a comma if there is another parameter */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") as "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* break into cases again */</comment>
					<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>mapper</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
					<block>{<block_content>  <comment type="block">/* 2a */</comment>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"m FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>qbuffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") mapxq\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/*
						 * Need to work this through, it seems that m is true
						 * whenever a column is null, which is not the desired
						 * behavior.
						 *
						 * Look more closely at "grep" code for why we want it,
						 * and "oreilly" code for why we don't.
						 *
						 * For the moment the compromise is that we do it only
						 * for SINGLE mode functions, since MULTI mode can
						 * control it's own filtering without this.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>mapper</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>mode</name></name> <operator>!=</operator> <name>MAPRED_MODE_MULTI</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"WHERE m is not null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>qbuffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * Swap the buffer into the qbuffer for input as the next
					 * stage of the query pipeline.
					 */</comment>
					<expr_stmt><expr><name>swap</name> <operator>=</operator> <name>qbuffer</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>qbuffer</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>swap</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufreset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Columns are now the output of the mapper */</comment>
					<expr_stmt><expr><name>columns</name>  <operator>=</operator> <name><name>mapper</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>ingrouping</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * 3) Handle the Reducer, several sub-cases:
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>name</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Step 1:   Determine grouping columns
					 *    Find which columns are returned from the previous
					 *    stage that are NOT parameters to the reducer.
					 */</comment>
					<expr_stmt><expr><name>grouping</name> <operator>=</operator> <name>last</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reducer</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * We have a reducer, but it isn't listed in the YAML.
						 * How to work out parameter handling still needs to
						 * be worked out.  For now we just assume that this
						 * sort of function always takes a single "value" column
						 * and returns a "value" column.
						 */</comment>
						<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name>columns</name></expr>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name>grouping</name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator>
										<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>last</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
								</block_content>}</block></if>
								<else>else
								<block>{<block_content>
									<expr_stmt><expr><name>grouping</name> <operator>=</operator>
										<call><name>mapred_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapred_plist_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><name>last</name> <operator>=</operator> <name>grouping</name></expr>;</expr_stmt>
								</block_content>}</block></else></if_stmt>
								<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></for>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>   <comment type="block">/* The reducer exists in the YAML */</comment>

						<comment type="block">/* We precalculated the grouping columns */</comment>
						<expr_stmt><expr><name>grouping</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>grouping</name></name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/* Fill in the buffer */</comment>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name>grouping</name></expr>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>

					<comment type="block">/* Call the aggregation function */</comment>
					<if_stmt><if>if <condition>(<expr><name>reducer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>reducer</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>reducer</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>reducer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>parameters</name></name></expr>;</expr_stmt>
						<for>for <control>(<init>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
						<block>{<block_content>
							<comment type="block">/* Check if parameter is one of the input columns */</comment>
							<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>columns</name></expr>;</init> <condition><expr><name>scan</name></expr>;</condition> <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
								<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<break>break;</break>
								</block_content>}</block></if></if_stmt></block_content></block></for>

							<comment type="block">/* Task inputs need to scan the grouping columns */</comment>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition><block type="pseudo"><block_content>
								<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>ingrouping</name></expr>;</init> <condition><expr><name>scan</name></expr>;</condition> <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
									<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
									<block>{<block_content>
										<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<break>break;</break>
									</block_content>}</block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

							<comment type="block">/* Check if this parameter is in global_plist */</comment>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition>
							<block>{<block_content>
								<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>global_plist</name></expr>;</init>
									 <condition><expr><name>scan</name></expr>;</condition>
									 <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
								<block>{<block_content>
									<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
									<block>{<block_content>
										<comment type="block">/*
										 * (HACK)
										 * Note that global_plist overloads the
										 * plist structure using the "type"
										 * field to store "value".
										 * (HACK)
										 */</comment>
										<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'::"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<break>break;</break>
									</block_content>}</block></if></if_stmt>
								</block_content>}</block></for>
							</block_content>}</block></if></if_stmt>

							<comment type="block">/*
							 * If we couldn't find it issue a warning
							 * and set to NULL
							 */</comment>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"       "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
										<argument><expr><literal type="string">"WARNING: unset parameter - "</literal>
										<literal type="string">"%s(%s =&gt; NULL)\n"</literal></expr></argument>,
										<argument><expr><name><name>reducer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"NULL::"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></for>

						<comment type="block">/* Handle ORDERING, if specified */</comment>
						<expr_stmt><expr><name>clist</name> <operator>=</operator> <name><name>reducer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>ordering</name></name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>clist</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<for>for<control>(<init>;</init> <condition><expr><name>clist</name></expr>;</condition> <incr><expr><name>clist</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
						<block>{<block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>clist</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></for>

					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * non-yaml reducer always takes "value" as the
						 * input column
						 */</comment>

						<comment type="block">/* Check if "value" is one of the input columns */</comment>
						<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>columns</name></expr>;</init> <condition><expr><name>scan</name></expr>;</condition> <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt></block_content></block></for>

						<comment type="block">/* Task inputs also need to scan the grouping columns */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition><block type="pseudo"><block_content>
							<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>ingrouping</name></expr>;</init> <condition><expr><name>scan</name></expr>;</condition> <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
								<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<break>break;</break>
								</block_content>}</block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

						<comment type="block">/* Check if this parameter is in global_plist */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition><block type="pseudo"><block_content>
							<for>for <control>(<init><expr><name>scan</name> <operator>=</operator> <name>global_plist</name></expr>;</init> <condition><expr><name>scan</name></expr>;</condition> <incr><expr><name>scan</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
								<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<comment type="block">/*
									 * (HACK)
									 * Note that global_plist overloads the
									 * plist structure using the "type" field
									 * to store "value".
									 * (HACK)
									 */</comment>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"'::"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<break>break;</break>
								</block_content>}</block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"       "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
									<argument><expr><literal type="string">"WARNING: unset parameter - "</literal>
									<literal type="string">"%s(value =&gt; NULL)\n"</literal></expr></argument>,
									<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>

					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") as "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>reducer</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>reducer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>plist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Need to have a return! */</comment>

						<comment type="block">/*
						 * If the reducer has a finalizer we push it outside of
						 * the context of the UDA so that we can properly handle
						 * set returning/column returning functions.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>reducer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * non-yaml reducer always return a single column
						 * named "value"
						 */</comment>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\nFROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>mapper</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>qbuffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") mapsubq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>qbuffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>grouping</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\nGROUP BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name>grouping</name></expr>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
						<block>{<block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></for>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Swap the buffer into the qbuffer for input as the next
					 * stage of the query pipeline.
					 */</comment>
					<expr_stmt><expr><name>swap</name> <operator>=</operator> <name>qbuffer</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>qbuffer</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>swap</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufreset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Add the return columns to the grouping columns and set
					 * it to the current columns.
					 *
					 * Note that unlike the columns set by the mapper or the
					 * input this is a list that must be de-allocated.
					 */</comment>
					<expr_stmt><expr><name>columns</name> <operator>=</operator> <name>last</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * If the reducer had a finalizer we push it into another
					 * nested subquery since user defined aggregates aren't
					 * allowed to return sets.
					 *
					 * NOTE: this code mostly duplicates the MAP code above
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>reducer</name> <operator>&amp;&amp;</operator> <name><name>reducer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>name</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>finalizer</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>finalizer</name> <operator>=</operator> <name><name>reducer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>finalizer</name><operator>.</operator><name>object</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>finalizer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* FIXME */</comment>
						<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>finalizer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * If the finalizer returns multiple columns then we
						 * need an extra layer of wrapping to extract them.
						 */</comment>
						<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>finalizer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/* the grouping columns */</comment>
							<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name>grouping</name></expr>;</init>
								 <condition><expr><name>plist</name></expr>;</condition>
								 <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
							<block>{<block_content>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></for>
							<expr_stmt><expr><name>plist2</name> <operator>=</operator> <name><name>finalizer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>internal_returns</name></name></expr>;</expr_stmt>
							<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>finalizer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</init>
								 <condition><expr><name>plist</name></expr>;</condition>
								 <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
							<block>{<block_content>
								<if_stmt><if>if<condition>( <expr><name><name>finalizer</name><operator>-&gt;</operator><name>internal</name></name></expr> )</condition>
								<block>{<block_content>
									<expr_stmt><expr><call><name>XASSERT</name><argument_list>( <argument><expr><name>plist2</name> <operator>!=</operator> <name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><name>plist2</name> <operator>=</operator> <name><name>plist2</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
								</block_content>}</block></if>
								<else>else
								<block>{<block_content>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								</block_content>}</block></else></if_stmt>

								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"(r)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" as "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							</block_content>}</block></for>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\nFROM ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * Call the function on the returned state from
						 * the reducer.
						 */</comment>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* grouping columns */</comment>
						<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name>grouping</name></expr>;</init>
							 <condition><expr><name>plist</name></expr>;</condition>
							 <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
						<block>{<block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></for>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>finalizer</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>finalizer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"(r) as "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* break into cases again */</comment>
						<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>finalizer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name></name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" FROM ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>qbuffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") redxq\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * If we have that extra layer of wrapping
						 * then close it off
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>finalizer</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>returns</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") redsubq\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * Swap the buffer into the qbuffer for input as the next
						 * stage of the query pipeline.
						 */</comment>
						<expr_stmt><expr><name>swap</name> <operator>=</operator> <name>qbuffer</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>qbuffer</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>swap</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufreset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>


				<comment type="block">/*
				 * 4) Handle the final transform into the view definition:
				 *        "CREATE TEMPORARY VIEW . AS .;"
				 */</comment>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE TEMPORARY VIEW "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" AS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>qbuffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">";\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If there was a reducer then we have to release the columns
				 * list, otherwise it is a pointer to an existing list and can
				 * be ignored.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>task</name><operator>.</operator><name>reducer</name><operator>.</operator><name>name</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>plist</name> <operator>=</operator> <name>columns</name></expr>;</expr_stmt>
					<while>while <condition>(<expr><name>plist</name> <operator>&amp;&amp;</operator> <name>plist</name> <operator>!=</operator> <name>grouping</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>newitem</name> <operator>=</operator> <name>plist</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></while>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>MAPRED_ADT</name></expr>:</case>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mapred_setup_columns</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * ADT's have generated names that already include the
				 * document prefix
				 */</comment>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"CREATE TYPE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" as ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>adt</name><operator>.</operator><name>returns</name></name></expr>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">");\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>

			<comment type="block">/*
			 * In print-only mode we do everything but run the queries
			 * ie, we still create and destroy objects.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>||</operator> <name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Try to create the object, but failure should not terminate
			 * the transaction, so wrap it in a savepoint.
			 */</comment>
			<expr_stmt><expr><call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT mapreduce_save"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>created</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"RELEASE SAVEPOINT mapreduce_save"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* rollback to savepoint */</comment>
				<expr_stmt><expr><call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK TO SAVEPOINT mapreduce_save"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"RELEASE SAVEPOINT mapreduce_save"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we have an "object does not exist" error from a SQL input
				 * then it may just be a dependency issue, so we don't error
				 * right away.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>MAPRED_INPUT</name> <operator>||</operator>
					<name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>MAPRED_INPUT_QUERY</name> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>OBJ_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"     - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XRAISE</name><argument_list>(<argument><expr><name>MAPRED_SQL_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Object creation Failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"       Error: %s\n"</literal></expr></argument>,
							<argument><expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If it is an error that we think we can recover from then we don't
				 * log the error immediately, but write it to a buffer in the event
				 * that recovery wasn't successful.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>, <argument><expr><literal type="string">"  - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>, <argument><expr><literal type="string">"Error: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>mapred_kind_name</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>, <argument><expr><literal type="string">" '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>, <argument><expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>line</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name></type> <name><name>numbuf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>numbuf</name></expr></argument>, <argument><expr><literal type="string">", at line %d"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>, <argument><expr><name>numbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>doc</name><operator>-&gt;</operator><name>errors</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * INPUTS setup columns AFTER creation.
		 * All other objects handle it above prior to creation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MAPRED_INPUT</name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>created</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mapred_setup_columns</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<macro><name>XFINALLY</name></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>qbuffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>qbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>XTRY_END</name></expr>;</expr_stmt>

	<return>return <expr><name><name>obj</name><operator>-&gt;</operator><name>created</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>mapred_remove_object</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>mapred_document_t</name> <modifier>*</modifier></type><name>doc</name></decl></parameter>, <parameter><decl><type><name>mapred_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mapred_plist_t</name> <modifier>*</modifier></type><name>plist</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>     <modifier>*</modifier></type><name>ckind</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>buffer_t</name>       <modifier>*</modifier></type><name>buffer</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


	<comment type="block">/* If the object wasn't created, then do nothing */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>created</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>created</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>XTRY</name></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>makebuffer</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Otherwise attempt to create the object */</comment>
		<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>MAPRED_INPUT</name></expr>:</case>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>input</name><operator>.</operator><name>type</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>MAPRED_INPUT_TABLE</name></expr>:</case>
						<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>created</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>  <comment type="block">/* do nothing */</comment>

					<case>case <expr><name>MAPRED_INPUT_FILE</name></expr>:</case>
					<case>case <expr><name>MAPRED_INPUT_GPFDIST</name></expr>:</case>
					<case>case <expr><name>MAPRED_INPUT_EXEC</name></expr>:</case>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"DROP EXTERNAL TABLE IF EXISTS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" CASCADE;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>MAPRED_INPUT_QUERY</name></expr>:</case>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"DROP VIEW IF EXISTS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" CASCADE;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>MAPRED_INPUT_NONE</name></expr>:</case>
					<default>default:</default>
						<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
				<break>break;</break>

			<case>case <expr><name>MAPRED_OUTPUT</name></expr>:</case>
				<comment type="block">/* nothing to do for outputs */</comment>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>created</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * The function types have different defaults and generate
				 * slightly different error messages, but basically do the
				 * same thing.
				 */</comment>
			<case>case <expr><name>MAPRED_MAPPER</name></expr>:</case>
			<case>case <expr><name>MAPRED_TRANSITION</name></expr>:</case>
			<case>case <expr><name>MAPRED_COMBINER</name></expr>:</case>
			<case>case <expr><name>MAPRED_FINALIZER</name></expr>:</case>
				<expr_stmt><expr><name>ckind</name> <operator>=</operator> <name><name>mapred_kind_name</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>kind</name></name></expr>]</index></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"DROP FUNCTION IF EXISTS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr>;</init>
					 <condition><expr><name>plist</name></expr>;</condition>
					 <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
				<block>{<block_content>  <comment type="block">/* Handle parameter list */</comment>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") CASCADE;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>


			<case>case <expr><name>MAPRED_REDUCER</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>mapred_object_t</name>  <modifier>*</modifier></type><name>transition</name> <init>= <expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>reducer</name><operator>.</operator><name>transition</name><operator>.</operator><name>object</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>transition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* is this a good assumption? */</comment>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transition</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* FIXME */</comment>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>transition</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"DROP AGGREGATE IF EXISTS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>internal</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>doc</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * The first parameter of the transition function is the 'state'
				 * and is not listed as a parameter of the reducer, but all the
				 * rest of the parameters are
				 */</comment>
				<expr_stmt><expr><name>plist</name> <operator>=</operator> <name><name>transition</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>function</name><operator>.</operator><name>parameters</name></name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>plist</name></expr>;</condition> <incr><expr><name>plist</name> <operator>=</operator> <name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>plist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>plist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">") CASCADE;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>MAPRED_TASK</name></expr>:</case>
			<case>case <expr><name>MAPRED_EXECUTION</name></expr>:</case>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"DROP VIEW IF EXISTS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" CASCADE;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>MAPRED_ADT</name></expr>:</case>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"DROP TYPE IF EXISTS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bufcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">" CASCADE;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>XASSERT</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * In print-only mode we do everything but run the queries
			 * ie, we still create and destroy objects.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>global_print_flag</name> <operator>||</operator> <name>global_debug_flag</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Try to delete the object, but don't raise exception on error */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>created</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Errors that we can expect/ignore:
				 *
				 *     IN_FAILED_SQL_TRANSACTION -
				 *        another error has occured and the transaction was
				 *        aborted
				 *
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"    - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
								<argument><expr><literal type="string">"[WARNING] Error dropping '%s'\n"</literal></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
								<argument><expr><literal type="string">"[WARNING] Error dropping unnamed object\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>global_verbose_flag</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"    - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<macro><name>XFINALLY</name></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mapred_free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>XTRY_END</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
