<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/gpcontrib/gp_sparse_vector/operators.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * operators.c
 *
 * Copyright (c) 2010, Greenplum Software
 * Portions Copyright (c) 2013-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    gpcontrib/gp_sparse_vector/operators.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/numeric.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sparse_vector.h"</cpp:file></cpp:include>

<function_decl><type><name>void</name></type> <name>check_dimension</name><parameter_list>(<parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name></decl></parameter>, <parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Datum</name></type> <name>svec_dimension</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_dimension</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>svec_dimension</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>svec</name><operator>-&gt;</operator><name>dimension</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>Datum</name></type> <name>svec_concat_replicate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_concat_replicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>svec_concat_replicate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>multiplier</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>makeEmptySparseData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vals</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>l_val_len</name> <init>= <expr><name><name>left</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>l_ind_len</name> <init>= <expr><name><name>left</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>val_len</name><init>=<expr><name>l_val_len</name><operator>*</operator><name>multiplier</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ind_len</name><init>=<expr><name>l_ind_len</name><operator>*</operator><name>multiplier</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>vals</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>ind_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>multiplier</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>vals</name><operator>+</operator><name>i</name><operator>*</operator><name>l_val_len</name></expr></argument>,<argument><expr><name><name>left</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>l_val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>index</name><operator>+</operator><name>i</name><operator>*</operator><name>l_ind_len</name></expr></argument>,<argument><expr><name><name>left</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>l_ind_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name></name>  <operator>=</operator> <call><name>makeStringInfoFromData</name><argument_list>(<argument><expr><name>vals</name></expr></argument>,<argument><expr><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <call><name>makeStringInfoFromData</name><argument_list>(<argument><expr><name>index</name></expr></argument>,<argument><expr><name>ind_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>type_of_data</name></name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>type_of_data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>unique_value_count</name></name> <operator>=</operator> <name>multiplier</name> <operator>*</operator> <name><name>left</name><operator>-&gt;</operator><name>unique_value_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>total_value_count</name></name>  <operator>=</operator> <name>multiplier</name> <operator>*</operator> <name><name>left</name><operator>-&gt;</operator><name>total_value_count</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>Datum</name></type> <name>svec_concat</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_concat</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_concat</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else
	<block>{<block_content>

		<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>makeEmptySparseData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vals</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>l_val_len</name> <init>= <expr><name><name>left</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>r_val_len</name> <init>= <expr><name><name>right</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>l_ind_len</name> <init>= <expr><name><name>left</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>r_ind_len</name> <init>= <expr><name><name>right</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>val_len</name><init>=<expr><name>l_val_len</name><operator>+</operator><name>r_val_len</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ind_len</name><init>=<expr><name>l_ind_len</name><operator>+</operator><name>r_ind_len</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>vals</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>ind_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>vals</name></expr></argument>          ,<argument><expr><name><name>left</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>l_val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>vals</name><operator>+</operator><name>l_val_len</name></expr></argument>,<argument><expr><name><name>right</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>r_val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>index</name></expr></argument>,          <argument><expr><name><name>left</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>l_ind_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>index</name><operator>+</operator><name>l_ind_len</name></expr></argument>,<argument><expr><name><name>right</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>r_ind_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name></name>  <operator>=</operator> <call><name>makeStringInfoFromData</name><argument_list>(<argument><expr><name>vals</name></expr></argument>,<argument><expr><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <call><name>makeStringInfoFromData</name><argument_list>(<argument><expr><name>index</name></expr></argument>,<argument><expr><name>ind_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>type_of_data</name></name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>type_of_data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>unique_value_count</name></name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>unique_value_count</name></name><operator>+</operator>
			<name><name>right</name><operator>-&gt;</operator><name>unique_value_count</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>total_value_count</name></name>  <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>total_value_count</name></name><operator>+</operator>
			<name><name>right</name><operator>-&gt;</operator><name>total_value_count</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function_decl><type><name>Datum</name></type> <name>svec_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_eq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>sparsedata_eq</name><argument_list>(<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type>
<name>svec_l2_cmp_internal</name><parameter_list>(<parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name></decl></parameter>, <parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>magleft</name>  <init>= <expr><call><name>l2norm_sdata_values_double</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>magright</name> <init>= <expr><call><name>l2norm_sdata_values_double</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>magleft</name> <operator>&lt;</operator> <name>magright</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>magleft</name> <operator>&gt;</operator> <name>magright</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>Datum</name></type> <name>svec_l2_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_l2_cmp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_l2_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>svec_l2_cmp_internal</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>Datum</name></type> <name>svec_l2_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_l2_lt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_l2_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>svec_l2_cmp_internal</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>result</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>Datum</name></type> <name>svec_l2_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_l2_le</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_l2_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>svec_l2_cmp_internal</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>result</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>||</operator><operator>(</operator><name>result</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>Datum</name></type> <name>svec_l2_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_l2_eq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_l2_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>svec_l2_cmp_internal</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>result</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>Datum</name></type> <name>svec_l2_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_l2_ne</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_l2_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>svec_l2_cmp_internal</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>result</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>Datum</name></type> <name>svec_l2_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_l2_gt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_l2_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>svec_l2_cmp_internal</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>result</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>Datum</name></type> <name>svec_l2_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_l2_ge</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_l2_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>svec_l2_cmp_internal</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>result</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>result</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Do one of subtract, add, multiply, divide or modulo depending on value
 * of operation(0,1,2,3,4)
 */</comment>
<function><type><name>SvecType</name> <modifier>*</modifier></type>
<name>svec_operate_on_sdata_pair</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>scalar_args</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>,<parameter><decl><type><name>SparseData</name></type> <name>left</name></decl></parameter>,<parameter><decl><type><name>SparseData</name></type> <name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name> <modifier>*</modifier></type><name>left_vals</name> <init>=<expr><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>left</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name> <modifier>*</modifier></type><name>right_vals</name><init>=<expr><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>right</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type> <name>data_result</name></decl>;</decl_stmt>

	<switch>switch<condition>(<expr><name>scalar_args</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case> 		<comment type="line">//neither arg is scalar</comment>
			<expr_stmt><expr><name>sdata</name> <operator>=</operator> <call><name>op_sdata_by_sdata</name><argument_list>(<argument><expr><name>operation</name></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">1</literal></expr>:</case>			<comment type="line">//left arg is scalar</comment>
			
			<expr_stmt><expr><name>sdata</name> <operator>=</operator> <call><name>op_sdata_by_scalar_copy</name><argument_list>(<argument><expr><name>operation</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>left_vals</name></expr></argument>,
					<argument><expr><name>right</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>			<comment type="line">//right arg is scalar</comment>
			<expr_stmt><expr><name>sdata</name> <operator>=</operator> <call><name>op_sdata_by_scalar_copy</name><argument_list>(<argument><expr><name>operation</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>right_vals</name></expr></argument>,
					<argument><expr><name>left</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">3</literal></expr>:</case>			<comment type="line">//both args are scalar</comment>
			<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="number">1</literal></expr>:</case>
				<default>default:</default>
					<expr_stmt><expr><name>data_result</name> <operator>=</operator> <name><name>left_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><name><name>right_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">2</literal></expr>:</case>
					<expr_stmt><expr><name>data_result</name> <operator>=</operator> <name><name>left_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>*</operator><name><name>right_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">3</literal></expr>:</case>
					<expr_stmt><expr><name>data_result</name> <operator>=</operator> <name><name>left_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>/</operator><name><name>right_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">4</literal></expr>:</case>
					<expr_stmt><expr><name>data_result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>left_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>%</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>right_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<return>return<expr><operator>(</operator><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>data_result</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return<expr><operator>(</operator><call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>SvecType</name> <modifier>*</modifier></type>
<name>op_svec_by_svec_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name></decl></parameter>, <parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name><init>=<expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>IS_SCALAR</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>IS_SCALAR</name><argument_list>(<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return<expr><operator>(</operator><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><name>operation</name></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 * Do exponentiation, only makes sense if the left is a vector and the right
 * is a scalar or if both are scalar
 */</comment>
<function><type><specifier>static</specifier> <name>SvecType</name> <modifier>*</modifier></type>
<name>pow_svec_by_scalar_internal</name><parameter_list>(<parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name></decl></parameter>, <parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>left_vals</name><init>=<expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>left</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>right_vals</name><init>=<expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>right</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>data_result</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name><init>=<expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>IS_SCALAR</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>IS_SCALAR</name><argument_list>(<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch<condition>(<expr><name>scalar_args</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case> 		<comment type="line">//neither arg is scalar</comment>
		<case>case <expr><literal type="number">1</literal></expr>:</case>			<comment type="line">//left arg is scalar</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"svec exponentiation is undefined when the right argument is a vector"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>			<comment type="line">//right arg is scalar</comment>
			<if_stmt><if>if <condition>(<expr><name><name>right_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">2.</literal></expr>)</condition> <comment type="line">//recognize the squared case as special</comment>
			<block>{<block_content>
			  <expr_stmt><expr><name>sdata</name> <operator>=</operator> <call><name>square_sdata</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>  <if type="elseif">else if <condition>(<expr><name><name>right_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">3.</literal></expr>)</condition> <comment type="line">//recognize the cubed case as special</comment>
			<block>{<block_content>
			  <expr_stmt><expr><name>sdata</name> <operator>=</operator> <call><name>cube_sdata</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>  <if type="elseif">else if <condition>(<expr><name><name>right_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">4.</literal></expr>)</condition> <comment type="line">//recognize the quad case as special</comment>
			<block>{<block_content>
			  <expr_stmt><expr><name>sdata</name> <operator>=</operator> <call><name>quad_sdata</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
			  <expr_stmt><expr><name>sdata</name> <operator>=</operator> <call><name>pow_sdata_by_scalar</name><argument_list>(<argument><expr><name>left</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>right_vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">3</literal></expr>:</case>			<comment type="line">//both args are scalar</comment>
			<expr_stmt><expr><name>data_result</name> <operator>=</operator> <call><name>pow</name><argument_list>(<argument><expr><name><name>left_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>right_vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return<expr><operator>(</operator><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>data_result</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return<expr><operator>(</operator><call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_pow</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_pow</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>check_dimension</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>,<argument><expr><literal type="string">"svec_pow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>pow_svec_by_scalar_internal</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_minus</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_minus</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>check_dimension</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>,<argument><expr><literal type="string">"svec_minus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>op_svec_by_svec_internal</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_plus</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_plus</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>check_dimension</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>,<argument><expr><literal type="string">"svec_plus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>op_svec_by_svec_internal</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_mult</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_mult</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>check_dimension</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>,<argument><expr><literal type="string">"svec_mult"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>op_svec_by_svec_internal</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_div</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>check_dimension</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>,<argument><expr><literal type="string">"svec_div"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>op_svec_by_svec_internal</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Count the number of non-zero entries in the input vector
 * Right argument is capped at 1, then added to the left
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_count</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>svec_count</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>right_vals</name><init>=<expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>right</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>clamped_vals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right_clamped</name></decl>,<decl><type ref="prev"/><name>sdata_result</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name><init>=<expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>IS_SCALAR</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>IS_SCALAR</name><argument_list>(<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>check_dimension</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>,<argument><expr><literal type="string">"svec_count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clamp the right vector values to 1.
	 */</comment>
	<switch>switch <condition>(<expr><name>scalar_args</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>			<comment type="line">//left arg is scalar</comment>
			<comment type="block">/*
			 * If the left argument is a scalar, this is almost certainly the
			 * first call to the routine, and we need a zero vector for the
			 * beginning of the accumulation of the correct dimension.
			 */</comment>
			<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>makeSparseDataFromDouble</name><argument_list>(<argument><expr><literal type="number">0.</literal></expr></argument>,<argument><expr><name><name>right</name><operator>-&gt;</operator><name>total_value_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* FALLTHROUGH */</comment>

		<case>case <expr><literal type="number">0</literal></expr>:</case> 		<comment type="line">//neither arg is scalar</comment>
		<case>case <expr><literal type="number">2</literal></expr>:</case>			<comment type="line">//right arg is scalar</comment>

			<comment type="block">/* Create an array of values either 1 or 0 depending on whether
			 * the right vector has a non-zero value in it
			 */</comment>
			<expr_stmt><expr><name>clamped_vals</name> <operator>=</operator>
				<operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>right</name><operator>-&gt;</operator><name>unique_value_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name><name>right</name><operator>-&gt;</operator><name>unique_value_count</name></name><operator>)</operator></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>right_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="number">0.</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>clamped_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>=</operator><literal type="number">1.</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>right_clamped</name> <operator>=</operator> <call><name>makeInplaceSparseData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>clamped_vals</name></expr></argument>,<argument><expr><name><name>right</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					<argument><expr><name><name>right</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,<argument><expr><name><name>right</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,<argument><expr><name>FLOAT8OID</name></expr></argument>,
					<argument><expr><name><name>right</name><operator>-&gt;</operator><name>unique_value_count</name></name></expr></argument>,<argument><expr><name><name>right</name><operator>-&gt;</operator><name>total_value_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Create the output SVEC */</comment>
			<expr_stmt><expr><name>sdata_result</name> <operator>=</operator> <call><name>op_sdata_by_sdata</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right_clamped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata_result</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>clamped_vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>right_clamped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">3</literal></expr>:</case>			<comment type="line">//both args are scalar</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"svec count is undefined when both arguments are scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_dot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>svec_dot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>mult_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>accum</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>check_dimension</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>,<argument><expr><name>svec2</name></expr></argument>,<argument><expr><literal type="string">"svec_dot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>mult_result</name> <operator>=</operator> <call><name>op_sdata_by_sdata</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>accum</name> <operator>=</operator> <call><name>sum_sdata_values_double</name><argument_list>(<argument><expr><name>mult_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeSparseDataAndData</name><argument_list>(<argument><expr><name>mult_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_l2norm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>svec_l2norm</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name>  <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>accum</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>accum</name> <operator>=</operator> <call><name>l2norm_sdata_values_double</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_l1norm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>svec_l1norm</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name>  <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>accum</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>accum</name> <operator>=</operator> <call><name>l1norm_sdata_values_double</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_summate</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>svec_summate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name>  <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>accum</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>accum</name> <operator>=</operator> <call><name>sum_sdata_values_double</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_log</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>svec_log</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>vals</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><call><name>SVEC_VALS_PTR</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>unique_value_count</name><init>=<expr><call><name>SVEC_UNIQUE_VALCNT</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>unique_value_count</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>log</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * Cast from int2,int4,int8,float4,float8 scalar to SvecType
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_cast_int2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_cast_int2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name><init>=<expr><operator>(</operator><name>float8</name> <operator>)</operator><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_cast_int4</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_cast_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name><init>=<expr><operator>(</operator><name>float8</name> <operator>)</operator><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_cast_int8</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_cast_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name><init>=<expr><operator>(</operator><name>float8</name> <operator>)</operator><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_cast_float4</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_cast_float4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name><init>=<expr><operator>(</operator><name>float8</name> <operator>)</operator><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_cast_float8</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_cast_float8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name><init>=<expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_cast_numeric</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>svec_cast_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>num</name><init>=<expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cast from int2,int4,int8,float4,float8 scalar to float8[]
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_cast_int2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>float8arr_cast_int2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name><init>=<expr><operator>(</operator><name>float8</name> <operator>)</operator><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>svec_return_array_internal</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_cast_int4</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>float8arr_cast_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name><init>=<expr><operator>(</operator><name>float8</name> <operator>)</operator><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>svec_return_array_internal</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_cast_int8</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>float8arr_cast_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name><init>=<expr><operator>(</operator><name>float8</name> <operator>)</operator><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>svec_return_array_internal</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_cast_float4</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>float8arr_cast_float4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name><init>=<expr><operator>(</operator><name>float8</name> <operator>)</operator><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>svec_return_array_internal</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_cast_float8</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>float8arr_cast_float8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name><init>=<expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>svec_return_array_internal</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_cast_numeric</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>float8arr_cast_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>num</name><init>=<expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>svec_return_array_internal</name><argument_list>(<argument><expr><call><name>svec_make_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>SvecType</name> <modifier>*</modifier></type><name>svec_make_scalar</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dimension</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name><init>=<expr><call><name>float8arr_to_sdata</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>result</name><init>=<expr><call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dimension</name></name><operator>=</operator><operator>-</operator><name>dimension</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>check_dimension</name><parameter_list>(<parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec1</name></decl></parameter>, <parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec2</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<comment type="block">/* If the array dimensions aren't the same, operation has no meaning unless one of 
	 * the inputs is a constant
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>IS_SCALAR</name><argument_list>(<argument><expr><name>svec1</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
	    <operator>(</operator><operator>!</operator><call><name>IS_SCALAR</name><argument_list>(<argument><expr><name>svec2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>svec1</name><operator>-&gt;</operator><name>dimension</name></name> <operator>!=</operator> <name><name>svec2</name><operator>-&gt;</operator><name>dimension</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: array dimension of inputs are not the same: dim1=%d, dim2=%d\n"</literal></expr></argument>,
						<argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>svec1</name><operator>-&gt;</operator><name>dimension</name></name></expr></argument>, <argument><expr><name><name>svec2</name><operator>-&gt;</operator><name>dimension</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_cast_float8arr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>svec_cast_float8arr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>A_PG</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>output_svec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>A_PG</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>FLOAT8OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"svec_cast_float8arr only defined over float8[]"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>A_PG</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"svec_cast_float8arr only defined over 1 dimensional arrays"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>A_PG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"svec_cast_float8arr does not allow null bitmaps on arrays"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/* Extract array */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>dimension</name> <init>= <expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>A_PG</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float8</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>A_PG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Create the output SVEC */</comment>
		<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>float8arr_to_sdata</name><argument_list>(<argument><expr><name>array</name></expr></argument>,<argument><expr><name>dimension</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>output_svec</name> <operator>=</operator> <call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>output_svec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Provide some operators for Postgres FLOAT8OID arrays
 */</comment>
<comment type="block">/*
 * Equality
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>float8arr_equals_internal</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>dimleft</name> <init>= <expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>dimright</name> <init>= <expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>dimsleft</name> <init>= <expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dimsright</name> <init>= <expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numleft</name> <init>= <expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>dimleft</name></expr></argument>,<argument><expr><name>dimsleft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numright</name> <init>= <expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>dimright</name></expr></argument>,<argument><expr><name>dimsright</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>vals_left</name><init>=<expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vals_right</name><init>=<expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bits8</name> <modifier>*</modifier></type><name>bitmap_left</name><init>=<expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bitmap_right</name><init>=<expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>   <name>bitmask</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>dimsleft</name><operator>!=</operator><name>dimsright</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>numleft</name><operator>!=</operator><name>numright</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return<expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Note that we are only defined for FLOAT8OID
	 */</comment>
        <comment type="line">//get_typlenbyvalalign(ARR_ELEMTYPE(array),</comment>
        <comment type="line">//                                         &amp;typlen, &amp;typbyval, &amp;typalign);</comment>

	<comment type="block">/*
	 * First we'll check to see if the null bitmaps are equivalent
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bitmap_left</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>bitmap_right</name></expr>)</condition><block type="pseudo"><block_content> <return>return<expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>bitmap_right</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>bitmap_left</name></expr>)</condition><block type="pseudo"><block_content> <return>return<expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>bitmap_left</name></expr>)</condition>
	<block>{<block_content>
        	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>numleft</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
                	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>bitmap_left</name> <operator>&amp;</operator> <name>bitmask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>bitmap_left</name> <operator>&amp;</operator> <name>bitmask</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			  		<return>return<expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>bitmask</name> <operator>==</operator> <literal type="number">0x100</literal></expr>)</condition>
                        <block>{<block_content>
                                <expr_stmt><expr><name>bitmap_left</name><operator>++</operator></expr>;</expr_stmt>
                                <expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now we check for equality of all array values
	 */</comment>
       	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>numleft</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>vals_left</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>vals_right</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return<expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

        <return>return<expr><operator>(</operator><name>true</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>Datum</name></type> <name>float8arr_equals</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_equals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>float8arr_equals</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>left</name>  <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8arr_equals_internal</name><argument_list>(<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a SparseData formed from a dense float8[] in uncompressed format.
 * This is useful for creating a SparseData without processing that can be
 * used by the SparseData processing routines.
 */</comment>
<function><type><specifier>static</specifier> <name>SparseData</name></type>
<name>sdata_uncompressed_from_float8arr_internal</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>dim</name> <init>= <expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>dims</name> <init>= <expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>dim</name></expr></argument>,<argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>vals</name> <init>=<expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bits8</name> <modifier>*</modifier></type><name>bitmap</name> <init>= <expr><call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>   <name>bitmask</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>result</name> <init>= <expr><call><name>makeInplaceSparseData</name><argument_list>(
			<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>vals</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,
			<argument><expr><name>num</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>FLOAT8OID</name></expr></argument>,
			<argument><expr><name>num</name></expr></argument>,<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Convert null items into zeros
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bitmap</name></expr>)</condition>
	<block>{<block_content>
        	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
                	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>bitmap</name><operator>&amp;</operator> <name>bitmask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0.</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>bitmask</name> <operator>==</operator> <literal type="number">0x100</literal></expr>)</condition>
                        <block>{<block_content>
                                <expr_stmt><expr><name>bitmap</name><operator>++</operator></expr>;</expr_stmt>
                                <expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<return>return<expr><operator>(</operator><name>result</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * L1 Norm
 */</comment>
<function_decl><type><name>Datum</name></type> <name>float8arr_l1norm</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_l1norm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>float8arr_l1norm</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name>  <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>result</name> <init>= <expr><call><name>l1norm_sdata_values_double</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>Datum</name></type> <name>float8arr_summate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_summate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>float8arr_summate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name>  <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>result</name> <init>= <expr><call><name>sum_sdata_values_double</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * L2 Norm
 */</comment>
<function_decl><type><name>Datum</name></type> <name>float8arr_l2norm</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_l2norm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>float8arr_l2norm</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name>  <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>result</name> <init>= <expr><call><name>l2norm_sdata_values_double</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Dot product
 */</comment>
<function_decl><type><name>Datum</name></type> <name>float8arr_dot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_dot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>float8arr_dot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr_left</name>   <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr_right</name>  <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr_left</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr_right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>mult_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>accum</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>mult_result</name> <operator>=</operator> <call><name>op_sdata_by_sdata</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>accum</name> <operator>=</operator> <call><name>sum_sdata_values_double</name><argument_list>(<argument><expr><name>mult_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeSparseData</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeSparseData</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeSparseDataAndData</name><argument_list>(<argument><expr><name>mult_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Permute the basic operators (minus,plus,mult,div) between SparseData and float8[]
 *
 * For each function, make a version that takes the left and right args as
 * each type (without copies)
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_minus_float8arr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>float8arr_minus_float8arr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr1</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr2</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_minus_float8arr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_minus_float8arr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_minus_svec</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>float8arr_minus_svec</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_plus_float8arr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>float8arr_plus_float8arr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr1</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr2</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_plus_float8arr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_plus_float8arr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_plus_svec</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>float8arr_plus_svec</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_mult_float8arr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>float8arr_mult_float8arr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr1</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr2</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_mult_float8arr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_mult_float8arr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_mult_svec</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>float8arr_mult_svec</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_div_float8arr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>float8arr_div_float8arr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr1</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr2</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name>  <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_div_float8arr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_div_float8arr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_div_svec</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>float8arr_div_svec</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scalar_args</name> <init>= <expr><call><name>check_scalar</name><argument_list>(<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>SDATA_IS_SCALAR</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><call><name>svec_operate_on_sdata_pair</name><argument_list>(<argument><expr><name>scalar_args</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_dot_float8arr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_dot_float8arr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>mult_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>accum</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>mult_result</name> <operator>=</operator> <call><name>op_sdata_by_sdata</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>accum</name> <operator>=</operator> <call><name>sum_sdata_values_double</name><argument_list>(<argument><expr><name>mult_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeSparseData</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeSparseDataAndData</name><argument_list>(<argument><expr><name>mult_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_dot_svec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>float8arr_dot_svec</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>left</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>right</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>mult_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>accum</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>mult_result</name> <operator>=</operator> <call><name>op_sdata_by_sdata</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>accum</name> <operator>=</operator> <call><name>sum_sdata_values_double</name><argument_list>(<argument><expr><name>mult_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeSparseData</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeSparseDataAndData</name><argument_list>(<argument><expr><name>mult_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Hash function for float8[]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>float8arr_hash_internal</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>l1norm</name> <init>= <expr><call><name>l1norm_sdata_values_double</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>arr_hash</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>hashfloat8</name></expr></argument>, <argument><expr><call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>l1norm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return<expr><operator>(</operator><name>arr_hash</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>Datum</name></type> <name>float8arr_hash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>float8arr_hash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name>  <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>float8arr_hash_internal</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Aggregate function svec_pivot takes it's float8 argument and appends it
 * to the state variable (an svec) to produce the concatenated return variable.
 * The StringInfo variables within the state variable svec are used in a way
 * that minimizes the number of memory re-allocations.
 *
 * Note that the first time this is called, the state variable should be null.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_pivot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_pivot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type> <name>value</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">0.</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>svec</name> <operator>=</operator> <call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>	<comment type="line">//first call, construct a new svec</comment>
		<comment type="block">/*
		 * Allocate space for the unique values and index
		 *
		 * Note that we do this manually because we are going to
		 * manage the memory allocations for the StringInfo structures
		 * manually within this aggregate so that we can preserve
		 * the intermediate state without re-serializing until there is
		 * a need to re-alloc, at which point we will re-serialize to
		 * form the returned state variable.
		 */</comment>
		<expr_stmt><expr><name>svec</name> <operator>=</operator> <call><name>makeEmptySvec</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>sdata</name> <operator>=</operator> <call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add the incoming float8 value to the svec.
	 *
	 * First check to see if there is room in both the data area and index
	 * and if there isn't, re-alloc and recreate the svec
	 */</comment>
	<if_stmt><if>if <condition>(   <expr><operator>(</operator><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>maxlen</name></name><operator>)</operator>
	    <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">9</literal> <operator>+</operator><literal type="number">1</literal><operator>)</operator>            <operator>&gt;</operator> <name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>maxlen</name></name><operator>)</operator></expr> )</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>svec</name> <operator>=</operator> <call><name>reallocSvec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sdata</name> <operator>=</operator> <call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Now let's check to see if we're adding a new value or appending to the last
	 * run.  If the incoming value is the same as the last value, just increment
	 * the last run.  Note that we need to use the index cursor to find where the
	 * last index counter is located.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>index_location</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>old_index_storage_size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>run_count</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float8</name></type> <name>last_value</name><init>=<expr><operator>-</operator><literal type="number">100000</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>new_run</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name><operator>==</operator><literal type="number">0</literal></expr>)</condition> <comment type="line">//New vector</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>new_run</name><operator>=</operator><name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>index_location</name> <operator>=</operator> <name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else
		<block>{<block_content>
			<expr_stmt><expr><name>index_location</name> <operator>=</operator> <name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cursor</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_index_storage_size</name> <operator>=</operator> <call><name>int8compstoragesize</name><argument_list>(<argument><expr><name>index_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_count</name> <operator>=</operator> <call><name>compword_to_int8</name><argument_list>(<argument><expr><name>index_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_value</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name><operator>+</operator><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>last_value</name> <operator>==</operator> <name>value</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>new_run</name><operator>=</operator><name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name>new_run</name><operator>=</operator><name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_run</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>run_count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>int8_to_compword</name><argument_list>(<argument><expr><name>run_count</name></expr></argument>,<argument><expr><name>index_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <operator>(</operator><call><name>int8compstoragesize</name><argument_list>(<argument><expr><name>index_location</name></expr></argument>)</argument_list></call>
					<operator>-</operator> <name>old_index_storage_size</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>total_value_count</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>add_run_to_sdata</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>i_ptr</name><init>=<expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>len</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>j</name><operator>&lt;</operator><name><name>sdata</name><operator>-&gt;</operator><name>unique_value_count</name></name><operator>-</operator><literal type="number">1</literal></expr>;</condition><incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>len</name><operator>+=</operator><call><name>int8compstoragesize</name><argument_list>(<argument><expr><name>i_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>i_ptr</name><operator>+=</operator><call><name>int8compstoragesize</name><argument_list>(<argument><expr><name>i_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANDOM_RANGE</name></cpp:macro>	<cpp:value>(((double)random())/(2147483647.+1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANDOM_INT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((int)(x)+(int)(((y+1)-(x))*RANDOM_RANGE))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAPVAL</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>temp</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>{ (temp) = (x); (x) = (y); (y) = (temp); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>tmp</name></type></parameter>,<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>{ memcpy((tmp),(x),(size)); memcpy((x),(y),(size)); memcpy((y),(tmp),(size)); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAPN</name><parameter_list>(<parameter><type><name>lists</name></type></parameter>,<parameter><type><name>nlists</name></type></parameter>,<parameter><type><name>widths</name></type></parameter>,<parameter><type><name>tmp</name></type></parameter>,<parameter><type><name>I</name></type></parameter>,<parameter><type><name>J</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>{ \
	for (int III=0;III&lt;nlists;III++) <comment type="block">/* This should be unrolled as nlists will be small */</comment> \
	{ \
	  	memcpy((tmp)[III]                  ,(lists)[III]+I*(widths)[III],(widths)[III]); \
		memcpy((lists)[III]+I*(widths)[III],(lists)[III]+J*(widths)[III],(widths)[III]); \
		memcpy((lists)[III]+J*(widths)[III],(tmp)[III]                  ,(widths)[III]); \
	} \
}</cpp:value></cpp:define>
<comment type="block">/*
 * Implements the partition selection algorithm with randomized selection
 *
 * From: http://en.wikipedia.org/wiki/Selection_algorithm#Linear_general_selection_algorithm_-_.22Median_of_Medians_algorithm.22
 *
 * Arguments:
 * 	char **lists:	A list of lists, the first of which contains the values used for pivots
 * 			the 2nd and further lists will be pivoted alongside the first.
 * 			A common usage would be to have the first list point to an array
 * 			of values, then the second would point to another char ** list of
 * 			strings.  The second list would have it's pointer values moved
 * 			around as part of the pivots, and the index location where the
 * 			partition value (say for the median) occurs would allow a reference
 * 			to the associated strings in the second list.
 * 	size_t nlists	the number of lists
 * 	size_t *widths	An array of widths, one for each list
 * 	int left,right	The left and right boundary of the list to be pivoted
 * 	int pivotIndex	The index around which to pivot the list.  A common use-case is
 * 			to choose pivotIndex = listLength/2, then the pivot will provide
 * 			the median location.
 * 	int (*compar)	A comparison function for the first list, which takes two pointers
 * 			to values in the first list and returns 0,-1 or 1 when the first
 * 			value is equal, less than or greater than the second.
 * 	char **tmp 	A list of temporary variables, allocated with the size of the value
 * 			in each list
 * 	void *pvalue	Pointers to temporary variable allocated with the width of the
 * 			values of the first list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>partition_pivot</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lists</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nlists</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>widths</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pivotIndex</name></decl></parameter>,
		<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>compar</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
		<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tmp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>storeIndex</name> <init>= <expr><name>left</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>,<argument><expr><name><name>lists</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><name>pivotIndex</name><operator>*</operator><name><name>widths</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>widths</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>SWAPN</name><argument_list>(<argument>lists</argument>,<argument>nlists</argument>,<argument>widths</argument>,<argument>tmp</argument>,<argument>pivotIndex</argument>,<argument>right</argument>)</argument_list></macro> <comment type="line">// Move pivot to end</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><name>left</name></expr></init></decl>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>right</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>compar</name><argument_list>(<argument><expr><name><name>lists</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><name>i</name><operator>*</operator><name><name>widths</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<macro><name>SWAPN</name><argument_list>(<argument>lists</argument>,<argument>nlists</argument>,<argument>widths</argument>,<argument>tmp</argument>,<argument>i</argument>,<argument>storeIndex</argument>)</argument_list></macro>
			<expr_stmt><expr><name>storeIndex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<macro><name>SWAPN</name><argument_list>(<argument>lists</argument>,<argument>nlists</argument>,<argument>widths</argument>,<argument>tmp</argument>,<argument>storeIndex</argument>,<argument>right</argument>)</argument_list></macro> <comment type="line">// Move pivot to its final place</comment>
	<return>return<expr><operator>(</operator><name>storeIndex</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The call interface to partition_select has one complicated looking feature:
 * you must pass in a "Real Index Calculation" function that will return an integer
 * corresponding to the actual partition index.  This is used to enable the same routine to
 * work with dense and compressed structures.  This function can just return the input
 * integer unmodified if using a dense array of values as input.
 * The arguments to realIndexCalc() should be:
 * 	int: 		the pivot index (returned from the pivot function)
 * 	char **:	the list of lists
 * 	size_t:		the number of lists
 * 	size_t *:	the width of each value in the list
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>partition_select</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lists</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nlists</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>widths</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>,
		<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>compar</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
		<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>realIndexCalc</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>pivotIndex</name></decl>,<decl><type ref="prev"/><name>pivotNewIndex</name></decl>,<decl><type ref="prev"/><name>realIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tmp</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>maxlen</name> <init>= <expr><name>right</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate memory for the temporary variables
	 */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>nlists</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>nlists</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name><name>widths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>pvalue</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name><name>widths</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pivotIndex</name> <operator>=</operator> <call><name>RANDOM_INT</name><argument_list>(<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pivotNewIndex</name> <operator>=</operator> <call><name>partition_pivot</name><argument_list>(<argument><expr><name>lists</name></expr></argument>,<argument><expr><name>nlists</name></expr></argument>,<argument><expr><name>widths</name></expr></argument>,
					<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>,<argument><expr><name>pivotIndex</name></expr></argument>,
					<argument><expr><name>compar</name></expr></argument>,
					<argument><expr><name>tmp</name></expr></argument>,<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>realIndex</name> <operator>=</operator> <call><name>realIndexCalc</name><argument_list>(<argument><expr><name>pivotNewIndex</name></expr></argument>,
				<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>lists</name></expr></argument>,<argument><expr><name>nlists</name></expr></argument>,<argument><expr><name>widths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nextRealIndex</name> <init>= <expr><call><name>realIndexCalc</name><argument_list>(<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>maxlen</name></expr></argument>,<argument><expr><name>pivotNewIndex</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
	                                <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>lists</name></expr></argument>,<argument><expr><name>nlists</name></expr></argument>,<argument><expr><name>widths</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>realIndex</name> <operator>&lt;=</operator> <name>k</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>k</name> <operator>&lt;</operator> <name>nextRealIndex</name> <operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>k</name> <operator>&lt;</operator> <name>realIndex</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>right</name> <operator>=</operator> <name>pivotNewIndex</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else
		<block>{<block_content>
			<expr_stmt><expr><name>left</name> <operator>=</operator> <name>pivotNewIndex</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;=</operator> <name>maxlen</name></expr>)</condition> 
			<block>{<block_content>
				<expr_stmt><expr><name>pivotNewIndex</name> <operator>=</operator> <name>maxlen</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Free temporary variables
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>nlists</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tmp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return<expr><operator>(</operator><name>pivotNewIndex</name><operator>)</operator></expr>;</return> <comment type="line">//This index is in the compressed coordinate system</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compar_float8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content><if_stmt><if>if<condition>(<expr><operator>*</operator><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator><name>left</name><operator>&lt;</operator><operator>*</operator><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator><name>right</name></expr>)</condition><block>{<block_content><return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content>}</block></if><if type="elseif">else if<condition>(<expr><operator>*</operator><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator><name>left</name><operator>==</operator><operator>*</operator><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator><name>right</name></expr>)</condition><block>{<block_content><return>return <expr><literal type="number">0</literal></expr>;</return></block_content>}</block></if><else>else<block>{<block_content><return>return <expr><literal type="number">1</literal></expr>;</return></block_content>}</block></else></if_stmt></block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>real_index_calc_dense</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lists</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>nlists</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>widths</name></decl></parameter>)</parameter_list> <block>{<block_content><return>return <expr><name>idx</name></expr>;</return></block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>real_index_calc_sparse_RLE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lists</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>nlists</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>size_t</name> <modifier>*</modifier></type><name>widths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>index</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>idx</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <name>index</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>lists</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/*
	 * The index calculation corresponds to the beginning
	 * of the run located at (idx).
	 */</comment>
	<return>return <expr><operator>(</operator><name>index</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>float8arr_partition_internal</name><parameter_list>(<parameter><decl><type><name>float8</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>width</name><init>=<expr><sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>array</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>partition_select</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>width</name></expr></argument>,
				<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr></argument>,
			   	<argument><expr><name>k</name></expr></argument>,<argument><expr><name>compar_float8</name></expr></argument>,
				<argument><expr><name>real_index_calc_dense</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>(</operator><name>index</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>Datum</name></type> <name>float8arr_median</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8arr_median</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>float8arr_median</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name>  <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>sdata_uncompressed_from_float8arr_internal</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>,<decl><type ref="prev"/><name>median_index</name> <init>= <expr><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>total_value_count</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>float8arr_partition_internal</name><argument_list>(<argument><expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></argument>,
					     <argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>total_value_count</name></name></expr></argument>,
					     <argument><expr><name>median_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>Datum</name></type> <name>svec_median</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_median</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>svec_median</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name>  <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>,<decl><type ref="prev"/><name>median_index</name> <init>= <expr><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>total_value_count</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>i_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name> <modifier>*</modifier></type><name>rle_index</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <comment type="line">//Sparse vector</comment>
	<block>{<block_content>
		<comment type="block">/*
	 	 * We need to create an uncompressed run length index to
	 	 * feed to the partition select routine
	 	 */</comment>
		<expr_stmt><expr><name>rle_index</name> <operator>=</operator> <operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>unique_value_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_ptr</name> <operator>=</operator> <name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>sdata</name><operator>-&gt;</operator><name>unique_value_count</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator><expr><name>i_ptr</name><operator>+=</operator><call><name>int8compstoragesize</name><argument_list>(<argument><expr><name>i_ptr</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rle_index</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>compword_to_int8</name><argument_list>(<argument><expr><name>i_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/*
		 * Allocate the outer "list of lists"
		 */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lists</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>lists</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lists</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>rle_index</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>widths</name> <init>= <expr><operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>widths</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>widths</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>partition_select</name><argument_list>(<argument><expr><name>lists</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>widths</name></expr></argument>,
					<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>unique_value_count</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>,
			   		<argument><expr><name>median_index</name></expr></argument>,<argument><expr><name>compar_float8</name></expr></argument>,
					<argument><expr><name>real_index_calc_sparse_RLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Convert the uncompressed index into the compressed index
		 */</comment>
		<expr_stmt><expr><name>i_ptr</name> <operator>=</operator> <name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>i</name><operator>&lt;</operator><name><name>sdata</name><operator>-&gt;</operator><name>unique_value_count</name></name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator><expr><name>i_ptr</name><operator>+=</operator><call><name>int8compstoragesize</name><argument_list>(<argument><expr><name>i_ptr</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>int8_to_compword</name><argument_list>(<argument><expr><name><name>rle_index</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>i_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>widths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rle_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else
	<block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>float8arr_partition_internal</name><argument_list>(<argument><expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></argument>,
				<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>total_value_count</name></name></expr></argument>,
				<argument><expr><name>median_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
