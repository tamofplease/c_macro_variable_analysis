<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/gpcontrib/gp_sparse_vector/sparse_vector.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * sparse_vector.c
 *
 * Sparse Vector Datatype.  We would like to store sparse arrays in a terse
 * representation that fits in a small amount of memory.  We also want to be
 * able to compare the number of instances where the svec of one document
 * intersects another.

 * Copyright (c) 2010, Greenplum Software
 * Portions Copyright (c) 2013-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    gpcontrib/gp_sparse_vector/sparse_vector.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;search.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sparse_vector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Input and Output routines
 */</comment>

<function><type><name>ArrayType</name> <modifier>*</modifier></type><name>svec_return_array_internal</name><parameter_list>(<parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>pgarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name><init>=<expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>array</name><init>=<expr><call><name>sdata_to_float8arr</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>pgarray</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator><name>array</name></expr></argument>,
		<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>total_value_count</name></name></expr></argument>,<argument><expr><name>FLOAT8OID</name></expr></argument>,
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>true</name></expr></argument>,<argument><expr><literal type="char">'d'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return<expr><operator>(</operator><name>pgarray</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * Must serialize for binary communication with libpq via
 * creating a StringInfo and sending individual data items like:
 *	(from backend/libpq/pqformat.c):
 *              pq_beginmessage - initialize StringInfo buffer
 *              pq_sendbyte             - append a raw byte to a StringInfo buffer
 *              pq_sendint              - append a binary integer to a StringInfo buffer
 *              pq_sendint64    - append a binary 8-byte int to a StringInfo buffer
 *              pq_sendfloat4   - append a float4 to a StringInfo buffer
 *              pq_sendfloat8   - append a float8 to a StringInfo buffer
 *              pq_sendbytes    - append raw data to a StringInfo buffer
 *              pq_sendcountedtext - append a counted text string (with character set conversion)
 *              pq_sendtext             - append a text string (with conversion)
 *              pq_sendstring   - append a null-terminated text string (with conversion)
 *              pq_send_ascii_string - append a null-terminated text string (without conversion)
 *              pq_endmessage   - send the completed message to the frontend
 *
 */</comment>

<comment type="block">/*
 *        svec_send            - converts text to binary format
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>svec_send</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>type_of_data</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>unique_value_count</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>total_value_count</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 *        svec_recv            - converts external binary format to text
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>svec_recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name><init>=<expr><call><name>makeEmptySparseData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>type_of_data</name></name>       <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>unique_value_count</name></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>total_value_count</name></name>  <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name>          <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name>         <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name>         <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name>        <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>svec</name> <operator>=</operator> <call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//Note that this copies the data</comment>
<comment type="line">//	freeSparseDataAndData(sdata);</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Basic floating point operators like MIN,MAX
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8_min</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>Datum</name></type> <name>float8_min</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>Datum</name></type>
<name>float8_min</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>left</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type> <name>right</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>float8_max</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>Datum</name></type> <name>float8_max</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>Datum</name></type>
<name>float8_max</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>left</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type> <name>right</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name>left</name></expr></argument>,<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns an uncompressed Array
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>( <argument><expr><name>svec_return_array</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_return_array</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>pgarray</name> <init>= <expr><call><name>svec_return_array_internal</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>pgarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>svec_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name> <init>= <expr><call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>svec_out_internal</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>svec_out_internal</name><parameter_list>(<parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ix_string</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>vals_string</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ixlen</name></decl>,<decl><type ref="prev"/><name>vslen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name><init>=<expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name> <modifier>*</modifier></type><name>array_ix</name> <init>=<expr><call><name>sdata_index_to_int64arr</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>pgarray_ix</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pgarray_vals</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pgarray_ix</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator><name>array_ix</name></expr></argument>,
		<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>unique_value_count</name></name></expr></argument>,<argument><expr><name>INT8OID</name></expr></argument>,
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>true</name></expr></argument>,<argument><expr><literal type="char">'d'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ix_string</name><operator>=</operator><call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>F_ARRAY_OUT</name></expr></argument>,
				<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>pgarray_ix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ixlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ix_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pgarray_vals</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
		<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>unique_value_count</name></name></expr></argument>,<argument><expr><name>FLOAT8OID</name></expr></argument>,
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>true</name></expr></argument>,<argument><expr><literal type="char">'d'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vals_string</name><operator>=</operator><call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>F_ARRAY_OUT</name></expr></argument>,
				<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>pgarray_vals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vslen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>vals_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>vslen</name><operator>+</operator><name>ixlen</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>,<argument><expr><literal type="string">"%s:%s"</literal></expr></argument>,<argument><expr><name>ix_string</name></expr></argument>,<argument><expr><name>vals_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ix_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>vals_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>array_ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return<expr><operator>(</operator><name>result</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>svec_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>pgarray_vals</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>pgarray_ix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>vals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name> <modifier>*</modifier></type><name>u_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32_t</name></type> <name>num_values</name></decl>,<decl><type ref="prev"/><name>total_value_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Read in the two arrays defining the Sparse Vector, first is the array
	 * of run lengths, the second is an array of the unique values.
	 *
	 * The input format is a pair of standard Postgres arrays separated by a colon,
	 * like this:
	 * 	{1,10,1,5,1}:{4.3,0,0.2,0,7.4}
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>values</name><operator>=</operator><call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input string for svec"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>values</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>values</name> <operator>=</operator> <name>values</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>pgarray_vals</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><call><name>OidFunctionCall3</name><argument_list>(<argument><expr><name>F_ARRAY_IN</name></expr></argument>,<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>FLOAT8OID</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make an empty StringInfo because we have the data array already */</comment>
	<expr_stmt><expr><name>vals</name> <operator>=</operator> <operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>pgarray_vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_values</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>pgarray_vals</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>pgarray_ix</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><call><name>OidFunctionCall3</name><argument_list>(<argument><expr><name>F_ARRAY_IN</name></expr></argument>,<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>u_index</name> <operator>=</operator> <operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator><call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>pgarray_ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>num_values</name> <operator>!=</operator> <operator>*</operator><operator>(</operator><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>pgarray_ix</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unique value count not equal to run length count"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_value_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init><condition><expr><name>i</name><operator>&lt;</operator><name>num_values</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>total_value_count</name><operator>+=</operator><name><name>u_index</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>append_to_rle_index</name><argument_list>(<argument><expr><name>index</name></expr></argument>,<argument><expr><name><name>u_index</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>sdata</name> <operator>=</operator> <call><name>makeInplaceSparseData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>vals</name></expr></argument>,<argument><expr><name><name>index</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
			<argument><expr><name>num_values</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name><name>index</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,<argument><expr><name>FLOAT8OID</name></expr></argument>,
			<argument><expr><name>num_values</name></expr></argument>,<argument><expr><name>total_value_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>type_of_data</name></name> <operator>=</operator> <name>FLOAT8OID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>total_value_count</name><operator>==</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dimension</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="line">//Scalar</comment>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* str is allocated from a strdup */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pgarray_ix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pgarray_vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_SVECTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SvecType</name> <modifier>*</modifier></type><name>svec_from_sparsedata</name><parameter_list>(<parameter><decl><type><name>SparseData</name></type> <name>sdata</name></decl></parameter>,<parameter><decl><type><name>bool</name></type> <name>trim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>trim</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Trim the extra space off of the StringInfo dynamic strings
		 * before serializing the SparseData
		 */</comment>
		<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>maxlen</name></name><operator>=</operator><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>maxlen</name></name><operator>=</operator><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>size</name><operator>=</operator><name>SVECHDRSIZE</name> <operator>+</operator> <call><name>SIZEOF_SPARSEDATASERIAL</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>SvecType</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>serializeSparseData</name><argument_list>(<argument><expr><call><name>SVEC_SDATAPTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dimension</name></name> <operator>=</operator> <name><name>sdata</name><operator>-&gt;</operator><name>total_value_count</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>dimension</name></name><operator>==</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dimension</name></name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="line">//Scalar</comment>
	<return>return <expr><operator>(</operator><name>result</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>SvecType</name> <modifier>*</modifier></type><name>svec_from_float8arr</name><parameter_list>(<parameter><decl><type><name>float8</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dimension</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>float8arr_to_sdata</name><argument_list>(<argument><expr><name>array</name></expr></argument>,<argument><expr><name>dimension</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SvecType</name> <modifier>*</modifier></type><name>makeEmptySvec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>allocation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>val_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>allocation</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ind_len</name> <init>= <expr><literal type="number">9</literal><operator>*</operator><name>allocation</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>makeEmptySparseData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name>    <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>maxlen</name></name>  <operator>=</operator> <name>val_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name>   <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>ind_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>=</operator> <name>ind_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>svec</name> <operator>=</operator> <call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>,<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeSparseDataAndData</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return<expr><operator>(</operator><name>svec</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>SvecType</name> <modifier>*</modifier></type><name>reallocSvec</name><parameter_list>(<parameter><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name> <init>= <expr><call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>val_newmaxlen</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><literal type="number">9</literal></expr></argument>,<argument><expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>maxlen</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newvals</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>val_newmaxlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ind_newmaxlen</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>,<argument><expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>maxlen</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newindex</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>ind_newmaxlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * This space was never allocated with palloc, so we can't repalloc it!
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newvals</name></expr></argument> ,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name></expr></argument> ,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newindex</name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name> <index>[<expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name>  <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name>    <operator>=</operator> <name>newvals</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>maxlen</name></name>  <operator>=</operator> <name>val_newmaxlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name>   <operator>=</operator> <name>newindex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>=</operator> <name>ind_newmaxlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>svec</name> <operator>=</operator> <call><name>svec_from_sparsedata</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>,<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="line">//	pfree(source);</comment>
	<return>return<expr><operator>(</operator><name>svec</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SparseData</name></type> <name>sdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>dimension</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>absolute_value_position</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>unique_value_position</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>run_position</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>index_position</name></decl>;</decl_stmt>
}</block></struct></type>	<name>svec_unnest_fctx</name>;</typedef>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>svec_unnest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>svec_unnest</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
        <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>svec_unnest_fctx</name> <modifier>*</modifier></type><name>fctx</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SvecType</name> <modifier>*</modifier></type><name>svec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>run_length</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* stuff done only on the first call of the function */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
                <comment type="block">/* create a function context for cross-call persistence */</comment>
                <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * switch to memory context appropriate for multiple function calls
                 */</comment>
                <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* allocate memory for user context */</comment>
                <expr_stmt><expr><name>fctx</name> <operator>=</operator> <operator>(</operator><name>svec_unnest_fctx</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svec_unnest_fctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>svec</name>   <operator>=</operator> <call><name>PG_GETARG_SVECTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>sdata</name></name> <operator>=</operator> <call><name>sdata_from_svec</name><argument_list>(<argument><expr><name>svec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* set initial index into the sparse vector argument */</comment>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>dimension</name></name>               <operator>=</operator> <name><name>svec</name><operator>-&gt;</operator><name>dimension</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>absolute_value_position</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>unique_value_position</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>index_position</name></name>          <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>sdata</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>run_position</name></name>            <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>fctx</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>fctx</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>run_length</name> <operator>=</operator> <call><name>compword_to_int8</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>index_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fctx</name><operator>-&gt;</operator><name>dimension</name></name> <operator>&gt;</operator> <name><name>fctx</name><operator>-&gt;</operator><name>absolute_value_position</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>fctx</name><operator>-&gt;</operator><name>sdata</name><operator>-&gt;</operator><name>vals</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator><operator>)</operator>
			<index>[<expr><name><name>fctx</name><operator>-&gt;</operator><name>unique_value_position</name></name></expr>]</index></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>absolute_value_position</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>run_position</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fctx</name><operator>-&gt;</operator><name>run_position</name></name> <operator>&gt;</operator> <name>run_length</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>run_position</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>unique_value_position</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>index_position</name></name> <operator>+=</operator> <call><name>int8compstoragesize</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>index_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

                <comment type="block">/* send the result */</comment>
                <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
	<block>{<block_content>
                <comment type="block">/* do when there is no more left */</comment>
                <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
		
</block_content>}</block></function>




<comment type="block">/*
 * TODO
 *
 * "R" basic matrix routines
 * 	From: file:///opt/local/var/macports/software/R/2.6.2_0/opt/local/lib/R/doc/manual/R-intro.html
 * 		The function crossprod() forms crossproducts, meaning that crossprod(X, y) is the
 * 		same as t(X) %*% y but the operation is more efficient. If the second argument to
 * 		crossprod() is omitted it is taken to be the same as the first.
 *
 * 		The meaning of diag() depends on its argument. diag(v), where v is a vector, gives
 * 		a diagonal matrix with elements of the vector as the diagonal entries. On the other
 * 		hand diag(M), where M is a matrix, gives the vector of main diagonal entries of M.
 * 		This is the same convention as that used for diag() in Matlab. Also, somewhat
 * 		confusingly, if k is a single numeric value then diag(k) is the k by k identity matrix!
 *
 * 		5.7.2 Linear equations and inversion
 *
 * 		Solving linear equations is the inverse of matrix multiplication. When after
 *      		&gt; b &lt;- A %*% x
 *      	only A and b are given, the vector x is the solution of that linear equation system. In R,
 *           		&gt; solve(A,b)
 *           	solves the system, returning x (up to some accuracy loss). Note that in linear algebra,
 *           	formally x = A^{-1} %*% b where A^{-1} denotes the inverse of A, which can be computed by
 *              solve(A) but rarely is needed. Numerically, it is both inefficient and potentially unstable
 *              to compute x &lt;- solve(A) %*% b instead of solve(A,b).
 *
 *              The quadratic form x %*% A^{-1} %*% x which is used in multivariate computations, should
 *              be computed by something like16 x %*% solve(A,x), rather than computing the inverse of A.
 *
 */</comment>


</unit>
