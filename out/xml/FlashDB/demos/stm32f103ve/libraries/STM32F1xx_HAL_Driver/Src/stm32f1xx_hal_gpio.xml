<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f103ve/libraries/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f1xx_hal_gpio.c
  * @author  MCD Application Team
  * @brief   GPIO HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *
  @verbatim
  ==============================================================================
                    ##### GPIO Peripheral features #####
  ==============================================================================
  [..]
  Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each
  port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software
  in several modes:
  (+) Input mode
  (+) Analog mode
  (+) Output mode
  (+) Alternate function mode
  (+) External interrupt/event lines

  [..]
  During and just after reset, the alternate functions and external interrupt
  lines are not active and the I/O ports are configured in input floating mode.

  [..]
  All GPIO pins have weak internal pull-up and pull-down resistors, which can be
  activated or not.

  [..]
  In Output or Alternate mode, each IO can be configured on open-drain or push-pull
  type and the IO speed can be selected depending on the VDD value.

  [..]
  All ports have external interrupt/event capability. To use external interrupt
  lines, the port must be configured in input mode. All available GPIO pins are
  connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.

  [..]
  The external interrupt/event controller consists of up to 20 edge detectors in connectivity
  line devices, or 19 edge detectors in other devices for generating event/interrupt requests.
  Each input line can be independently configured to select the type (event or interrupt) and
  the corresponding trigger event (rising or falling or both). Each line can also masked
  independently. A pending register maintains the status line of the interrupt requests

                     ##### How to use this driver #####
  ==============================================================================
 [..]
   (#) Enable the GPIO APB2 clock using the following function : __HAL_RCC_GPIOx_CLK_ENABLE().

   (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
       (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
       (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef
            structure.
       (++) In case of Output or alternate function mode selection: the speed is
            configured through "Speed" member from GPIO_InitTypeDef structure
       (++) Analog mode is required when a pin is to be used as ADC channel
            or DAC output.
       (++) In case of external interrupt/event selection the "Mode" member from
            GPIO_InitTypeDef structure select the type (interrupt or event) and
            the corresponding trigger event (rising or falling or both).

   (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority
       mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
       HAL_NVIC_EnableIRQ().

   (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().

   (#) To set/reset the level of a pin configured in output mode use
       HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().

   (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().

   (#) During and just after reset, the alternate functions are not
       active and the GPIO pins are configured in input floating mode (except JTAG
       pins).

   (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose
       (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has
       priority over the GPIO function.

   (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as
       general purpose PD0 and PD1, respectively, when the HSE oscillator is off.
       The HSE has priority over the GPIO function.

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f1xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F1xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup GPIO GPIO
  * @brief GPIO HAL module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_GPIO_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup GPIO_Private_Constants GPIO Private Constants
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GPIO_MODE</name></cpp:macro>             <cpp:value>0x00000003u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTI_MODE</name></cpp:macro>             <cpp:value>0x10000000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GPIO_MODE_IT</name></cpp:macro>          <cpp:value>0x00010000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GPIO_MODE_EVT</name></cpp:macro>         <cpp:value>0x00020000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RISING_EDGE</name></cpp:macro>           <cpp:value>0x00100000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FALLING_EDGE</name></cpp:macro>          <cpp:value>0x00200000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GPIO_OUTPUT_TYPE</name></cpp:macro>      <cpp:value>0x00000010u</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GPIO_NUMBER</name></cpp:macro>           <cpp:value>16u</cpp:value></cpp:define>

<comment type="block">/* Definitions for bit manipulation of CRL and CRH register */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>GPIO_CR_MODE_INPUT</name></cpp:macro>         <cpp:value>0x00000000u</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; 00: Input mode (reset state)  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>GPIO_CR_CNF_ANALOG</name></cpp:macro>         <cpp:value>0x00000000u</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; 00: Analog mode  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>GPIO_CR_CNF_INPUT_FLOATING</name></cpp:macro> <cpp:value>0x00000004u</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; 01: Floating input (reset state)  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>GPIO_CR_CNF_INPUT_PU_PD</name></cpp:macro>    <cpp:value>0x00000008u</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; 10: Input with pull-up / pull-down  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>GPIO_CR_CNF_GP_OUTPUT_PP</name></cpp:macro>   <cpp:value>0x00000000u</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; 00: General purpose output push-pull  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>GPIO_CR_CNF_GP_OUTPUT_OD</name></cpp:macro>   <cpp:value>0x00000004u</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; 01: General purpose output Open-drain  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>GPIO_CR_CNF_AF_OUTPUT_PP</name></cpp:macro>   <cpp:value>0x00000008u</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; 10: Alternate function output Push-pull  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>GPIO_CR_CNF_AF_OUTPUT_OD</name></cpp:macro>   <cpp:value>0x0000000Cu</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; 11: Alternate function output Open-drain  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>
<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block">/* Private functions ---------------------------------------------------------*/</comment>
<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup GPIO_Exported_Functions GPIO Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions
 *  @brief    Initialization and Configuration functions
 *
@verbatim
 ===============================================================================
              ##### Initialization and de-initialization functions #####
 ===============================================================================
  [..]
    This section provides functions allowing to initialize and de-initialize the GPIOs
    to be ready for use.

@endverbatim
  * @{
  */</comment>


<comment type="block" format="doxygen">/**
  * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
  * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_GPIO_Init</name><parameter_list>(<parameter><decl><type><name>GPIO_TypeDef</name>  <modifier>*</modifier></type><name>GPIOx</name></decl></parameter>, <parameter><decl><type><name>GPIO_InitTypeDef</name> <modifier>*</modifier></type><name>GPIO_Init</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>position</name> <init>= <expr><literal type="number">0x00u</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>ioposition</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>iocurrent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>temp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>config</name> <init>= <expr><literal type="number">0x00u</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name> <modifier>*</modifier></type><name>configregister</name></decl>;</decl_stmt> <comment type="block">/* Store the address of CRL or CRH register based on pin number */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>registeroffset</name></decl>;</decl_stmt>       <comment type="block">/* offset used during computation of CNF and MODE bits placement inside CRL or CRH register */</comment>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_ALL_INSTANCE</name><argument_list>(<argument><expr><name>GPIOx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_PIN</name><argument_list>(<argument><expr><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Pin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_MODE</name><argument_list>(<argument><expr><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Configure the port pins */</comment>
  <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Pin</name></name><operator>)</operator> <operator>&gt;&gt;</operator> <name>position</name><operator>)</operator> <operator>!=</operator> <literal type="number">0x00u</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Get the IO position */</comment>
    <expr_stmt><expr><name>ioposition</name> <operator>=</operator> <operator>(</operator><literal type="number">0x01uL</literal> <operator>&lt;&lt;</operator> <name>position</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Get the current IO position */</comment>
    <expr_stmt><expr><name>iocurrent</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Pin</name></name><operator>)</operator> <operator>&amp;</operator> <name>ioposition</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>iocurrent</name> <operator>==</operator> <name>ioposition</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check the Alternate function parameters */</comment>
      <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_AF_INSTANCE</name><argument_list>(<argument><expr><name>GPIOx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */</comment>
      <switch>switch <condition>(<expr><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Mode</name></name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* If we are configuring the pin in OUTPUT push-pull mode */</comment>
        <case>case <expr><name>GPIO_MODE_OUTPUT_PP</name></expr>:</case>
          <comment type="block">/* Check the GPIO speed parameter */</comment>
          <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_SPEED</name><argument_list>(<argument><expr><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Speed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>config</name> <operator>=</operator> <name><name>GPIO_Init</name><operator>-&gt;</operator><name>Speed</name></name> <operator>+</operator> <name>GPIO_CR_CNF_GP_OUTPUT_PP</name></expr>;</expr_stmt>
          <break>break;</break>

        <comment type="block">/* If we are configuring the pin in OUTPUT open-drain mode */</comment>
        <case>case <expr><name>GPIO_MODE_OUTPUT_OD</name></expr>:</case>
          <comment type="block">/* Check the GPIO speed parameter */</comment>
          <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_SPEED</name><argument_list>(<argument><expr><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Speed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>config</name> <operator>=</operator> <name><name>GPIO_Init</name><operator>-&gt;</operator><name>Speed</name></name> <operator>+</operator> <name>GPIO_CR_CNF_GP_OUTPUT_OD</name></expr>;</expr_stmt>
          <break>break;</break>

        <comment type="block">/* If we are configuring the pin in ALTERNATE FUNCTION push-pull mode */</comment>
        <case>case <expr><name>GPIO_MODE_AF_PP</name></expr>:</case>
          <comment type="block">/* Check the GPIO speed parameter */</comment>
          <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_SPEED</name><argument_list>(<argument><expr><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Speed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>config</name> <operator>=</operator> <name><name>GPIO_Init</name><operator>-&gt;</operator><name>Speed</name></name> <operator>+</operator> <name>GPIO_CR_CNF_AF_OUTPUT_PP</name></expr>;</expr_stmt>
          <break>break;</break>

        <comment type="block">/* If we are configuring the pin in ALTERNATE FUNCTION open-drain mode */</comment>
        <case>case <expr><name>GPIO_MODE_AF_OD</name></expr>:</case>
          <comment type="block">/* Check the GPIO speed parameter */</comment>
          <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_SPEED</name><argument_list>(<argument><expr><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Speed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>config</name> <operator>=</operator> <name><name>GPIO_Init</name><operator>-&gt;</operator><name>Speed</name></name> <operator>+</operator> <name>GPIO_CR_CNF_AF_OUTPUT_OD</name></expr>;</expr_stmt>
          <break>break;</break>

        <comment type="block">/* If we are configuring the pin in INPUT (also applicable to EVENT and IT mode) */</comment>
        <case>case <expr><name>GPIO_MODE_INPUT</name></expr>:</case>
        <case>case <expr><name>GPIO_MODE_IT_RISING</name></expr>:</case>
        <case>case <expr><name>GPIO_MODE_IT_FALLING</name></expr>:</case>
        <case>case <expr><name>GPIO_MODE_IT_RISING_FALLING</name></expr>:</case>
        <case>case <expr><name>GPIO_MODE_EVT_RISING</name></expr>:</case>
        <case>case <expr><name>GPIO_MODE_EVT_FALLING</name></expr>:</case>
        <case>case <expr><name>GPIO_MODE_EVT_RISING_FALLING</name></expr>:</case>
          <comment type="block">/* Check the GPIO pull parameter */</comment>
          <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_PULL</name><argument_list>(<argument><expr><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Pull</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Pull</name></name> <operator>==</operator> <name>GPIO_NOPULL</name></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><name>config</name> <operator>=</operator> <name>GPIO_CR_MODE_INPUT</name> <operator>+</operator> <name>GPIO_CR_CNF_INPUT_FLOATING</name></expr>;</expr_stmt>
          </block_content>}</block></if>
          <if type="elseif">else if <condition>(<expr><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Pull</name></name> <operator>==</operator> <name>GPIO_PULLUP</name></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><name>config</name> <operator>=</operator> <name>GPIO_CR_MODE_INPUT</name> <operator>+</operator> <name>GPIO_CR_CNF_INPUT_PU_PD</name></expr>;</expr_stmt>

            <comment type="block">/* Set the corresponding ODR bit */</comment>
            <expr_stmt><expr><name><name>GPIOx</name><operator>-&gt;</operator><name>BSRR</name></name> <operator>=</operator> <name>ioposition</name></expr>;</expr_stmt>
          </block_content>}</block></if>
          <else>else <comment type="block">/* GPIO_PULLDOWN */</comment>
          <block>{<block_content>
            <expr_stmt><expr><name>config</name> <operator>=</operator> <name>GPIO_CR_MODE_INPUT</name> <operator>+</operator> <name>GPIO_CR_CNF_INPUT_PU_PD</name></expr>;</expr_stmt>

            <comment type="block">/* Reset the corresponding ODR bit */</comment>
            <expr_stmt><expr><name><name>GPIOx</name><operator>-&gt;</operator><name>BRR</name></name> <operator>=</operator> <name>ioposition</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <break>break;</break>

        <comment type="block">/* If we are configuring the pin in INPUT analog mode */</comment>
        <case>case <expr><name>GPIO_MODE_ANALOG</name></expr>:</case>
          <expr_stmt><expr><name>config</name> <operator>=</operator> <name>GPIO_CR_MODE_INPUT</name> <operator>+</operator> <name>GPIO_CR_CNF_ANALOG</name></expr>;</expr_stmt>
          <break>break;</break>

        <comment type="block">/* Parameters are checked with assert_param */</comment>
        <default>default:</default>
          <break>break;</break>
      </block_content>}</block></switch>

      <comment type="block">/* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/</comment>
      <expr_stmt><expr><name>configregister</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>iocurrent</name> <operator>&lt;</operator> <name>GPIO_PIN_8</name><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>GPIOx</name><operator>-&gt;</operator><name>CRL</name></name></expr>     </then><else>: <expr><operator>&amp;</operator><name><name>GPIOx</name><operator>-&gt;</operator><name>CRH</name></name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>registeroffset</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>iocurrent</name> <operator>&lt;</operator> <name>GPIO_PIN_8</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>position</name> <operator>&lt;&lt;</operator> <literal type="number">2u</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>position</name> <operator>-</operator> <literal type="number">8u</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2u</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

      <comment type="block">/* Apply the new configuration of the pin to the register */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>configregister</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>GPIO_CRL_MODE0</name> <operator>|</operator> <name>GPIO_CRL_CNF0</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>registeroffset</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>config</name> <operator>&lt;&lt;</operator> <name>registeroffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/*--------------------- EXTI Mode Configuration ------------------------*/</comment>
      <comment type="block">/* Configure the External Interrupt or event for the current IO */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Mode</name></name> <operator>&amp;</operator> <name>EXTI_MODE</name><operator>)</operator> <operator>==</operator> <name>EXTI_MODE</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable AFIO Clock */</comment>
        <expr_stmt><expr><call><name>__HAL_RCC_AFIO_CLK_ENABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>temp</name> <operator>=</operator> <name><name>AFIO</name><operator>-&gt;</operator><name>EXTICR</name><index>[<expr><name>position</name> <operator>&gt;&gt;</operator> <literal type="number">2u</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">0x0Fu</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">4u</literal> <operator>*</operator> <operator>(</operator><name>position</name> <operator>&amp;</operator> <literal type="number">0x03u</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><operator>(</operator><call><name>GPIO_GET_INDEX</name><argument_list>(<argument><expr><name>GPIOx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">4u</literal> <operator>*</operator> <operator>(</operator><name>position</name> <operator>&amp;</operator> <literal type="number">0x03u</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>AFIO</name><operator>-&gt;</operator><name>EXTICR</name><index>[<expr><name>position</name> <operator>&gt;&gt;</operator> <literal type="number">2u</literal></expr>]</index></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>


        <comment type="block">/* Configure the interrupt mask */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Mode</name></name> <operator>&amp;</operator> <name>GPIO_MODE_IT</name><operator>)</operator> <operator>==</operator> <name>GPIO_MODE_IT</name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>IMR</name></name></expr></argument>, <argument><expr><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>IMR</name></name></expr></argument>, <argument><expr><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Configure the event mask */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Mode</name></name> <operator>&amp;</operator> <name>GPIO_MODE_EVT</name><operator>)</operator> <operator>==</operator> <name>GPIO_MODE_EVT</name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>EMR</name></name></expr></argument>, <argument><expr><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>EMR</name></name></expr></argument>, <argument><expr><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Enable or disable the rising trigger */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Mode</name></name> <operator>&amp;</operator> <name>RISING_EDGE</name><operator>)</operator> <operator>==</operator> <name>RISING_EDGE</name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>RTSR</name></name></expr></argument>, <argument><expr><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>RTSR</name></name></expr></argument>, <argument><expr><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Enable or disable the falling trigger */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>GPIO_Init</name><operator>-&gt;</operator><name>Mode</name></name> <operator>&amp;</operator> <name>FALLING_EDGE</name><operator>)</operator> <operator>==</operator> <name>FALLING_EDGE</name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>FTSR</name></name></expr></argument>, <argument><expr><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>FTSR</name></name></expr></argument>, <argument><expr><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>position</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
  * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_GPIO_DeInit</name><parameter_list>(<parameter><decl><type><name>GPIO_TypeDef</name>  <modifier>*</modifier></type><name>GPIOx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>GPIO_Pin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>position</name> <init>= <expr><literal type="number">0x00u</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>iocurrent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name> <modifier>*</modifier></type><name>configregister</name></decl>;</decl_stmt> <comment type="block">/* Store the address of CRL or CRH register based on pin number */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>registeroffset</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_ALL_INSTANCE</name><argument_list>(<argument><expr><name>GPIOx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_PIN</name><argument_list>(<argument><expr><name>GPIO_Pin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Configure the port pins */</comment>
  <while>while <condition>(<expr><operator>(</operator><name>GPIO_Pin</name> <operator>&gt;&gt;</operator> <name>position</name><operator>)</operator> <operator>!=</operator> <literal type="number">0u</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Get current io position */</comment>
    <expr_stmt><expr><name>iocurrent</name> <operator>=</operator> <operator>(</operator><name>GPIO_Pin</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><literal type="number">1uL</literal> <operator>&lt;&lt;</operator> <name>position</name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>iocurrent</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/*------------------------- EXTI Mode Configuration --------------------*/</comment>
      <comment type="block">/* Clear the External Interrupt or Event for the current IO */</comment>

      <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>AFIO</name><operator>-&gt;</operator><name>EXTICR</name><index>[<expr><name>position</name> <operator>&gt;&gt;</operator> <literal type="number">2u</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmp</name> <operator>&amp;=</operator> <literal type="number">0x0FuL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">4u</literal> <operator>*</operator> <operator>(</operator><name>position</name> <operator>&amp;</operator> <literal type="number">0x03u</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <operator>(</operator><call><name>GPIO_GET_INDEX</name><argument_list>(<argument><expr><name>GPIOx</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">4u</literal> <operator>*</operator> <operator>(</operator><name>position</name> <operator>&amp;</operator> <literal type="number">0x03u</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0x0FuL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">4u</literal> <operator>*</operator> <operator>(</operator><name>position</name> <operator>&amp;</operator> <literal type="number">0x03u</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>AFIO</name><operator>-&gt;</operator><name>EXTICR</name><index>[<expr><name>position</name> <operator>&gt;&gt;</operator> <literal type="number">2u</literal></expr>]</index></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear EXTI line configuration */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>IMR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>EMR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear Rising Falling edge configuration */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>RTSR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>EXTI</name><operator>-&gt;</operator><name>FTSR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/*------------------------- GPIO Mode Configuration --------------------*/</comment>
      <comment type="block">/* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register */</comment>
      <expr_stmt><expr><name>configregister</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>iocurrent</name> <operator>&lt;</operator> <name>GPIO_PIN_8</name><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>GPIOx</name><operator>-&gt;</operator><name>CRL</name></name></expr>     </then><else>: <expr><operator>&amp;</operator><name><name>GPIOx</name><operator>-&gt;</operator><name>CRH</name></name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>registeroffset</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>iocurrent</name> <operator>&lt;</operator> <name>GPIO_PIN_8</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>position</name> <operator>&lt;&lt;</operator> <literal type="number">2u</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>position</name> <operator>-</operator> <literal type="number">8u</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2u</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

      <comment type="block">/* CRL/CRH default value is floating input(0x04) shifted to correct position */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><operator>*</operator><name>configregister</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>GPIO_CRL_MODE0</name> <operator>|</operator> <name>GPIO_CRL_CNF0</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>registeroffset</name><operator>)</operator></expr></argument>, <argument><expr><name>GPIO_CRL_CNF0_0</name> <operator>&lt;&lt;</operator> <name>registeroffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* ODR default value is 0 */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>GPIOx</name><operator>-&gt;</operator><name>ODR</name></name></expr></argument>, <argument><expr><name>iocurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>position</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup GPIO_Exported_Functions_Group2 IO operation functions
 *  @brief   GPIO Read and Write
 *
@verbatim
 ===============================================================================
                       ##### IO operation functions #####
 ===============================================================================
  [..]
    This subsection provides a set of functions allowing to manage the GPIOs.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Reads the specified input port pin.
  * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */</comment>
<function><type><name>GPIO_PinState</name></type> <name>HAL_GPIO_ReadPin</name><parameter_list>(<parameter><decl><type><name>GPIO_TypeDef</name> <modifier>*</modifier></type><name>GPIOx</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>GPIO_Pin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>GPIO_PinState</name></type> <name>bitstatus</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_PIN</name><argument_list>(<argument><expr><name>GPIO_Pin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>GPIOx</name><operator>-&gt;</operator><name>IDR</name></name> <operator>&amp;</operator> <name>GPIO_Pin</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>GPIO_PIN_RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>bitstatus</name> <operator>=</operator> <name>GPIO_PIN_SET</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name>bitstatus</name> <operator>=</operator> <name>GPIO_PIN_RESET</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>bitstatus</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sets or clears the selected data port bit.
  *
  * @note   This function uses GPIOx_BSRR register to allow atomic read/modify
  *         accesses. In this way, there is no risk of an IRQ occurring between
  *         the read and the modify access.
  *
  * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @param  PinState: specifies the value to be written to the selected bit.
  *          This parameter can be one of the GPIO_PinState enum values:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_GPIO_WritePin</name><parameter_list>(<parameter><decl><type><name>GPIO_TypeDef</name> <modifier>*</modifier></type><name>GPIOx</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>GPIO_Pin</name></decl></parameter>, <parameter><decl><type><name>GPIO_PinState</name></type> <name>PinState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_PIN</name><argument_list>(<argument><expr><name>GPIO_Pin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_PIN_ACTION</name><argument_list>(<argument><expr><name>PinState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>PinState</name> <operator>!=</operator> <name>GPIO_PIN_RESET</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>GPIOx</name><operator>-&gt;</operator><name>BSRR</name></name> <operator>=</operator> <name>GPIO_Pin</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name><name>GPIOx</name><operator>-&gt;</operator><name>BSRR</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>GPIO_Pin</name> <operator>&lt;&lt;</operator> <literal type="number">16u</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Toggles the specified GPIO pin
  * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_GPIO_TogglePin</name><parameter_list>(<parameter><decl><type><name>GPIO_TypeDef</name> <modifier>*</modifier></type><name>GPIOx</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>GPIO_Pin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_PIN</name><argument_list>(<argument><expr><name>GPIO_Pin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>GPIOx</name><operator>-&gt;</operator><name>ODR</name></name> <operator>&amp;</operator> <name>GPIO_Pin</name><operator>)</operator> <operator>!=</operator> <literal type="number">0x00u</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>GPIOx</name><operator>-&gt;</operator><name>BRR</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>GPIO_Pin</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <expr_stmt><expr><name><name>GPIOx</name><operator>-&gt;</operator><name>BSRR</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>GPIO_Pin</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
* @brief  Locks GPIO Pins configuration registers.
* @note   The locking mechanism allows the IO configuration to be frozen. When the LOCK sequence
*         has been applied on a port bit, it is no longer possible to modify the value of the port bit until
*         the next reset.
* @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
* @param  GPIO_Pin: specifies the port bit to be locked.
*         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
* @retval None
*/</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_GPIO_LockPin</name><parameter_list>(<parameter><decl><type><name>GPIO_TypeDef</name> <modifier>*</modifier></type><name>GPIOx</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>GPIO_Pin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>tmp</name> <init>= <expr><name>GPIO_LCKR_LCKK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_LOCK_INSTANCE</name><argument_list>(<argument><expr><name>GPIOx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_GPIO_PIN</name><argument_list>(<argument><expr><name>GPIO_Pin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Apply lock key write sequence */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>GPIO_Pin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Set LCKx bit(s): LCKK='1' + LCK[15-0] */</comment>
  <expr_stmt><expr><name><name>GPIOx</name><operator>-&gt;</operator><name>LCKR</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
  <comment type="block">/* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */</comment>
  <expr_stmt><expr><name><name>GPIOx</name><operator>-&gt;</operator><name>LCKR</name></name> <operator>=</operator> <name>GPIO_Pin</name></expr>;</expr_stmt>
  <comment type="block">/* Set LCKx bit(s): LCKK='1' + LCK[15-0] */</comment>
  <expr_stmt><expr><name><name>GPIOx</name><operator>-&gt;</operator><name>LCKR</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
  <comment type="block">/* Read LCKK register. This read is mandatory to complete key lock sequence */</comment>
  <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>GPIOx</name><operator>-&gt;</operator><name>LCKR</name></name></expr>;</expr_stmt>

  <comment type="block">/* read again in order to confirm lock is active */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>GPIOx</name><operator>-&gt;</operator><name>LCKR</name></name> <operator>&amp;</operator> <name>GPIO_LCKR_LCKK</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_GPIO_EXTI_IRQHandler</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>GPIO_Pin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* EXTI line interrupt detected */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_GPIO_EXTI_GET_IT</name><argument_list>(<argument><expr><name>GPIO_Pin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0x00u</literal></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_GPIO_EXTI_CLEAR_IT</name><argument_list>(<argument><expr><name>GPIO_Pin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HAL_GPIO_EXTI_Callback</name><argument_list>(<argument><expr><name>GPIO_Pin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  EXTI line detection callbacks.
  * @param  GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_GPIO_EXTI_Callback</name><parameter_list>(<parameter><decl><type><name>uint16_t</name></type> <name>GPIO_Pin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>GPIO_Pin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_GPIO_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
