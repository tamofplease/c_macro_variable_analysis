<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f103ve/libraries/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f1xx_hal_pwr.c
  * @author  MCD Application Team
  * @brief   PWR HAL module driver.
  *
  *          This file provides firmware functions to manage the following
  *          functionalities of the Power Controller (PWR) peripheral:
  *           + Initialization/de-initialization functions
  *           + Peripheral Control functions 
  *
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f1xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F1xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup PWR PWR
  * @brief    PWR HAL module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_PWR_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>

<comment type="block" format="doxygen">/** @defgroup PWR_Private_Constants PWR Private Constants
  * @{
  */</comment>
  
<comment type="block" format="doxygen">/** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask
  * @{
  */</comment> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PVD_MODE_IT</name></cpp:macro>               <cpp:value>0x00010000U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PVD_MODE_EVT</name></cpp:macro>              <cpp:value>0x00020000U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PVD_RISING_EDGE</name></cpp:macro>           <cpp:value>0x00000001U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PVD_FALLING_EDGE</name></cpp:macro>          <cpp:value>0x00000002U</cpp:value></cpp:define>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>


<comment type="block" format="doxygen">/** @defgroup PWR_register_alias_address PWR Register alias address
  * @{
  */</comment> 
<comment type="block">/* ------------- PWR registers bit address in the alias region ---------------*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PWR_OFFSET</name></cpp:macro>               <cpp:value>(PWR_BASE - PERIPH_BASE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PWR_CR_OFFSET</name></cpp:macro>            <cpp:value>0x00U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PWR_CSR_OFFSET</name></cpp:macro>           <cpp:value>0x04U</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PWR_CR_OFFSET_BB</name></cpp:macro>         <cpp:value>(PWR_OFFSET + PWR_CR_OFFSET)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PWR_CSR_OFFSET_BB</name></cpp:macro>        <cpp:value>(PWR_OFFSET + PWR_CSR_OFFSET)</cpp:value></cpp:define>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>
   
<comment type="block" format="doxygen">/** @defgroup PWR_CR_register_alias PWR CR Register alias address
  * @{
  */</comment>  
<comment type="block">/* --- CR Register ---*/</comment>
<comment type="block">/* Alias word address of LPSDSR bit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LPSDSR_BIT_NUMBER</name></cpp:macro>        <cpp:value>PWR_CR_LPDS_Pos</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CR_LPSDSR_BB</name></cpp:macro>             <cpp:value>((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (LPSDSR_BIT_NUMBER * 4U)))</cpp:value></cpp:define>

<comment type="block">/* Alias word address of DBP bit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBP_BIT_NUMBER</name></cpp:macro>            <cpp:value>PWR_CR_DBP_Pos</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CR_DBP_BB</name></cpp:macro>                <cpp:value>((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (DBP_BIT_NUMBER * 4U)))</cpp:value></cpp:define>

<comment type="block">/* Alias word address of PVDE bit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PVDE_BIT_NUMBER</name></cpp:macro>           <cpp:value>PWR_CR_PVDE_Pos</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CR_PVDE_BB</name></cpp:macro>               <cpp:value>((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (PVDE_BIT_NUMBER * 4U)))</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup PWR_CSR_register_alias PWR CSR Register alias address
  * @{
  */</comment>

<comment type="block">/* --- CSR Register ---*/</comment>
<comment type="block">/* Alias word address of EWUP1 bit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSR_EWUP_BB</name><parameter_list>(<parameter><type><name>VAL</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>((uint32_t)(PERIPH_BB_BASE + (PWR_CSR_OFFSET_BB * 32U) + (POSITION_VAL(VAL) * 4U)))</cpp:value></cpp:define>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>
  
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup PWR_Private_Functions PWR Private Functions
 * brief   WFE cortex command overloaded for HAL_PWR_EnterSTOPMode usage only (see Workaround section)
 * @{
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PWR_OverloadWfe</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Private functions ---------------------------------------------------------*/</comment>
<function><type><name>__NOINLINE</name>
<specifier>static</specifier> <name>void</name></type> <name>PWR_OverloadWfe</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <asm>__asm volatile( "wfe" );</asm>
  <asm>__asm volatile( "nop" );</asm>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>


<comment type="block" format="doxygen">/** @defgroup PWR_Exported_Functions PWR Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
  *  @brief   Initialization and de-initialization functions
  *
@verbatim
 ===============================================================================
              ##### Initialization and de-initialization functions #####
 ===============================================================================
    [..]
      After reset, the backup domain (RTC registers, RTC backup data
      registers) is protected against possible unwanted
      write accesses.
      To enable access to the RTC Domain and RTC registers, proceed as follows:
        (+) Enable the Power Controller (PWR) APB1 interface clock using the
            __HAL_RCC_PWR_CLK_ENABLE() macro.
        (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Deinitializes the PWR peripheral registers to their default reset values.  
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_DeInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <expr_stmt><expr><call><name>__HAL_RCC_PWR_FORCE_RESET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>__HAL_RCC_PWR_RELEASE_RESET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables access to the backup domain (RTC registers, RTC
  *         backup data registers ).
  * @note   If the HSE divided by 128 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_EnableBkUpAccess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Enable access to RTC and backup registers */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CR_DBP_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ENABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables access to the backup domain (RTC registers, RTC
  *         backup data registers).
  * @note   If the HSE divided by 128 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_DisableBkUpAccess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Disable access to RTC and backup registers */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CR_DBP_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DISABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions 
  * @brief    Low Power modes configuration functions
  *
@verbatim
 ===============================================================================
                 ##### Peripheral Control functions #####
 ===============================================================================
     
    *** PVD configuration ***
    =========================
    [..]
      (+) The PVD is used to monitor the VDD power supply by comparing it to a
          threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).

      (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower
          than the PVD threshold. This event is internally connected to the EXTI
          line16 and can generate an interrupt if enabled. This is done through
          __HAL_PVD_EXTI_ENABLE_IT() macro.
      (+) The PVD is stopped in Standby mode.

    *** WakeUp pin configuration ***
    ================================
    [..]
      (+) WakeUp pin is used to wake up the system from Standby mode. This pin is
          forced in input pull-down configuration and is active on rising edges.
      (+) There is one WakeUp pin:
          WakeUp Pin 1 on PA.00.

    [..]

    *** Low Power modes configuration ***
    =====================================
     [..]
      The device features 3 low-power modes:
      (+) Sleep mode: CPU clock off, all peripherals including Cortex-M3 core peripherals like 
                      NVIC, SysTick, etc. are kept running
      (+) Stop mode: All clocks are stopped
      (+) Standby mode: 1.8V domain powered off
  
  
   *** Sleep mode ***
   ==================
    [..]
      (+) Entry:
          The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFx)
              functions with
          (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
          (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
     
      (+) Exit:
        (++) WFI entry mode, Any peripheral interrupt acknowledged by the nested vectored interrupt
             controller (NVIC) can wake up the device from Sleep mode.
        (++) WFE entry mode, Any wakeup event can wake up the device from Sleep mode.
           (+++) Any peripheral interrupt w/o NVIC configuration &amp; SEVONPEND bit set in the Cortex (HAL_PWR_EnableSEVOnPend)
           (+++) Any EXTI Line (Internal or External) configured in Event mode

   *** Stop mode ***
   =================
    [..]
      The Stop mode is based on the Cortex-M3 deepsleep mode combined with peripheral
      clock gating. The voltage regulator can be configured either in normal or low-power mode.
      In Stop mode, all clocks in the 1.8 V domain are stopped, the PLL, the HSI and the HSE RC 
      oscillators are disabled. SRAM and register contents are preserved.
      In Stop mode, all I/O pins keep the same state as in Run mode.

      (+) Entry:
           The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_REGULATOR_VALUE, PWR_SLEEPENTRY_WFx )
             function with:
          (++) PWR_REGULATOR_VALUE= PWR_MAINREGULATOR_ON: Main regulator ON.
          (++) PWR_REGULATOR_VALUE= PWR_LOWPOWERREGULATOR_ON: Low Power regulator ON.
          (++) PWR_SLEEPENTRY_WFx= PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
          (++) PWR_SLEEPENTRY_WFx= PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
      (+) Exit:
          (++) WFI entry mode, Any EXTI Line (Internal or External) configured in Interrupt mode with NVIC configured
          (++) WFE entry mode, Any EXTI Line (Internal or External) configured in Event mode.

   *** Standby mode ***
   ====================
     [..]
      The Standby mode allows to achieve the lowest power consumption. It is based on the
      Cortex-M3 deepsleep mode, with the voltage regulator disabled. The 1.8 V domain is 
      consequently powered off. The PLL, the HSI oscillator and the HSE oscillator are also 
      switched off. SRAM and register contents are lost except for registers in the Backup domain 
      and Standby circuitry
      
      (+) Entry:
        (++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
      (+) Exit:
        (++) WKUP pin rising edge, RTC alarm event rising edge, external Reset in 
             NRSTpin, IWDG Reset

   *** Auto-wakeup (AWU) from low-power mode ***
       =============================================
       [..]
        
       (+) The MCU can be woken up from low-power mode by an RTC Alarm event, 
           without depending on an external interrupt (Auto-wakeup mode).
   
       (+) RTC auto-wakeup (AWU) from the Stop and Standby modes

           (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to 
                configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() function.

   *** PWR Workarounds linked to Silicon Limitation ***
       ====================================================
       [..]
       Below the list of all silicon limitations known on STM32F1xx prouct.

       (#)Workarounds Implemented inside PWR HAL Driver
          (##)Debugging Stop mode with WFE entry - overloaded the WFE by an internal function    
        
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
  * @param  sConfigPVD: pointer to an PWR_PVDTypeDef structure that contains the configuration
  *         information for the PVD.
  * @note   Refer to the electrical characteristics of your device datasheet for
  *         more details about the voltage threshold corresponding to each
  *         detection level.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_ConfigPVD</name><parameter_list>(<parameter><decl><type><name>PWR_PVDTypeDef</name> <modifier>*</modifier></type><name>sConfigPVD</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PWR_PVD_LEVEL</name><argument_list>(<argument><expr><name><name>sConfigPVD</name><operator>-&gt;</operator><name>PVDLevel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PWR_PVD_MODE</name><argument_list>(<argument><expr><name><name>sConfigPVD</name><operator>-&gt;</operator><name>Mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set PLS[7:5] bits according to PVDLevel value */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>PWR</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>PWR_CR_PLS</name></expr></argument>, <argument><expr><name><name>sConfigPVD</name><operator>-&gt;</operator><name>PVDLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Clear any previous config. Keep it clear if no event or IT mode is selected */</comment>
  <expr_stmt><expr><call><name>__HAL_PWR_PVD_EXTI_DISABLE_EVENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>__HAL_PWR_PVD_EXTI_DISABLE_IT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>__HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><call><name>__HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Configure interrupt mode */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>sConfigPVD</name><operator>-&gt;</operator><name>Mode</name></name> <operator>&amp;</operator> <name>PVD_MODE_IT</name><operator>)</operator> <operator>==</operator> <name>PVD_MODE_IT</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_PWR_PVD_EXTI_ENABLE_IT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Configure event mode */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>sConfigPVD</name><operator>-&gt;</operator><name>Mode</name></name> <operator>&amp;</operator> <name>PVD_MODE_EVT</name><operator>)</operator> <operator>==</operator> <name>PVD_MODE_EVT</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_PWR_PVD_EXTI_ENABLE_EVENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Configure the edge */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>sConfigPVD</name><operator>-&gt;</operator><name>Mode</name></name> <operator>&amp;</operator> <name>PVD_RISING_EDGE</name><operator>)</operator> <operator>==</operator> <name>PVD_RISING_EDGE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>sConfigPVD</name><operator>-&gt;</operator><name>Mode</name></name> <operator>&amp;</operator> <name>PVD_FALLING_EDGE</name><operator>)</operator> <operator>==</operator> <name>PVD_FALLING_EDGE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>__HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables the Power Voltage Detector(PVD).
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_EnablePVD</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Enable the power voltage detector */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CR_PVDE_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ENABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disables the Power Voltage Detector(PVD).
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_DisablePVD</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Disable the power voltage detector */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <name>CR_PVDE_BB</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DISABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Enables the WakeUp PINx functionality.
  * @param WakeUpPinx: Specifies the Power Wake-Up pin to enable.
  *        This parameter can be one of the following values:
  *           @arg PWR_WAKEUP_PIN1
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_EnableWakeUpPin</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>WakeUpPinx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameter */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PWR_WAKEUP_PIN</name><argument_list>(<argument><expr><name>WakeUpPinx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Enable the EWUPx pin */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <call><name>CSR_EWUP_BB</name><argument_list>(<argument><expr><name>WakeUpPinx</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ENABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Disables the WakeUp PINx functionality.
  * @param WakeUpPinx: Specifies the Power Wake-Up pin to disable.
  *        This parameter can be one of the following values:
  *           @arg PWR_WAKEUP_PIN1
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_DisableWakeUpPin</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>WakeUpPinx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameter */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PWR_WAKEUP_PIN</name><argument_list>(<argument><expr><name>WakeUpPinx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Disable the EWUPx pin */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>__IO</name> <name>uint32_t</name> <operator>*</operator><operator>)</operator> <call><name>CSR_EWUP_BB</name><argument_list>(<argument><expr><name>WakeUpPinx</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>DISABLE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Enters Sleep mode.
  * @note  In Sleep mode, all I/O pins keep the same state as in Run mode.
  * @param Regulator: Regulator state as no effect in SLEEP mode -  allows to support portability from legacy software
  * @param SLEEPEntry: Specifies if SLEEP mode is entered with WFI or WFE instruction.
  *           When WFI entry is used, tick interrupt have to be disabled if not desired as 
  *           the interrupt wake up source.
  *           This parameter can be one of the following values:
  *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
  *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_EnterSLEEPMode</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Regulator</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>SLEEPEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <comment type="block">/* No check on Regulator because parameter not used in SLEEP mode */</comment>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>Regulator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PWR_SLEEP_ENTRY</name><argument_list>(<argument><expr><name>SLEEPEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clear SLEEPDEEP bit of Cortex System Control Register */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>SCB</name><operator>-&gt;</operator><name>SCR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>SCB_SCR_SLEEPDEEP_Msk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Select SLEEP mode entry -------------------------------------------------*/</comment>
  <if_stmt><if>if<condition>(<expr><name>SLEEPEntry</name> <operator>==</operator> <name>PWR_SLEEPENTRY_WFI</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Request Wait For Interrupt */</comment>
    <expr_stmt><expr><call><name>__WFI</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Request Wait For Event */</comment>
    <expr_stmt><expr><call><name>__SEV</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__WFE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>__WFE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Enters Stop mode. 
  * @note  In Stop mode, all I/O pins keep the same state as in Run mode.
  * @note  When exiting Stop mode by using an interrupt or a wakeup event,
  *        HSI RC oscillator is selected as system clock.
  * @note  When the voltage regulator operates in low power mode, an additional
  *         startup delay is incurred when waking up from Stop mode. 
  *         By keeping the internal regulator ON during Stop mode, the consumption
  *         is higher although the startup time is reduced.    
  * @param Regulator: Specifies the regulator state in Stop mode.
  *          This parameter can be one of the following values:
  *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON
  *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON
  * @param STOPEntry: Specifies if Stop mode in entered with WFI or WFE instruction.
  *          This parameter can be one of the following values:
  *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction
  *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction   
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_EnterSTOPMode</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>Regulator</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>STOPEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PWR_REGULATOR</name><argument_list>(<argument><expr><name>Regulator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_PWR_STOP_ENTRY</name><argument_list>(<argument><expr><name>STOPEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clear PDDS bit in PWR register to specify entering in STOP mode when CPU enter in Deepsleep */</comment> 
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>PWR</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>,  <argument><expr><name>PWR_CR_PDDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Select the voltage regulator mode by setting LPDS bit in PWR register according to Regulator parameter value */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>PWR</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>PWR_CR_LPDS</name></expr></argument>, <argument><expr><name>Regulator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set SLEEPDEEP bit of Cortex System Control Register */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>SCB</name><operator>-&gt;</operator><name>SCR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>SCB_SCR_SLEEPDEEP_Msk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Select Stop mode entry --------------------------------------------------*/</comment>
  <if_stmt><if>if<condition>(<expr><name>STOPEntry</name> <operator>==</operator> <name>PWR_STOPENTRY_WFI</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Request Wait For Interrupt */</comment>
    <expr_stmt><expr><call><name>__WFI</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Request Wait For Event */</comment>
    <expr_stmt><expr><call><name>__SEV</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PWR_OverloadWfe</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* WFE redefine locally */</comment>
    <expr_stmt><expr><call><name>PWR_OverloadWfe</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* WFE redefine locally */</comment>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Reset SLEEPDEEP bit of Cortex System Control Register */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>SCB</name><operator>-&gt;</operator><name>SCR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>SCB_SCR_SLEEPDEEP_Msk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief Enters Standby mode.
  * @note  In Standby mode, all I/O pins are high impedance except for:
  *          - Reset pad (still available) 
  *          - TAMPER pin if configured for tamper or calibration out.
  *          - WKUP pin (PA0) if enabled.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_EnterSTANDBYMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Select Standby mode */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>PWR</name><operator>-&gt;</operator><name>CR</name></name></expr></argument>, <argument><expr><name>PWR_CR_PDDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set SLEEPDEEP bit of Cortex System Control Register */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>SCB</name><operator>-&gt;</operator><name>SCR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>SCB_SCR_SLEEPDEEP_Msk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This option is used to ensure that store operations are completed */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>( <argument><expr><name>__CC_ARM</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>__force_stores</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* Request Wait For Interrupt */</comment>
  <expr_stmt><expr><call><name>__WFI</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. 
  * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
  *       re-enters SLEEP mode when an interruption handling is over.
  *       Setting this bit is useful when the processor is expected to run only on
  *       interruptions handling.         
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_EnableSleepOnExit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Set SLEEPONEXIT bit of Cortex System Control Register */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>SCB</name><operator>-&gt;</operator><name>SCR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>SCB_SCR_SLEEPONEXIT_Msk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. 
  * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
  *       re-enters SLEEP mode when an interruption handling is over.          
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_DisableSleepOnExit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Clear SLEEPONEXIT bit of Cortex System Control Register */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>SCB</name><operator>-&gt;</operator><name>SCR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>SCB_SCR_SLEEPONEXIT_Msk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief Enables CORTEX M3 SEVONPEND bit. 
  * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes 
  *       WFE to wake up when an interrupt moves from inactive to pended.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_EnableSEVOnPend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Set SEVONPEND bit of Cortex System Control Register */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>SCB</name><operator>-&gt;</operator><name>SCR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>SCB_SCR_SEVONPEND_Msk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
  * @brief Disables CORTEX M3 SEVONPEND bit. 
  * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes 
  *       WFE to wake up when an interrupt moves from inactive to pended.         
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_DisableSEVOnPend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Clear SEVONPEND bit of Cortex System Control Register */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>SCB</name><operator>-&gt;</operator><name>SCR</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>SCB_SCR_SEVONPEND_Msk</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/**
  * @brief  This function handles the PWR PVD interrupt request.
  * @note   This API should be called under the PVD_IRQHandler().
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_PWR_PVD_IRQHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check PWR exti flag */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>__HAL_PWR_PVD_EXTI_GET_FLAG</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* PWR PVD interrupt user callback */</comment>
    <expr_stmt><expr><call><name>HAL_PWR_PVDCallback</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clear PWR Exti pending bit */</comment>
    <expr_stmt><expr><call><name>__HAL_PWR_PVD_EXTI_CLEAR_FLAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  PWR PVD interrupt callback
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_PWR_PVDCallback</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_PWR_PVDCallback could be implemented in the user file
   */</comment> 
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_PWR_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
