<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f103ve/libraries/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_i2c.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f1xx_hal_i2c.c
  * @author  MCD Application Team
  * @brief   I2C HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral State, Mode and Error functions
  *
  @verbatim
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
  [..]
    The I2C HAL driver can be used as follows:

    (#) Declare a I2C_HandleTypeDef handle structure, for example:
        I2C_HandleTypeDef  hi2c;

    (#)Initialize the I2C low level resources by implementing the @ref HAL_I2C_MspInit() API:
        (##) Enable the I2Cx interface clock
        (##) I2C pins configuration
            (+++) Enable the clock for the I2C GPIOs
            (+++) Configure I2C pins as alternate function open-drain
        (##) NVIC configuration if you need to use interrupt process
            (+++) Configure the I2Cx interrupt priority
            (+++) Enable the NVIC I2C IRQ Channel
        (##) DMA Configuration if you need to use DMA process
            (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive channel
            (+++) Enable the DMAx interface clock using
            (+++) Configure the DMA handle parameters
            (+++) Configure the DMA Tx or Rx channel
            (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
            (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on
                  the DMA Tx or Rx channel

    (#) Configure the Communication Speed, Duty cycle, Addressing mode, Own Address1,
        Dual Addressing mode, Own Address2, General call and Nostretch mode in the hi2c Init structure.

    (#) Initialize the I2C registers by calling the @ref HAL_I2C_Init(), configures also the low level Hardware
        (GPIO, CLOCK, NVIC...etc) by calling the customized @ref HAL_I2C_MspInit() API.

    (#) To check if target device is ready for communication, use the function @ref HAL_I2C_IsDeviceReady()

    (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :

    *** Polling mode IO operation ***
    =================================
    [..]
      (+) Transmit in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Transmit()
      (+) Receive in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Receive()
      (+) Transmit in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Transmit()
      (+) Receive in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Receive()

    *** Polling mode IO MEM operation ***
    =====================================
    [..]
      (+) Write an amount of data in blocking mode to a specific memory address using @ref HAL_I2C_Mem_Write()
      (+) Read an amount of data in blocking mode from a specific memory address using @ref HAL_I2C_Mem_Read()


    *** Interrupt mode IO operation ***
    ===================================
    [..]
      (+) Transmit in master mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Transmit_IT()
      (+) At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
      (+) Receive in master mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Receive_IT()
      (+) At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
      (+) Transmit in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Transmit_IT()
      (+) At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
      (+) Receive in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Receive_IT()
      (+) At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
      (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
      (+) Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
      (+) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()

    *** Interrupt mode or DMA mode IO sequential operation ***
    ==========================================================
    [..]
      (@) These interfaces allow to manage a sequential transfer with a repeated start condition
          when a direction change during transfer
    [..]
      (+) A specific option field manage the different steps of a sequential transfer
      (+) Option field values are defined through @ref I2C_XferOptions_definition and are listed below:
      (++) I2C_FIRST_AND_LAST_FRAME: No sequential usage, functionnal is same as associated interfaces in no sequential mode
      (++) I2C_FIRST_FRAME: Sequential usage, this option allow to manage a sequence with start condition, address
                            and data to transfer without a final stop condition
      (++) I2C_FIRST_AND_NEXT_FRAME: Sequential usage (Master only), this option allow to manage a sequence with start condition, address
                            and data to transfer without a final stop condition, an then permit a call the same master sequential interface
                            several times (like @ref HAL_I2C_Master_Seq_Transmit_IT() then @ref HAL_I2C_Master_Seq_Transmit_IT()
                            or @ref HAL_I2C_Master_Seq_Transmit_DMA() then @ref HAL_I2C_Master_Seq_Transmit_DMA())
      (++) I2C_NEXT_FRAME: Sequential usage, this option allow to manage a sequence with a restart condition, address
                            and with new data to transfer if the direction change or manage only the new data to transfer
                            if no direction change and without a final stop condition in both cases
      (++) I2C_LAST_FRAME: Sequential usage, this option allow to manage a sequance with a restart condition, address
                            and with new data to transfer if the direction change or manage only the new data to transfer
                            if no direction change and with a final stop condition in both cases
      (++) I2C_LAST_FRAME_NO_STOP: Sequential usage (Master only), this option allow to manage a restart condition after several call of the same master sequential
                            interface several times (link with option I2C_FIRST_AND_NEXT_FRAME).
                            Usage can, transfer several bytes one by one using HAL_I2C_Master_Seq_Transmit_IT(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
                              or HAL_I2C_Master_Seq_Receive_IT(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
                              or HAL_I2C_Master_Seq_Transmit_DMA(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
                              or HAL_I2C_Master_Seq_Receive_DMA(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME).
                            Then usage of this option I2C_LAST_FRAME_NO_STOP at the last Transmit or Receive sequence permit to call the oposite interface Receive or Transmit
                              without stopping the communication and so generate a restart condition.
      (++) I2C_OTHER_FRAME: Sequential usage (Master only), this option allow to manage a restart condition after each call of the same master sequential
                            interface.
                            Usage can, transfer several bytes one by one with a restart with slave address between each bytes using HAL_I2C_Master_Seq_Transmit_IT(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
                              or HAL_I2C_Master_Seq_Receive_IT(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
                              or HAL_I2C_Master_Seq_Transmit_DMA(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
                              or HAL_I2C_Master_Seq_Receive_DMA(option I2C_FIRST_FRAME then I2C_OTHER_FRAME).
                            Then usage of this option I2C_OTHER_AND_LAST_FRAME at the last frame to help automatic generation of STOP condition.

      (+) Differents sequential I2C interfaces are listed below:
      (++) Sequential transmit in master I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Seq_Transmit_IT()
            or using @ref HAL_I2C_Master_Seq_Transmit_DMA()
      (+++) At transmission end of current frame transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
      (++) Sequential receive in master I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Seq_Receive_IT()
            or using @ref HAL_I2C_Master_Seq_Receive_DMA()
      (+++) At reception end of current frame transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
      (++) Abort a master IT or DMA I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
      (+++) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
      (++) Enable/disable the Address listen mode in slave I2C mode using @ref HAL_I2C_EnableListen_IT() @ref HAL_I2C_DisableListen_IT()
      (+++) When address slave I2C match, @ref HAL_I2C_AddrCallback() is executed and user can
           add his own code to check the Address Match Code and the transmission direction request by master (Write/Read).
      (+++) At Listen mode end @ref HAL_I2C_ListenCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_ListenCpltCallback()
      (++) Sequential transmit in slave I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Seq_Transmit_IT()
            or using @ref HAL_I2C_Slave_Seq_Transmit_DMA()
      (+++) At transmission end of current frame transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
      (++) Sequential receive in slave I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Seq_Receive_IT()
            or using @ref HAL_I2C_Slave_Seq_Receive_DMA()
      (+++) At reception end of current frame transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
      (++) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()

    *** Interrupt mode IO MEM operation ***
    =======================================
    [..]
      (+) Write an amount of data in non-blocking mode with Interrupt to a specific memory address using
          @ref HAL_I2C_Mem_Write_IT()
      (+) At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
      (+) Read an amount of data in non-blocking mode with Interrupt from a specific memory address using
          @ref HAL_I2C_Mem_Read_IT()
      (+) At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
      (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()

    *** DMA mode IO operation ***
    ==============================
    [..]
      (+) Transmit in master mode an amount of data in non-blocking mode (DMA) using
          @ref HAL_I2C_Master_Transmit_DMA()
      (+) At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
      (+) Receive in master mode an amount of data in non-blocking mode (DMA) using
          @ref HAL_I2C_Master_Receive_DMA()
      (+) At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
      (+) Transmit in slave mode an amount of data in non-blocking mode (DMA) using
          @ref HAL_I2C_Slave_Transmit_DMA()
      (+) At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
      (+) Receive in slave mode an amount of data in non-blocking mode (DMA) using
          @ref HAL_I2C_Slave_Receive_DMA()
      (+) At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
      (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
      (+) Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
      (+) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()

    *** DMA mode IO MEM operation ***
    =================================
    [..]
      (+) Write an amount of data in non-blocking mode with DMA to a specific memory address using
          @ref HAL_I2C_Mem_Write_DMA()
      (+) At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
      (+) Read an amount of data in non-blocking mode with DMA from a specific memory address using
          @ref HAL_I2C_Mem_Read_DMA()
      (+) At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
      (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
           add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()


     *** I2C HAL driver macros list ***
     ==================================
     [..]
       Below the list of most used macros in I2C HAL driver.

      (+) @ref __HAL_I2C_ENABLE:     Enable the I2C peripheral
      (+) @ref __HAL_I2C_DISABLE:    Disable the I2C peripheral
      (+) @ref __HAL_I2C_GET_FLAG:   Checks whether the specified I2C flag is set or not
      (+) @ref __HAL_I2C_CLEAR_FLAG: Clear the specified I2C pending flag
      (+) @ref __HAL_I2C_ENABLE_IT:  Enable the specified I2C interrupt
      (+) @ref __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt

     *** Callback registration ***
     =============================================
    [..]
     The compilation flag USE_HAL_I2C_REGISTER_CALLBACKS when set to 1
     allows the user to configure dynamically the driver callbacks.
     Use Functions @ref HAL_I2C_RegisterCallback() or @ref HAL_I2C_RegisterAddrCallback()
     to register an interrupt callback.
    [..]
     Function @ref HAL_I2C_RegisterCallback() allows to register following callbacks:
       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
       (+) MasterRxCpltCallback : callback for Master reception end of transfer.
       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
       (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
       (+) ListenCpltCallback   : callback for end of listen mode.
       (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
       (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
       (+) ErrorCallback        : callback for error detection.
       (+) AbortCpltCallback    : callback for abort completion process.
       (+) MspInitCallback      : callback for Msp Init.
       (+) MspDeInitCallback    : callback for Msp DeInit.
     This function takes as parameters the HAL peripheral handle, the Callback ID
     and a pointer to the user callback function.
    [..]
     For specific callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_RegisterAddrCallback().
    [..]
     Use function @ref HAL_I2C_UnRegisterCallback to reset a callback to the default
     weak function.
     @ref HAL_I2C_UnRegisterCallback takes as parameters the HAL peripheral handle,
     and the Callback ID.
     This function allows to reset following callbacks:
       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
       (+) MasterRxCpltCallback : callback for Master reception end of transfer.
       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
       (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
       (+) ListenCpltCallback   : callback for end of listen mode.
       (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
       (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
       (+) ErrorCallback        : callback for error detection.
       (+) AbortCpltCallback    : callback for abort completion process.
       (+) MspInitCallback      : callback for Msp Init.
       (+) MspDeInitCallback    : callback for Msp DeInit.
    [..]
     For callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_UnRegisterAddrCallback().
    [..]
     By default, after the @ref HAL_I2C_Init() and when the state is @ref HAL_I2C_STATE_RESET
     all callbacks are set to the corresponding weak functions:
     examples @ref HAL_I2C_MasterTxCpltCallback(), @ref HAL_I2C_MasterRxCpltCallback().
     Exception done for MspInit and MspDeInit functions that are
     reset to the legacy weak functions in the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit() only when
     these callbacks are null (not registered beforehand).
     If MspInit or MspDeInit are not null, the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit()
     keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
    [..]
     Callbacks can be registered/unregistered in @ref HAL_I2C_STATE_READY state only.
     Exception done MspInit/MspDeInit functions that can be registered/unregistered
     in @ref HAL_I2C_STATE_READY or @ref HAL_I2C_STATE_RESET state,
     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
     Then, the user first registers the MspInit/MspDeInit user callbacks
     using @ref HAL_I2C_RegisterCallback() before calling @ref HAL_I2C_DeInit()
     or @ref HAL_I2C_Init() function.
    [..]
     When the compilation flag USE_HAL_I2C_REGISTER_CALLBACKS is set to 0 or
     not defined, the callback registration feature is not available and all callbacks
     are set to the corresponding weak functions.


     *** I2C Workarounds linked to Silicon Limitation ***
     ====================================================
     [..]
       Below the list of all silicon limitations implemented for HAL on STM32F1xx product.
       (@) See ErrataSheet to know full silicon limitation list of your product.

       (+) Workarounds Implemented inside I2C HAL Driver
          (++) Wrong data read into data register (Polling and Interrupt mode)
          (++) Start cannot be generated after a misplaced Stop
          (++) Some software events must be managed before the current byte is being transferred:
               Workaround: Use DMA in general, except when the Master is receiving a single byte.
               For Interupt mode, I2C should have the highest priority in the application.
          (++) Mismatch on the "Setup time for a repeated Start condition" timing parameter:
               Workaround: Reduce the frequency down to 88 kHz or use the I2C Fast-mode if
               supported by the slave.
          (++) Data valid time (tVD;DAT) violated without the OVR flag being set:
               Workaround: If the slave device allows it, use the clock stretching mechanism
               by programming NoStretchMode = I2C_NOSTRETCH_DISABLE in @ref HAL_I2C_Init.

     [..]
       (@) You can refer to the I2C HAL driver header file for more useful macros

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f1xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F1xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup I2C I2C
  * @brief I2C HAL module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_I2C_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @addtogroup I2C_Private_Define
  * @{
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I2C_TIMEOUT_FLAG</name></cpp:macro>          <cpp:value>35U</cpp:value></cpp:define>         <comment type="block" format="doxygen">/*!&lt; Timeout 35 ms             */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I2C_TIMEOUT_BUSY_FLAG</name></cpp:macro>     <cpp:value>25U</cpp:value></cpp:define>         <comment type="block" format="doxygen">/*!&lt; Timeout 25 ms             */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I2C_NO_OPTION_FRAME</name></cpp:macro>       <cpp:value>0xFFFF0000U</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; XferOptions default value */</comment>

<comment type="block">/* Private define for @ref PreviousState usage */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I2C_STATE_MSK</name></cpp:macro>             <cpp:value>((uint32_t)((uint32_t)((uint32_t)HAL_I2C_STATE_BUSY_TX | (uint32_t)HAL_I2C_STATE_BUSY_RX) &amp; (uint32_t)(~((uint32_t)HAL_I2C_STATE_READY))))</cpp:value></cpp:define> <comment type="block" format="doxygen">/*!&lt; Mask State define, keep only RX and TX bits            */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I2C_STATE_NONE</name></cpp:macro>            <cpp:value>((uint32_t)(HAL_I2C_MODE_NONE))</cpp:value></cpp:define>                                                        <comment type="block" format="doxygen">/*!&lt; Default Value                                          */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I2C_STATE_MASTER_BUSY_TX</name></cpp:macro>  <cpp:value>((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX &amp; I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))</cpp:value></cpp:define>            <comment type="block" format="doxygen">/*!&lt; Master Busy TX, combinaison of State LSB and Mode enum */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I2C_STATE_MASTER_BUSY_RX</name></cpp:macro>  <cpp:value>((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX &amp; I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))</cpp:value></cpp:define>            <comment type="block" format="doxygen">/*!&lt; Master Busy RX, combinaison of State LSB and Mode enum */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I2C_STATE_SLAVE_BUSY_TX</name></cpp:macro>   <cpp:value>((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX &amp; I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))</cpp:value></cpp:define>             <comment type="block" format="doxygen">/*!&lt; Slave Busy TX, combinaison of State LSB and Mode enum  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I2C_STATE_SLAVE_BUSY_RX</name></cpp:macro>   <cpp:value>((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX &amp; I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))</cpp:value></cpp:define>             <comment type="block" format="doxygen">/*!&lt; Slave Busy RX, combinaison of State LSB and Mode enum  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>

<comment type="block" format="doxygen">/** @defgroup I2C_Private_Functions I2C Private Functions
  * @{
  */</comment>
<comment type="block">/* Private functions to handle DMA transfer */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_DMAXferCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_DMAError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_DMAAbort</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_ITError</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_MasterRequestWrite</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_MasterRequestRead</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_RequestMemoryWrite</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddSize</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_RequestMemoryRead</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddSize</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Private functions to handle flags during polling transfer */</comment>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Flag</name></decl></parameter>, <parameter><decl><type><name>FlagStatus</name></type> <name>Status</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnMasterAddressFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Flag</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnTXEFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnBTFFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnRXNEFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnSTOPFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_IsAcknowledgeFailed</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Private functions for I2C transfer IRQ handler */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_MasterTransmit_TXE</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_MasterTransmit_BTF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_MasterReceive_RXNE</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_MasterReceive_BTF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Master_SB</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Master_ADD10</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Master_ADDR</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_SlaveTransmit_TXE</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_SlaveTransmit_BTF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_SlaveReceive_RXNE</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_SlaveReceive_BTF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Slave_ADDR</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>IT2Flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Slave_STOPF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Slave_AF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Private function to Convert Specific options */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>I2C_ConvertOtherXferOptions</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Exported functions --------------------------------------------------------*/</comment>

<comment type="block" format="doxygen">/** @defgroup I2C_Exported_Functions I2C Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
 *  @brief    Initialization and Configuration functions
 *
@verbatim
 ===============================================================================
              ##### Initialization and de-initialization functions #####
 ===============================================================================
    [..]  This subsection provides a set of functions allowing to initialize and
          deinitialize the I2Cx peripheral:

      (+) User must Implement HAL_I2C_MspInit() function in which he configures
          all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC).

      (+) Call the function HAL_I2C_Init() to configure the selected device with
          the selected configuration:
        (++) Communication Speed
        (++) Duty cycle
        (++) Addressing mode
        (++) Own Address 1
        (++) Dual Addressing mode
        (++) Own Address 2
        (++) General call mode
        (++) Nostretch mode

      (+) Call the function HAL_I2C_DeInit() to restore the default configuration
          of the selected I2Cx peripheral.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Initializes the I2C according to the specified parameters
  *         in the I2C_InitTypeDef and initialize the associated handle.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Init</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>freqrange</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>pclk1</name></decl>;</decl_stmt>

  <comment type="block">/* Check the I2C handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>hi2c</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_CLOCK_SPEED</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockSpeed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_DUTY_CYCLE</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DutyCycle</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_OWN_ADDRESS1</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress1</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_ADDRESSING_MODE</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AddressingMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_DUAL_ADDRESS</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DualAddressMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_OWN_ADDRESS2</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_GENERAL_CALL</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>GeneralCallMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_NO_STRETCH</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NoStretchMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Allocate lock resource and initialize it */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Lock</name></name> <operator>=</operator> <name>HAL_UNLOCKED</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <comment type="block">/* Init the I2C Callback settings */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name> <operator>=</operator> <name>HAL_I2C_MasterTxCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MasterTxCpltCallback */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MasterRxCpltCallback</name></name> <operator>=</operator> <name>HAL_I2C_MasterRxCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MasterRxCpltCallback */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveTxCpltCallback</name></name>  <operator>=</operator> <name>HAL_I2C_SlaveTxCpltCallback</name></expr>;</expr_stmt>  <comment type="block">/* Legacy weak SlaveTxCpltCallback  */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveRxCpltCallback</name></name>  <operator>=</operator> <name>HAL_I2C_SlaveRxCpltCallback</name></expr>;</expr_stmt>  <comment type="block">/* Legacy weak SlaveRxCpltCallback  */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name>   <operator>=</operator> <name>HAL_I2C_ListenCpltCallback</name></expr>;</expr_stmt>   <comment type="block">/* Legacy weak ListenCpltCallback   */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MemTxCpltCallback</name></name>    <operator>=</operator> <name>HAL_I2C_MemTxCpltCallback</name></expr>;</expr_stmt>    <comment type="block">/* Legacy weak MemTxCpltCallback    */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MemRxCpltCallback</name></name>    <operator>=</operator> <name>HAL_I2C_MemRxCpltCallback</name></expr>;</expr_stmt>    <comment type="block">/* Legacy weak MemRxCpltCallback    */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCallback</name></name>        <operator>=</operator> <name>HAL_I2C_ErrorCallback</name></expr>;</expr_stmt>        <comment type="block">/* Legacy weak ErrorCallback        */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name>    <operator>=</operator> <name>HAL_I2C_AbortCpltCallback</name></expr>;</expr_stmt>    <comment type="block">/* Legacy weak AbortCpltCallback    */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>AddrCallback</name></name>         <operator>=</operator> <name>HAL_I2C_AddrCallback</name></expr>;</expr_stmt>         <comment type="block">/* Legacy weak AddrCallback         */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_I2C_MspInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspInit  */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MspInitCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Init the low level hardware : GPIO, CLOCK, NVIC */</comment>
    <expr_stmt><expr><call><name>HAL_I2C_MspInit</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the selected I2C peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_I2C_DISABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get PCLK1 frequency */</comment>
  <expr_stmt><expr><name>pclk1</name> <operator>=</operator> <call><name>HAL_RCC_GetPCLK1Freq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the minimum allowed PCLK1 frequency */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_MIN_PCLK_FREQ</name><argument_list>(<argument><expr><name>pclk1</name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockSpeed</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Calculate frequency range */</comment>
  <expr_stmt><expr><name>freqrange</name> <operator>=</operator> <call><name>I2C_FREQRANGE</name><argument_list>(<argument><expr><name>pclk1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- I2Cx CR2 Configuration ----------------------*/</comment>
  <comment type="block">/* Configure I2Cx: Frequency range */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_FREQ</name></expr></argument>, <argument><expr><name>freqrange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- I2Cx TRISE Configuration --------------------*/</comment>
  <comment type="block">/* Configure I2Cx: Rise Time */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>TRISE</name></name></expr></argument>, <argument><expr><name>I2C_TRISE_TRISE</name></expr></argument>, <argument><expr><call><name>I2C_RISE_TIME</name><argument_list>(<argument><expr><name>freqrange</name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockSpeed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- I2Cx CCR Configuration ----------------------*/</comment>
  <comment type="block">/* Configure I2Cx: Speed */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CCR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>I2C_CCR_FS</name> <operator>|</operator> <name>I2C_CCR_DUTY</name> <operator>|</operator> <name>I2C_CCR_CCR</name><operator>)</operator></expr></argument>, <argument><expr><call><name>I2C_SPEED</name><argument_list>(<argument><expr><name>pclk1</name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ClockSpeed</name></name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DutyCycle</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- I2Cx CR1 Configuration ----------------------*/</comment>
  <comment type="block">/* Configure I2Cx: Generalcall and NoStretch mode */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><operator>(</operator><name>I2C_CR1_ENGC</name> <operator>|</operator> <name>I2C_CR1_NOSTRETCH</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>GeneralCallMode</name></name> <operator>|</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>NoStretchMode</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- I2Cx OAR1 Configuration ---------------------*/</comment>
  <comment type="block">/* Configure I2Cx: Own Address1 and addressing mode */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>OAR1</name></name></expr></argument>, <argument><expr><operator>(</operator><name>I2C_OAR1_ADDMODE</name> <operator>|</operator> <name>I2C_OAR1_ADD8_9</name> <operator>|</operator> <name>I2C_OAR1_ADD1_7</name> <operator>|</operator> <name>I2C_OAR1_ADD0</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AddressingMode</name></name> <operator>|</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress1</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*---------------------------- I2Cx OAR2 Configuration ---------------------*/</comment>
  <comment type="block">/* Configure I2Cx: Dual mode and Own Address2 */</comment>
  <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>OAR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>I2C_OAR2_ENDUAL</name> <operator>|</operator> <name>I2C_OAR2_ADD2</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>DualAddressMode</name></name> <operator>|</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress2</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Enable the selected I2C peripheral */</comment>
  <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitialize the I2C peripheral.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_DeInit</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the I2C handle allocation */</comment>
  <if_stmt><if>if <condition>(<expr><name>hi2c</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_BUSY</name></expr>;</expr_stmt>

  <comment type="block">/* Disable the I2C Peripheral Clock */</comment>
  <expr_stmt><expr><call><name>__HAL_I2C_DISABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_I2C_MspDeInit</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MspDeInit  */</comment>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC */</comment>
  <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* DeInit the low level hardware: GPIO, CLOCK, NVIC */</comment>
  <expr_stmt><expr><call><name>HAL_I2C_MspDeInit</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>

  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>     <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>         <operator>=</operator> <name>HAL_I2C_STATE_RESET</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>          <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Initialize the I2C MSP.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_MspInit</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DeInitialize the I2C MSP.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_MspDeInit</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Register a User I2C Callback
  *         To be used instead of the weak predefined callback
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  CallbackID ID of the callback to be registered
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
  *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
  *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
  *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
  *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
  *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
  *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
  * @param  pCallback pointer to the Callback function
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_RegisterCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>HAL_I2C_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>, <parameter><decl><type><name>pI2C_CallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>HAL_I2C_STATE_READY</name> <operator>==</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_I2C_MASTER_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MASTER_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MasterRxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_SLAVE_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveTxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_SLAVE_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveRxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_LISTEN_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MEM_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MemTxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MEM_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MemRxCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>HAL_I2C_STATE_RESET</name> <operator>==</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_I2C_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Unregister an I2C Callback
  *         I2C callback is redirected to the weak predefined callback
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  CallbackID ID of the callback to be unregistered
  *         This parameter can be one of the following values:
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
  *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
  *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
  *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
  *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
  *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
  *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_UnRegisterCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>HAL_I2C_CallbackIDTypeDef</name></type> <name>CallbackID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>HAL_I2C_STATE_READY</name> <operator>==</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_I2C_MASTER_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name> <operator>=</operator> <name>HAL_I2C_MasterTxCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MasterTxCpltCallback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MASTER_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MasterRxCpltCallback</name></name> <operator>=</operator> <name>HAL_I2C_MasterRxCpltCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak MasterRxCpltCallback */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_SLAVE_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveTxCpltCallback</name></name> <operator>=</operator> <name>HAL_I2C_SlaveTxCpltCallback</name></expr>;</expr_stmt>   <comment type="block">/* Legacy weak SlaveTxCpltCallback  */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_SLAVE_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveRxCpltCallback</name></name> <operator>=</operator> <name>HAL_I2C_SlaveRxCpltCallback</name></expr>;</expr_stmt>   <comment type="block">/* Legacy weak SlaveRxCpltCallback  */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_LISTEN_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name> <operator>=</operator> <name>HAL_I2C_ListenCpltCallback</name></expr>;</expr_stmt>     <comment type="block">/* Legacy weak ListenCpltCallback   */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MEM_TX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MemTxCpltCallback</name></name> <operator>=</operator> <name>HAL_I2C_MemTxCpltCallback</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak MemTxCpltCallback    */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MEM_RX_COMPLETE_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MemRxCpltCallback</name></name> <operator>=</operator> <name>HAL_I2C_MemRxCpltCallback</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak MemRxCpltCallback    */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_ERROR_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCallback</name></name> <operator>=</operator> <name>HAL_I2C_ErrorCallback</name></expr>;</expr_stmt>               <comment type="block">/* Legacy weak ErrorCallback        */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_ABORT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name> <operator>=</operator> <name>HAL_I2C_AbortCpltCallback</name></expr>;</expr_stmt>       <comment type="block">/* Legacy weak AbortCpltCallback    */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_I2C_MspInit</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak MspInit              */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_I2C_MspDeInit</name></expr>;</expr_stmt>               <comment type="block">/* Legacy weak MspDeInit            */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>HAL_I2C_STATE_RESET</name> <operator>==</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <switch>switch <condition>(<expr><name>CallbackID</name></expr>)</condition>
    <block>{<block_content>
      <case>case <expr><name>HAL_I2C_MSPINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspInitCallback</name></name> <operator>=</operator> <name>HAL_I2C_MspInit</name></expr>;</expr_stmt>                   <comment type="block">/* Legacy weak MspInit              */</comment>
        <break>break;</break>

      <case>case <expr><name>HAL_I2C_MSPDEINIT_CB_ID</name></expr> :</case>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MspDeInitCallback</name></name> <operator>=</operator> <name>HAL_I2C_MspDeInit</name></expr>;</expr_stmt>               <comment type="block">/* Legacy weak MspDeInit            */</comment>
        <break>break;</break>

      <default>default :</default>
        <comment type="block">/* Update the error code */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

        <comment type="block">/* Return error status */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Register the Slave Address Match I2C Callback
  *         To be used instead of the weak HAL_I2C_AddrCallback() predefined callback
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pCallback pointer to the Address Match Callback function
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_RegisterAddrCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>pI2C_AddrCallbackTypeDef</name></type> <name>pCallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>pCallback</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>HAL_I2C_STATE_READY</name> <operator>==</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>AddrCallback</name></name> <operator>=</operator> <name>pCallback</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  UnRegister the Slave Address Match I2C Callback
  *         Info Ready I2C Callback is redirected to the weak HAL_I2C_AddrCallback() predefined callback
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_UnRegisterAddrCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>HAL_I2C_STATE_READY</name> <operator>==</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>AddrCallback</name></name> <operator>=</operator> <name>HAL_I2C_AddrCallback</name></expr>;</expr_stmt> <comment type="block">/* Legacy weak AddrCallback  */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update the error code */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_INVALID_CALLBACK</name></expr>;</expr_stmt>

    <comment type="block">/* Return error status */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator>  <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Release Lock */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions
 *  @brief   Data transfers functions
 *
@verbatim
 ===============================================================================
                      ##### IO operation functions #####
 ===============================================================================
    [..]
    This subsection provides a set of functions allowing to manage the I2C data
    transfers.

    (#) There are two modes of transfer:
       (++) Blocking mode : The communication is performed in the polling mode.
            The status of all data processing is returned by the same function
            after finishing transfer.
       (++) No-Blocking mode : The communication is performed using Interrupts
            or DMA. These functions return the status of the transfer startup.
            The end of the data processing will be indicated through the
            dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when
            using DMA mode.

    (#) Blocking mode functions are :
        (++) HAL_I2C_Master_Transmit()
        (++) HAL_I2C_Master_Receive()
        (++) HAL_I2C_Slave_Transmit()
        (++) HAL_I2C_Slave_Receive()
        (++) HAL_I2C_Mem_Write()
        (++) HAL_I2C_Mem_Read()
        (++) HAL_I2C_IsDeviceReady()

    (#) No-Blocking mode functions with Interrupt are :
        (++) HAL_I2C_Master_Transmit_IT()
        (++) HAL_I2C_Master_Receive_IT()
        (++) HAL_I2C_Slave_Transmit_IT()
        (++) HAL_I2C_Slave_Receive_IT()
        (++) HAL_I2C_Mem_Write_IT()
        (++) HAL_I2C_Mem_Read_IT()
        (++) HAL_I2C_Master_Seq_Transmit_IT()
        (++) HAL_I2C_Master_Seq_Receive_IT()
        (++) HAL_I2C_Slave_Seq_Transmit_IT()
        (++) HAL_I2C_Slave_Seq_Receive_IT()
        (++) HAL_I2C_EnableListen_IT()
        (++) HAL_I2C_DisableListen_IT()
        (++) HAL_I2C_Master_Abort_IT()

    (#) No-Blocking mode functions with DMA are :
        (++) HAL_I2C_Master_Transmit_DMA()
        (++) HAL_I2C_Master_Receive_DMA()
        (++) HAL_I2C_Slave_Transmit_DMA()
        (++) HAL_I2C_Slave_Receive_DMA()
        (++) HAL_I2C_Mem_Write_DMA()
        (++) HAL_I2C_Mem_Read_DMA()
        (++) HAL_I2C_Master_Seq_Transmit_DMA()
        (++) HAL_I2C_Master_Seq_Receive_DMA()
        (++) HAL_I2C_Slave_Seq_Transmit_DMA()
        (++) HAL_I2C_Slave_Seq_Receive_DMA()

    (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
        (++) HAL_I2C_MasterTxCpltCallback()
        (++) HAL_I2C_MasterRxCpltCallback()
        (++) HAL_I2C_SlaveTxCpltCallback()
        (++) HAL_I2C_SlaveRxCpltCallback()
        (++) HAL_I2C_MemTxCpltCallback()
        (++) HAL_I2C_MemRxCpltCallback()
        (++) HAL_I2C_AddrCallback()
        (++) HAL_I2C_ListenCpltCallback()
        (++) HAL_I2C_ErrorCallback()
        (++) HAL_I2C_AbortCpltCallback()

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Transmits in master mode an amount of data in blocking mode.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Master_Transmit</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>I2C_TIMEOUT_BUSY_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_BUSY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>       <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>        <operator>=</operator> <name>HAL_I2C_MODE_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Send Slave Address */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_MasterRequestWrite</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>DevAddress</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clear ADDR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until TXE flag is set */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnTXEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_I2C_ERROR_AF</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Generate Stop */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Write data to DR */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr>;</expr_stmt>

      <comment type="block">/* Increment Buffer pointer */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Update counter */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Write data to DR */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr>;</expr_stmt>

        <comment type="block">/* Increment Buffer pointer */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Update counter */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Wait until BTF flag is set */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnBTFFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_I2C_ERROR_AF</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Generate Stop */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Generate Stop */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Receives in master mode an amount of data in blocking mode.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Master_Receive</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>I2C_TIMEOUT_BUSY_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_BUSY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>       <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>        <operator>=</operator> <name>HAL_I2C_MODE_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Send Slave Address */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_MasterRequestRead</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>DevAddress</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable Acknowledge */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
      software sequence must complete before the current byte end of transfer */</comment>
      <expr_stmt><expr><call><name>__disable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Re-enable IRQs */</comment>
      <expr_stmt><expr><call><name>__enable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">2U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable Pos */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
      software sequence must complete before the current byte end of transfer */</comment>
      <expr_stmt><expr><call><name>__disable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Disable Acknowledge */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Re-enable IRQs */</comment>
      <expr_stmt><expr><call><name>__enable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Enable Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <while>while <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&lt;=</operator> <literal type="number">3U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* One byte */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Wait until RXNE flag is set */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnRXNEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <return>return <expr><name>HAL_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* Two bytes */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">2U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Wait until BTF flag is set */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <return>return <expr><name>HAL_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
             software sequence must complete before the current byte end of transfer */</comment>
          <expr_stmt><expr><call><name>__disable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Generate Stop */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

          <comment type="block">/* Re-enable IRQs */</comment>
          <expr_stmt><expr><call><name>__enable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* 3 Last bytes */</comment>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Wait until BTF flag is set */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <return>return <expr><name>HAL_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Disable Acknowledge */</comment>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
             software sequence must complete before the current byte end of transfer */</comment>
          <expr_stmt><expr><call><name>__disable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

          <comment type="block">/* Wait until BTF flag is set */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <return>return <expr><name>HAL_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Generate Stop */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

          <comment type="block">/* Re-enable IRQs */</comment>
          <expr_stmt><expr><call><name>__enable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Wait until RXNE flag is set */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnRXNEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Read data from DR */</comment>
        <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

        <comment type="block">/* Increment Buffer pointer */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Update counter */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmits in slave mode an amount of data in blocking mode.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Slave_Transmit</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>       <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>        <operator>=</operator> <name>HAL_I2C_MODE_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Enable Address Acknowledge */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait until ADDR flag is set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clear ADDR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If 10bit addressing mode is selected */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AddressingMode</name></name> <operator>==</operator> <name>I2C_ADDRESSINGMODE_10BIT</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until ADDR flag is set */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until TXE flag is set */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnTXEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Disable Address Acknowledge */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Write data to DR */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr>;</expr_stmt>

      <comment type="block">/* Increment Buffer pointer */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Update counter */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Write data to DR */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr>;</expr_stmt>

        <comment type="block">/* Increment Buffer pointer */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Update counter */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Wait until AF flag is set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clear AF flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable Address Acknowledge */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Receive in slave mode an amount of data in blocking mode
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Slave_Receive</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>       <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>        <operator>=</operator> <name>HAL_I2C_MODE_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>   <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Enable Address Acknowledge */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait until ADDR flag is set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clear ADDR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until RXNE flag is set */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnRXNEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Disable Address Acknowledge */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

      <comment type="block">/* Increment Buffer pointer */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Update counter */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Read data from DR */</comment>
        <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

        <comment type="block">/* Increment Buffer pointer */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Update counter */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Wait until STOP flag is set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnSTOPFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable Address Acknowledge */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clear STOP flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_STOPFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable Address Acknowledge */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmit in master mode an amount of data in non-blocking mode with Interrupt
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Master_Transmit_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>

    <comment type="block">/* Generate Start */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */</comment>
    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Receive in master mode an amount of data in non-blocking mode with Interrupt
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Master_Receive_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>

    <comment type="block">/* Enable Acknowledge */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate Start */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */</comment>

    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmit in slave mode an amount of data in non-blocking mode with Interrupt
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Slave_Transmit_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Enable Address Acknowledge */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */</comment>

    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Receive in slave mode an amount of data in non-blocking mode with Interrupt
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Slave_Receive_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Enable Address Acknowledge */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */</comment>

    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmit in master mode an amount of data in non-blocking mode with DMA
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Master_Transmit_DMA</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>dmaxferstatus</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set the I2C DMA transfer complete callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>I2C_DMAXferCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>I2C_DMAError</name></expr>;</expr_stmt>

      <comment type="block">/* Set the unused DMA callbacks to NULL */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

      <comment type="block">/* Enable the DMA channel */</comment>
      <expr_stmt><expr><name>dmaxferstatus</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>dmaxferstatus</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable Acknowledge */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Generate Start */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
        to avoid the risk of I2C interrupt handle execution before current
        process unlock */</comment>

        <comment type="block">/* Enable EVT and ERR interrupt */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Enable DMA Request */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Update I2C state */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

        <comment type="block">/* Update I2C error code */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_DMA</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Enable Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate Start */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
      to avoid the risk of I2C interrupt handle execution before current
      process unlock */</comment>

      <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Receive in master mode an amount of data in non-blocking mode with DMA
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Master_Receive_DMA</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>dmaxferstatus</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set the I2C DMA transfer complete callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>I2C_DMAXferCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>I2C_DMAError</name></expr>;</expr_stmt>

      <comment type="block">/* Set the unused DMA callbacks to NULL */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

      <comment type="block">/* Enable the DMA channel */</comment>
      <expr_stmt><expr><name>dmaxferstatus</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>dmaxferstatus</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable Acknowledge */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Generate Start */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
        to avoid the risk of I2C interrupt handle execution before current
        process unlock */</comment>

        <comment type="block">/* Enable EVT and ERR interrupt */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Enable DMA Request */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Update I2C state */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

        <comment type="block">/* Update I2C error code */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_DMA</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Enable Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate Start */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
      to avoid the risk of I2C interrupt handle execution before current
      process unlock */</comment>

      <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Transmit in slave mode an amount of data in non-blocking mode with DMA
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Slave_Transmit_DMA</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>dmaxferstatus</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Set the I2C DMA transfer complete callback */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>I2C_DMAXferCplt</name></expr>;</expr_stmt>

    <comment type="block">/* Set the DMA error callback */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>I2C_DMAError</name></expr>;</expr_stmt>

    <comment type="block">/* Set the unused DMA callbacks to NULL */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Enable the DMA channel */</comment>
    <expr_stmt><expr><name>dmaxferstatus</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dmaxferstatus</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable Address Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
      to avoid the risk of I2C interrupt handle execution before current
      process unlock */</comment>
      <comment type="block">/* Enable EVT and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Enable DMA Request */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>|=</operator> <name>I2C_CR2_DMAEN</name></expr>;</expr_stmt>

      <return>return <expr><name>HAL_OK</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Update I2C state */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

      <comment type="block">/* Update I2C error code */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_DMA</name></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Receive in slave mode an amount of data in non-blocking mode with DMA
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Slave_Receive_DMA</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>dmaxferstatus</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Set the I2C DMA transfer complete callback */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>I2C_DMAXferCplt</name></expr>;</expr_stmt>

    <comment type="block">/* Set the DMA error callback */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>I2C_DMAError</name></expr>;</expr_stmt>

    <comment type="block">/* Set the unused DMA callbacks to NULL */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Enable the DMA channel */</comment>
    <expr_stmt><expr><name>dmaxferstatus</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dmaxferstatus</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable Address Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
      to avoid the risk of I2C interrupt handle execution before current
      process unlock */</comment>
      <comment type="block">/* Enable EVT and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Enable DMA Request */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_OK</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Update I2C state */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

      <comment type="block">/* Update I2C error code */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_DMA</name></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Write an amount of data in blocking mode to a specific memory address
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Mem_Write</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddSize</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_MEMADD_SIZE</name><argument_list>(<argument><expr><name>MemAddSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>I2C_TIMEOUT_BUSY_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_BUSY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MEM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Send Slave Address and Memory Address */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_RequestMemoryWrite</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>DevAddress</name></expr></argument>, <argument><expr><name>MemAddress</name></expr></argument>, <argument><expr><name>MemAddSize</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until TXE flag is set */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnTXEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_I2C_ERROR_AF</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Generate Stop */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Write data to DR */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr>;</expr_stmt>

      <comment type="block">/* Increment Buffer pointer */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Update counter */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>!=</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Write data to DR */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr>;</expr_stmt>

        <comment type="block">/* Increment Buffer pointer */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Update counter */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Wait until BTF flag is set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnBTFFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_I2C_ERROR_AF</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Generate Stop */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Read an amount of data in blocking mode from a specific memory address
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Mem_Read</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddSize</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_MEMADD_SIZE</name><argument_list>(<argument><expr><name>MemAddSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>I2C_TIMEOUT_BUSY_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_BUSY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MEM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Send Slave Address and Memory Address */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_RequestMemoryRead</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>DevAddress</name></expr></argument>, <argument><expr><name>MemAddress</name></expr></argument>, <argument><expr><name>MemAddSize</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable Acknowledge */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
         software sequence must complete before the current byte end of transfer */</comment>
      <expr_stmt><expr><call><name>__disable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Re-enable IRQs */</comment>
      <expr_stmt><expr><call><name>__enable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">2U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable Pos */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
         software sequence must complete before the current byte end of transfer */</comment>
      <expr_stmt><expr><call><name>__disable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Disable Acknowledge */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Re-enable IRQs */</comment>
      <expr_stmt><expr><call><name>__enable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Enable Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <while>while <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&lt;=</operator> <literal type="number">3U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* One byte */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Wait until RXNE flag is set */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnRXNEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <return>return <expr><name>HAL_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* Two bytes */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">2U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Wait until BTF flag is set */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <return>return <expr><name>HAL_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
             software sequence must complete before the current byte end of transfer */</comment>
          <expr_stmt><expr><call><name>__disable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Generate Stop */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

          <comment type="block">/* Re-enable IRQs */</comment>
          <expr_stmt><expr><call><name>__enable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* 3 Last bytes */</comment>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Wait until BTF flag is set */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <return>return <expr><name>HAL_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Disable Acknowledge */</comment>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Disable all active IRQs around ADDR clearing and STOP programming because the EV6_3
             software sequence must complete before the current byte end of transfer */</comment>
          <expr_stmt><expr><call><name>__disable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

          <comment type="block">/* Wait until BTF flag is set */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <return>return <expr><name>HAL_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>

          <comment type="block">/* Generate Stop */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

          <comment type="block">/* Re-enable IRQs */</comment>
          <expr_stmt><expr><call><name>__enable_irq</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Wait until RXNE flag is set */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnRXNEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Read data from DR */</comment>
        <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

        <comment type="block">/* Increment Buffer pointer */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Update counter */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

          <comment type="block">/* Update counter */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Write an amount of data in non-blocking mode with Interrupt to a specific memory address
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Mem_Write_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddSize</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_MEMADD_SIZE</name><argument_list>(<argument><expr><name>MemAddSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MEM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Memaddress</name></name>  <operator>=</operator> <name>MemAddress</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MemaddSize</name></name>  <operator>=</operator> <name>MemAddSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name>  <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

    <comment type="block">/* Generate Start */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */</comment>

    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Read an amount of data in non-blocking mode with Interrupt from a specific memory address
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Mem_Read_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddSize</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_MEMADD_SIZE</name><argument_list>(<argument><expr><name>MemAddSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MEM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Memaddress</name></name>  <operator>=</operator> <name>MemAddress</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>MemaddSize</name></name>  <operator>=</operator> <name>MemAddSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name>  <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

    <comment type="block">/* Enable Acknowledge */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate Start */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
      to avoid the risk of I2C interrupt handle execution before current
      process unlock */</comment>

      <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Write an amount of data in non-blocking mode with DMA to a specific memory address
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Mem_Write_DMA</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddSize</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>dmaxferstatus</name></decl>;</decl_stmt>

  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_MEMADD_SIZE</name><argument_list>(<argument><expr><name>MemAddSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MEM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set the I2C DMA transfer complete callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>I2C_DMAXferCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>I2C_DMAError</name></expr>;</expr_stmt>

      <comment type="block">/* Set the unused DMA callbacks to NULL */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

      <comment type="block">/* Enable the DMA channel */</comment>
      <expr_stmt><expr><name>dmaxferstatus</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>dmaxferstatus</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Send Slave Address and Memory Address */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>I2C_RequestMemoryWrite</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>DevAddress</name></expr></argument>, <argument><expr><name>MemAddress</name></expr></argument>, <argument><expr><name>MemAddSize</name></expr></argument>, <argument><expr><name>I2C_TIMEOUT_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Clear ADDR flag */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
        to avoid the risk of I2C interrupt handle execution before current
        process unlock */</comment>
        <comment type="block">/* Enable ERR interrupt */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Enable DMA Request */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_OK</name></expr>;</return>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Update I2C state */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

        <comment type="block">/* Update I2C error code */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_DMA</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Update I2C state */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

      <comment type="block">/* Update I2C error code */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_SIZE</name></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be read
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Mem_Read_DMA</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddSize</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Init tickstart for timeout management*/</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>dmaxferstatus</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_MEMADD_SIZE</name><argument_list>(<argument><expr><name>MemAddSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
    <do>do
    <block>{<block_content>
      <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MEM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set the I2C DMA transfer complete callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>I2C_DMAXferCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>I2C_DMAError</name></expr>;</expr_stmt>

      <comment type="block">/* Set the unused DMA callbacks to NULL */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

      <comment type="block">/* Enable the DMA channel */</comment>
      <expr_stmt><expr><name>dmaxferstatus</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>dmaxferstatus</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Send Slave Address and Memory Address */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>I2C_RequestMemoryRead</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>DevAddress</name></expr></argument>, <argument><expr><name>MemAddress</name></expr></argument>, <argument><expr><name>MemAddSize</name></expr></argument>, <argument><expr><name>I2C_TIMEOUT_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Disable Acknowledge */</comment>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Enable Last DMA bit */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Clear ADDR flag */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
        to avoid the risk of I2C interrupt handle execution before current
        process unlock */</comment>
        <comment type="block">/* Enable ERR interrupt */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Enable DMA Request */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>|=</operator> <name>I2C_CR2_DMAEN</name></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Update I2C state */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

        <comment type="block">/* Update I2C error code */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_DMA</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Send Slave Address and Memory Address */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>I2C_RequestMemoryRead</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>DevAddress</name></expr></argument>, <argument><expr><name>MemAddress</name></expr></argument>, <argument><expr><name>MemAddSize</name></expr></argument>, <argument><expr><name>I2C_TIMEOUT_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Checks if target device is ready for communication.
  * @note   This function is used with Memory devices
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  Trials Number of trials
  * @param  Timeout Timeout duration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_IsDeviceReady</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Trials</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Get tick */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name> <init>= <expr><call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>I2C_Trials</name> <init>= <expr><literal type="number">1U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FlagStatus</name></type> <name>tmp1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FlagStatus</name></type> <name>tmp2</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until BUSY flag is reset */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>I2C_TIMEOUT_BUSY_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_BUSY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_BUSY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <do>do
    <block>{<block_content>
      <comment type="block">/* Generate Start */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Wait until SB flag is set */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_SB</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Send slave address */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_7BIT_ADD_WRITE</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Wait until ADDR or AF flag are set */</comment>
      <comment type="block">/* Get tick */</comment>
      <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_I2C_STATE_TIMEOUT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp1</name> <operator>==</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp2</name> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_TIMEOUT</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>

      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

      <comment type="block">/* Check if the ADDR flag has been set */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear ADDR Flag */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Wait until BUSY flag is reset */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>I2C_TIMEOUT_BUSY_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_OK</name></expr>;</return>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Clear AF Flag */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Wait until BUSY flag is reset */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>, <argument><expr><name>SET</name></expr></argument>, <argument><expr><name>I2C_TIMEOUT_BUSY_FLAG</name></expr></argument>, <argument><expr><name>tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
        <block>{<block_content>
          <return>return <expr><name>HAL_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Increment Trials */</comment>
      <expr_stmt><expr><name>I2C_Trials</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    while <condition>(<expr><name>I2C_Trials</name> <operator>&lt;</operator> <name>Trials</name></expr>)</condition>;</do>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with Interrupt.
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Master_Seq_Transmit_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>Prev_State</name> <init>= <expr><literal type="number">0x00U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name>      <init>= <expr><literal type="number">0x00U</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check Busy Flag only if FIRST call of Master interface */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_FIRST_FRAME</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until BUSY flag is reset */</comment>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
      <do>do
      <block>{<block_content>
        <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

          <comment type="block">/* Process Unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <return>return <expr><name>HAL_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
      while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>Prev_State</name> <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name></expr>;</expr_stmt>

    <comment type="block">/* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */</comment>
    <comment type="block">/* Mean Previous state is same as current state */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Prev_State</name> <operator>!=</operator> <name>I2C_STATE_MASTER_BUSY_TX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Generate Start */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */</comment>

    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with DMA.
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Master_Seq_Transmit_DMA</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>Prev_State</name> <init>= <expr><literal type="number">0x00U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name>      <init>= <expr><literal type="number">0x00U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>dmaxferstatus</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check Busy Flag only if FIRST call of Master interface */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_FIRST_FRAME</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until BUSY flag is reset */</comment>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
      <do>do
      <block>{<block_content>
        <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

          <comment type="block">/* Process Unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <return>return <expr><name>HAL_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
      while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>Prev_State</name> <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set the I2C DMA transfer complete callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>I2C_DMAXferCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>I2C_DMAError</name></expr>;</expr_stmt>

      <comment type="block">/* Set the unused DMA callbacks to NULL */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

      <comment type="block">/* Enable the DMA channel */</comment>
      <expr_stmt><expr><name>dmaxferstatus</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>dmaxferstatus</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Enable Acknowledge */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */</comment>
        <comment type="block">/* Mean Previous state is same as current state */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Prev_State</name> <operator>!=</operator> <name>I2C_STATE_MASTER_BUSY_TX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Generate Start */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
        to avoid the risk of I2C interrupt handle execution before current
        process unlock */</comment>

        <comment type="block">/* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */</comment>
        <comment type="block">/* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_NEXT_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME_NO_STOP</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Enable DMA Request */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Enable EVT and ERR interrupt */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Update I2C state */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

        <comment type="block">/* Update I2C error code */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_DMA</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Enable Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */</comment>
      <comment type="block">/* Mean Previous state is same as current state */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Prev_State</name> <operator>!=</operator> <name>I2C_STATE_MASTER_BUSY_TX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Generate Start */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
      to avoid the risk of I2C interrupt handle execution before current
      process unlock */</comment>

      <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with Interrupt
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Master_Seq_Receive_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>Prev_State</name> <init>= <expr><literal type="number">0x00U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>enableIT</name> <init>= <expr><operator>(</operator><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check Busy Flag only if FIRST call of Master interface */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_FIRST_FRAME</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until BUSY flag is reset */</comment>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
      <do>do
      <block>{<block_content>
        <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

          <comment type="block">/* Process Unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <return>return <expr><name>HAL_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
      while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>Prev_State</name> <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">2U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME_NO_STOP</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>Prev_State</name> <operator>==</operator> <name>I2C_STATE_MASTER_BUSY_RX</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Disable Acknowledge */</comment>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Enable Pos */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Remove Enabling of IT_BUF, mean RXNE treatment, treat the 2 bytes through BTF */</comment>
        <expr_stmt><expr><name>enableIT</name> <operator>&amp;=</operator> <operator>~</operator><name>I2C_IT_BUF</name></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Enable Acknowledge */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Enable Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */</comment>
    <comment type="block">/* Mean Previous state is same as current state */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Prev_State</name> <operator>!=</operator> <name>I2C_STATE_MASTER_BUSY_RX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Generate Start */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */</comment>

    <comment type="block">/* Enable interrupts */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>enableIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sequential receive in master mode an amount of data in non-blocking mode with DMA
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Master_Seq_Receive_DMA</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>Prev_State</name> <init>= <expr><literal type="number">0x00U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>enableIT</name> <init>= <expr><operator>(</operator><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>dmaxferstatus</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check Busy Flag only if FIRST call of Master interface */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_FIRST_FRAME</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Wait until BUSY flag is reset */</comment>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name>I2C_TIMEOUT_BUSY_FLAG</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">25U</literal> <operator>/</operator> <literal type="number">1000U</literal><operator>)</operator></expr>;</expr_stmt>
      <do>do
      <block>{<block_content>
        <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

          <comment type="block">/* Process Unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <return>return <expr><name>HAL_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
      while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BUSY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clear Last DMA bit */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_MASTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name>  <operator>=</operator> <name>DevAddress</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>Prev_State</name> <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>&gt;</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">2U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME_NO_STOP</name><operator>)</operator><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>Prev_State</name> <operator>==</operator> <name>I2C_STATE_MASTER_BUSY_RX</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Disable Acknowledge */</comment>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Enable Pos */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Enable Last DMA bit */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Enable Acknowledge */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Enable Acknowledge */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_OTHER_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME_NO_STOP</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Enable Last DMA bit */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Set the I2C DMA transfer complete callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>I2C_DMAXferCplt</name></expr>;</expr_stmt>

      <comment type="block">/* Set the DMA error callback */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>I2C_DMAError</name></expr>;</expr_stmt>

      <comment type="block">/* Set the unused DMA callbacks to NULL */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

      <comment type="block">/* Enable the DMA channel */</comment>
      <expr_stmt><expr><name>dmaxferstatus</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>dmaxferstatus</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */</comment>
        <comment type="block">/* Mean Previous state is same as current state */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Prev_State</name> <operator>!=</operator> <name>I2C_STATE_MASTER_BUSY_RX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Generate Start */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Update interrupt for only EVT and ERR */</comment>
          <expr_stmt><expr><name>enableIT</name> <operator>=</operator> <operator>(</operator><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Update interrupt for only ERR */</comment>
          <expr_stmt><expr><name>enableIT</name> <operator>=</operator> <name>I2C_IT_ERR</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
        to avoid the risk of I2C interrupt handle execution before current
        process unlock */</comment>

        <comment type="block">/* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */</comment>
        <comment type="block">/* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_NEXT_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>XferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME_NO_STOP</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Enable DMA Request */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Enable EVT and ERR interrupt */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>enableIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Update I2C state */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

        <comment type="block">/* Update I2C error code */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_DMA</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Enable Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */</comment>
      <comment type="block">/* Mean Previous state is same as current state */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>Prev_State</name> <operator>!=</operator> <name>I2C_STATE_MASTER_BUSY_RX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Generate Start */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
      to avoid the risk of I2C interrupt handle execution before current
      process unlock */</comment>

      <comment type="block">/* Enable interrupts */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>enableIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sequential transmit in slave mode an amount of data in non-blocking mode with Interrupt
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Slave_Seq_Transmit_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX_LISTEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>

    <comment type="block">/* Clear ADDR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */</comment>

    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sequential transmit in slave mode an amount of data in non-blocking mode with DMA
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Slave_Seq_Transmit_DMA</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>dmaxferstatus</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable Interrupts, to prevent preemption during treatment in case of multicall */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* I2C cannot manage full duplex exchange so disable previous IT enabled if any */</comment>
    <comment type="block">/* and then toggle the HAL slave RX state to TX state */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX_LISTEN</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>I2C_CR2_DMAEN</name><operator>)</operator> <operator>==</operator> <name>I2C_CR2_DMAEN</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Abort DMA Xfer if any */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>I2C_DMAAbort</name></expr>;</expr_stmt>

          <comment type="block">/* Abort DMA RX */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Call Directly XferAbortCallback function in case of error */</comment>
            <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX_LISTEN</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>I2C_CR2_DMAEN</name><operator>)</operator> <operator>==</operator> <name>I2C_CR2_DMAEN</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Abort DMA Xfer if any */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>I2C_DMAAbort</name></expr>;</expr_stmt>

          <comment type="block">/* Abort DMA TX */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Call Directly XferAbortCallback function in case of error */</comment>
            <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Nothing to do */</comment>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_TX_LISTEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>

    <comment type="block">/* Set the I2C DMA transfer complete callback */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>I2C_DMAXferCplt</name></expr>;</expr_stmt>

    <comment type="block">/* Set the DMA error callback */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>I2C_DMAError</name></expr>;</expr_stmt>

    <comment type="block">/* Set the unused DMA callbacks to NULL */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Enable the DMA channel */</comment>
    <expr_stmt><expr><name>dmaxferstatus</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dmaxferstatus</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable Address Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
      to avoid the risk of I2C interrupt handle execution before current
      process unlock */</comment>
      <comment type="block">/* Enable EVT and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Enable DMA Request */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>|=</operator> <name>I2C_CR2_DMAEN</name></expr>;</expr_stmt>

      <return>return <expr><name>HAL_OK</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Update I2C state */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

      <comment type="block">/* Update I2C error code */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_DMA</name></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sequential receive in slave mode an amount of data in non-blocking mode with Interrupt
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Slave_Seq_Receive_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX_LISTEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>

    <comment type="block">/* Clear ADDR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */</comment>

    <comment type="block">/* Enable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Sequential receive in slave mode an amount of data in non-blocking mode with DMA
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Slave_Seq_Receive_DMA</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>Size</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>XferOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>dmaxferstatus</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_I2C_TRANSFER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>XferOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pData</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Size</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return  <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable Interrupts, to prevent preemption during treatment in case of multicall */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* I2C cannot manage full duplex exchange so disable previous IT enabled if any */</comment>
    <comment type="block">/* and then toggle the HAL slave RX state to TX state */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX_LISTEN</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>I2C_CR2_DMAEN</name><operator>)</operator> <operator>==</operator> <name>I2C_CR2_DMAEN</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Abort DMA Xfer if any */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>I2C_DMAAbort</name></expr>;</expr_stmt>

          <comment type="block">/* Abort DMA RX */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Call Directly XferAbortCallback function in case of error */</comment>
            <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX_LISTEN</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>I2C_CR2_DMAEN</name><operator>)</operator> <operator>==</operator> <name>I2C_CR2_DMAEN</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Abort DMA Xfer if any */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>I2C_DMAAbort</name></expr>;</expr_stmt>

          <comment type="block">/* Abort DMA TX */</comment>
          <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Call Directly XferAbortCallback function in case of error */</comment>
            <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Nothing to do */</comment>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Pos */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_BUSY_RX_LISTEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_SLAVE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Prepare transfer parameters */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name>    <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>   <operator>=</operator> <name>Size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name>    <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>XferOptions</name></expr>;</expr_stmt>

    <comment type="block">/* Set the I2C DMA transfer complete callback */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>I2C_DMAXferCplt</name></expr>;</expr_stmt>

    <comment type="block">/* Set the DMA error callback */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>I2C_DMAError</name></expr>;</expr_stmt>

    <comment type="block">/* Set the unused DMA callbacks to NULL */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Enable the DMA channel */</comment>
    <expr_stmt><expr><name>dmaxferstatus</name> <operator>=</operator> <call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr></argument>, <argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dmaxferstatus</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable Address Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Enable DMA Request */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Note : The I2C interrupts must be enabled after unlocking current process
      to avoid the risk of I2C interrupt handle execution before current
      process unlock */</comment>
      <comment type="block">/* Enable EVT and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_OK</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Update I2C state */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>     <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>      <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

      <comment type="block">/* Update I2C error code */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_DMA</name></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enable the Address listen mode with Interrupt.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_EnableListen_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_READY</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_LISTEN</name></expr>;</expr_stmt>

    <comment type="block">/* Check if the I2C is already enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;</operator> <name>I2C_CR1_PE</name><operator>)</operator> <operator>!=</operator> <name>I2C_CR1_PE</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Enable Address Acknowledge */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Enable EVT and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Disable the Address listen mode with Interrupt.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_DisableListen_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of tmp to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name></decl>;</decl_stmt>

  <comment type="block">/* Disable Address listen mode only if a transfer is not ongoing */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_LISTEN</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name><operator>)</operator> <operator>&amp;</operator> <name>I2C_STATE_MSK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>tmp</name> <operator>|</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Disable Address Acknowledge */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable EVT and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <return>return <expr><name>HAL_BUSY</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Abort a master I2C IT or DMA process communication with Interrupt.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_I2C_Master_Abort_IT</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Abort Master transfer during Receive or Transmit process    */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>==</operator> <name>HAL_I2C_MODE_MASTER</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Process Locked */</comment>
    <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_ABORT</name></expr>;</expr_stmt>

    <comment type="block">/* Disable Acknowledge */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate Stop */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

    <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
    <expr_stmt><expr><call><name>I2C_ITError</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_OK</name></expr>;</return>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Wrong usage of abort function */</comment>
    <comment type="block">/* This function should be used only in case of abort monitored by master device */</comment>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
 * @{
 */</comment>

<comment type="block" format="doxygen">/**
  * @brief  This function handles I2C event interrupt request.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_I2C_EV_IRQHandler</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>sr1itflags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>sr2itflags</name>               <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>itsources</name>                <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name>       <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_I2C_ModeTypeDef</name></type> <name>CurrentMode</name>   <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_I2C_StateTypeDef</name></type> <name>CurrentState</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Master or Memory mode selected */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentMode</name> <operator>==</operator> <name>HAL_I2C_MODE_MASTER</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentMode</name> <operator>==</operator> <name>HAL_I2C_MODE_MEM</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>sr2itflags</name>   <operator>=</operator> <call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sr1itflags</name>   <operator>=</operator> <call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Exit IRQ event until Start Bit detected in case of Other frame requested */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_SB</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST</name><argument_list>(<argument><expr><name>CurrentXferOptions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* SB Set ----------------------------------------------------------------*/</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_SB</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Convert OTHER_xxx XferOptions if any */</comment>
      <expr_stmt><expr><call><name>I2C_ConvertOtherXferOptions</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>I2C_Master_SB</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* ADD10 Set -------------------------------------------------------------*/</comment>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADD10</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>I2C_Master_ADD10</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* ADDR Set --------------------------------------------------------------*/</comment>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>I2C_Master_ADDR</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* I2C in mode Transmitter -----------------------------------------------*/</comment>
    <if type="elseif">else if <condition>(<expr><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr2itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_TRA</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Do not check buffer and BTF flag if a Xfer DMA is on going */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>I2C_CR2_DMAEN</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* TXE set and BTF reset -----------------------------------------------*/</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_TXE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_BUF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>I2C_MasterTransmit_TXE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* BTF set -------------------------------------------------------------*/</comment>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>I2C_MasterTransmit_BTF</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Do nothing */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* I2C in mode Receiver --------------------------------------------------*/</comment>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Do not check buffer and BTF flag if a Xfer DMA is on going */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>I2C_CR2_DMAEN</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* RXNE set and BTF reset -----------------------------------------------*/</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_RXNE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_BUF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>I2C_MasterReceive_RXNE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* BTF set -------------------------------------------------------------*/</comment>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>I2C_MasterReceive_BTF</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Do nothing */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <comment type="block">/* Slave mode selected */</comment>
  <else>else
  <block>{<block_content>
    <comment type="block">/* If an error is detected, read only SR1 register to prevent */</comment>
    <comment type="block">/* a clear of ADDR flags by reading SR2 after reading SR1 in Error treatment */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>sr1itflags</name>   <operator>=</operator> <call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name>sr2itflags</name>   <operator>=</operator> <call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sr1itflags</name>   <operator>=</operator> <call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* ADDR set --------------------------------------------------------------*/</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Now time to read SR2, this will clear ADDR flag automatically */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name>sr2itflags</name>   <operator>=</operator> <call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>I2C_Slave_ADDR</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>sr2itflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* STOPF set --------------------------------------------------------------*/</comment>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_STOPF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>I2C_Slave_STOPF</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* I2C in mode Transmitter -----------------------------------------------*/</comment>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX_LISTEN</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* TXE set and BTF reset -----------------------------------------------*/</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_TXE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_BUF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>I2C_SlaveTransmit_TXE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <comment type="block">/* BTF set -------------------------------------------------------------*/</comment>
      <if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>I2C_SlaveTransmit_BTF</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Do nothing */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* I2C in mode Receiver --------------------------------------------------*/</comment>
    <else>else
    <block>{<block_content>
      <comment type="block">/* RXNE set and BTF reset ----------------------------------------------*/</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_RXNE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_BUF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>I2C_SlaveReceive_RXNE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <comment type="block">/* BTF set -------------------------------------------------------------*/</comment>
      <if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>I2C_SlaveReceive_BTF</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Do nothing */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles I2C error interrupt request.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><name>void</name></type> <name>HAL_I2C_ER_IRQHandler</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_I2C_ModeTypeDef</name></type> <name>tmp1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_I2C_StateTypeDef</name></type> <name>tmp3</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp4</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>sr1itflags</name> <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR1</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>itsources</name>  <init>= <expr><call><name>READ_REG</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>error</name>      <init>= <expr><name>HAL_I2C_ERROR_NONE</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* I2C Bus error interrupt occurred ----------------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_BERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_ERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>error</name> <operator>|=</operator> <name>HAL_I2C_ERROR_BERR</name></expr>;</expr_stmt>

    <comment type="block">/* Clear BERR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Workaround: Start cannot be generated after a misplaced Stop */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_SWRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* I2C Arbitration Lost error interrupt occurred ---------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_ARLO</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_ERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>error</name> <operator>|=</operator> <name>HAL_I2C_ERROR_ARLO</name></expr>;</expr_stmt>

    <comment type="block">/* Clear ARLO flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ARLO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* I2C Acknowledge failure error interrupt occurred ------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_ERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp3</name> <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp4</name> <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp1</name> <operator>==</operator> <name>HAL_I2C_MODE_SLAVE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp2</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> \
        <operator>(</operator><operator>(</operator><name>tmp3</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tmp3</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX_LISTEN</name><operator>)</operator> <operator>||</operator> \
         <operator>(</operator><operator>(</operator><name>tmp3</name> <operator>==</operator> <name>HAL_I2C_STATE_LISTEN</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp4</name> <operator>==</operator> <name>I2C_STATE_SLAVE_BUSY_TX</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>I2C_Slave_AF</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Clear AF flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>error</name> <operator>|=</operator> <name>HAL_I2C_ERROR_AF</name></expr>;</expr_stmt>

      <comment type="block">/* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>==</operator> <name>HAL_I2C_MODE_MASTER</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>sr1itflags</name></expr></argument>, <argument><expr><name>I2C_FLAG_OVR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>I2C_CHECK_IT_SOURCE</name><argument_list>(<argument><expr><name>itsources</name></expr></argument>, <argument><expr><name>I2C_IT_ERR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>error</name> <operator>|=</operator> <name>HAL_I2C_ERROR_OVR</name></expr>;</expr_stmt>
    <comment type="block">/* Clear OVR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_OVR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Call the Error Callback in case of Error detected -----------------------*/</comment>
  <if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>error</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>I2C_ITError</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Master Tx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_MasterTxCpltCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Master Rx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_MasterRxCpltCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** @brief  Slave Tx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_SlaveTxCpltCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Slave Rx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_SlaveRxCpltCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Slave Address Match callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XferDirection_definition
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_AddrCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>TransferDirection</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>AddrMatchCode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>TransferDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>AddrMatchCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Listen Complete callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_ListenCpltCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
  */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Memory Tx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_MemTxCpltCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Memory Rx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_MemRxCpltCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  I2C error callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_ErrorCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ErrorCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  I2C abort callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_I2C_AbortCpltCallback</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
 *  @brief   Peripheral State, Mode and Error functions
  *
@verbatim
 ===============================================================================
            ##### Peripheral State, Mode and Error functions #####
 ===============================================================================
    [..]
    This subsection permit to get in run-time the status of the peripheral
    and the data flow.

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Return the I2C handle state.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */</comment>
<function><type><name>HAL_I2C_StateTypeDef</name></type> <name>HAL_I2C_GetState</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Return I2C handle state */</comment>
  <return>return <expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Returns the I2C Master, Slave, Memory or no mode.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL mode
  */</comment>
<function><type><name>HAL_I2C_ModeTypeDef</name></type> <name>HAL_I2C_GetMode</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Return the I2C error code.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
  * @retval I2C Error Code
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_I2C_GetError</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <return>return <expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @addtogroup I2C_Private_Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Handle TXE flag for Master
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_MasterTransmit_TXE</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>HAL_I2C_StateTypeDef</name></type> <name>CurrentState</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_I2C_ModeTypeDef</name></type> <name>CurrentMode</name>   <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name>       <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>XferSize</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Call TxCpltCallback() directly if no stop mode is set */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_LAST_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_NO_OPTION_FRAME</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_MASTER_BUSY_TX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_I2C_MasterTxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if>
    <else>else <comment type="block">/* Generate Stop condition then Call TxCpltCallback() */</comment>
    <block>{<block_content>
      <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>==</operator> <name>HAL_I2C_MODE_MEM</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MemTxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_I2C_MemTxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_I2C_MasterTxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX</name><operator>)</operator> <operator>||</operator> \
           <operator>(</operator><operator>(</operator><name>CurrentMode</name> <operator>==</operator> <name>HAL_I2C_MODE_MEM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX</name><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable BUF interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>==</operator> <name>HAL_I2C_MODE_MEM</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* If Memory address size is 8Bit */</comment>
          <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>MemaddSize</name></name> <operator>==</operator> <name>I2C_MEMADD_SIZE_8BIT</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Send Memory Address */</comment>
            <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_MEM_ADD_LSB</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Memaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>+=</operator> <literal type="number">2U</literal></expr>;</expr_stmt>
          </block_content>}</block></if>
          <comment type="block">/* If Memory address size is 16Bit */</comment>
          <else>else
          <block>{<block_content>
            <comment type="block">/* Send MSB of Memory Address */</comment>
            <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_MEM_ADD_MSB</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Memaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Send LSB of Memory Address */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_MEM_ADD_LSB</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Memaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>==</operator> <literal type="number">2U</literal></expr>)</condition>
        <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Generate Restart */</comment>
            <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>|=</operator> <name>I2C_CR1_START</name></expr>;</expr_stmt>
          </block_content>}</block></if>
          <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Write data to DR */</comment>
            <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr>;</expr_stmt>

            <comment type="block">/* Increment Buffer pointer */</comment>
            <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/* Update counter */</comment>
            <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></if>
          <else>else
          <block>{<block_content>
            <comment type="block">/* Do nothing */</comment>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Do nothing */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Write data to DR */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr>;</expr_stmt>

        <comment type="block">/* Increment Buffer pointer */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Update counter */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Do nothing */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle BTF flag for Master transmitter
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_MasterTransmit_BTF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Write data to DR */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr>;</expr_stmt>

      <comment type="block">/* Increment Buffer pointer */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Update counter */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Call TxCpltCallback() directly if no stop mode is set */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_LAST_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_NO_OPTION_FRAME</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_MASTER_BUSY_TX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_I2C_MasterTxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <else>else <comment type="block">/* Generate Stop condition then Call TxCpltCallback() */</comment>
      <block>{<block_content>
        <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>==</operator> <name>HAL_I2C_MODE_MEM</name></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
          <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MemTxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><call><name>HAL_I2C_MemTxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
          <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MasterTxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><call><name>HAL_I2C_MasterTxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle RXNE flag for Master
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_MasterReceive_RXNE</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>)</condition>
  <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&gt;</operator> <literal type="number">3U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

      <comment type="block">/* Increment Buffer pointer */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Update counter */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><literal type="number">3</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Disable BUF interrupt, this help to treat correctly the last 4 bytes
        on BTF subroutine */</comment>
        <comment type="block">/* Disable BUF interrupt */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>!=</operator> <name>I2C_FIRST_AND_NEXT_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>tmp</name> <operator>==</operator> <literal type="number">1U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>tmp</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable Acknowledge */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

      <comment type="block">/* Increment Buffer pointer */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Update counter */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>==</operator> <name>HAL_I2C_MODE_MEM</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MemRxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_I2C_MemRxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_MASTER_BUSY_RX</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MasterRxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_I2C_MasterRxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Do nothing */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle BTF flag for Master receiver
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_MasterReceive_BTF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">4U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable BUF interrupt, this help to treat correctly the last 2 bytes
       on BTF subroutine if there is a reception delay between N-1 and N byte */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

    <comment type="block">/* Increment Buffer pointer */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Update counter */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">3U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable BUF interrupt, this help to treat correctly the last 2 bytes
       on BTF subroutine if there is a reception delay between N-1 and N byte */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_NEXT_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_FIRST_AND_NEXT_FRAME</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable Acknowledge */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

    <comment type="block">/* Increment Buffer pointer */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Update counter */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">2U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Prepare next transfer or stop current transfer */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME_NO_STOP</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable Acknowledge */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_NEXT_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_AND_NEXT_FRAME</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_LAST_FRAME_NO_STOP</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Do nothing */</comment>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

    <comment type="block">/* Increment Buffer pointer */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Update counter */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

    <comment type="block">/* Increment Buffer pointer */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Update counter */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/* Disable EVT and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>==</operator> <name>HAL_I2C_MODE_MEM</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MemRxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_I2C_MemRxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_MASTER_BUSY_RX</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MasterRxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_I2C_MasterRxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

    <comment type="block">/* Increment Buffer pointer */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Update counter */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle SB flag for Master
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Master_SB</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>==</operator> <name>HAL_I2C_MODE_MEM</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Send slave address */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_7BIT_ADD_WRITE</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_7BIT_ADD_READ</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AddressingMode</name></name> <operator>==</operator> <name>I2C_ADDRESSINGMODE_7BIT</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Send slave 7 Bits address */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_7BIT_ADD_WRITE</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_7BIT_ADD_READ</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Enable DMA Request */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Send header of slave address */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_10BIT_HEADER_WRITE</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Send header of slave address */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_10BIT_HEADER_READ</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Do nothing */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle ADD10 flag for Master
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Master_ADD10</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Send slave address */</comment>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_10BIT_ADDRESS</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Devaddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Enable DMA Request */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle ADDR flag for Master
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Master_ADDR</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variable to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>HAL_I2C_ModeTypeDef</name></type> <name>CurrentMode</name>       <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name>           <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>Prev_State</name>                   <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentMode</name> <operator>==</operator> <name>HAL_I2C_MODE_MEM</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AddressingMode</name></name> <operator>==</operator> <name>I2C_ADDRESSINGMODE_10BIT</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear ADDR flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate Restart */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Clear ADDR flag */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">1U</literal></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_NO_OPTION_FRAME</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Disable Acknowledge */</comment>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>I2C_CR2_DMAEN</name><operator>)</operator> <operator>==</operator> <name>I2C_CR2_DMAEN</name></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Disable Acknowledge */</comment>
            <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Clear ADDR flag */</comment>
            <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if>
          <else>else
          <block>{<block_content>
            <comment type="block">/* Clear ADDR flag */</comment>
            <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Generate Stop */</comment>
            <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <comment type="block">/* Prepare next transfer or stop current transfer */</comment>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_LAST_FRAME</name><operator>)</operator> \
                 <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Prev_State</name> <operator>!=</operator> <name>I2C_STATE_MASTER_BUSY_RX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_FRAME</name><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_NEXT_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_FIRST_AND_NEXT_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_LAST_FRAME_NO_STOP</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
            <comment type="block">/* Disable Acknowledge */</comment>
            <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if>
          <else>else
          <block>{<block_content>
            <comment type="block">/* Enable Acknowledge */</comment>
            <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>

          <comment type="block">/* Clear ADDR flag */</comment>
          <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Disable Acknowledge */</comment>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Clear ADDR flag */</comment>
          <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Generate Stop */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">2U</literal></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_NEXT_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_FIRST_AND_NEXT_FRAME</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>!=</operator> <name>I2C_LAST_FRAME_NO_STOP</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Enable Pos */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Clear ADDR flag */</comment>
          <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Disable Acknowledge */</comment>
          <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
          <comment type="block">/* Enable Acknowledge */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Clear ADDR flag */</comment>
          <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>I2C_CR2_DMAEN</name><operator>)</operator> <operator>==</operator> <name>I2C_CR2_DMAEN</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_NO_OPTION_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME_NO_STOP</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME</name><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Enable Last DMA bit */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Enable Acknowledge */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>I2C_CR2_DMAEN</name><operator>)</operator> <operator>==</operator> <name>I2C_CR2_DMAEN</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_NO_OPTION_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME_NO_STOP</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME</name><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Enable Last DMA bit */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Clear ADDR flag */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* Reset Event counter  */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>EventCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Clear ADDR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle TXE flag for Slave
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_SlaveTransmit_TXE</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>HAL_I2C_StateTypeDef</name></type> <name>CurrentState</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Write data to DR */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr>;</expr_stmt>

    <comment type="block">/* Increment Buffer pointer */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Update counter */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX_LISTEN</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Last Byte is received, disable Interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set state at HAL_I2C_STATE_LISTEN */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_SLAVE_BUSY_TX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_LISTEN</name></expr>;</expr_stmt>

      <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveTxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_I2C_SlaveTxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle BTF flag for Slave transmitter
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_SlaveTransmit_BTF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Write data to DR */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name></expr>;</expr_stmt>

    <comment type="block">/* Increment Buffer pointer */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Update counter */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle RXNE flag for Slave
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_SlaveReceive_RXNE</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>HAL_I2C_StateTypeDef</name></type> <name>CurrentState</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

    <comment type="block">/* Increment Buffer pointer */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Update counter */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX_LISTEN</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Last Byte is received, disable Interrupt */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set state at HAL_I2C_STATE_LISTEN */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_SLAVE_BUSY_RX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_LISTEN</name></expr>;</expr_stmt>

      <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveRxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_I2C_SlaveRxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle BTF flag for Slave receiver
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_SlaveReceive_BTF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Read data from DR */</comment>
    <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

    <comment type="block">/* Increment Buffer pointer */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Update counter */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle ADD flag for Slave
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @param  IT2Flags Interrupt2 flags to handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Slave_ADDR</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>IT2Flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>TransferDirection</name> <init>= <expr><name>I2C_DIRECTION_RECEIVE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>SlaveAddrCode</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable BUF interrupt, BUF enabling is manage through slave specific interface */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><operator>(</operator><name>I2C_IT_BUF</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Transfer Direction requested by Master */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>IT2Flags</name></expr></argument>, <argument><expr><name>I2C_FLAG_TRA</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>TransferDirection</name> <operator>=</operator> <name>I2C_DIRECTION_TRANSMIT</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>I2C_CHECK_FLAG</name><argument_list>(<argument><expr><name>IT2Flags</name></expr></argument>, <argument><expr><name>I2C_FLAG_DUALF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>SlaveAddrCode</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress1</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name>SlaveAddrCode</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>OwnAddress2</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Call Slave Addr callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>AddrCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>TransferDirection</name></expr></argument>, <argument><expr><name>SlaveAddrCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_I2C_AddrCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>TransferDirection</name></expr></argument>, <argument><expr><name>SlaveAddrCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Clear ADDR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Handle STOPF flag for Slave
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Slave_STOPF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variable to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>HAL_I2C_StateTypeDef</name></type> <name>CurrentState</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clear STOPF flag */</comment>
  <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_STOPFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disable Acknowledge */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If a DMA is ongoing, Update handle size context */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;</operator> <name>I2C_CR2_DMAEN</name><operator>)</operator> <operator>==</operator> <name>I2C_CR2_DMAEN</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX_LISTEN</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><call><name>__HAL_DMA_GET_COUNTER</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set ErrorCode corresponding to a Non-Acknowledge */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_AF</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Disable, stop the current DMA */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Abort DMA Xfer if any */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_GetState</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_DMA_STATE_READY</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>I2C_DMAAbort</name></expr>;</expr_stmt>

        <comment type="block">/* Abort DMA RX */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Call Directly XferAbortCallback function in case of error */</comment>
          <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><call><name>__HAL_DMA_GET_COUNTER</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set ErrorCode corresponding to a Non-Acknowledge */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_AF</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* Disable, stop the current DMA */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Abort DMA Xfer if any */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_GetState</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_DMA_STATE_READY</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */</comment>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>I2C_DMAAbort</name></expr>;</expr_stmt>

        <comment type="block">/* Abort DMA TX */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Call Directly XferAbortCallback function in case of error */</comment>
          <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* All data are not transferred, so set error code accordingly */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Store Last receive data if any */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

      <comment type="block">/* Increment Buffer pointer */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Update counter */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Store Last receive data if any */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_RXNE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

      <comment type="block">/* Increment Buffer pointer */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Update counter */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set ErrorCode corresponding to a Non-Acknowledge */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>|=</operator> <name>HAL_I2C_ERROR_AF</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
    <expr_stmt><expr><call><name>I2C_ITError</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX_LISTEN</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set state at HAL_I2C_STATE_LISTEN */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_LISTEN</name></expr>;</expr_stmt>

      <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveRxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_I2C_SlaveRxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_LISTEN</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

      <comment type="block">/* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_I2C_ListenCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>  <operator>==</operator> <name>I2C_STATE_SLAVE_BUSY_RX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveRxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_I2C_SlaveRxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_Slave_AF</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variables to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>HAL_I2C_StateTypeDef</name></type> <name>CurrentState</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name>       <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator>  <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> \
      <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_LISTEN</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>

    <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clear AF flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable Acknowledge */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>         <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>          <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_I2C_ListenCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name>   <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_SLAVE_BUSY_TX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>         <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>          <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clear AF flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable Acknowledge */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveTxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_I2C_SlaveTxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Clear AF flag only */</comment>
    <comment type="block">/* State Listen, but XferOptions == FIRST or NEXT */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  I2C interrupts error process
  * @param  hi2c I2C handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_ITError</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variable to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>HAL_I2C_StateTypeDef</name></type> <name>CurrentState</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>==</operator> <name>HAL_I2C_MODE_MASTER</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name> <operator>&amp;=</operator> <operator>~</operator><name>I2C_CR1_POS</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>CurrentState</name> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* keep HAL_I2C_STATE_LISTEN */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_LISTEN</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* If state is an abort treatment on going, don't change state */</comment>
    <comment type="block">/* This change will be do later */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>I2C_CR2_DMAEN</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentState</name> <operator>!=</operator> <name>HAL_I2C_STATE_ABORT</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Abort DMA transfer */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>I2C_CR2_DMAEN</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>I2C_CR2_DMAEN</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>State</name></name> <operator>!=</operator> <name>HAL_DMA_STATE_READY</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set the DMA Abort callback :
      will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>I2C_DMAAbort</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Disable I2C peripheral to prevent dummy data in buffer */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_DISABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

        <comment type="block">/* Call Directly XferAbortCallback function in case of error */</comment>
        <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Set the DMA Abort callback :
      will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>I2C_DMAAbort</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>HAL_DMA_Abort_IT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Store Last receive data if any */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_RXNE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Read data from DR */</comment>
          <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

          <comment type="block">/* Increment Buffer pointer */</comment>
          <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Disable I2C peripheral to prevent dummy data in buffer */</comment>
        <expr_stmt><expr><call><name>__HAL_I2C_DISABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

        <comment type="block">/* Call Directly hi2c-&gt;hdmarx-&gt;XferAbortCallback function in case of error */</comment>
        <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_ABORT</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Store Last receive data if any */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_RXNE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

      <comment type="block">/* Increment Buffer pointer */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable I2C peripheral to prevent dummy data in buffer */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_I2C_AbortCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Store Last receive data if any */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_RXNE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Read data from DR */</comment>
      <expr_stmt><expr><operator>*</operator><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

      <comment type="block">/* Increment Buffer pointer */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>pBuffPtr</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Call user error callback */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_I2C_ErrorCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* STOP Flag is not set after a NACK reception */</comment>
  <comment type="block">/* So may inform upper layer that listen phase is stopped */</comment>
  <comment type="block">/* during NACK error treatment */</comment>
  <expr_stmt><expr><name>CurrentState</name> <operator>=</operator> <name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>&amp;</operator> <name>HAL_I2C_ERROR_AF</name><operator>)</operator> <operator>==</operator> <name>HAL_I2C_ERROR_AF</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_LISTEN</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable EVT, BUF and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_BUF</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name>   <operator>=</operator> <name>I2C_NO_OPTION_FRAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>         <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>          <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>ListenCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_I2C_ListenCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_MasterRequestWrite</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variable to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Generate Start condition if first transfer */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_NO_OPTION_FRAME</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Generate Start */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>==</operator> <name>I2C_STATE_MASTER_BUSY_RX</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Generate ReStart */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Do nothing */</comment>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Wait until SB flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_SB</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AddressingMode</name></name> <operator>==</operator> <name>I2C_ADDRESSINGMODE_7BIT</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Send slave address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_7BIT_ADD_WRITE</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Send header of slave address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_10BIT_HEADER_WRITE</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait until ADD10 flag is set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnMasterAddressFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADD10</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send slave address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_10BIT_ADDRESS</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Wait until ADDR flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnMasterAddressFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Master sends target device address for read request.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_MasterRequestRead</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Declaration of temporary variable to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Enable Acknowledge */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate Start condition if first transfer */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_FRAME</name><operator>)</operator>  <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_NO_OPTION_FRAME</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Generate Start */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>==</operator> <name>I2C_STATE_MASTER_BUSY_TX</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Generate ReStart */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Do nothing */</comment>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Wait until SB flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_SB</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>AddressingMode</name></name> <operator>==</operator> <name>I2C_ADDRESSINGMODE_7BIT</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Send slave address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_7BIT_ADD_READ</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Send header of slave address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_10BIT_HEADER_WRITE</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait until ADD10 flag is set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnMasterAddressFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADD10</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send slave address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_10BIT_ADDRESS</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait until ADDR flag is set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnMasterAddressFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Clear ADDR flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate Restart */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait until SB flag is set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_SB</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send header of slave address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_10BIT_HEADER_READ</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Wait until ADDR flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnMasterAddressFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Master sends target device address followed by internal memory address for write request.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_RequestMemoryWrite</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddSize</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Generate Start */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until SB flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_SB</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Send slave address */</comment>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_7BIT_ADD_WRITE</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until ADDR flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnMasterAddressFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clear ADDR flag */</comment>
  <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until TXE flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnTXEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_I2C_ERROR_AF</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If Memory address size is 8Bit */</comment>
  <if_stmt><if>if <condition>(<expr><name>MemAddSize</name> <operator>==</operator> <name>I2C_MEMADD_SIZE_8BIT</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Send Memory Address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_MEM_ADD_LSB</name><argument_list>(<argument><expr><name>MemAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <comment type="block">/* If Memory address size is 16Bit */</comment>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Send MSB of Memory Address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_MEM_ADD_MSB</name><argument_list>(<argument><expr><name>MemAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait until TXE flag is set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnTXEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_I2C_ERROR_AF</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send LSB of Memory Address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_MEM_ADD_LSB</name><argument_list>(<argument><expr><name>MemAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Master sends target device address followed by internal memory address for read request.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_RequestMemoryRead</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>DevAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddress</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>MemAddSize</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Enable Acknowledge */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate Start */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until SB flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_SB</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Send slave address */</comment>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_7BIT_ADD_WRITE</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until ADDR flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnMasterAddressFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Clear ADDR flag */</comment>
  <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_ADDRFLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until TXE flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnTXEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_I2C_ERROR_AF</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If Memory address size is 8Bit */</comment>
  <if_stmt><if>if <condition>(<expr><name>MemAddSize</name> <operator>==</operator> <name>I2C_MEMADD_SIZE_8BIT</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Send Memory Address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_MEM_ADD_LSB</name><argument_list>(<argument><expr><name>MemAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <comment type="block">/* If Memory address size is 16Bit */</comment>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Send MSB of Memory Address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_MEM_ADD_MSB</name><argument_list>(<argument><expr><name>MemAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait until TXE flag is set */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnTXEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_I2C_ERROR_AF</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Generate Stop */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send LSB of Memory Address */</comment>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_MEM_ADD_LSB</name><argument_list>(<argument><expr><name>MemAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Wait until TXE flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnTXEFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>==</operator> <name>HAL_I2C_ERROR_AF</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Generate Restart */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until SB flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_SB</name></expr></argument>, <argument><expr><name>RESET</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Send slave address */</comment>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name> <operator>=</operator> <call><name>I2C_7BIT_ADD_READ</name><argument_list>(<argument><expr><name>DevAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wait until ADDR flag is set */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>I2C_WaitOnMasterAddressFlagUntilTimeout</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_ADDR</name></expr></argument>, <argument><expr><name>Timeout</name></expr></argument>, <argument><expr><name>Tickstart</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA I2C process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_DMAXferCplt</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name> <init>= <expr><operator>(</operator><name>I2C_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>

  <comment type="block">/* Declaration of temporary variable to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>HAL_I2C_StateTypeDef</name></type> <name>CurrentState</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HAL_I2C_ModeTypeDef</name></type> <name>CurrentMode</name>   <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>CurrentXferOptions</name>       <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Disable EVT and ERR interrupt */</comment>
  <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clear Complete callback */</comment>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>CurrentState</name> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_BUSY_TX</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_BUSY_TX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>CurrentState</name> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_BUSY_RX</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_BUSY_RX</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>CurrentMode</name> <operator>==</operator> <name>HAL_I2C_MODE_SLAVE</name><operator>)</operator><operator>)</operator></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Disable DMA Request */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_TX_LISTEN</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set state at HAL_I2C_STATE_LISTEN */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_SLAVE_BUSY_TX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_LISTEN</name></expr>;</expr_stmt>

      <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveTxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_I2C_SlaveTxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>CurrentState</name> <operator>==</operator> <name>HAL_I2C_STATE_BUSY_RX_LISTEN</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set state at HAL_I2C_STATE_LISTEN */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_SLAVE_BUSY_RX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_LISTEN</name></expr>;</expr_stmt>

      <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>SlaveRxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_I2C_SlaveRxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Do nothing */</comment>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Enable EVT and ERR interrupt to treat end of transfer in IRQ handler */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_ENABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <comment type="block">/* Check current Mode, in case of treatment DMA handler have been preempted by a prior interrupt */</comment>
  <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>!=</operator> <name>HAL_I2C_MODE_NONE</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>==</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable Acknowledge */</comment>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable EVT and ERR interrupt */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_DISABLE_IT</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_IT_EVT</name> <operator>|</operator> <name>I2C_IT_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Prepare next transfer or stop current transfer */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_NO_OPTION_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_FIRST_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_OTHER_AND_LAST_FRAME</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>CurrentXferOptions</name> <operator>==</operator> <name>I2C_LAST_FRAME</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable Last DMA */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable DMA Request */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>I2C_CR2_DMAEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

    <comment type="block">/* Check if Errors has been detected during transfer */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name> <operator>!=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
      <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>HAL_I2C_ErrorCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>==</operator> <name>HAL_I2C_MODE_MEM</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MemRxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_I2C_MemRxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_MASTER_BUSY_RX</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>MasterRxCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HAL_I2C_MasterRxCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Do nothing */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  DMA I2C communication error callback.
  * @param  hdma DMA handle
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_DMAError</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name> <init>= <expr><operator>(</operator><name>I2C_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>

  <comment type="block">/* Clear Complete callback */</comment>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Disable Acknowledge */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name>       <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>           <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>            <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>       <operator>|=</operator> <name>HAL_I2C_ERROR_DMA</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>HAL_I2C_ErrorCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief DMA I2C communication abort callback
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_DMAAbort</name><parameter_list>(<parameter><decl><type><name>DMA_HandleTypeDef</name> <modifier>*</modifier></type><name>hdma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name> <init>= <expr><operator>(</operator><name>I2C_HandleTypeDef</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>DMA_HandleTypeDef</name> <operator>*</operator><operator>)</operator><name>hdma</name><operator>)</operator><operator>-&gt;</operator><name>Parent</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Derogation MISRAC2012-Rule-11.5 */</comment>

  <comment type="block">/* Declaration of temporary variable to prevent undefined behavior of volatile usage */</comment>
  <decl_stmt><decl><type><name>HAL_I2C_StateTypeDef</name></type> <name>CurrentState</name> <init>= <expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Clear Complete callback */</comment>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Disable Acknowledge */</comment>
  <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferCount</name></name> <operator>=</operator> <literal type="number">0U</literal></expr>;</expr_stmt>

  <comment type="block">/* Reset XferAbortCallback */</comment>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmatx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>hdmarx</name><operator>-&gt;</operator><name>XferAbortCallback</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Disable I2C peripheral to prevent dummy data in buffer */</comment>
  <expr_stmt><expr><call><name>__HAL_I2C_DISABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check if come from abort from user */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>==</operator> <name>HAL_I2C_STATE_ABORT</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>         <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>          <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>     <operator>=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

    <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>AbortCpltCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_I2C_AbortCpltCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name>CurrentState</name> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>HAL_I2C_STATE_LISTEN</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Renable I2C peripheral */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_ENABLE</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Enable Acknowledge */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_ACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* keep HAL_I2C_STATE_LISTEN */</comment>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name> <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_LISTEN</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name> <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Call the corresponding callback to inform upper layer of End of Transfer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>USE_HAL_I2C_REGISTER_CALLBACKS</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></cpp:if>
    <expr_stmt><expr><call><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCallback</name></name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>HAL_I2C_ErrorCallback</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_HAL_I2C_REGISTER_CALLBACKS */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles I2C Communication Timeout.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @param  Flag specifies the I2C flag to check.
  * @param  Status The new Flag status (SET or RESET).
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Flag</name></decl></parameter>, <parameter><decl><type><name>FlagStatus</name></type> <name>Status</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Wait until flag is set */</comment>
  <while>while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Flag</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Status</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if <condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>Tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>     <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>             <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>              <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>         <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles I2C Communication Timeout for Master addressing phase.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @param  Flag specifies the I2C flag to check.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnMasterAddressFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Flag</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>Flag</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Generate Stop */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>I2C_CR1_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Clear AF Flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_AF</name></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if <condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>Tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles I2C Communication Timeout for specific usage of TXE flag.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnTXEFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_TXE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check if a NACK is detected */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_IsAcknowledgeFailed</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if <condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>Tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles I2C Communication Timeout for specific usage of BTF flag.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnBTFFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_BTF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check if a NACK is detected */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_IsAcknowledgeFailed</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if <condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>Tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

        <comment type="block">/* Process Unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnSTOPFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <while>while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_STOPF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check if a NACK is detected */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>I2C_IsAcknowledgeFailed</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>Tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_WaitOnRXNEFlagUntilTimeout</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Tickstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>

  <while>while <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_RXNE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Check if a STOPF is detected */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_STOPF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear STOP Flag */</comment>
      <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_STOPF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_NONE</name></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for the Timeout */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>Tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_TIMEOUT</name></expr>;</expr_stmt>

      <comment type="block">/* Process Unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  This function handles Acknowledge failed detection during an I2C Communication.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */</comment>
<function><type><specifier>static</specifier> <name>HAL_StatusTypeDef</name></type> <name>I2C_IsAcknowledgeFailed</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>__HAL_I2C_GET_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Clear NACKF Flag */</comment>
    <expr_stmt><expr><call><name>__HAL_I2C_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>, <argument><expr><name>I2C_FLAG_AF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>PreviousState</name></name>       <operator>=</operator> <name>I2C_STATE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>State</name></name>               <operator>=</operator> <name>HAL_I2C_STATE_READY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>Mode</name></name>                <operator>=</operator> <name>HAL_I2C_MODE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>ErrorCode</name></name>           <operator>|=</operator> <name>HAL_I2C_ERROR_AF</name></expr>;</expr_stmt>

    <comment type="block">/* Process Unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hi2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Convert I2Cx OTHER_xxx XferOptions to functionnal XferOptions.
  * @param  hi2c I2C handle.
  * @retval None
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>I2C_ConvertOtherXferOptions</name><parameter_list>(<parameter><decl><type><name>I2C_HandleTypeDef</name> <modifier>*</modifier></type><name>hi2c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* if user set XferOptions to I2C_OTHER_FRAME            */</comment>
  <comment type="block">/* it request implicitly to generate a restart condition */</comment>
  <comment type="block">/* set XferOptions to I2C_FIRST_FRAME                    */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>I2C_OTHER_FRAME</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_FIRST_FRAME</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <comment type="block">/* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */</comment>
  <comment type="block">/* it request implicitly to generate a restart condition    */</comment>
  <comment type="block">/* then generate a stop condition at the end of transfer    */</comment>
  <comment type="block">/* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */</comment>
  <if type="elseif">else if <condition>(<expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>==</operator> <name>I2C_OTHER_AND_LAST_FRAME</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name><name>hi2c</name><operator>-&gt;</operator><name>XferOptions</name></name> <operator>=</operator> <name>I2C_FIRST_AND_LAST_FRAME</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Nothing to do */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_I2C_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
