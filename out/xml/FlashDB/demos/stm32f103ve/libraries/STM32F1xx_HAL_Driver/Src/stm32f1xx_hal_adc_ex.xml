<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FlashDB/demos/stm32f103ve/libraries/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_adc_ex.c"><comment type="block" format="doxygen">/**
  ******************************************************************************
  * @file    stm32f1xx_hal_adc_ex.c
  * @author  MCD Application Team
  * @brief   This file provides firmware functions to manage the following 
  *          functionalities of the Analog to Digital Convertor (ADC)
  *          peripheral:
  *           + Operation functions
  *             ++ Start, stop, get result of conversions of injected
  *                group, using 2 possible modes: polling, interruption.
  *             ++ Multimode feature (available on devices with 2 ADCs or more)
  *             ++ Calibration (ADC automatic self-calibration)
  *           + Control functions
  *             ++ Channels configuration on injected group
  *          Other functions (generic functions) are available in file 
  *          "stm32f1xx_hal_adc.c".
  *
  @verbatim
  [..] 
  (@) Sections "ADC peripheral features" and "How to use this driver" are
      available in file of generic functions "stm32f1xx_hal_adc.c".
  [..]
  @endverbatim
  ******************************************************************************
  * @attention
  *
  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */</comment>

<comment type="block">/* Includes ------------------------------------------------------------------*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stm32f1xx_hal.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/** @addtogroup STM32F1xx_HAL_Driver
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ADCEx ADCEx
  * @brief ADC Extension HAL module driver
  * @{
  */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAL_ADC_MODULE_ENABLED</name></cpp:ifdef>

<comment type="block">/* Private typedef -----------------------------------------------------------*/</comment>
<comment type="block">/* Private define ------------------------------------------------------------*/</comment>
<comment type="block" format="doxygen">/** @defgroup ADCEx_Private_Constants ADCEx Private Constants
  * @{
  */</comment>

  <comment type="block">/* Delay for ADC calibration:                                               */</comment>
  <comment type="block">/* Hardware prerequisite before starting a calibration: the ADC must have   */</comment>
  <comment type="block">/* been in power-on state for at least two ADC clock cycles.                */</comment>
  <comment type="block">/* Unit: ADC clock cycles                                                   */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADC_PRECALIBRATION_DELAY_ADCCLOCKCYCLES</name></cpp:macro>       <cpp:value>2U</cpp:value></cpp:define>

  <comment type="block">/* Timeout value for ADC calibration                                        */</comment>
  <comment type="block">/* Value defined to be higher than worst cases: low clocks freq,            */</comment>
  <comment type="block">/* maximum prescaler.                                                       */</comment>
  <comment type="block">/* Ex of profile low frequency : Clock source at 0.1 MHz, ADC clock         */</comment>
  <comment type="block">/* prescaler 4, sampling time 12.5 ADC clock cycles, resolution 12 bits.    */</comment>
  <comment type="block">/* Unit: ms                                                                 */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADC_CALIBRATION_TIMEOUT</name></cpp:macro>          <cpp:value>10U</cpp:value></cpp:define>

  <comment type="block">/* Delay for temperature sensor stabilization time.                         */</comment>
  <comment type="block">/* Maximum delay is 10us (refer to device datasheet, parameter tSTART).     */</comment>
  <comment type="block">/* Unit: us                                                                 */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADC_TEMPSENSOR_DELAY_US</name></cpp:macro>         <cpp:value>10U</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block">/* Private macro -------------------------------------------------------------*/</comment>
<comment type="block">/* Private variables ---------------------------------------------------------*/</comment>
<comment type="block">/* Private function prototypes -----------------------------------------------*/</comment>
<comment type="block">/* Private functions ---------------------------------------------------------*/</comment>

<comment type="block" format="doxygen">/** @defgroup ADCEx_Exported_Functions ADCEx Exported Functions
  * @{
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ADCEx_Exported_Functions_Group1 Extended Extended IO operation functions
 *  @brief    Extended Extended Input and Output operation functions
 *
@verbatim    
 ===============================================================================
                      ##### IO operation functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Start conversion of injected group.
      (+) Stop conversion of injected group.
      (+) Poll for conversion complete on injected group.
      (+) Get result of injected channel conversion.
      (+) Start conversion of injected group and enable interruptions.
      (+) Stop conversion of injected group and disable interruptions.

      (+) Start multimode and enable DMA transfer.
      (+) Stop multimode and disable ADC DMA transfer.
      (+) Get result of multimode conversion.

      (+) Perform the ADC self-calibration for single or differential ending.
      (+) Get calibration factors for single or differential ending.
      (+) Set calibration factors for single or differential ending.
      
@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Perform an ADC automatic self-calibration
  *         Calibration prerequisite: ADC must be disabled (execute this
  *         function before HAL_ADC_Start() or after HAL_ADC_Stop() ).
  *         During calibration process, ADC is enabled. ADC is let enabled at
  *         the completion of this function.
  * @param  hadc: ADC handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_Calibration_Start</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>wait_loop_index</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* 1. Calibration prerequisite:                                             */</comment>
  <comment type="block">/*    - ADC must be disabled for at least two ADC clock cycles in disable   */</comment>
  <comment type="block">/*      mode before ADC enable                                              */</comment>
  <comment type="block">/* Stop potential conversion on going, on regular and injected groups       */</comment>
  <comment type="block">/* Disable ADC peripheral */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_ConversionStop_Disable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check if ADC is effectively disabled */</comment>
  <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_BUSY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Hardware prerequisite: delay before starting the calibration.          */</comment>
    <comment type="block">/*  - Computation of CPU clock cycles corresponding to ADC clock cycles.  */</comment>
    <comment type="block">/*  - Wait for the expected ADC clock cycles delay */</comment>
    <expr_stmt><expr><name>wait_loop_index</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SystemCoreClock</name>
                        <operator>/</operator> <call><name>HAL_RCCEx_GetPeriphCLKFreq</name><argument_list>(<argument><expr><name>RCC_PERIPHCLK_ADC</name></expr></argument>)</argument_list></call><operator>)</operator>
                       <operator>*</operator> <name>ADC_PRECALIBRATION_DELAY_ADCCLOCKCYCLES</name>        <operator>)</operator></expr>;</expr_stmt>

    <while>while<condition>(<expr><name>wait_loop_index</name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>wait_loop_index</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <comment type="block">/* 2. Enable the ADC peripheral */</comment>
    <expr_stmt><expr><call><name>ADC_Enable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* 3. Resets ADC calibration registers */</comment>  
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_RSTCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  

    <comment type="block">/* Wait for calibration reset completion */</comment>
    <while>while<condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_RSTCAL</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>ADC_CALIBRATION_TIMEOUT</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update ADC state machine to error */</comment>
        <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                          <argument><expr><name>HAL_ADC_STATE_BUSY_INTERNAL</name></expr></argument>,
                          <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Process unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    
    
    <comment type="block">/* 4. Start ADC calibration */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_CAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  

    <comment type="block">/* Wait for calibration completion */</comment>
    <while>while<condition>(<expr><call><name>HAL_IS_BIT_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_CAL</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name><operator>)</operator> <operator>&gt;</operator> <name>ADC_CALIBRATION_TIMEOUT</name></expr>)</condition>
      <block>{<block_content>
        <comment type="block">/* Update ADC state machine to error */</comment>
        <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                          <argument><expr><name>HAL_ADC_STATE_BUSY_INTERNAL</name></expr></argument>,
                          <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Process unlocked */</comment>
        <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <return>return <expr><name>HAL_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    
    <comment type="block">/* Set ADC state */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_BUSY_INTERNAL</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables ADC, starts conversion of injected group.
  *         Interruptions enabled in this function: None.
  * @param  hadc: ADC handle
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedStart</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Enable the ADC peripheral */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_Enable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Start conversion if ADC is effectively enabled */</comment>
  <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state                                                          */</comment>
    <comment type="block">/* - Clear state bitfield related to injected group conversion results    */</comment>
    <comment type="block">/* - Set state bitfield related to injected operation                     */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Case of independent mode or multimode (for devices with several ADCs): */</comment>
    <comment type="block">/* Set multimode state.                                                   */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ADC_NONMULTIMODE_OR_MULTIMODEMASTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_MULTIMODE_SLAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_MULTIMODE_SLAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/* Check if a regular conversion is ongoing */</comment>
    <comment type="block">/* Note: On this device, there is no ADC error code fields related to     */</comment>
    <comment type="block">/*       conversions on group injected only. In case of conversion on     */</comment>
    <comment type="block">/*       going on group regular, no error code is reset.                  */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Reset ADC all error code fields */</comment>
      <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Process unlocked */</comment>
    <comment type="block">/* Unlock before starting ADC conversions: in case of potential           */</comment>
    <comment type="block">/* interruption, to let the process to ADC IRQ Handler.                   */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Clear injected group conversion flag */</comment>
    <comment type="block">/* (To ensure of no unknown state from potential previous ADC operations) */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_JEOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    <comment type="block">/* Enable conversion of injected group.                                   */</comment>
    <comment type="block">/* If software start has been selected, conversion starts immediately.    */</comment>
    <comment type="block">/* If external trigger has been selected, conversion will start at next   */</comment>
    <comment type="block">/* trigger event.                                                         */</comment>
    <comment type="block">/* If automatic injected conversion is enabled, conversion will start     */</comment>
    <comment type="block">/* after next regular group conversion.                                   */</comment>
    <comment type="block">/* Case of multimode enabled (for devices with several ADCs): if ADC is   */</comment>
    <comment type="block">/* slave, ADC is enabled only (conversion is not started). If ADC is      */</comment>
    <comment type="block">/* master, ADC is enabled and conversion is started.                      */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ADC_IS_SOFTWARE_START_INJECTED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>     <operator>&amp;&amp;</operator>
          <call><name>ADC_NONMULTIMODE_OR_MULTIMODEMASTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>  )</condition>
      <block>{<block_content>
        <comment type="block">/* Start ADC conversion on injected group with SW start */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_CR2_JSWSTART</name> <operator>|</operator> <name>ADC_CR2_JEXTTRIG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Start ADC conversion on injected group with external trigger */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_JEXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop conversion of injected channels. Disable ADC peripheral if
  *         no regular conversion is on going.
  * @note   If ADC must be disabled and if conversion is on going on 
  *         regular group, function HAL_ADC_Stop must be used to stop both
  *         injected and regular groups, and disable the ADC.
  * @note   If injected group mode auto-injection is enabled,
  *         function HAL_ADC_Stop must be used.
  * @note   In case of auto-injection mode, HAL_ADC_Stop must be used.
  * @param  hadc: ADC handle
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedStop</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Stop potential conversion and disable ADC peripheral                     */</comment>
  <comment type="block">/* Conditioned to:                                                          */</comment>
  <comment type="block">/* - No conversion on the other group (regular group) is intended to        */</comment>
  <comment type="block">/*   continue (injected and regular groups stop conversion and ADC disable  */</comment>
  <comment type="block">/*   are common)                                                            */</comment>
  <comment type="block">/* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */</comment>
  <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name> <operator>&amp;</operator> <name>HAL_ADC_STATE_REG_BUSY</name><operator>)</operator> <operator>==</operator> <name>RESET</name><operator>)</operator>  <operator>&amp;&amp;</operator>
     <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call></expr>   )</condition>
  <block>{<block_content>
    <comment type="block">/* Stop potential conversion on going, on regular and injected groups */</comment>
    <comment type="block">/* Disable ADC peripheral */</comment>
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_ConversionStop_Disable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Check if ADC is effectively disabled */</comment>
    <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Set ADC state */</comment>
      <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update ADC state machine to error */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Wait for injected group conversion to be completed.
  * @param  hadc: ADC handle
  * @param  Timeout: Timeout value in millisecond.
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedPollForConversion</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tickstart</name></decl>;</decl_stmt>

  <comment type="block">/* Variables for polling in case of scan mode enabled and polling for each  */</comment>
  <comment type="block">/* conversion.                                                              */</comment>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>Conversion_Timeout_CPU_cycles</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>Conversion_Timeout_CPU_cycles_max</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get timeout */</comment>
  <expr_stmt><expr><name>tickstart</name> <operator>=</operator> <call><name>HAL_GetTick</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  
     
  <comment type="block">/* Polling for end of conversion: differentiation if single/sequence        */</comment>
  <comment type="block">/* conversion.                                                              */</comment>
  <comment type="block">/* For injected group, flag JEOC is set only at the end of the sequence,    */</comment>
  <comment type="block">/* not for each conversion within the sequence.                             */</comment>
  <comment type="block">/*  - If single conversion for injected group (scan mode disabled or        */</comment>
  <comment type="block">/*    InjectedNbrOfConversion ==1), flag JEOC is used to determine the      */</comment>
  <comment type="block">/*    conversion completion.                                                */</comment>
  <comment type="block">/*  - If sequence conversion for injected group (scan mode enabled and      */</comment>
  <comment type="block">/*    InjectedNbrOfConversion &gt;=2), flag JEOC is set only at the end of the */</comment>
  <comment type="block">/*    sequence.                                                             */</comment>
  <comment type="block">/*    To poll for each conversion, the maximum conversion time is computed  */</comment>
  <comment type="block">/*    from ADC conversion time (selected sampling time + conversion time of */</comment>
  <comment type="block">/*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */</comment>
  <comment type="block">/*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */</comment>
  <comment type="block">/*    As flag JEOC is not set after each conversion, no timeout status can  */</comment>
  <comment type="block">/*    be set.                                                               */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JSQR</name></name> <operator>&amp;</operator> <name>ADC_JSQR_JL</name><operator>)</operator> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Wait until End of Conversion flag is raised */</comment>
    <while>while<condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SR</name></name></expr></argument>, <argument><expr><name>ADC_FLAG_JEOC</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check if timeout is disabled (set to infinite wait) */</comment>
      <if_stmt><if>if<condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0U</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Update ADC state machine to timeout */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <comment type="block">/* Process unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Replace polling by wait for maximum conversion time */</comment>
    <comment type="block">/*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */</comment>
    <comment type="block">/*    and ADC maximum conversion cycles on all channels.                  */</comment>
    <comment type="block">/*  - Wait for the expected ADC clock cycles delay                        */</comment>
    <expr_stmt><expr><name>Conversion_Timeout_CPU_cycles_max</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SystemCoreClock</name>
                                          <operator>/</operator> <call><name>HAL_RCCEx_GetPeriphCLKFreq</name><argument_list>(<argument><expr><name>RCC_PERIPHCLK_ADC</name></expr></argument>)</argument_list></call><operator>)</operator>
                                         <operator>*</operator> <call><name>ADC_CONVCYCLES_MAX_RANGE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>                 <operator>)</operator></expr>;</expr_stmt>
    
    <while>while<condition>(<expr><name>Conversion_Timeout_CPU_cycles</name> <operator>&lt;</operator> <name>Conversion_Timeout_CPU_cycles_max</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Check if timeout is disabled (set to infinite wait) */</comment>
      <if_stmt><if>if<condition>(<expr><name>Timeout</name> <operator>!=</operator> <name>HAL_MAX_DELAY</name></expr>)</condition>
      <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>(</operator><name>Timeout</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>||</operator><operator>(</operator><operator>(</operator><call><name>HAL_GetTick</name><argument_list>()</argument_list></call> <operator>-</operator> <name>tickstart</name> <operator>)</operator> <operator>&gt;</operator> <name>Timeout</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Update ADC state machine to timeout */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Process unlocked */</comment>
          <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <return>return <expr><name>HAL_TIMEOUT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>Conversion_Timeout_CPU_cycles</name> <operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Clear injected group conversion flag */</comment>
  <comment type="block">/* Note: On STM32F1 ADC, clear regular conversion flag raised               */</comment>
  <comment type="block">/* simultaneously.                                                          */</comment>
  <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_JSTRT</name> <operator>|</operator> <name>ADC_FLAG_JEOC</name> <operator>|</operator> <name>ADC_FLAG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Update ADC state machine */</comment>
  <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Determine whether any further conversion upcoming on group injected      */</comment>
  <comment type="block">/* by external trigger or by automatic injected conversion                  */</comment>
  <comment type="block">/* from group regular.                                                      */</comment>
  <if_stmt><if>if<condition>(<expr><call><name>ADC_IS_SOFTWARE_START_INJECTED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>                     <operator>||</operator> 
     <operator>(</operator><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>     
     <operator>(</operator><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>        <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name> <operator>==</operator> <name>DISABLE</name><operator>)</operator>   <operator>)</operator>        <operator>)</operator></expr>   )</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
    
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Return ADC state */</comment>
  <return>return <expr><name>HAL_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Enables ADC, starts conversion of injected group with interruption.
  *          - JEOC (end of conversion of injected group)
  *         Each of these interruptions has its dedicated callback function.
  * @param  hadc: ADC handle
  * @retval HAL status.
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedStart_IT</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Enable the ADC peripheral */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_Enable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Start conversion if ADC is effectively enabled */</comment>
  <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state                                                          */</comment>
    <comment type="block">/* - Clear state bitfield related to injected group conversion results    */</comment>
    <comment type="block">/* - Set state bitfield related to injected operation                     */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Case of independent mode or multimode (for devices with several ADCs): */</comment>
    <comment type="block">/* Set multimode state.                                                   */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ADC_NONMULTIMODE_OR_MULTIMODEMASTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_MULTIMODE_SLAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_MULTIMODE_SLAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <comment type="block">/* Check if a regular conversion is ongoing */</comment>
    <comment type="block">/* Note: On this device, there is no ADC error code fields related to     */</comment>
    <comment type="block">/*       conversions on group injected only. In case of conversion on     */</comment>
    <comment type="block">/*       going on group regular, no error code is reset.                  */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Reset ADC all error code fields */</comment>
      <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Process unlocked */</comment>
    <comment type="block">/* Unlock before starting ADC conversions: in case of potential           */</comment>
    <comment type="block">/* interruption, to let the process to ADC IRQ Handler.                   */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Clear injected group conversion flag */</comment>
    <comment type="block">/* (To ensure of no unknown state from potential previous ADC operations) */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_JEOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Enable end of conversion interrupt for injected channels */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_ENABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_JEOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Start conversion of injected group if software start has been selected */</comment>
    <comment type="block">/* and if automatic injected conversion is disabled.                      */</comment>
    <comment type="block">/* If external trigger has been selected, conversion will start at next   */</comment>
    <comment type="block">/* trigger event.                                                         */</comment>
    <comment type="block">/* If automatic injected conversion is enabled, conversion will start     */</comment>
    <comment type="block">/* after next regular group conversion.                                   */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>ADC_IS_SOFTWARE_START_INJECTED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call>     <operator>&amp;&amp;</operator>
          <call><name>ADC_NONMULTIMODE_OR_MULTIMODEMASTER</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>  )</condition>
      <block>{<block_content>
        <comment type="block">/* Start ADC conversion on injected group with SW start */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_CR2_JSWSTART</name> <operator>|</operator> <name>ADC_CR2_JEXTTRIG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Start ADC conversion on injected group with external trigger */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_JEXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop conversion of injected channels, disable interruption of 
  *         end-of-conversion. Disable ADC peripheral if no regular conversion
  *         is on going.
  * @note   If ADC must be disabled and if conversion is on going on 
  *         regular group, function HAL_ADC_Stop must be used to stop both
  *         injected and regular groups, and disable the ADC.
  * @note   If injected group mode auto-injection is enabled,
  *         function HAL_ADC_Stop must be used.
  * @param  hadc: ADC handle
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedStop_IT</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Stop potential conversion and disable ADC peripheral                     */</comment>
  <comment type="block">/* Conditioned to:                                                          */</comment>
  <comment type="block">/* - No conversion on the other group (regular group) is intended to        */</comment>
  <comment type="block">/*   continue (injected and regular groups stop conversion and ADC disable  */</comment>
  <comment type="block">/*   are common)                                                            */</comment>
  <comment type="block">/* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */</comment> 
  <if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name> <operator>&amp;</operator> <name>HAL_ADC_STATE_REG_BUSY</name><operator>)</operator> <operator>==</operator> <name>RESET</name><operator>)</operator>  <operator>&amp;&amp;</operator>
     <call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call></expr>   )</condition>
  <block>{<block_content>
    <comment type="block">/* Stop potential conversion on going, on regular and injected groups */</comment>
    <comment type="block">/* Disable ADC peripheral */</comment>
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_ConversionStop_Disable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Check if ADC is effectively disabled */</comment>
    <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Disable ADC end of conversion interrupt for injected channels */</comment>
      <expr_stmt><expr><call><name>__HAL_ADC_DISABLE_IT</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_IT_JEOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Set ADC state */</comment>
      <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>,
                        <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update ADC state machine to error */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103x6</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103xB</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F105xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F107xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103xG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Enables ADC, starts conversion of regular group and transfers result
  *         through DMA.
  *         Multimode must have been previously configured using 
  *         HAL_ADCEx_MultiModeConfigChannel() function.
  *         Interruptions enabled in this function:
  *          - DMA transfer complete
  *          - DMA half transfer
  *         Each of these interruptions has its dedicated callback function.
  * @note:  On STM32F1 devices, ADC slave regular group must be configured 
  *         with conversion trigger ADC_SOFTWARE_START.
  * @note:  ADC slave can be enabled preliminarily using single-mode  
  *         HAL_ADC_Start() function.
  * @param  hadc: ADC handle of ADC master (handle of ADC slave must not be used)
  * @param  pData: The destination Buffer address.
  * @param  Length: The length of data to be transferred from ADC peripheral to memory.
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_MultiModeStart_DMA</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>pData</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ADC_HandleTypeDef</name></type> <name>tmphadcSlave</name></decl>;</decl_stmt>

  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_MULTIMODE_MASTER_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ContinuousConvMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set a temporary handle of the ADC slave associated to the ADC master     */</comment>
  <expr_stmt><expr><call><name>ADC_MULTI_SLAVE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmphadcSlave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* On STM32F1 devices, ADC slave regular group must be configured with      */</comment>
  <comment type="block">/* conversion trigger ADC_SOFTWARE_START.                                   */</comment>
  <comment type="block">/* Note: External trigger of ADC slave must be enabled, it is already done  */</comment>
  <comment type="block">/*       into function "HAL_ADC_Init()".                                    */</comment>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmphadcSlave</name></expr></argument>)</argument_list></call></expr>)</condition>  
  <block>{<block_content>
    <comment type="block">/* Update ADC state machine to error */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>HAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Enable the ADC peripherals: master and slave (in case if not already     */</comment>
  <comment type="block">/* enabled previously)                                                      */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_Enable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_Enable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmphadcSlave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Start conversion if all ADCs of multimode are effectively enabled */</comment>
  <if_stmt><if>if <condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set ADC state (ADC master)                                             */</comment>
    <comment type="block">/* - Clear state bitfield related to regular group conversion results     */</comment>
    <comment type="block">/* - Set state bitfield related to regular operation                      */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name> <operator>|</operator> <name>HAL_ADC_STATE_REG_EOC</name> <operator>|</operator> <name>HAL_ADC_STATE_MULTIMODE_SLAVE</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
    <comment type="block">/* If conversions on group regular are also triggering group injected,    */</comment>
    <comment type="block">/* update ADC state.                                                      */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RESET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_EOC</name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Process unlocked */</comment>
    <comment type="block">/* Unlock before starting ADC conversions: in case of potential           */</comment>
    <comment type="block">/* interruption, to let the process to ADC IRQ Handler.                   */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Set ADC error code to none */</comment>
    <expr_stmt><expr><call><name>ADC_CLEAR_ERRORCODE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    
    <comment type="block">/* Set the DMA transfer complete callback */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name><operator>-&gt;</operator><name>XferCpltCallback</name></name> <operator>=</operator> <name>ADC_DMAConvCplt</name></expr>;</expr_stmt>
       
    <comment type="block">/* Set the DMA half transfer complete callback */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name><operator>-&gt;</operator><name>XferHalfCpltCallback</name></name> <operator>=</operator> <name>ADC_DMAHalfConvCplt</name></expr>;</expr_stmt>
    
    <comment type="block">/* Set the DMA error callback */</comment>
    <expr_stmt><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name><operator>-&gt;</operator><name>XferErrorCallback</name></name> <operator>=</operator> <name>ADC_DMAError</name></expr>;</expr_stmt>

    
    <comment type="block">/* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */</comment>
    <comment type="block">/* start (in case of SW start):                                           */</comment>
    
    <comment type="block">/* Clear regular group conversion flag and overrun flag */</comment>
    <comment type="block">/* (To ensure of no unknown state from potential previous ADC operations) */</comment>
    <expr_stmt><expr><call><name>__HAL_ADC_CLEAR_FLAG</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name>ADC_FLAG_EOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Enable ADC DMA mode of ADC master */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Start the DMA channel */</comment>
    <expr_stmt><expr><call><name>HAL_DMA_Start_IT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>&amp;</operator><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>pData</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Start conversion of regular group if software start has been selected. */</comment>
    <comment type="block">/* If external trigger has been selected, conversion will start at next   */</comment>
    <comment type="block">/* trigger event.                                                         */</comment>
    <comment type="block">/* Note: Alternate trigger for single conversion could be to force an     */</comment>
    <comment type="block">/*       additional set of bit ADON "hadc-&gt;Instance-&gt;CR2 |= ADC_CR2_ADON;"*/</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ADC_IS_SOFTWARE_START_REGULAR</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Start ADC conversion on regular group with SW start */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ADC_CR2_SWSTART</name> <operator>|</operator> <name>ADC_CR2_EXTTRIG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Start ADC conversion on regular group with external trigger */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_EXTTRIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Process unlocked */</comment>
    <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @brief  Stop ADC conversion of regular group (and injected channels in 
  *         case of auto_injection mode), disable ADC DMA transfer, disable 
  *         ADC peripheral.
  * @note   Multimode is kept enabled after this function. To disable multimode 
  *         (set with HAL_ADCEx_MultiModeConfigChannel(), ADC must be 
  *         reinitialized using HAL_ADC_Init() or HAL_ADC_ReInit().
  * @note   In case of DMA configured in circular mode, function 
  *         HAL_ADC_Stop_DMA must be called after this function with handle of
  *         ADC slave, to properly disable the DMA channel.
  * @param  hadc: ADC handle of ADC master (handle of ADC slave must not be used)
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_MultiModeStop_DMA</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ADC_HandleTypeDef</name></type> <name>tmphadcSlave</name></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_MULTIMODE_MASTER_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
 
  <comment type="block">/* Stop potential conversion on going, on regular and injected groups */</comment>
  <comment type="block">/* Disable ADC master peripheral */</comment>
  <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_ConversionStop_Disable</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check if ADC is effectively disabled */</comment>
  <if_stmt><if>if<condition>(<expr><name>tmp_hal_status</name> <operator>==</operator> <name>HAL_OK</name></expr>)</condition>
  <block>{<block_content>
    <comment type="block">/* Set a temporary handle of the ADC slave associated to the ADC master   */</comment>
    <expr_stmt><expr><call><name>ADC_MULTI_SLAVE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmphadcSlave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Disable ADC slave peripheral */</comment>
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>ADC_ConversionStop_Disable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmphadcSlave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if ADC is effectively disabled */</comment>
    <if_stmt><if>if<condition>(<expr><name>tmp_hal_status</name> <operator>!=</operator> <name>HAL_OK</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Update ADC state machine to error */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Process unlocked */</comment>
      <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>HAL_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Disable ADC DMA mode */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_DMA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Reset configuration of ADC DMA continuous request for dual mode */</comment>
    <expr_stmt><expr><call><name>CLEAR_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_DUALMOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    <comment type="block">/* Disable the DMA channel (in case of DMA in circular mode or stop while */</comment>
    <comment type="block">/* while DMA transfer is on going)                                        */</comment>
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <call><name>HAL_DMA_Abort</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>DMA_Handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Change ADC state (ADC master) */</comment>
    <expr_stmt><expr><call><name>ADC_STATE_CLR_SET</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_REG_BUSY</name> <operator>|</operator> <name>HAL_ADC_STATE_INJ_BUSY</name></expr></argument>,
                      <argument><expr><name>HAL_ADC_STATE_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined STM32F103x6 || defined STM32F103xB || defined STM32F105xC || defined STM32F107xC || defined STM32F103xE || defined STM32F103xG */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Get ADC injected group conversion result.
  * @note   Reading register JDRx automatically clears ADC flag JEOC
  *         (ADC group injected end of unitary conversion).
  * @note   This function does not clear ADC flag JEOS 
  *         (ADC group injected end of sequence conversion)
  *         Occurrence of flag JEOS rising:
  *          - If sequencer is composed of 1 rank, flag JEOS is equivalent
  *            to flag JEOC.
  *          - If sequencer is composed of several ranks, during the scan
  *            sequence flag JEOC only is raised, at the end of the scan sequence
  *            both flags JEOC and EOS are raised.
  *         Flag JEOS must not be cleared by this function because
  *         it would not be compliant with low power features
  *         (feature low power auto-wait, not available on all STM32 families).
  *         To clear this flag, either use function: 
  *         in programming model IT: @ref HAL_ADC_IRQHandler(), in programming
  *         model polling: @ref HAL_ADCEx_InjectedPollForConversion() 
  *         or @ref __HAL_ADC_CLEAR_FLAG(&amp;hadc, ADC_FLAG_JEOS).
  * @param  hadc: ADC handle
  * @param  InjectedRank: the converted ADC injected rank.
  *          This parameter can be one of the following values:
  *            @arg ADC_INJECTED_RANK_1: Injected Channel1 selected
  *            @arg ADC_INJECTED_RANK_2: Injected Channel2 selected
  *            @arg ADC_INJECTED_RANK_3: Injected Channel3 selected
  *            @arg ADC_INJECTED_RANK_4: Injected Channel4 selected
  * @retval ADC group injected conversion data
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_ADCEx_InjectedGetValue</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>InjectedRank</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmp_jdr</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_INJECTED_RANK</name><argument_list>(<argument><expr><name>InjectedRank</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Get ADC converted value */</comment> 
  <switch>switch<condition>(<expr><name>InjectedRank</name></expr>)</condition>
  <block>{<block_content>  
    <case>case <expr><name>ADC_INJECTED_RANK_4</name></expr>:</case> 
      <expr_stmt><expr><name>tmp_jdr</name> <operator>=</operator> <name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JDR4</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>ADC_INJECTED_RANK_3</name></expr>:</case> 
      <expr_stmt><expr><name>tmp_jdr</name> <operator>=</operator> <name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JDR3</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>ADC_INJECTED_RANK_2</name></expr>:</case> 
      <expr_stmt><expr><name>tmp_jdr</name> <operator>=</operator> <name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JDR2</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>ADC_INJECTED_RANK_1</name></expr>:</case>
    <default>default:</default>
      <expr_stmt><expr><name>tmp_jdr</name> <operator>=</operator> <name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JDR1</name></name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  
  <comment type="block">/* Return ADC converted value */</comment> 
  <return>return <expr><name>tmp_jdr</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103x6</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103xB</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F105xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F107xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103xG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Returns the last ADC Master&amp;Slave regular conversions results data
  *         in the selected multi mode.
  * @param  hadc: ADC handle of ADC master (handle of ADC slave must not be used)
  * @retval The converted data value.
  */</comment>
<function><type><name>uint32_t</name></type> <name>HAL_ADCEx_MultiModeGetValue</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>tmpDR</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_MULTIMODE_MASTER_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Note: EOC flag is not cleared here by software because automatically     */</comment>
  <comment type="block">/*       cleared by hardware when reading register DR.                      */</comment>
  
  <comment type="block">/* On STM32F1 devices, ADC1 data register DR contains ADC2 conversions      */</comment>
  <comment type="block">/* only if ADC1 DMA mode is enabled.                                        */</comment>
  <expr_stmt><expr><name>tmpDR</name> <operator>=</operator> <name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>DR</name></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>HAL_IS_BIT_CLR</name><argument_list>(<argument><expr><name><name>ADC1</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_DMA</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><name>tmpDR</name> <operator>|=</operator> <operator>(</operator><name><name>ADC2</name><operator>-&gt;</operator><name>DR</name></name> <operator>&lt;&lt;</operator> <literal type="number">16U</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
    
  <comment type="block">/* Return ADC converted value */</comment> 
  <return>return <expr><name>tmpDR</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined STM32F103x6 || defined STM32F103xB || defined STM32F105xC || defined STM32F107xC || defined STM32F103xE || defined STM32F103xG */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Injected conversion complete callback in non blocking mode 
  * @param  hadc: ADC handle
  * @retval None
  */</comment>
<function><type><specifier>__weak</specifier> <name>void</name></type> <name>HAL_ADCEx_InjectedConvCpltCallback</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Prevent unused argument(s) compilation warning */</comment>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADCEx_InjectedConvCpltCallback could be implemented in the user file
  */</comment>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/** @defgroup ADCEx_Exported_Functions_Group2 Extended Peripheral Control functions
  * @brief    Extended Peripheral Control functions
  *
@verbatim   
 ===============================================================================
             ##### Peripheral Control functions #####
 ===============================================================================  
    [..]  This section provides functions allowing to:
      (+) Configure channels on injected group
      (+) Configure multimode

@endverbatim
  * @{
  */</comment>

<comment type="block" format="doxygen">/**
  * @brief  Configures the ADC injected group and the selected channel to be
  *         linked to the injected group.
  * @note   Possibility to update parameters on the fly:
  *         This function initializes injected group, following calls to this 
  *         function can be used to reconfigure some parameters of structure
  *         "ADC_InjectionConfTypeDef" on the fly, without reseting the ADC.
  *         The setting of these parameters is conditioned to ADC state: 
  *         this function must be called when ADC is not under conversion.
  * @param  hadc: ADC handle
  * @param  sConfigInjected: Structure of ADC injected group and ADC channel for
  *         injected group.
  * @retval None
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_InjectedConfigChannel</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>ADC_InjectionConfTypeDef</name><modifier>*</modifier></type> <name>sConfigInjected</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__IO</name> <name>uint32_t</name></type> <name>wait_loop_index</name> <init>= <expr><literal type="number">0U</literal></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_ALL_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_CHANNEL</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_SAMPLE_TIME</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedSamplingTime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>AutoInjectedConv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_EXTTRIGINJEC</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>ExternalTrigInjecConv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_RANGE</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedOffset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if<condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ScanConvMode</name></name> <operator>!=</operator> <name>ADC_SCAN_DISABLE</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_INJECTED_RANK</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedRank</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_INJECTED_NB_CONV</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedNbrOfConversion</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_FUNCTIONAL_STATE</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedDiscontinuousConvMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Configuration of injected group sequencer:                               */</comment>
  <comment type="block">/* - if scan mode is disabled, injected channels sequence length is set to  */</comment>
  <comment type="block">/*   0x00: 1 channel converted (channel on regular rank 1)                  */</comment>
  <comment type="block">/*   Parameter "InjectedNbrOfConversion" is discarded.                      */</comment>
  <comment type="block">/*   Note: Scan mode is present by hardware on this device and, if          */</comment>
  <comment type="block">/*   disabled, discards automatically nb of conversions. Anyway, nb of      */</comment>
  <comment type="block">/*   conversions is forced to 0x00 for alignment over all STM32 devices.    */</comment>
  <comment type="block">/* - if scan mode is enabled, injected channels sequence length is set to   */</comment>
  <comment type="block">/*   parameter "InjectedNbrOfConversion".                                   */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>Init</name><operator>.</operator><name>ScanConvMode</name></name> <operator>==</operator> <name>ADC_SCAN_DISABLE</name></expr>)</condition>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedRank</name></name> <operator>==</operator> <name>ADC_INJECTED_RANK_1</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear the old SQx bits for all injected ranks */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JSQR</name></name></expr></argument>                             ,
                 <argument><expr><name>ADC_JSQR_JL</name>   <operator>|</operator>
                 <name>ADC_JSQR_JSQ4</name> <operator>|</operator>
                 <name>ADC_JSQR_JSQ3</name> <operator>|</operator>
                 <name>ADC_JSQR_JSQ2</name> <operator>|</operator>
                 <name>ADC_JSQR_JSQ1</name></expr></argument>                                    ,
                 <argument><expr><call><name>ADC_JSQR_RK_JL</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>,
                                  <argument><expr><name>ADC_INJECTED_RANK_1</name></expr></argument>,
                                  <argument><expr><literal type="number">0x01U</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* If another injected rank than rank1 was intended to be set, and could  */</comment>
    <comment type="block">/* not due to ScanConvMode disabled, error is reported.                   */</comment>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Update ADC state machine to error */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Since injected channels rank conv. order depends on total number of   */</comment>
    <comment type="block">/* injected conversions, selected rank must be below or equal to total   */</comment>
    <comment type="block">/* number of injected conversions to be updated.                         */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedRank</name></name> <operator>&lt;=</operator> <name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedNbrOfConversion</name></name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Clear the old SQx bits for the selected rank */</comment>
      <comment type="block">/* Set the SQx bits for the selected rank */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JSQR</name></name></expr></argument>                                         ,
                 
                 <argument><expr><name>ADC_JSQR_JL</name>                                               <operator>|</operator>
                 <call><name>ADC_JSQR_RK_JL</name><argument_list>(<argument><expr><name>ADC_JSQR_JSQ1</name></expr></argument>,                         
                                  <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedRank</name></name></expr></argument>,         
                                  <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedNbrOfConversion</name></name></expr></argument>)</argument_list></call></expr></argument>   ,
                 
                 <argument><expr><call><name>ADC_JSQR_JL_SHIFT</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedNbrOfConversion</name></name></expr></argument>)</argument_list></call> <operator>|</operator>
                 <call><name>ADC_JSQR_RK_JL</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>,      
                                  <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedRank</name></name></expr></argument>,         
                                  <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedNbrOfConversion</name></name></expr></argument>)</argument_list></call></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Clear the old SQx bits for the selected rank */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JSQR</name></name></expr></argument>                                       ,
                 
                 <argument><expr><name>ADC_JSQR_JL</name>                                               <operator>|</operator>
                 <call><name>ADC_JSQR_RK_JL</name><argument_list>(<argument><expr><name>ADC_JSQR_JSQ1</name></expr></argument>,                         
                                  <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedRank</name></name></expr></argument>,         
                                  <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedNbrOfConversion</name></name></expr></argument>)</argument_list></call></expr></argument> ,
                 
                 <argument><expr><literal type="number">0x00000000U</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt> 
    
  <comment type="block">/* Configuration of injected group                                          */</comment>
  <comment type="block">/* Parameters update conditioned to ADC state:                              */</comment>
  <comment type="block">/* Parameters that can be updated only when ADC is disabled:                */</comment>
  <comment type="block">/*  - external trigger to start conversion                                  */</comment>
  <comment type="block">/* Parameters update not conditioned to ADC state:                          */</comment>
  <comment type="block">/*  - Automatic injected conversion                                         */</comment>
  <comment type="block">/*  - Injected discontinuous mode                                           */</comment>
  <comment type="block">/* Note: In case of ADC already enabled, caution to not launch an unwanted  */</comment>
  <comment type="block">/*       conversion while modifying register CR2 by writing 1 to bit ADON.  */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ADC_IS_ENABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
  <block>{<block_content>    
    <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>                                           ,
               <argument><expr><name>ADC_CR2_JEXTSEL</name> <operator>|</operator>
               <name>ADC_CR2_ADON</name></expr></argument>                                                  ,
               <argument><expr><call><name>ADC_CFGR_JEXTSEL</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>ExternalTrigInjecConv</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  
  <comment type="block">/* Configuration of injected group                                          */</comment>
  <comment type="block">/*  - Automatic injected conversion                                         */</comment>
  <comment type="block">/*  - Injected discontinuous mode                                           */</comment>
  
    <comment type="block">/* Automatic injected conversion can be enabled if injected group         */</comment>
    <comment type="block">/* external triggers are disabled.                                        */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>AutoInjectedConv</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>ExternalTrigInjecConv</name></name> <operator>==</operator> <name>ADC_INJECTED_SOFTWARE_START</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JAUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else
      <block>{<block_content>
        <comment type="block">/* Update ADC state machine to error */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Injected discontinuous can be enabled only if auto-injected mode is    */</comment>
    <comment type="block">/* disabled.                                                              */</comment>  
    <if_stmt><if>if <condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedDiscontinuousConvMode</name></name> <operator>==</operator> <name>ENABLE</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>AutoInjectedConv</name></name> <operator>==</operator> <name>DISABLE</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>, <argument><expr><name>ADC_CR1_JDISCEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> 
      <else>else
      <block>{<block_content>
        <comment type="block">/* Update ADC state machine to error */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>


  <comment type="block">/* InjectedChannel sampling time configuration */</comment>
  <comment type="block">/* For channels 10 to 17 */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name> <operator>&gt;=</operator> <name>ADC_CHANNEL_10</name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMPR1</name></name></expr></argument>                                                             ,
               <argument><expr><call><name>ADC_SMPR1</name><argument_list>(<argument><expr><name>ADC_SMPR1_SMP10</name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>)</argument_list></call></expr></argument>                      ,
               <argument><expr><call><name>ADC_SMPR1</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedSamplingTime</name></name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <comment type="block">/* For channels 0 to 9 */</comment>
  <block>{<block_content>
    <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>SMPR2</name></name></expr></argument>                                                             ,
               <argument><expr><call><name>ADC_SMPR2</name><argument_list>(<argument><expr><name>ADC_SMPR2_SMP0</name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>)</argument_list></call></expr></argument>                       ,
               <argument><expr><call><name>ADC_SMPR2</name><argument_list>(<argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedSamplingTime</name></name></expr></argument>, <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* If ADC1 InjectedChannel_16 or InjectedChannel_17 is selected, enable Temperature sensor  */</comment>
  <comment type="block">/* and VREFINT measurement path.                                            */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name> <operator>==</operator> <name>ADC_CHANNEL_TEMPSENSOR</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name> <operator>==</operator> <name>ADC_CHANNEL_VREFINT</name><operator>)</operator></expr>      )</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_TSVREFE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  
  <comment type="block">/* Configure the offset: offset enable/disable, InjectedChannel, offset value */</comment>
  <switch>switch<condition>(<expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedRank</name></name></expr>)</condition>
  <block>{<block_content>
    <case>case <expr><literal type="number">1</literal></expr>:</case>
      <comment type="block">/* Set injected channel 1 offset */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR1</name></name></expr></argument>,
                 <argument><expr><name>ADC_JOFR1_JOFFSET1</name></expr></argument>,
                 <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="number">2</literal></expr>:</case>
      <comment type="block">/* Set injected channel 2 offset */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR2</name></name></expr></argument>,
                 <argument><expr><name>ADC_JOFR2_JOFFSET2</name></expr></argument>,
                 <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="number">3</literal></expr>:</case>
      <comment type="block">/* Set injected channel 3 offset */</comment>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR3</name></name></expr></argument>,
                 <argument><expr><name>ADC_JOFR3_JOFFSET3</name></expr></argument>,
                 <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><literal type="number">4</literal></expr>:</case>
    <default>default:</default>
      <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>JOFR4</name></name></expr></argument>,
                 <argument><expr><name>ADC_JOFR4_JOFFSET4</name></expr></argument>,
                 <argument><expr><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  
  <comment type="block">/* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */</comment>
  <comment type="block">/* and VREFINT measurement path.                                            */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name> <operator>==</operator> <name>ADC_CHANNEL_TEMPSENSOR</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name> <operator>==</operator> <name>ADC_CHANNEL_VREFINT</name><operator>)</operator></expr>      )</condition>
  <block>{<block_content>
    <comment type="block">/* For STM32F1 devices with several ADC: Only ADC1 can access internal    */</comment>
    <comment type="block">/* measurement channels (VrefInt/TempSensor). If these channels are       */</comment>
    <comment type="block">/* intended to be set on other ADC instances, an error is reported.       */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name> <operator>==</operator> <name>ADC1</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>READ_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_TSVREFE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR2</name></name></expr></argument>, <argument><expr><name>ADC_CR2_TSVREFE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sConfigInjected</name><operator>-&gt;</operator><name>InjectedChannel</name></name> <operator>==</operator> <name>ADC_CHANNEL_TEMPSENSOR</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
          <comment type="block">/* Delay for temperature sensor stabilization time */</comment>
          <comment type="block">/* Compute number of CPU cycles to wait for */</comment>
          <expr_stmt><expr><name>wait_loop_index</name> <operator>=</operator> <operator>(</operator><name>ADC_TEMPSENSOR_DELAY_US</name> <operator>*</operator> <operator>(</operator><name>SystemCoreClock</name> <operator>/</operator> <literal type="number">1000000U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <while>while<condition>(<expr><name>wait_loop_index</name> <operator>!=</operator> <literal type="number">0U</literal></expr>)</condition>
          <block>{<block_content>
            <expr_stmt><expr><name>wait_loop_index</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
      <comment type="block">/* Update ADC state machine to error */</comment>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103x6</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103xB</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F105xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F107xC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103xE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>STM32F103xG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/**
  * @brief  Enable ADC multimode and configure multimode parameters
  * @note   Possibility to update parameters on the fly:
  *         This function initializes multimode parameters, following  
  *         calls to this function can be used to reconfigure some parameters 
  *         of structure "ADC_MultiModeTypeDef" on the fly, without reseting 
  *         the ADCs (both ADCs of the common group).
  *         The setting of these parameters is conditioned to ADC state.
  *         For parameters constraints, see comments of structure 
  *         "ADC_MultiModeTypeDef".
  * @note   To change back configuration from multimode to single mode, ADC must
  *         be reset (using function HAL_ADC_Init() ).
  * @param  hadc: ADC handle
  * @param  multimode: Structure of ADC multimode configuration
  * @retval HAL status
  */</comment>
<function><type><name>HAL_StatusTypeDef</name></type> <name>HAL_ADCEx_MultiModeConfigChannel</name><parameter_list>(<parameter><decl><type><name>ADC_HandleTypeDef</name><modifier>*</modifier></type> <name>hadc</name></decl></parameter>, <parameter><decl><type><name>ADC_MultiModeTypeDef</name><modifier>*</modifier></type> <name>multimode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>HAL_StatusTypeDef</name></type> <name>tmp_hal_status</name> <init>= <expr><name>HAL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ADC_HandleTypeDef</name></type> <name>tmphadcSlave</name></decl>;</decl_stmt>
  
  <comment type="block">/* Check the parameters */</comment>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_MULTIMODE_MASTER_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert_param</name><argument_list>(<argument><expr><call><name>IS_ADC_MODE</name><argument_list>(<argument><expr><name><name>multimode</name><operator>-&gt;</operator><name>Mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Process locked */</comment>
  <expr_stmt><expr><call><name>__HAL_LOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Set a temporary handle of the ADC slave associated to the ADC master     */</comment>
  <expr_stmt><expr><call><name>ADC_MULTI_SLAVE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmphadcSlave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Parameters update conditioned to ADC state:                              */</comment>
  <comment type="block">/* Parameters that can be updated when ADC is disabled or enabled without   */</comment>
  <comment type="block">/* conversion on going on regular group:                                    */</comment>
  <comment type="block">/*  - ADC master and ADC slave DMA configuration                            */</comment>
  <comment type="block">/* Parameters that can be updated only when ADC is disabled:                */</comment>
  <comment type="block">/*  - Multimode mode selection                                              */</comment>
  <comment type="block">/* To optimize code, all multimode settings can be set when both ADCs of    */</comment>
  <comment type="block">/* the common group are in state: disabled.                                 */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>ADC_IS_ENABLE</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name><operator>)</operator>                     <operator>&amp;&amp;</operator>
      <operator>(</operator><call><name>ADC_IS_ENABLE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmphadcSlave</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESET</name><operator>)</operator>            <operator>&amp;&amp;</operator>
      <operator>(</operator><call><name>IS_ADC_MULTIMODE_MASTER_INSTANCE</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>   )</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>MODIFY_REG</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>Instance</name><operator>-&gt;</operator><name>CR1</name></name></expr></argument>,
               <argument><expr><name>ADC_CR1_DUALMOD</name></expr></argument>    ,
               <argument><expr><name><name>multimode</name><operator>-&gt;</operator><name>Mode</name></name></expr></argument>     )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <comment type="block">/* If one of the ADC sharing the same common group is enabled, no update    */</comment>
  <comment type="block">/* could be done on neither of the multimode structure parameters.          */</comment>
  <else>else
  <block>{<block_content>
    <comment type="block">/* Update ADC state machine to error */</comment>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>hadc</name><operator>-&gt;</operator><name>State</name></name></expr></argument>, <argument><expr><name>HAL_ADC_STATE_ERROR_CONFIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>tmp_hal_status</name> <operator>=</operator> <name>HAL_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
    
    
  <comment type="block">/* Process unlocked */</comment>
  <expr_stmt><expr><call><name>__HAL_UNLOCK</name><argument_list>(<argument><expr><name>hadc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return function status */</comment>
  <return>return <expr><name>tmp_hal_status</name></expr>;</return>
</block_content>}</block></function> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined STM32F103x6 || defined STM32F103xB || defined STM32F105xC || defined STM32F107xC || defined STM32F103xE || defined STM32F103xG */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>  

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAL_ADC_MODULE_ENABLED */</comment>
<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/**
  * @}
  */</comment>

<comment type="block" format="doxygen">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</comment>
</unit>
